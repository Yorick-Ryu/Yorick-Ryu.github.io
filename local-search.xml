<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DeepSeek白嫖指南</title>
    <link href="/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/DeepSeek%E7%99%BD%E5%AB%96%E6%8C%87%E5%8D%97/"/>
    <url>/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/DeepSeek%E7%99%BD%E5%AB%96%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="DeepSeek白嫖指南"><a href="#DeepSeek白嫖指南" class="headerlink" title="DeepSeek白嫖指南"></a>DeepSeek白嫖指南</h1><table><thead><tr><th align="left">平台</th><th align="left">免费额度（Tokens）</th><th align="left">获取链接</th><th>接口地址（base_url）</th><th>模型名称（model）</th><th>文档</th></tr></thead><tbody><tr><td align="left">DeepSeek官方</td><td align="left">10元免费额度，折算500万</td><td align="left"><a href="https://platform.deepseek.com/api_keys">点击跳转</a></td><td><a href="https://api.deepseek.com/">https://api.deepseek.com</a></td><td>deepseek-chat或deepseek-reasoner</td><td><a href="https://api-docs.deepseek.com/zh-cn/">点击跳转</a></td></tr><tr><td align="left">硅基流动</td><td align="left">14元免费额度，折算2000万</td><td align="left"><a href="https://cloud.siliconflow.cn/i/23c6QiTj">点击跳转</a></td><td><a href="https://api.siliconflow.cn/">https://api.siliconflow.cn</a></td><td>deepseek-ai&#x2F;DeepSeek-R1或deepseek-ai&#x2F;DeepSeek-V3</td><td><a href="https://docs.siliconflow.cn/capabilities/reasoning">点击跳转</a></td></tr><tr><td align="left">华为云</td><td align="left">R1和V3各200万</td><td align="left"><a href="https://console.huaweicloud.com/modelarts/?region=cn-southwest-2#/model-studio/deployment">点击跳转</a></td><td>官网查看</td><td>DeepSeek-R1或DeepSeek-V3</td><td><a href="https://support.huaweicloud.com/usermanual-maas-modelarts/maas-modelarts-0010.html">点击跳转</a></td></tr><tr><td align="left">阿里云</td><td align="left">R1和V3各1000万，限开通后半年内</td><td align="left"><a href="https://bailian.console.aliyun.com/">点击跳转</a></td><td><a href="https://dashscope.aliyuncs.com/compatible-mode/v1/">https://dashscope.aliyuncs.com/compatible-mode/v1/</a></td><td>deepseek-r1、deepseek-v3、deepseek-r1-distill-qwen-1.5b、deepseek-r1-distill-llama-8b、deepseek-r1-distill-llama-70b（免费）</td><td><a href="https://help.aliyun.com/zh/model-studio/developer-reference/get-api-key">点击跳转</a></td></tr><tr><td align="left">腾讯云</td><td align="left">无限制，截止2月25日23:59:59</td><td align="left"><a href="https://console.cloud.tencent.com/lkeap/api">点击跳转</a></td><td><a href="https://api.lkeap.cloud.tencent.com/">https://api.lkeap.cloud.tencent.com</a></td><td>deepseek-r1或deepseek-v3</td><td><a href="https://cloud.tencent.com/document/product/1772/115963">点击跳转</a></td></tr><tr><td align="left">百度云</td><td align="left">无限制，截止2月18日23:59:59</td><td align="left"><a href="https://console.bce.baidu.com/qianfan/ais/console/onlineTest/LLM/DeepSeek-R1">点击跳转</a></td><td><a href="https://qianfan.baidubce.com/v2/">https://qianfan.baidubce.com/v2/</a></td><td>deepseek-r1或deepseek-v3</td><td><a href="https://cloud.baidu.com/doc/WENXINWORKSHOP/s/Fm2vrveyu">点击跳转</a></td></tr><tr><td align="left">火山</td><td align="left">R1和V3各50万</td><td align="left"><a href="https://www.volcengine.com/product/ark">点击跳转</a></td><td><a href="https://ark.cn-beijing.volces.com/api/v3/chat/completions">https://ark.cn-beijing.volces.com/api/v3/chat/completions</a></td><td>官网查看你的接入点ID，YOUR_ENDPOINT_ID</td><td><a href="https://www.volcengine.com/docs/82379/1449737">点击跳转</a></td></tr><tr><td align="left">天翼云</td><td align="left">2500万</td><td align="left"><a href="https://huiju.ctyun.cn/modelSquare">点击跳转</a></td><td><a href="https://wishub-x1.ctyun.cn/">https://wishub-x1.ctyun.cn</a></td><td>DeepSeek-R1-昇腾版：4bd107bff85941239e27b1509eccfe98 DeepSeek-R1-英伟达版：7ba7726dad4c4ea4ab7f39c7741ae</td><td><a href="https://huiju.ctyun.cn/modelSquare/4bd107bff85941239e27b1509eccfe98?regionId=200000001852&tab=API_DOCUMENT">点击跳转</a></td></tr><tr><td align="left">英伟达</td><td align="left">1000次调用</td><td align="left"><a href="https://build.nvidia.com/deepseek-ai/deepseek-r1">点击跳转</a></td><td><a href="https://integrate.api.nvidia.com/">https://integrate.api.nvidia.com</a></td><td>deepseek-ai&#x2F;deepseek-r1</td><td><a href="https://docs.api.nvidia.com/nim/reference/deepseek-ai-deepseek-r1-infer">点击跳转</a></td></tr><tr><td align="left">Github</td><td align="left"><a href="https://docs.github.com/zh/github-models/prototyping-with-ai-models#rate-limits">https://docs.github.com/zh/github-models/prototyping-with-ai-models#rate-limits</a></td><td align="left"><a href="https://github.com/marketplace/models/azureml-deepseek/DeepSeek-R1/playground">点击跳转</a></td><td><a href="https://models.inference.ai.azure.com/">https://models.inference.ai.azure.com/</a></td><td>DeepSeek-R1</td><td><a href="https://learn.microsoft.com/zh-cn/python/api/overview/azure/ai-inference-readme?view=azure-python-preview">点击跳转</a></td></tr><tr><td align="left">浮点奇迹</td><td align="left">R1和R1联网版每日各20次</td><td align="left"><a href="https://dazi.co/login?i=3dcee729">点击跳转</a></td><td>不支持API调用</td><td>\</td><td>\</td></tr></tbody></table><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li><p>点击获取链接完成注册登录创建应用等操作并获取API KEY（可以通过查看文档找到获取方法）</p></li><li><p>复制API KEY到Cherry Studio（没有就去下载：<a href="https://cherry-ai.com/%EF%BC%89">https://cherry-ai.com/）</a></p></li><li><p>点击设置</p><p><img src="/./img/image-20250210202730839.png" alt="image-20250210202730839"></p></li><li><p>找到对应的模型供应商</p><p><img src="/./img/image-20250210203016426.png" alt="image-20250210203016426"></p><p>没有则添加，输入供应商名称，如百度，点击确定</p><p><img src="/./img/image-20250210203059858.png" alt="image-20250210203059858"></p></li><li><p>填入API KEY和API地址</p><p><img src="/./img/image-20250210203329040.png" alt="image-20250210203329040"></p></li><li><p>点击添加</p><p><img src="/./img/image-20250210203413898.png" alt="image-20250210203413898"></p></li><li><p>输入模型ID，点击添加模型</p><p><img src="/./img/image-20250210203546272.png" alt="image-20250210203546272"></p></li><li><p>点击检查，选择刚刚添加的模型ID，点击确定，出现“连接成功”即成功</p><p><img src="/./img/image-20250210203643977.png" alt="image-20250210203643977"></p><p><img src="/./img/image-20250210203804639.png" alt="image-20250210203804639"></p><p><img src="/./img/image-20250210203858755.png" alt="image-20250210203858755"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>DeepSeek</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统重点</title>
    <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E7%82%B9/"/>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统重点"><a href="#操作系统重点" class="headerlink" title="操作系统重点"></a>操作系统重点</h1><h2 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h2><h3 id="OS主要目标"><a href="#OS主要目标" class="headerlink" title="OS主要目标"></a>OS主要目标</h3><ol><li>提高资源利用率</li><li>方便用户</li></ol><h3 id="OS四大基本特征"><a href="#OS四大基本特征" class="headerlink" title="OS四大基本特征"></a>OS四大基本特征</h3><p><strong>并发、共享</strong>、虚拟、同步</p><h3 id="操作系统发展过程"><a href="#操作系统发展过程" class="headerlink" title="操作系统发展过程"></a>操作系统发展过程</h3><p>三大基本操作系统</p><ul><li>批处理</li><li>分时</li><li>实时</li></ul><h3 id="操作系统的发展动力"><a href="#操作系统的发展动力" class="headerlink" title="操作系统的发展动力"></a>操作系统的发展动力</h3><ul><li>批处理：提高资源利用率和系统吞吐量</li><li>分时：方便用户<ul><li>人机交互</li><li>共享主机</li><li>便于用户上机</li></ul></li><li>微机：计算机硬件的不断升级换代</li></ul><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><p>将一个以上的作业放入内存，并且同时处于运行状态</p><p>硬件支持：通道和中断机构</p><p>前提：大内存</p><p>优点：提高资源利用率</p><h3 id="并发性与并行性"><a href="#并发性与并行性" class="headerlink" title="并发性与并行性"></a>并发性与并行性</h3><p>并发性：同一时间间隔内</p><p>并行性：同一时间</p><h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>只有OS中最基本的部分，提供最基本的核心功能</p><p>提供功能：</p><ul><li>进程（线程）管理</li><li>低级存储器管理</li><li>进程间通信管理</li><li>中断和陷入处理</li></ul><p>优点：</p><ul><li>提高OS的可拓展性</li><li>增强OS的可靠性</li><li>可移植性强</li><li>提供了对分布式系统的支持</li><li>融入了面向对象技术</li></ul><p>缺点：早期的微内核系统运行效率较低</p><h3 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h3><p>管态（核心态）目态（用户态）</p><p>特权指令：只能由操作系统才能执行的指令，如I&#x2F;O指令，内存清零指令，只能在核心态下执行</p><p>非特权指令：用户可以去执行的指令，在用户态下执行</p><h2 id="进程的描述和控制"><a href="#进程的描述和控制" class="headerlink" title="进程的描述和控制"></a>进程的描述和控制</h2><p>为什么要引入进程？</p><p>为了并发执行</p><p>进程的构成：</p><p>程序、数据和PCB</p><p>进程的三种基本状态及转换条件</p><ul><li>就绪</li><li>执行</li><li>阻塞</li></ul><p>PCB是进程存在的唯一标识</p><p>原语 进程控制</p><p>了解创建、终止、阻塞、唤醒，触发条件（选择、填空）</p><p>进程的同步</p><p>临界资源、临界区</p><p>临界资源（同步机制）使用原则</p><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ul><p>进程关系：同步（合作）、互斥（竞争资源）</p><p>记录型信号量（小题、大题）</p><p>PV原语（大题、不难但不是原题）</p><p>管程的组成部分、条件变量</p><p>经典进程的同步问题踩分点：</p><ol><li>设信号量（数量、类型、初值）</li><li>进程数量</li><li>p(wait)、v(signal)位置</li></ol><p>进程通信（1、2小题）</p><p>信箱、管道、消息传输对列</p><p>为什么要引入线程（引入）</p><p>线程和进程的关系</p><p>线程的实现方式</p><p>课后题根据重点选做</p><h2 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h2><p>调度层次</p><ul><li>高级调度（作业调度）</li><li>中级调度（内存调度）</li><li>低级调度（进程调度）</li></ul><p>作业调度算法（可能应用题）：</p><ul><li>先来先服务</li><li>短作业优先</li><li>优先级</li><li>高响应比优先</li></ul><p>进程调度算法</p><p>时间片轮转</p><p>死锁原因、必要条件、解决方法</p><p>安全状态、银行家算法、</p><p>打印机问题</p><h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><p>单一连续分区</p><p>固定分区</p><p>动态分区、分配算法</p><ul><li>首次适应</li><li>最佳</li><li>最坏</li></ul><p>判断伙伴</p><p>紧凑、拼接、前提条件有动态可重定位</p><p>上下界、限长</p><p>页式存储管理、地址变换（计算）</p><p>TLB、多级页表计算</p><p>段式、地址变换</p><p>段页式、地址变换</p><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>局部性原理</p><p>虚拟页式、页表组成、存在位、访问位（简答）</p><p>虚拟段式</p><p>缺页中断和一般中断的不同</p><p>内存的分配策略（选择）</p><p>页面置换算法</p><p>工作集（选择）</p><h2 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h2><p>小题：</p><p>IO控制方式（小题）</p><p>通道</p><p>设备之间单通路与多通路</p><p>设备无关性</p><p>设备分配</p><p>大题：</p><p>Spooling的组成、共享打印机</p><p>缓冲引入、缓冲池工作原理</p><p>磁盘、磁盘访问时间、磁盘调度算法</p><ul><li>先来先访问</li><li>最短寻道时间</li><li>电梯（SCAN）</li><li>循环扫描（CSCAN）</li></ul><p>调度序列、移动磁道数</p><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>文件的逻辑结构</p><p>流式文件</p><p>记录式文件</p><p>文件控制块、索引结点</p><p>文件共享</p><ul><li>基于结点</li><li>符号链接</li></ul><p>访问权限表</p><p>文件的物理结构</p><p>FAT</p><p>混合索引分配</p><h2 id="磁盘存储区的管理"><a href="#磁盘存储区的管理" class="headerlink" title="磁盘存储区的管理"></a>磁盘存储区的管理</h2><p>磁盘空间空闲管理</p><p>位示图（计算）</p><p>成组链接（解答）</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程复习</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
    <url>/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0">软件工程复习</a><ul><li><a href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0">软件工程概述</a><ul><li><a href="#%E5%8F%91%E5%B1%95%E9%98%B6%E6%AE%B5">发展阶段</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA">软件危机</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B">软件开发（过程）模型</a><ul><li><a href="#%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B">瀑布模型</a></li><li><a href="#%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B">增量模型</a></li><li><a href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B">原型模型</a></li><li><a href="#%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B">螺旋模型</a></li><li><a href="#%E5%96%B7%E6%B3%89%E6%A8%A1%E5%9E%8B">喷泉模型</a></li></ul></li><li><a href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95">软件开发方法</a><ul><li><a href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95structured-developing-method">结构化开发方法（Structured Developing Method）</a></li><li><a href="#%E5%8E%9F%E5%9E%8B%E5%8C%96%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95">原型化开发方法</a></li><li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95oosd">面向对象方法(OOSD)</a></li></ul></li></ul></li><li><a href="#%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B">软件需求工程</a><ul><li><a href="#%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B%E8%BF%87%E7%A8%8B">需求工程过程</a></li><li><a href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95">需求分析方法</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BEdfd">数据流图（DFD）</a></li><li><a href="#use-case-%E5%9B%BE">Use-Case 图</a><ul><li><a href="#%E7%94%A8%E4%BE%8B%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB">用例图中的各种关系</a></li></ul></li></ul></li><li><a href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">软件设计</a><ul><li><a href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BB%BB%E5%8A%A1">软件设计阶段的任务</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5%E7%9A%84%E7%9B%AE%E6%A0%87">软件设计阶段的目标</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">软件体系结构设计</a><ul><li><a href="#%E4%BB%93%E5%BA%93%E6%A8%A1%E5%9E%8B">仓库模型</a></li><li><a href="#%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B">层次模型</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%A8%A1%E5%9E%8B">分布式模型</a><ul><li><a href="#cs%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B">C&#x2F;S（客户&#x2F;服务器模型）</a></li><li><a href="#bs%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B">B&#x2F;S（浏览器&#x2F;服务器模型）</a></li></ul></li><li><a href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B">云计算模型</a></li></ul></li><li><a href="#%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BE%E8%AE%A1">系统的数据设计</a><ul><li><a href="#e-r%E5%9B%BE">E-R图</a></li></ul></li><li><a href="#%E6%A8%A1%E5%9D%97">模块</a><ul><li><a href="#%E6%A8%A1%E5%9D%97%E5%88%86%E8%A7%A3">模块分解</a></li><li><a href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%80%A7">模块的独立性</a><ul><li><a href="#%E8%80%A6%E5%90%88%E6%80%A7coupling">耦合性（Coupling）</a></li><li><a href="#%E5%86%85%E8%81%9A%E6%80%A7cohesion">内聚性（Cohesion）</a></li></ul></li></ul></li><li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1">面向对象设计</a><ul><li><a href="#ood%E7%9A%84%E5%87%86%E5%88%99">OOD的准则</a></li><li><a href="#ood%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1">OOD基本任务</a></li></ul></li><li><a href="#mvc%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">MVC设计模式</a></li></ul></li><li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%8E%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80uml">面向对象方法与统一建模语言UML</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0">软件构造</a><ul><li><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95structured-program">程序设计方法（Structured Program）</a><ul><li><a href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">结构化程序设计</a></li><li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象程序设计</a></li></ul></li><li><a href="#%E7%AE%97%E6%B3%95%E4%B8%8E%E7%A8%8B%E5%BA%8F%E6%95%88%E7%8E%87">算法与程序效率</a><ul><li><a href="#%E7%BC%96%E7%A0%81%E7%AD%96%E7%95%A5">编码策略</a></li></ul></li><li><a href="#%E8%BD%AF%E4%BB%B6%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5">软件代码审查</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E5%A4%8D%E7%94%A8">软件复用</a></li></ul></li><li><a href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95">软件测试</a><ul><li><a href="#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90">静态分析</a></li><li><a href="#%E5%8A%A8%E6%80%81%E6%B5%8B%E8%AF%95">动态测试</a><ul><li><a href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95">白盒测试</a></li><li><a href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95">黑盒测试</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E6%B3%95">基本路径法</a></li></ul></li><li><a href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B">测试用例</a></li></ul></li><li><a href="#%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4">软件维护</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a><ul><li><a href="#%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E7%B1%BB%E5%9E%8B">软件维护的类型</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E7%89%B9%E6%80%A7">软件维护的特性</a></li><li><a href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%B4%E6%8A%A4%E4%B8%8E%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%B4%E6%8A%A4">结构化维护与非结构化维护</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E4%BB%A3%E4%BB%B7">软件维护的代价</a></li></ul></li><li><a href="#%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E8%BF%87%E7%A8%8B">软件维护的过程</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7">软件可维护性</a></li></ul></li><li><a href="#%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86">软件项目管理</a><ul><li><a href="#%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E8%AE%A1%E5%88%92">软件项目计划</a><ul><li><a href="#%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E8%AE%A1%E5%88%92%E5%86%85%E5%AE%B9">软件项目计划内容</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%9B%E5%BA%A6%E8%AE%A1%E5%88%92">软件开发进度计划</a></li></ul></li><li><a href="#%E8%BD%AF%E4%BB%B6%E6%88%90%E6%9C%AC%E4%BC%B0%E7%AE%97%E6%8A%80%E6%9C%AF">软件成本估算技术</a><ul><li><a href="#%E6%88%90%E6%9C%AC%E4%BC%B0%E7%AE%97%E6%A8%A1%E5%9E%8B">成本估算模型</a></li></ul></li></ul></li><li><a href="#%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E6%88%90%E7%86%9F%E5%BA%A6%E6%A8%A1%E5%9E%8Bcmm">软件能力成熟度模型CMM</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%88%90%E7%86%9F%E5%BA%A6">什么是软件过程成熟度</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%9A%84%E6%88%90%E7%86%9F%E5%BA%A6%E7%AD%89%E7%BA%A7">软件过程的成熟度等级</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E6%88%90%E7%86%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B%E9%9B%86%E6%88%90cmmi">软件能力成熟度模型集成(CMMI)</a></li></ul></li><li><a href="#%E4%BE%8B%E9%A2%98%E5%B0%8F%E9%A2%98">例题（小题）</a></li><li><a href="#%E4%BE%8B%E9%A2%98%E5%A4%A7%E9%A2%98">例题（大题）</a><ul><li><a href="#%E4%BE%8B1%E5%8C%BB%E9%99%A2%E7%97%85%E6%88%BF%E7%9B%91%E6%8A%A4%E7%B3%BB%E7%BB%9F">例1：医院病房监护系统</a></li><li><a href="#%E4%BE%8B2bbs%E8%AE%BA%E5%9D%9B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD">例2：BBS论坛的基本功能</a></li><li><a href="#%E4%BE%8B3%E9%93%B6%E8%A1%8C%E5%8F%96%E6%AC%BE%E8%BF%87%E7%A8%8B">例3：银行取款过程</a></li><li><a href="#%E4%BE%8B4%E4%B8%80%E4%B8%AA%E6%8A%A5%E8%A1%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%89%BC%E8%A6%81%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9E%8B">例4：一个报表系统的扼要功能模型</a></li><li><a href="#%E4%BE%8B5%E5%AD%A6%E7%94%9F%E9%80%89%E8%AF%BE">例5：学生选课</a></li><li><a href="#%E4%BE%8B6%E4%BF%9D%E9%99%A9%E9%87%91%E7%A8%8B%E5%BA%8F">例6：保险金程序</a></li><li><a href="#%E4%BE%8B7%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95">例7：白盒测试</a></li><li><a href="#%E4%BE%8B8%E6%95%99%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">例8：教务管理系统</a></li><li><a href="#%E4%BE%8B9%E5%B7%A5%E8%B5%84%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F">例9：工资计算系统</a></li><li><a href="#%E4%BE%8B10%E7%9C%8B%E4%BB%A3%E7%A0%81%E7%A8%8B%E5%BA%8F">例10：看代码程序</a></li></ul></li></ul></li></ul><h1 id="软件工程复习"><a href="#软件工程复习" class="headerlink" title="软件工程复习"></a>软件工程复习</h1><h2 id="软件工程概述"><a href="#软件工程概述" class="headerlink" title="软件工程概述"></a>软件工程概述</h2><p>概念：<strong>用工程化的思想指导软件开发</strong></p><h3 id="发展阶段"><a href="#发展阶段" class="headerlink" title="发展阶段"></a>发展阶段</h3><ol><li>第一代软件工程 — 传统的软件工程</li><li>第二代软件工程 — 对象工程</li><li>第三代软件工程 — 过程工程</li><li>第四代软件工程 — 构件工程</li></ol><h3 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h3><p>软件危机的出现是由于<strong>软件的规模越来越大，复杂度不断增加，软件需求量增大。</strong></p><p>主要表现：</p><ul><li>质量差</li><li>效率低，不满足需求</li></ul><h3 id="软件开发（过程）模型"><a href="#软件开发（过程）模型" class="headerlink" title="软件开发（过程）模型"></a>软件开发（过程）模型</h3><p>软件过程模型是描述软件开发过程中各种活动如何执行的模型，也叫软件过程模型或软件生命周期。</p><p>目前典型的软件开发模型有：</p><p><strong>瀑布模型</strong>、增量模型、<strong>螺旋模型、喷泉模型</strong>、变换模型和基于知识的模型等。</p><p>参考<a href="http://www.uml.org.cn/SoftWareProcess/201802062.asp">软件过程模型-过程改进 (uml.org.cn)</a></p><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><p>瀑布模型是一种线性的过程，瀑布模型要求有明确的需求分析，而要达到这一点在现实开发中几乎不可能。这种模型是最早也是应用最广泛的软件过程模型。</p><p>瀑布模型的优缺点：</p><p>优点</p><ul><li>简单易行</li><li>可以进行阶段检查，能够及时发现问题</li><li>较好的分工协作，不同阶段不同职位，架构师，项目经理，开发工程师，测试工程师，运维工程师</li><li>对质量有一定的保障，因为每个阶段有详细的文档</li></ul><p>缺点</p><p>将充满回溯的软件开发过程硬性分割为几个阶段</p><ul><li>难以响应需求的变更</li><li>工作量分配不均匀</li><li>前期阶段受阻压缩后期进展</li></ul><p><a href="https://www.cnblogs.com/lanjianhappy/p/11934284.html">瀑布模型总结</a></p><h4 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h4><p>融合了瀑布模型的基本成分和原型实现的迭代特征。增量模型强调每一个增量均发布一个可操作的产品。增量模型在各个阶段并不交付一个可运行的完整产品，而是交付满足客户需求的一个子集的可运行产品。</p><p>优点：</p><ol><li><p>人员分配灵活</p></li><li><p>第一个可交付版本所需要的成本和时间很少</p></li></ol><p>缺点：</p><ol><li><p>软件具备开放式体系结构</p></li><li><p>容易退化为边做边改，使软件过程的控制失去整体性。</p></li><li><p>至始至终开发者和客户纠缠在一起，直到完全版本出来。</p></li></ol><h4 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h4><p>最大特点就是它采用了一种动态定义需求的方法。即不需要有明确的需求。被开发的原型应交付客户使用，并收集客户的反馈意见，可在下一轮中对原型进行改进。</p><p>过程：</p><ol><li>快速分析</li><li>构造原型</li><li>运行和评价原型</li><li>修改与改进</li></ol><p>是一种循环模型</p><p>优点：能够快速、低成本地构建原型</p><p>缺点：没有考虑软件的整体质量和长期的可维护性</p><p>适用对象：开发初期用户需求是不完整、不准确的</p><h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><p>将瀑布模型和原型化模型结合起来，并加入<strong>风险分析</strong>（主要特征）</p><p>螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期可分为<strong>4个工作步骤</strong>：</p><ol><li>确定目标、方案和限制条件；</li><li>评估方案、标识风险和解决风险；</li><li>开发确认产品；</li><li>计划下一周期工作。</li></ol><p><img src="/./img/spiral_model.png" alt="螺旋模型（Spiral model） 大项目+需求不明确+明确的风险管理_沐雨金鳞-CSDN博客_需求不明确用什么模型"></p><p>优点：支持用户需求的动态变化。</p><p>缺点：</p><ol><li>需要开发人员具有相当丰富的风险评估经验和专门知识。</li><li>增加开发成本和延迟提交时间。</li><li>支持用户需求的动态变化</li></ol><p>使用对象：庞大、复杂且具有高风险的系统。</p><h4 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h4><p>以用户需求为动力，已对象作为驱动的模型。适用<strong>面向对象</strong>的开发过程，最核心的特点是<strong>迭代性和无间隙性</strong>。所有的开发活动没有明显的边界，允许各种开发活动同步进行。</p><p>开发过程分为4个阶段：</p><ul><li>分析</li><li>系统设计</li><li>软件设计</li><li>实现</li></ul><p>特点：各阶段相互重叠，反映了软件过程<strong>并行</strong>的特点</p><p>优点：提高软件项目的开发效率，节省开发时间。</p><p>缺点：</p><ol><li>需要大量的开发人员，不利于项目的管理。</li><li>要求严格管理文档，使得审核的难度加大。</li></ol><h3 id="软件开发方法"><a href="#软件开发方法" class="headerlink" title="软件开发方法"></a>软件开发方法</h3><p>软件开发的目标是要在规定的投资和时间内，开发出符合用户的需求，高质量的软件，为此需要有成功的开发方法。</p><h4 id="结构化开发方法（Structured-Developing-Method）"><a href="#结构化开发方法（Structured-Developing-Method）" class="headerlink" title="结构化开发方法（Structured Developing Method）"></a>结构化开发方法（Structured Developing Method）</h4><p>大问题分解为小问题，逐一解决。</p><p>指导思想：<strong>自顶向下，逐步求精</strong></p><p>主要特点：<strong>快速，自然，方便，容易理解。</strong></p><p>具体组成：</p><ul><li>结构化程序设计方法（SP， Structured Program）</li><li>结构化设计方法（SD，Structured Design）</li><li>结构化分析方法（SA，Structured Analysis）</li></ul><h4 id="原型化开发方法"><a href="#原型化开发方法" class="headerlink" title="原型化开发方法"></a>原型化开发方法</h4><p>又称速成原型法（ RapidPrototyping），花费少量代价建立一个可运行的系统，使用户及早获得学习的机会。</p><ol><li><p>废弃（throw away）型</p><p>RSP法（Rapid Specific Prototyping）快速建立需求规格原型。</p></li><li><p>追加（add on）型</p><p>RCP法（Rapid Cyclic Prototyping）快速建立渐进原型法。采用循环渐进的开发方式，对系统模型作连续精化。</p></li></ol><h4 id="面向对象方法-OOSD"><a href="#面向对象方法-OOSD" class="headerlink" title="面向对象方法(OOSD)"></a>面向对象方法(OOSD)</h4><p>特点：封装，继承，多态</p><p>具体组成</p><ul><li>OOA 面向对象的分析</li><li>OOD 面向对象的设计</li><li>OOP 面向对象的程序设计</li></ul><h2 id="软件需求工程"><a href="#软件需求工程" class="headerlink" title="软件需求工程"></a>软件需求工程</h2><p>软件需求包括<strong>用户需求</strong>和<strong>系统需求</strong>，系统需求包括<strong>功能需求</strong>，<strong>非功能需求</strong>和<strong>领域需求</strong>。</p><p><img src="/./img/image-20230612183850368.png" alt="image-20230612183850368"></p><h3 id="需求工程过程"><a href="#需求工程过程" class="headerlink" title="需求工程过程"></a>需求工程过程</h3><ol><li>获取需求</li><li>获取分析与建模</li><li>确认需求</li><li>进化需求</li></ol><p>需求抽取的方法一般有：</p><ol><li>面谈法</li><li>问卷调查法</li><li>需求专题讨论会</li><li>原型法获取</li><li>面向用例的方法</li></ol><h3 id="需求分析方法"><a href="#需求分析方法" class="headerlink" title="需求分析方法"></a>需求分析方法</h3><ol><li><p>功能分析方法</p><p>系统功能模块划分图</p></li><li><p>结构化分析方法（SA法）</p><p>分层数据流图</p></li><li><p>信息建模法</p><p>ER图</p></li><li><p>面向对象分析法</p><p>UML</p></li></ol><h3 id="数据流图（DFD）"><a href="#数据流图（DFD）" class="headerlink" title="数据流图（DFD）"></a>数据流图（DFD）</h3><p>数据流图（Data Flow Diagram，DFD）是描述系统中数据流程的图形工具，它描述了将系统的逻辑输入转换为逻辑输出所需的加工处理过程。</p><p>数据字典：数据流，加工，数据存储和数据源点或终点。</p><p><img src="/./img/image-20230612184710465.png" alt="image-20230612184710465"></p><p><img src="/./img/image-20230612184755220.png" alt="image-20230612184755220"></p><h3 id="Use-Case-图"><a href="#Use-Case-图" class="headerlink" title="Use-Case 图"></a>Use-Case 图</h3><p>采用“基于用例的方法”来识别和获取需求，是从外部的角度来看系统功能，建立系统的Use case模型。描述外部执行者(Actor)所理解的系统功能。即待开发系统的功能需求。</p><ul><li>用例：表示一个子系统，或者系统一个独立的功能。</li><li>角色：表示外部的“执行者”。</li></ul><p><img src="/./img/image-20230613093422841.png" alt="image-20230613093422841"></p><h4 id="用例图中的各种关系"><a href="#用例图中的各种关系" class="headerlink" title="用例图中的各种关系"></a>用例图中的各种关系</h4><p>参与者与用例的关系：实线箭头，表示关联关系</p><p>用例与用例之间：虚线箭头连接</p><ul><li><p>包含<code>&lt;&lt;include&gt;&gt;</code>：一个用例需要某种功能，而该功能被另外一个用例定义，那么在用例的执行过程中，就可以调用已经定义好的用例</p><p><img src="/./img/image-20230613185824866.png" alt="image-20230613185824866"></p></li><li><p>拓展<code>&lt;&lt;extend&gt;&gt;</code>：可选的或只在特定条件下才执行的动作</p><p><img src="/./img/image-20230613185904037.png" alt="image-20230613185904037"></p></li></ul><h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><p>软件设计是软件开发的关键步骤，直接影响软件质量。软件设计阶段要解决<strong>“如何做”</strong>的问题。</p><h3 id="软件设计阶段的任务"><a href="#软件设计阶段的任务" class="headerlink" title="软件设计阶段的任务"></a>软件设计阶段的任务</h3><p>将分析阶段获得的需求说明转换为计算机中实现的系统。包括：</p><ul><li>确定软件结构</li><li>确定系统的数据结构</li><li>设计用户界面</li></ul><h3 id="软件设计阶段的目标"><a href="#软件设计阶段的目标" class="headerlink" title="软件设计阶段的目标"></a>软件设计阶段的目标</h3><p>软件设计的目标就是构建一个<strong>高内聚低耦合</strong>的软件模型。</p><h3 id="软件体系结构设计"><a href="#软件体系结构设计" class="headerlink" title="软件体系结构设计"></a>软件体系结构设计</h3><p>软件体系结构不仅指定了系统的<strong>组织结构和拓扑结构</strong>，显示了系统需求和构成系统的元素之间的对应关系，而且提供了一些设计决策的基本原理。</p><h4 id="仓库模型"><a href="#仓库模型" class="headerlink" title="仓库模型"></a>仓库模型</h4><p>仓库模型是一种<strong>集中式</strong>的模型。在这种结构模型中，应用系统<strong>用一个中央数据仓库来存储各个子系统共享的数据</strong>。</p><p>优点：</p><ol><li>数据由一个子系统产生，并且被其他一些子系统共享。</li><li>共享数据能得到有效的管理，各子系统之间不需要通过复杂的机制来传递共享数据。</li><li>一个子系统不必关心其他的子系统是如何使用它产生的数据的。</li><li><strong>所有的子系统都拥有一致的甚于中央数据仓库的数据视图</strong>。如果新子系统也采用相同的规范，则将它集成于系统中是容易的。</li></ol><p>缺陷：</p><ol><li>虽然共享数据得到了有效的管理，但随之而来的问题是<strong>各子系统必须有一致的数据视图，以便能共享数据</strong>，换句话说，就是各子系统之间为了能共享数据必须走一条折中的路线，这不可避免地会影响整个系统的性能。</li><li>一个子系统发生了改变，它产生的数据结构也可能发生改变。为了其他共享的目的，数据翻译系统会被用到。但这种翻译的代价是很高的，并且有时是不可能完成的。</li><li>中央数据仓库和各子系统拥有的数据库必须有相同的关于备份、安全、访问控制和恢复的策略，这可能会影响子系统的效率。</li><li>集中式的控制使数据和子系统的分布变得非常困难甚至成为不可能。这里分布一词指的是将数据或子系统分散到不同的机器上。</li></ol><h4 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h4><p>层次结构模型<strong>将系统划分为若干层次</strong>。适合增量的软件开发。</p><p>经典例子：OSI参考模型（七层）</p><h4 id="分布式模型"><a href="#分布式模型" class="headerlink" title="分布式模型"></a>分布式模型</h4><p>分布式结构中的节点可以是同构的（即具有相应的软&#x2F;硬系统），也可以是异构的。</p><h5 id="C-S（客户-服务器模型）"><a href="#C-S（客户-服务器模型）" class="headerlink" title="C&#x2F;S（客户&#x2F;服务器模型）"></a>C&#x2F;S（客户&#x2F;服务器模型）</h5><p>C&#x2F;S结构的应用都由三个相对独立的逻辑部分组成：</p><ul><li>用户界面层（客户端）</li><li>业务逻辑层（客户端&#x2F;服务器）</li><li>数据访问层（服务器）</li></ul><p>胖瘦客户端的区别主要在于<strong>数据逻辑层</strong>的占比。</p><p>C&#x2F;S在更新客户端时需要用户下载新版本或者更新程序，</p><h5 id="B-S（浏览器-服务器模型）"><a href="#B-S（浏览器-服务器模型）" class="headerlink" title="B&#x2F;S（浏览器&#x2F;服务器模型）"></a>B&#x2F;S（浏览器&#x2F;服务器模型）</h5><p>典型的瘦客户结构。重新部署很方便。</p><p>优点：</p><ol><li>资源共享</li><li>开放性好</li><li>可伸缩性好</li><li>容错能力强</li><li>透明性好</li></ol><p>不足：</p><ol><li>复杂性较大</li><li>安全性较低</li><li>可管理性较困难（异构）</li><li>不可预知性（系统响应时间，受网络环境影响大）</li></ol><h4 id="云计算模型"><a href="#云计算模型" class="headerlink" title="云计算模型"></a>云计算模型</h4><p>基本特征：</p><ol><li>随需应变自助服务</li><li>随时随地用任何网络设备访问</li><li>多人共享资源池</li><li>快速重新部署灵活度</li><li>可被监控与量测的服务</li></ol><p>服务模式：</p><ol><li>软件即服务（SaaS）</li><li>平台即服务（PaaS）</li><li>基础架构即服务（IaaS）</li></ol><h3 id="系统的数据设计"><a href="#系统的数据设计" class="headerlink" title="系统的数据设计"></a>系统的数据设计</h3><p>数据模型是系统内部的静态数据结构，它包括3种相互关联的信息：</p><ul><li>数据对象</li><li>数据属性</li><li>关系</li></ul><h4 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h4><p>E-R图也称实体——联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。</p><ul><li>用“矩形框”表示实体型，矩形框内写明实体名称；</li><li>用“椭圆图框”或圆角矩形表示实体的属性，并用“实心线段”将其与相应关系的“实体型”连接起来；</li><li>用“菱形框”表示实体型之间的联系成因，在菱形框内写明联系名，并用“实心线段”分别与有关实体型连接起来，同时在“实心线段”旁标上联系的类型（<code>1:1</code>,<code>1:n</code>或<code>m:n</code>）。</li></ul><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块（Module）是命名的程序对象的集合，如过程、函数、类等。</p><h4 id="模块分解"><a href="#模块分解" class="headerlink" title="模块分解"></a>模块分解</h4><p>目的：</p><ol><li>降低复杂性</li><li>使软件结构清晰，便于阅读和理解</li><li>易于测试和调试</li><li>提高软件的可靠性</li></ol><h4 id="模块的独立性"><a href="#模块的独立性" class="headerlink" title="模块的独立性"></a>模块的独立性</h4><p>所谓模块的独立性，是指软件系统中每个模块只涉及软件要求的具体的子功能，而和软件系统中其他的模块的接口是简单的。<strong>即独立性的模块应具有专一功能。</strong></p><p><strong>模块独立性越强，并行开发越容易。</strong></p><p>模块独立性的度量标准：<strong>耦合性</strong>和<strong>内聚性</strong></p><h5 id="耦合性（Coupling）"><a href="#耦合性（Coupling）" class="headerlink" title="耦合性（Coupling）"></a>耦合性（Coupling）</h5><p>指软件结构系统中模块之间相互连接的紧密程度，是模块间相互连接性的度量。</p><h5 id="内聚性（Cohesion）"><a href="#内聚性（Cohesion）" class="headerlink" title="内聚性（Cohesion）"></a>内聚性（Cohesion）</h5><p>表示一个模块内部各种数据和各种处理之间联系的紧密程度，它是从功能的角度来度量模块内的联系</p><h3 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h3><p>面向对象的系统开发分为三个阶段：</p><ol><li><p>面向对象分析（Object-OrientedAnalysis，OOA）</p></li><li><p><strong>面向对象设计</strong>（Object-Oriented Design，OOD）<strong>（核心）</strong></p></li><li><p>面向对象程序设计（Object-Oriented Programming，OOP）</p></li></ol><h4 id="OOD的准则"><a href="#OOD的准则" class="headerlink" title="OOD的准则"></a>OOD的准则</h4><ol><li>抽象</li><li>信息隐藏</li><li>弱耦合</li><li>强内聚</li><li>可重用</li></ol><h4 id="OOD基本任务"><a href="#OOD基本任务" class="headerlink" title="OOD基本任务"></a>OOD基本任务</h4><p>OOD的目标是产生一个<strong>满足用户需求的可实现的</strong>OOD模型。</p><p>OOD的主要任务是<strong>对象设计</strong>。</p><h3 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h3><p><img src="/./img/image-20230613191127582.png" alt="image-20230613191127582"></p><h2 id="面向对象方法与统一建模语言UML"><a href="#面向对象方法与统一建模语言UML" class="headerlink" title="面向对象方法与统一建模语言UML"></a>面向对象方法与统一建模语言UML</h2><p>用例之间的关系：</p><ul><li><p>包含<code>&lt;&lt;include&gt;&gt;</code>：</p><p>包含关系描述的是一个用例需要某种功能，而该功能被另外一个用例定义，那么在用例的执行过程中，就可以调用已经定义好的用例。</p></li><li><p>拓展<code>&lt;&lt;extend&gt;&gt;</code>：</p><p>用一个用例（可选）扩展另一个用例（基本例）的功能。<strong>将一些常规的动作放在一个基本用例中，将可选的或只在特定条件下才执行的动作</strong></p><p><strong>放在它的扩展用例中。</strong></p></li></ul><h2 id="软件构造"><a href="#软件构造" class="headerlink" title="软件构造"></a>软件构造</h2><p>软件构造（Software Construstion）指通过编码、验证、单元测试、集成测试和排错的组合，创建一个可以工作的、有意义的软件。</p><h3 id="程序设计方法（Structured-Program）"><a href="#程序设计方法（Structured-Program）" class="headerlink" title="程序设计方法（Structured Program）"></a>程序设计方法（Structured Program）</h3><h4 id="结构化程序设计"><a href="#结构化程序设计" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h4><p>结构程序设计的概念最早是由E.W.Dijkstra提出来的。其基本思想是<strong>自顶向下、逐步求精</strong>。它的基本原则是功能的<strong>分解</strong>与<strong>抽象</strong>。</p><p>特点：</p><ol><li><p>自顶向下，逐步求精</p></li><li><p>单入口和单出口的控制结构</p><p>结构化的程序是由且仅由<strong>顺序、选择、循环</strong>三种基本控制结构组成</p></li></ol><h4 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h4><p>背景：对软件的<strong>可重用和可扩展性</strong>的需求越来越强烈</p><p>核心概念：</p><ul><li>数据封装</li><li>继承</li><li>多态</li><li>泛型</li></ul><h3 id="算法与程序效率"><a href="#算法与程序效率" class="headerlink" title="算法与程序效率"></a>算法与程序效率</h3><h4 id="编码策略"><a href="#编码策略" class="headerlink" title="编码策略"></a>编码策略</h4><ol><li>在高级别的警告模式下编译程序</li><li>尽量采用自动化的编程工具</li><li>交叉审阅代码</li><li>只让一个功能模块完成一个任务</li><li>正确性、简单性和清晰性是第一位的</li><li>尽量避免全局和共享数据的使用</li><li>总是初始化变量</li><li>避免编写行数很多的函数，避免过深的嵌套</li></ol><h3 id="软件代码审查"><a href="#软件代码审查" class="headerlink" title="软件代码审查"></a>软件代码审查</h3><p>为保证代码开发的质量，在编码完成后，进行代码审查或称Review。审查内容：</p><ol><li>程序的版式</li><li>文件结构</li><li>命名规则</li><li>表达式与基本语句</li></ol><h3 id="软件复用"><a href="#软件复用" class="headerlink" title="软件复用"></a>软件复用</h3><p>软件复用就是将已有的软件成分用于构造新的软件系统，以达到提高软件系统的开发质量与效率，降低开发成本的目的。</p><p>软件复用不仅是对程序的复用，它包括对软件生产过程中任何活动所产生的制成品的复用。</p><p>软件复用的级别：（抽象程度<strong>由低到高</strong>）</p><ol><li>代码的复用</li><li>设计结果的复用</li><li>分析结果的复用</li><li>测试信息的复用</li></ol><p>可复用构建的标准：</p><p>一个软件只有在多个系统中被使用才可称为“可复用构件”，必须具备的条件：</p><ol><li>功能上的独立性和完整性</li><li>较高的通用性</li><li>较高的灵活性</li><li>严格的质量保证</li><li>较高的标准化程度</li></ol><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p>目的：发现和改正错误，最终提高软件质量。</p><p>特点：</p><ul><li>开销大</li><li>不能进行“穷举”测试</li></ul><p>软件测试的基本步骤：</p><ol><li>模块测试（单元测试）</li><li>整体测试（组装测试）</li><li>功能测试（有效性测试）</li><li>系统测试（确定测试）</li><li>验收测试</li><li>安装测试</li></ol><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>指以人工的、非形式化的方法对程序进行分析和测试。</p><p>主要特征：测试过程不在计算机上运行被测试的程序。</p><ul><li><p>桌前检查</p><p>由开发人员之外的其他人员对代码进行仔细的检查和评估，以确保代码的质量和正确性。</p></li><li><p>代码会审</p><p>多个开发人员一起审查和讨论代码的过程。</p></li><li><p>步行检查（Walkthrough）</p><p>由开发人员和其他相关人员一起进行的、结构化的、非正式的技术评审过程。</p><p>常用工具：调用图、数据流分析图</p></li></ul><h3 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h3><p>主要特征：必须要在计算机上运行被测试的程序，通过输入测试用例，对其运行结果进行分析。</p><h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>分析程序的内部逻辑结构，注意选择适当的覆盖标准，设计测试用例，对主要路径进行尽可能多的测试。</p><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><p>不考虑程序的内部结构与特性，只根据程序功能或程序的外部特性设计测试用例。</p><ol><li>语句覆盖：选择足够的测试用例，使得程序中每个语句至少都能被执行一次。</li><li>判定覆盖：执行足够的测试用例，使得程序中每个判定至少都获得一次“真”值和“假”值。</li><li>条件覆盖：执行足够的测试用例，使得判定中的每个条件获得各种可能的结果</li></ol><h4 id="基本路径法"><a href="#基本路径法" class="headerlink" title="基本路径法"></a>基本路径法</h4><p>从一个程序的入口开始，<strong>执行所经历的各个语句的完整过程</strong>。</p><ol><li>画出程序的控制流图</li><li>计算环路复杂度V（G）<ul><li><code>V(G)=边的数量-节点的数量+2</code></li><li><code>V(G)=判断节点的数量+1</code></li></ul></li><li>列出独立路径集</li><li>准备测试用例</li></ol><p>具体请参考：<a href="https://yorick.love/2023/02/18/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/">软件测试复习 | Yorick Harbor</a></p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p><img src="/./img/image-20230613131811049.png" alt="image-20230613131811049"></p><h2 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>软件维护是指软件系统交付使用以后，其目的是为了改正错误或满足新的需求而修改软件的过程。按照不同的维护目的，维护工作可分成4类。</p><h4 id="软件维护的类型"><a href="#软件维护的类型" class="headerlink" title="软件维护的类型"></a>软件维护的类型</h4><ol><li>完善性维护（Perfective Maintenance）</li><li>适应性维护（Corrective Maintenance）</li><li>纠错性维护（Adaptive Maintenance）</li><li>预防性维护（Preventive Maintenance）</li></ol><h4 id="软件维护的特性"><a href="#软件维护的特性" class="headerlink" title="软件维护的特性"></a>软件维护的特性</h4><ol><li><strong>时间长、工作量大、成本高</strong></li><li>维护的副作用<ul><li>修改代码的副作用</li><li>修改数据的副作用</li><li>修改文档的副作用</li></ul></li><li>软件维护的困难</li></ol><h4 id="结构化维护与非结构化维护"><a href="#结构化维护与非结构化维护" class="headerlink" title="结构化维护与非结构化维护"></a>结构化维护与非结构化维护</h4><ul><li>结构化维护：指软件开发过程是按照软件工程方法，软件的维护过程，有一整套完整的方案、技术、审定过程。显然，维护工作的难度及工作<br>量的大小，与前期的开发工作密切相关。</li><li>非结构化维护：缺乏必要的文档说明，难于确定数据结构、系统接口等特性。维护工作令人生畏，事倍功半</li></ul><h4 id="软件维护的代价"><a href="#软件维护的代价" class="headerlink" title="软件维护的代价"></a>软件维护的代价</h4><ol><li><p>软件维护的工作量大</p><p>影响因素</p><ol><li>系统规模大小</li><li>程序设计语言</li><li>系统使用年限</li><li>软件开发新技术的应用</li><li>设计过程中的技术</li></ol></li><li><p>软件维护工作量模型</p><p><code>M=P+K*EXP(C-D)</code></p><p>其中：M表示维护总工作量，P表示生产性活动工作量，K为经验常数，C表示由非结构化维护引起的程序复杂度，D表示对维护软件熟悉程度的度量。</p></li></ol><h3 id="软件维护的过程"><a href="#软件维护的过程" class="headerlink" title="软件维护的过程"></a>软件维护的过程</h3><p>软件维护工作不仅是技术性的，还需要大量的管理工作与之相配合，才能保证维护工作的质量。管理部门应对提交的修改方案进行分析和审查，并对修改带来的影响作充分的估计，对于不妥的修改予以撤销。</p><h3 id="软件可维护性"><a href="#软件可维护性" class="headerlink" title="软件可维护性"></a>软件可维护性</h3><p>软件可维护性是指软件<strong>能够被理解，并能纠正软件系统出现的错误和缺陷，以及为满足新的要求进行修改、扩充或压缩的容易程度</strong>。衡量可维护性标准：</p><ol><li>可理解性</li><li>可靠性</li><li>可测试性</li><li>可修改性</li><li>可移植性</li><li>效率</li><li>可使用性</li></ol><p>提高可维护性的方法：</p><ol><li>建立明确的软件质量目标</li><li>使用先进的软件开发技术和工具</li><li>建立明确的质量保证工作<ul><li>在检查点进行复审</li><li>验收检查</li><li>周期性的维护检查</li><li>对软件包进行检查</li></ul></li><li>选择可维护的程序设计语言</li><li>改进程序的文档</li></ol><h2 id="软件项目管理"><a href="#软件项目管理" class="headerlink" title="软件项目管理"></a>软件项目管理</h2><p>软件项目管理是对软件项目开发全过程的管理，是对整个软件生存期的所有活动进行的管理。</p><h3 id="软件项目计划"><a href="#软件项目计划" class="headerlink" title="软件项目计划"></a>软件项目计划</h3><h4 id="软件项目计划内容"><a href="#软件项目计划内容" class="headerlink" title="软件项目计划内容"></a>软件项目计划内容</h4><ol><li>项目范围</li><li>项目资源</li><li>项目进度安排</li></ol><h4 id="软件开发进度计划"><a href="#软件开发进度计划" class="headerlink" title="软件开发进度计划"></a>软件开发进度计划</h4><p>描述计划进度的主要工具：</p><ol><li>一般的表格工具</li><li>甘特图（Gantt Chart）</li><li>时标网状图（timescalar network）</li><li>PERTT（Program evaluation &amp; review technique）计划评审技术和CPM（Critical path method）关键路径法</li></ol><h3 id="软件成本估算技术"><a href="#软件成本估算技术" class="headerlink" title="软件成本估算技术"></a>软件成本估算技术</h3><h4 id="成本估算模型"><a href="#成本估算模型" class="headerlink" title="成本估算模型"></a>成本估算模型</h4><ol><li>专家估算模型</li><li>IBM估算模型</li><li>Putnam估算模型</li><li>COCOMO模型<ul><li>基本的COCOMO模型</li><li>中间的COCOMO模型</li><li>详细的COCOMO模型</li></ul></li></ol><h2 id="软件能力成熟度模型CMM"><a href="#软件能力成熟度模型CMM" class="headerlink" title="软件能力成熟度模型CMM"></a>软件能力成熟度模型CMM</h2><p>软件能力成熟度模型CMM（Capability MaturityModel）是由美国卡内基梅隆大学软件工程研究所(CMU&#x2F;SEI)推出的评估软件能力与成熟度的一套标<br>准，该标准基于众多软件专家的实践经验。</p><p>CMM侧重于软件开发过程的管理及工程能力的提高与评估，是国际上流行的软件生产过程标准和软件企业成熟度等级认证标准，它更代表了一种管理哲学在软件企业中的应用。</p><h3 id="什么是软件过程成熟度"><a href="#什么是软件过程成熟度" class="headerlink" title="什么是软件过程成熟度"></a>什么是软件过程成熟度</h3><p>一个组织的软件过程能力为组织提供了预测软件项目开发的数据基础，提供了全面的软件质量保证。</p><p>软件过程成熟度是指一个软件过程被明确<strong>定义、管理、度量和控制</strong>的有效程度。</p><p>成熟意味着软件过程能力持续改善的过程，<strong>成熟度代表软件过程能力改善的潜力</strong></p><h3 id="软件过程的成熟度等级"><a href="#软件过程的成熟度等级" class="headerlink" title="软件过程的成熟度等级"></a>软件过程的成熟度等级</h3><p>软件过程成熟度模型定义了五个等级，从初始级别到优化级别，分别是：</p><ol><li><p>初始级别（Level 1 - Initial）：过程是<strong>无序</strong>、<strong>无计划</strong>和<strong>不可预测</strong>的，缺乏一致性和稳定性。</p></li><li><p>可重复级别（Level 2 - Repeatable）：过程已经建立了基本的管理控制，能够在一定程度上<strong>重复</strong>执行。</p></li><li><p>定义级别（Level 3 - Defined）：过程已经被<strong>正式定义</strong>和<strong>文档化</strong>，能够在整个组织中得到有效的应用。</p></li><li><p>管理级别（Level 4 - Managed）：过程已经被<strong>量化</strong>和<strong>管理</strong>，能够进行定量的分析和改进。</p></li><li><p>优化级别（Level 5 - Optimizing）：过程已经达到了最高级别，能够<strong>不断优化和改进</strong>，以满足不断变化的需求和挑战。</p></li></ol><p>每个级别都有一组特定的目标和实践，组织可以根据自己的需求和实际情况选择适合自己的级别进行评估和改进。软件过程成熟度模型的目的是帮助组织建立一套可靠、稳定和可重复的软件开发过程，以提高软件质量和开发效率。</p><h3 id="软件能力成熟度模型集成-CMMI"><a href="#软件能力成熟度模型集成-CMMI" class="headerlink" title="软件能力成熟度模型集成(CMMI)"></a>软件能力成熟度模型集成(CMMI)</h3><p>CMMI （Capability Maturity Model Integration）是软件工程模型、系统工程模型、集成化产品和过程开发模型以及集成供应商管理模型等多个模型的<strong>集合</strong>。</p><h2 id="例题（小题）"><a href="#例题（小题）" class="headerlink" title="例题（小题）"></a>例题（小题）</h2><ol><li><p>软件设计的主要任务是（A）。<br><strong>A) 将分析阶段获得的需求说明转换为计算机中可实现的系统</strong><br>B) 完成系统的数据结构和程序结构设计<br>C) 完成模块的编码和测试<br>D) 对模块内部的过程进行设计</p></li><li><p>从工程管理的角度来看，软件设计分两步完成()。</p><p><strong>①总体设计 ②详细设计</strong></p></li><li><p>用户界面设计的任务包括()。</p><ul><li>确定用户界面类型</li><li>建立任务模型</li><li>建立用户模型</li></ul></li><li><p>胖客户模型和瘦客户模型的区别是什么？</p><p>胖客户模型和瘦客户模型是两种不同的客户端&#x2F;服务器端应用程序架构模型，它们的区别在于客户端的职责和功能不同。</p><ul><li>胖客户模型</li></ul><p>胖客户模型也称为“厚客户端”模型，它是指客户端负责处理应用程序的大部分逻辑和数据处理，而服务器端只提供少量的数据和处理服务。在这种模型中，客户端通常包含一个完整的应用程序，包括用户界面、业务逻辑和数据访问层。这种模型的优点是客户端可以快速响应用户请求，减轻服务器端的负载，但缺点是客户端需要占用较多的资源，且难以维护和升级。</p><ul><li>瘦客户模型</li></ul><p>瘦客户模型也称为“薄客户端”模型，它是指客户端只负责用户界面和少量的业务逻辑，而服务器端负责大部分的数据处理和业务逻辑。在这种模型中，客户端通常只包含一个简单的用户界面和少量的业务逻辑，所有的数据和处理都由服务器端提供。这种模型的优点是客户端资源占用较少，易于维护和升级，但缺点是对服务器端的负载较大，且客户端响应速度较慢。</p></li><li><p>面向对象设计的准则有哪些？</p><ol><li>抽象</li><li>信息隐藏</li><li>弱耦合</li><li>强内聚</li><li>可重用</li></ol></li><li><p>为什么要进行软件维护？</p><p><strong>软件维护是指软件系统交付使用以后，为了改正错误或满足新的需求而修改软件的过程。</strong>一个中等规模的软件，如果其开发过程需要一二年时间，则它投入使用以后，其运行时间可能持续5～10年之久。在这个维护阶段中，<strong>人们需要着手解决开发阶段尚未解决的问题</strong>，同时，<strong>还解决维护工作本身所产生的问题</strong>。做好软件的维护工作不仅能够<strong>排除软件中存在的错误，使它能够正常工作，而且还可以使它扩充功能，提高性能，为用户带来新的效益</strong>。维护阶段的花费约占整个软件生命期花费的67%。因此，应充分认识到维护现有软件的重要意义。</p></li><li><p>怎样防止维护的副作用？</p><ul><li><p><strong>修改代码所产生的副作用</strong>一般可以在<strong>退化测试</strong>过程中对其造成系统的故障进行查明和纠正；</p></li><li><p><strong>完善设计文档资料可以限制修改数据的副作用</strong>，在文档中描述了数据结构，并提供了一种把数据元素、记录、文件以及其他结构与系统模块联系起来的交叉对照表；</p></li><li><p>在软件系统再次交付使用之前，对整个软件配置进行复审，将能大大减少<strong>文档资料的副作用</strong>。</p></li></ul></li></ol><h2 id="例题（大题）"><a href="#例题（大题）" class="headerlink" title="例题（大题）"></a>例题（大题）</h2><h3 id="例1：医院病房监护系统"><a href="#例1：医院病房监护系统" class="headerlink" title="例1：医院病房监护系统"></a>例1：医院病房监护系统</h3><p>在医院ICU病房里，将病症监视器安置在每个病床，对病人进行监护。监视器将病人的组合病症信号实时地传送到中央监护系统进行分析处理。</p><p>在中心值班室里，值班护士使用中央监护系统对病员的情况进行监控，监护系统实时地将病人的病症信号与标准的病诊信号进行比较分析，当病症</p><p>出现异常时，系统会立即自动报警，并打印病情报告和更新病历。</p><p>根据医生的要求随时打印病人的病情报告，系统还定期自动更新病历。</p><p>经过初步的需求分析，得到系统功能要求：</p><ol><li><p>监视病员的病症(血压、体温、脉搏等)。</p></li><li><p>定时更新病历。</p></li><li><p>病情出现异常情况时报警。</p></li><li><p>随机地产生某一病员的病情报告。</p></li></ol><p>系统功能需求：</p><ol><li><p>监视病员的病症（局部监视）</p><ul><li>采集病症信号(血压、体温、脉搏等)。</li><li>组合病症信号。</li><li>将模拟病症信号转换为数字信号（A-D转换）。</li></ul></li><li><p>定时更新病历（更新日志）</p><ul><li>将病症信号进行格式化并加入更新日期、时间。</li><li>更新病历库中病人的信息。</li><li>可人工设定更新病历的时间间隔</li></ul></li><li><p>病情出现异常情况时报警</p><ul><li><p>根据标准病症信号库中的值，判断是否报警。</p></li><li><p>将报警信号转换为各种模拟信号（D-A转换）。</p></li><li><p>实时打印病情报告，立即更新病历。</p></li></ul></li><li><p>随机地产生某一病员的病情报告（产生病情报告）</p></li></ol><p>非功能需求：</p><p>1、监视器与网络的<strong>可靠性要求</strong>，涉及人的生命安全。</p><p>2、<strong>效率需求</strong>中对时间、空间的需求，所采集的病症信号数据量大。</p><p>3、<strong>互操作需求</strong>——如要求监视器采样频率可人工调整等。</p><p>4、对病人病历的<strong>隐私的要求</strong>。</p><p>医院病房监护系统分层DFD图</p><p>顶层确定了系统的范围，其外部实体为病员和护士</p><p><img src="/./img/image-20230612185844276.png" alt="image-20230612185844276"></p><p><img src="/./img/image-20230612185919785.png" alt="image-20230612185919785"></p><p><img src="/./img/image-20230612185944160.png" alt="image-20230612185944160"></p><h3 id="例2：BBS论坛的基本功能"><a href="#例2：BBS论坛的基本功能" class="headerlink" title="例2：BBS论坛的基本功能"></a>例2：BBS论坛的基本功能</h3><p>用户登录进入论坛(一般为游客，有时还要注册为会员)，就某个话题展开讨论。通过发帖功能发布新的话题；通过回帖功能回复已有的话题；通过搜索功能查找已有的话题。管理员通过管理功能创建、编辑、删除论坛的版块；管理注册的用户；管理帖子等。</p><p>请绘制系统管理和系统用户的用例图，以及会员发帖和回帖的时序图。</p><ul><li><p>系统管理的用例图</p><p><img src="/./img/image-20230613094220548.png" alt="image-20230613094220548"></p></li><li><p>系统用户的用例图</p><p><img src="/./img/image-20230613094257469.png" alt="image-20230613094257469"></p></li><li><p>会员发帖回帖的时序图</p><p><img src="/./img/image-20230613094328421.png" alt="image-20230613094328421"></p></li></ul><h3 id="例3：银行取款过程"><a href="#例3：银行取款过程" class="headerlink" title="例3：银行取款过程"></a>例3：银行取款过程</h3><p>画出银行取款过程的DFD图。问题描述为：储户用存折取款，首先填写取款单，根据“账卡”中的信息检验取款单与存折，如有问题，将问题反馈给储户，否则，登录“储户存款数据库”，修改相应数据，并更新“账卡”，同时发出付款通知，出纳向储户付款。</p><p><img src="/./img/image-20230613130114551.png" alt="image-20230613130114551"></p><h3 id="例4：一个报表系统的扼要功能模型"><a href="#例4：一个报表系统的扼要功能模型" class="headerlink" title="例4：一个报表系统的扼要功能模型"></a>例4：一个报表系统的扼要功能模型</h3><p>报表系统主要功能：根据输入数据，进行分析，最终输出符合要求的数据。</p><p><img src="/./img/image-20230614143120016.png" alt="image-20230614143120016"></p><p>报表系统的用例图</p><p><img src="/./img/image-20230614143146552.png" alt="image-20230614143146552"></p><h3 id="例5：学生选课"><a href="#例5：学生选课" class="headerlink" title="例5：学生选课"></a>例5：学生选课</h3><p>某程序的输入条件为：每个学生可以选修1至3门课程，试用黑盒法设计测试用例。</p><p>（1）按等价分类法设计测试用例</p><p>（2）按边缘值分析法设计测试用例。</p><p>（1）答：</p><ul><li>合理等价类<ul><li>选修1门</li><li>选修2门</li><li>选修3门</li></ul></li><li>不合理等价类<ul><li>没选课</li><li>选3门以上</li></ul></li><li>测试用例<ul><li>选修＝2</li><li>选修＝0</li><li>选修&gt;3</li></ul></li></ul><p> （2） 边缘值法 0，1，3，4</p><h3 id="例6：保险金程序"><a href="#例6：保险金程序" class="headerlink" title="例6：保险金程序"></a>例6：保险金程序</h3><p>保险金程序，用等价分类法设计测试用例。</p><p><code>保险金＝基本保险费率×年龄系数－安全驾驶折扣</code></p><table><thead><tr><th><strong>年龄范围</strong></th><th><strong>年龄系数</strong></th><th><strong>安全驾驶折扣</strong></th></tr></thead><tbody><tr><td><strong>〔18,25)</strong></td><td><strong>2.8</strong></td><td><strong>50</strong></td></tr><tr><td><strong>〔25,35)</strong></td><td><strong>1.8</strong></td><td><strong>50</strong></td></tr><tr><td><strong>〔35,45)</strong></td><td><strong>1.0</strong></td><td><strong>100</strong></td></tr><tr><td><strong>〔45,60)</strong></td><td><strong>0.8</strong></td><td><strong>150</strong></td></tr><tr><td><strong>〔60,100)</strong></td><td><strong>1.5</strong></td><td><strong>200</strong></td></tr></tbody></table><p>答：</p><table><thead><tr><th>编号</th><th>年龄</th><th>等价类类型</th></tr></thead><tbody><tr><td>1</td><td>20</td><td>有效等价类</td></tr><tr><td>2</td><td>30</td><td>有效等价类</td></tr><tr><td>3</td><td>40</td><td>有效等价类</td></tr><tr><td>4</td><td>50</td><td>有效等价类</td></tr><tr><td>5</td><td>80</td><td>有效等价类</td></tr><tr><td>6</td><td>10</td><td>无效等价类</td></tr><tr><td>7</td><td>120</td><td>无效等价类</td></tr></tbody></table><h3 id="例7：白盒测试"><a href="#例7：白盒测试" class="headerlink" title="例7：白盒测试"></a>例7：白盒测试</h3><p>为以下程序段设计一组测试用例，要求分别满足语句覆盖、判定覆盖、条件覆盖。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span>  <span class="hljs-title function_">DoWork</span> <span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span>&#123;   <span class="hljs-type">int</span>  k=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;   <span class="hljs-keyword">if</span> ( (x&gt;<span class="hljs-number">3</span>)&amp;&amp;(z&lt;<span class="hljs-number">10</span>) )   &#123;   k=x*y-<span class="hljs-number">1</span>;         j=sqrt(k);     &#125;                                <span class="hljs-comment">//语句块1 </span>   <span class="hljs-keyword">if</span> ( (x==<span class="hljs-number">4</span>)||(y&gt;<span class="hljs-number">5</span>) )   &#123;  j=x*y+<span class="hljs-number">10</span>;   &#125;                 <span class="hljs-comment">//语句块2 </span>   j=j%<span class="hljs-number">3</span>;                           <span class="hljs-comment">//语句块3</span>&#125;</code></pre></div><p>语句覆盖：</p><table><thead><tr><th>x</th><th>y</th><th>z</th></tr></thead><tbody><tr><td>4</td><td>6</td><td>9</td></tr></tbody></table><p>判定覆盖：</p><table><thead><tr><th>x</th><th>y</th><th>z</th><th>判定</th></tr></thead><tbody><tr><td>4</td><td>6</td><td>9</td><td>TT</td></tr><tr><td>3</td><td>4</td><td>10</td><td>FF</td></tr></tbody></table><p>条件覆盖：</p><table><thead><tr><th>x</th><th>y</th><th>z</th><th>条件</th></tr></thead><tbody><tr><td>4</td><td>6</td><td>9</td><td>TTTT</td></tr><tr><td>3</td><td>4</td><td>10</td><td>FFFF</td></tr></tbody></table><h3 id="例8：教务管理系统"><a href="#例8：教务管理系统" class="headerlink" title="例8：教务管理系统"></a>例8：教务管理系统</h3><p>拟开发一软件，完成学校管理中的教务部门功能，包括班级管理、课程管理、帐户管理等。</p><p>班级管理用例包括新建班级、修改班级、解散班级、查看班级。</p><p>课程管理用例包括添加课程计划、修改课程、删除课程、审批课程、课程查询、成绩查询。其中课程查询和成绩查询都包含了打印结果功能。</p><p>账户管理用例包括登录、添加账户、更改账户、删除账户。   画出该系统的用例图。</p><p>系统总用例图：</p><p><img src="/./img/image-20230614153126360.png" alt="image-20230614153126360"></p><p>班级管理用例图：</p><p><img src="/./img/image-20230614153146968.png" alt="image-20230614153146968"></p><p>课程管理用例图：</p><p><img src="/./img/image-20230614153154386.png" alt="image-20230614153154386"></p><p>账户管理用例图：</p><p><img src="/./img/image-20230614153204270.png" alt="image-20230614153204270"></p><h3 id="例9：工资计算系统"><a href="#例9：工资计算系统" class="headerlink" title="例9：工资计算系统"></a>例9：工资计算系统</h3><p>工资计算系统包含如下功能：</p><ol><li><p>计算工资</p><p>根据人事部门给出的出勤表和业绩表计算奖金和缺勤扣款，通过生成的奖金发放表及工资基本信息库的信息计算应发工资，根据应发工资表计算所得税，根据后勤部门给出的水电扣款及缺勤扣款表和所得税款计算出实发工资，生成实发工资表和工资清单。</p></li><li><p>打印工资清单</p><p>根据工资清单完成工资条的打印，给职工。  </p></li><li><p>工资转存</p><p>根据实发工资表生成职工工资存款清单并将其发送到银行</p></li></ol><p> 顶层数据流图如下：</p><p><img src="/./img/image-20230614153759423.png" alt="image-20230614153759423"></p><p>  请用绘制其中模块1计算工资的一层数据流图。</p><p><img src="/./img/image-20230614153821993.png" alt="image-20230614153821993"></p><h3 id="例10：看代码程序"><a href="#例10：看代码程序" class="headerlink" title="例10：看代码程序"></a>例10：看代码程序</h3><div class="code-wrapper"><pre><code class="hljs txt">void  Sort ( int  iRecordNum, int iType )1 &#123;2    int  x=0;3    int  y=0;4    while ( iRecordNum&gt; 0 )5   &#123;6       If ( iType==0 )7         x=y+2;8        else9           If ( iType==1 )10             x=y+10;11           else12               x=y+20;13  &#125;14&#125;</code></pre></div><p>要求：</p><p>（1）给以上代码画出控制流图</p><p>（2）控制流图的环复杂度V（G），写出独立路径。</p><p>答：</p><p>（1）控制流图：</p><p><img src="/./img/image-20230614155915620.png" alt="image-20230614155915620"></p><p>（2）<code>V(G)=4</code></p><ul><li>路径1：4→14</li><li>路径2：4→6→7→13 → 4 → 14</li><li>路径3：4→6→9→10→13→4→14</li><li>路径4：4→6→9→12→13→4→14</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习与深度学习复习</title>
    <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/"/>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="c0c0d01026f6b61205de2081a6b110c8273830436f3f209ef8959acae7a3fb1f">2efcdd43683410c5bda070fc3dac7b049e85e9af4b45a18eed9c924a52f21ea8c7fd3f52253d8e4ed3b545219dc3c9996ae0516a607fa7e9239a6cce41e4f41799b268129688f14b77290c1a469857f74d94fd38525778d9996cf1b5a4e9a0c3437c593cc9e4235fba875755091af23fe8ba32c1e84024d0b9274b21db04bd1239b25d04e13f958c50aff1d76d7226e8b4a1bbca52cd64006f0f88275b6728ac69f56b2f4bc3bad759b06dad6c91b143b2cc0e309642578e4f979d980b9c5e9fd97a362bff6c3fc8346b29bcfb43951b0513fce05bbc8a62f5d56cc8cfff72a44bd57bca80e8af66c8d008549d696233c6b5b189ec77e295bd905c95e324cf2f49f0eddb756bf1c20f13925c267358cee9ab3fb37f97caabb7608a670c5513da36bb6ed6c812ec1c15c86e99827cba643c5123aee748660138782bf07b6099f9f74aedcee5c7e198f16a8b4ebc6e87ac001c39ff5dd638927560ec7468f8ba6316101a874d5f83bc0e38645f80f0973d6ad4d02257edceca81a291ecfcea46d0cafb5b5a25edecfdc3c3bc825945342cf7b9fe7687394dfb4049aa3cffe51c3e76dcbcc896001d6b11cbe9e19bf8e5e6e116fc7f6c63fd35a114d2362977bbf6a28fb05d45708d601d0ba4d86829515f95c75e80edf1fd19e6f1e2ea73b9a303b0d4ed387da4f8d84ac32f7c9b06f565745b728c54a776b9d40fe40b6203d79c4a53df2a335dc16b7ee257f7fd679fc1b8e2ceca3cf94c9da674c7079c7934febf293fcc064a95e89037355585744e647c0eea21524c083d1e42da84c65087c8178055aff07a64c9017fcf12a113c07149140a1f2bb34ea44c6259a0e1cde0a8f8dfb2de9c70b84b698895a8fb9b57c488b80e5755b13713d3c8cd46b7fbd36c601554d5d30b7aa2e04fb7f0db0c82fc61bc9ad165b5e1ede8cd823035f2deb39820435abba9d3f3a1d5a5f5c3555ca4b682e578bb8b1584c840831895eb52072d1b94cab0b292f2e43d160f2dd658d2e719e94a7a14788b079d7fed993333b594012690b7e0ac23b6cab5b18e6197e44b038fb336d6849301497bd01e9934a27befa3e5f31bc2a7c09337c80174af116a377d78439ba4bc4e169df55ef36dcb3ec12b9b1c4a69ea0c986aa485b7dc6701863605012648bbba9b1679b4b5f4642da9b783cdfd628bed4f9d101df53e666006187c1e7a68543a40714bf481f5814992da3d40d1f33269a9f3b319d7546402a147b040fb34276dfffb6cfacfc6ac24e9714265da1def00e02ed8651aef72872d4da66f9583d9df5cc14b033ceacc3f22c62ac00718cf2e67519c6b6f5138b3e2858d5296ab87923dc60f7c9e57fe99a81dc68645ca6958a0319930c1cf598f29e9b248b543ae5985ea87c86d3885f716ac18f4c15e8856c4401b12d2530c77380c9410f75fdb201f8c3090be48c814475db1f22cab0fea691890e2b0921bcf33959dc4175364a2e15f19ca2c58b3e57aa754b82ff4497f268f08734cba5a03aa127549af1ae7450848b0bff30f557b3965baf12486c2404fcc24076b9828ddb1f229de25373a0463dd3820aebec9efddc5dc39d05b0dfc0cadeba25689122143df67e4ea5b759a8eaae796a98c87b546abce662ac7f566160d181b2afbd3b53e8c9bb0be1aa55cf6660ff48be78229a7f0ea28563f4d5d3cc9892515db6147660b19f4f2e19124725053f153c6505d9fa06be46caac41aad1f5e0cc5da2887623ee1daef344c409f70cfd62f76ce001be7e974d38aebd4a4e993ac3983c2018bbf3baaefd69d059e7318d568a650217fc454432a5499fb8d957cacc9d6b118ec224254b007f0551fb279c6d0633b3e93bd65932bdd69687532f74193150ca93a562b2f52340d5c2bc889411dae423e9b5f9e0ae668240a9ac70b2431b73f1f9c0df43a20ca9c7a765cfd27b0cd53dd1f8fc83fc5be863b8364febf4432cce8dc700981c745448457c29bc8e823a220d5321c1692b5cda2ed7dd5973bb4f9ec5b0ddd0d7042c90f982704958b6569b3031dbb65863099307c8a312aa03b41fd684c87c18c170a583bf7fcec6cca4dc0cc178629c7d1e9cc46e25aa15b7262b923bd0fb23602dfad53b46d3875860c9f384f16847c498aea052e3abf28c2f989593d5c44f5a685d24b97adff3d6ae1747554ffc2c7f8ef90a8370fc649adfff064c39b82b77b038c8425359776114007cea0cee38548ceb3d5a8bb676ef97e4e6813ba27e8e0c9df3694bc0e4d2b94682fac98de53223f34a54f042c7cc9c142c865d6eb2509ce8f81ec485e91b5f3a574e73c6fa380bc9e136cdff7bf7285331a780732a0e109cf34bc68eb13ffa9acdfe3307f56a095c007f55d1ad4165b6a9ef5feefbc428dc253631276d227ecbb4c3afea9e19802a63ff47858d375871eb0173752f4d876d9c3fb813e44735035eb074c73a9367c3c1776b07ca81b31b1334efe33c89992f90675c1d6bde7e1aa8c7250d847734a15bdd27ba275ace3e8439547a5959caeafe2b4dbb794b303fc33e9517bacc8cd31ff68d2d1ac7fdd53fdfa66da87bd3a9f48549b3369ae817b3f3aa9a27edc74bf2ad3937e58c9be8cfb88b0310ed478bfd94d528a4bb3341cb850441cf85223194a4c0f01d759098188d01376b613adeb4e8f83f23cfaed9fcf489a4ae67b321e1dc7741da8429c9e78e8cdf3aecce4e0dc26854cc673c7ae2d41ca7b5d574b521e3bf72783ddd7ed4f2f2e52437ffbc2749c34364e7c252829a490a8aa86b80c398d7f241880f50fdb1c7cc5094394dd40daf559dd07f8a7e70b62cd0f54f42953a682de0856c8c3927806a08e469975e880a9ad566b5ac5fb63f71e032856e316e663718a8b34f2d35b21c383903e726c6e41c61e1903386750a6f59ca95d3cfb0d653d73cdad0a8936ed5652751854e98ce49b2fbe76f9b503be2b5fc63b5dd15508436175fca4772c613c6005976951b6731200bdf0d79c6b907da47abf3ac7ae60aa072e960d7cc9caa5465292c2f6ddf723d6e2510515a968e58a6e6e02f647f0d1268fb6ae73d50b62335f27ace9bcc5b2cf32ae530523843adb8c9bf9087601ed02175a95ed9453fe8932347a857270aa4043d3cc44e21e4dae3e7b957f8c2d643942ddaea66416f56d7adcdf4f8e3995f2057866ab5073f64faef54bd6ab7819e88be0490f9c93c04d30241f4582ec078182b26e0c23581bb77915266a580a38974f3715e7c91d39ec3ab6694c5da5ec6e9cc0d45f4b759e60298ed028c6d6ed7d05c6c09118fb0208c8be8821e105d4dc3d58a3067c87d69e0c7ec764fb923abf423a6b3e4d167c12115166cb3bed6a63830f270a12bc0d573874c95826c292c34b714e2a934badc3360d10db547c5d28d3c04304e791f381415a69a55030ef496572eccfb39ce310c39d2dbd92b34f276127261c8e11b2ba4c669175c8a9df376cf0f0e0a636ea1da44aa54fd4a990762b386f5d3cee9ad1cc102dc68b0f712789cc5ea76ddb0112aff9a21d7442dc65ad813ecd68f3526a014eeba8d2ca77168b56a104194e14eb7231929d7a51f6557ad689166db7b49d7bb97636bb7dae495d6729c500b8204bafaf0200934d25fb49e1e76dec7f449d824c8e4355519313e0cb069c6887b49c96b0b68d3ddbf0b84f7d99ed0d3d5ffcc20beb3e7db47752ce70ba9fc0ed4c32531b0aa232f5a991b1f7c1856df625721bf6d3b0be03b9a839b6db2692c9030e619ba7dbd2a398ccf2cae258e9e04b46c09ecc1905698a413d77d8f6a99cedbb5a2057d1b70de72c63816315bdf916e6fe531be125852cb352488a96186e7f34b5bccd79314127341d441671bd9b459e632c09864c9078e5d28cc1f19b417947828b5681f68ff9241a4dcf33c4cb36400150ed23ebf7a1537ab2a5ecf590484283596e044d5bf3026a723560a8ae8ed1220a8e2e23bca4cc9a535d53b28949998708fc842ad06286da2920859bceb54c2aaa81109cc8c558c543ce5310750d953bf7ee2c9b0a13afee5a3201fa19681c70e2d4009310531cdb8c57d48f41736e5c98d4e50a175fe0de57e2f85b0ee2191f1ce620b458132bb7e4a35ce3c7c74e2af871e4d74b401c6048185fb2d3cc1926f9d5b40150741952094498635cb16721d33f9891416c1784fde891cdb5576eeb402d9a8d421937edfa019363e636deb4e0ab4cbaab5a0cd4f716db6948792d1db91546e3fe61342a26dc6022ecda430a9bdc895b2b286a01979010037bf3b064f41e68e34685f1354286be6fa6f3d9a8d682d8bfd8b6b064794969b5ffdbf0d329e26a1ba1e4909a8482413cf4ce4686945cc3525a63182314327195efaf92a556aae3a90303c96c86ae71aaf3d153fab785fe76f5ee51d8cd6692620a0ee63e525396b936474a26e96829611c9be4004c612c0a6de6af8ed636ae6036f56c7de35fecc1ff2b57fce148afd3030163b97210d49a7258a5f7ba3e541aab7f5480bb0224af9d2afb5b1b7ba5ddd1d81d640544d2af4b3ec8df8d5a75c53a468431d75ee10dab0fedf83e9951056bf4c4ac0e9d2343ea85d1bc9a1c60806d48851b588706775a1501c6f02024e159b080281bac2be01c5d6420ac75143201e8e809ad6f6c035f492a9ddaaffe14c35a775618b77e291c32e90deb230f9b01f8b1560506f290d4b2263dd65d4471c01f3b248497b111c05129ef266d2addba68aaf5e276d451a228c642c67fc7a9822d268db52bfabe06fde2f58595f6c6e8a2019780179c7a66f55be75fc6a0c6477a94c4ab132741518d5690d35dc3ad96b9f5439e27b1520bf999d7d601cae1fa24573ee442280c845a10bd2e10f1216303201b380f26e9024f1bab5ec7fd7de36704c83f25a3bf89d7af7e39354070d6665e105d9dc1cf8ea29277123966d03d80ace3455dc612905495af91cadd2b19575098532431b362860aa8744b42c005256cc75ca5589bdf06e224eeb991ae9a4e680499561346f46440337d784412f306e064fa7ad5cccf09a1a3fd77f2795175dcb551acf089ade80c172637a9e4eaf5d2216d489ec2a79e9e89cb8fce24cdb4d7ec0cf1f078ffb961993239365542173da06ea7c714bb5261f873378c7355f494d1ed1b08cc5704328dfeac2d2a2fafde743c33ef57a2bcbc9a8c92d605f8f3fdb391b68408be206da874cbb209fe433abd52afaa0b46b4f3bc66640fe10bb17f7013fc56285ad04325f0bdf60ce700632af66ae675ac090f192fb33df8d88cb1e2f4db5abc1bf6ea3bebf13bc4e1c8e7b2d07dd4fc1589557dfb0b79a58ad46a1aeb803699b439545e8ad5895432187c0a243a7aefdecbb1f336e1b8e215ba53f5e84aad48287ed02a2025fdf2ec1d0cf4b3a767b24f77cebff7d1f5d5fc8558a7e000f3efa1cd071b0ecc73ec07070f44c5ec7bd9cda390ba590782a729f75cd83b37ede4da1253a367f1f67a5add751a2e515218b32f0c9464701e902cf6f0c1997811f6338e8543cc7ff3657a754a4427c9c925c83b1545be69d0a2ccc4c720bdda04997ecc3515af9856b2f1c7830b370f3349c6f80227141c4888a463e1c3ba609867c2728bebed56910429d4f56d38e8e1dfcd8b3df4bcd17a1fb7ce49662a240460ca638fbe3680c852fdd5a07485b258acbf3bab680e38f65e2917452e6cd1042bb737a6fabfbc33821e78e73ecc52aaaf63d507c8256637ad2b1e532a86a6eca6e0b63b4d68a9d169aa6e641987df97983abf96c63a7d0141b191b455184f30871405a5d7ff843a0e025d956580994447faefc0ec0ab3d0c0c57fd993fe56fd2ce37906a840f726e3d67940ed33bc5edf6884aa9942d256e6504d3acc54830a7f5389b4bb187d5b7215c587f6fa994f960d233efca892a40479401fbcf92c3f5836a158477a2a783d1b7d176ca4d5989671ab9ce043d7592f0b9e06175909cf79582cbcba6089daa8b2a87a20bb673f58b0ff7daeefaf41460a0239337f101850be90ec6cfc2276cbef5cad528c70caeb136a2aedbb65a04996fdba9e655c9d2aabfdcefe0018630617f7a36fca157a49e45be69a03f4ec104ca7ee723a17d2b4c37a5e569de40bb8d4ef7e9e465389652d6774806c58611c380e7518cc7e2210c11560e776fac0da514747b230d2b20e4df083b75bc6c29e4f66c83c132bb6f7f084f968cb4c8045e65029667a0100b64a533f3a974e71217b725f0f136b0a9d4c8ca7c9da8b5ee36971acfc9b030210e7610c170eeb43eb93d917339a965589d9be3ce0799f739e3d334d69a68d00c57580bc184a650a86fc00bc549ae921389e376c8bd69eafdf9e335ba9a130fe66893b5eb340884c333c11cf8d8ed7bb78927599aab84acf8fa9f8340dc888075e7e5e8cb667cbbd033b744bd678a369b43a76433e651dded45a94ab52cef3c4c4b3163c6814d8a23162813b7eea37f238326e94972f81bb00842eaa7749d70a850da81bb8dab983c6e998b1bf184f8403de638d17c94af3a4eba063722734b7e1380f1861a0c12cbf73a412c031096083b924b382554a21230ee18074e56bd10b7dd50b8f11c3f18cbe8638ec02aa99a89c8548212831a15c523993a2934d4cba1c0630374c4e88575109095129c0390c9f3efd7a3ceb9b519c2f46e40bd6ea9f8bb01db3e9cf2cfdf4c805787103a9c6d41be7a21cc4a4c1c6687307ad1910a2b9b4f08e84034fb4b83e54b33d7e0732ac7127f10ac47669aa2f59f1b95e6560df664b16d8a441f7f4ea921d159042d3bedbd30258a391d3c7acf7fb5993b368ed2ca9d635b65e12167cc508eba447697309aaf41475cc4de5357a29ad6d76735ac361bb3c26b0f6a26ba74a296b04c0e4a7343679814d9f3151aa06d01e9b24dc223be143719072e762b476c518315c78786bdf41163896804151b7c8791c69bb53f8214eabfd3ffe1fc0a7aa7db4361c0c17bee1500744a82c9f0cd3e355e840722ebd534b7edf4577512e7f2ecaf4185b6aaf9c3b3c16e2857efafd73eb792f433a08456f1a0b56dc6bd4d4f848de30f7ded0595fac406937ed045f02baac6d32046226810ae3ff1218300eaf35cabcd69809f9a5da7087e691cb3a944a0e5dd6d39c3bf8e276102c30fd472a2107c8b022419770f6060b4afa8259bc0cf6dfb5a919f751dbcca2bb7bdfdc97f64796da62e4c56da46a218922932519de428802c4dac99d05be8d7f83ec1d941926c39b2ecc728a80968146bcc45577e56edd05af31ced7d6a83796b13011fbd74e0358d167dad4f2d0dd5632cc802f58d3ac6ce8cce5584fabf17d4bbb294c9b29cd2e313b73b8c914b8b7a7097bf83b59257753e1f8d12a8ac391ba7feaf0eb27d13ce08457ffa5bfb0341d4b8911d5efc9b2320a32a633d0432c0e2ba6eae2e86d291d0184cbc77f2cd424996f4ef194fc2d19fdd7fd8c5f34126657465063dcc922f53bf3c1fe565d5574a47b9f2dc58bb3cffee8409111f62da4c3a1a7d38567db1ae6cdfa87ae534e98d48123453d73612f581fcab0fc2f66b7b9e5a816b9bd2559b856c992c7c7d081839886a6139b59a82d54875af7aa435d6c41105d0c25989bcb42dc5ee8996647c59879fabc3dc9339d9c24cb61694aa36e285c9ca5c7ae89a76d59d8943e1396948c95b1067484b2bbe10cbfddf05b69ba7102e4a51b404fb999ac2abfe9b12ebd584fe8b6b8aa73f0594afec9fc60817103a55dc12a3122850a336fcea55215c119afd3648c55408c60aa88647d50602c0c626f281344dfb7d44a92340c9b54946cf73ab35086b57ff7ec770cca304fe1b058bb5cd85c01b51a4a09e6e5131afede64696a4a42ebd975925c89a25192bf988bfb60fe37c9e0292ed5ef72d6b2b25535854445f6d51ca000834347c211e2cce5cdec5b68f9dea1e0e4dce36654abdcfd95033badc58a4aed14273dbdd5f721ed5fe57f0260606526191fdcb07c02f01adc9137bc9a2b3ebab2538b5bd6af223c2b4d4a2151838fe2492d83bdd0028db21937ccc0eb0ccb052be10e28b9d8bf6fdaac5d34df407a04257593ed8f350a0545bc009993a2ef7d88c77f48f2d1d4f3995ce799fe11851e94a8637ebf7f2fd39743c5077e46c63739fe2bc681610f9c3372aa9760bb22b7a2f46fc4275aeda3a915193896686895cfa1459f312f742fb35c2fe895b4bc7cacbe51c92a1bbfc7c9b7228b32b0db749148c842376f91c25bc4c1ce177c1eabf1407f91a0629e01b665aa0e4757d7d7ee96b197d7badb147fdb744bd96c9c60ee1d75abdc5f31f4576ed02066c9d9808bdd14871b57c796d0af69449bfc4b8b859da5af5d1d2f59866b63277a822477df0917967d0254689454b02de8ea8624ef944893a3110fbd0588d6beecefc8839a27da84b11c91c6adafca378cd35cbb7238657d2252e300b50535d57840b159d01aab477d2ebeae5f55a2025bd5f1a958b2fde6ef3ece522be8615b74a1256d9a85cce9923c6f2c5a9d766327006045adcded8326569280efac61ae4a448ba013408e6d83848224cc9818d4a2bcb2caf3c0c7a6595f5bbcbb9229140774eb74aa67221e404572f6bc10ce76d24d7010d2125731ea021329be7d29c297e4a09f78e12a26deb5d8c46f526bf9086521e5eceb194632d9d6914582df338f4ee03b0d794e5ecb4d824b2821bdae43a9502520d99994af0bfdf89f78c66f59cc8d4b44eadd290331d8420a58df708219bee86e9adfdb889fb2a1589e7af7d49a054c9eac4b19ff4092c0209fa2cd322ef2cbe6ee31c2975fc2619c51bcb6b09cf905cdddb7d69971774b99210408cbc724954689eacfeb9e37681d18ee0086964a17a37c94d2d602e4daf1c9bc84ed699a85ca2508caa2e327b82e0440aaf8001e7fa1327841f8e05776d8ef419d2dd3ae45ec3effad44f66863da08d78805d986113a7c8b406a04d2545c4daef7b3bc8f764c40c8d9cd8252eb2a27dd720539be9c0d74d5553ad8df8591c11da0ecbb5ac4b9f32d867168025194d3996476ffd3e330ba506ba3a933c045c63c3d8eea9886704d2944cc720f782f3295dc6db0c006c8a88758614704112e461e45c2bbb5ab8c7598b033c36caf007512fccd31427c611fa1959eb747b2c90d4da6a1d821f5314ad055316ec2bf9281263e9840b5fd6ccfe4f2632bb24e4c85e3ed414f70af9ed3478ad61ecf93164abf8d03feff19a1f7034754521134bb3315cc3725325a6e58c8d603c31fcd057b133718bab52865e4497492b491712eefdbf97bfd18660c37885847a3d62bf2cba16095ca877a60f5e8322edafc5ae8a34a9ae5b351ad7d05477351b37c189c2c8807ba94f845310e9d5fce5aa4d3e94ef1371e7c0d64775a1cae28816aff4bec864730aeb93f755ee38d1382d75a330da124f14c1b07daf58b91c3cabb2012ef2af0ec06442e758b25d29d62aba50a166d17fc099bef875f2ef9c511d0ab72740fdf63af13d6dc53cb9be1c554fa4cd3aec000e94b375dfe5a9bf36e02d9b258b3fcdd975ee336c4a32a25a0729c4cd920614a5d66309876a0f9e660c743ac9cf79f303d74430747d9c45718309f9930f371de3223ede04989a7db3987606bd17de10504ba362be514cb2a2c26b96e83ad043305581500bdd0ac77b35043e6104b64394cdb18a52feb1d8e6d8c444ce364d91c2c92d690168fc8c5ded0482d2f294ab78f6f6d556f263099d7537b27418b7a218206e19bb76fd83a3eae105dc3c77188922777b439c16a3e14b068d28eea100bb9aec0bc91baf2ee384c9c8bb5be42a72a1fa86222c988a8be1a60b694b3b19dd282fe59cb09339b72b0d5ed92e80356ad116d7b01ac3d14fd7732fe1ee25c488b41ee5a1c5c104f329c6fd9789d67cfe34a5d946bb7f63a611207aa959a53539b978b0096af7a10cb987edf302642d883b5ed5d5efcc0bfdde4bd2fedb2c7c76c9da8af3ee90015dc5b153e73cec307a38860fbab92cd7e6cdf58c6fd2bbcb988c4ce3b7aeaa872d9ddec9c9da59a8ca5fab66e5e0d74d02978c70540d383734299e6ea4a3c8e253864a0286d83d40be74066326467ab5910485dee4fef992d3f4925408407cd5578800d2184124a7a8b22e036f26c0fbb6a4841f66e103f090036fe13a74dc9b20d24e507837c15875ddade92ed5304d629a7fca068e7a77b1c599de6b48df13bebafc7f5e7d202638436f6af6ee738ff4eb192ecf07a71c0906d38c888cce26c764f8e7888e6938dd81a2f3e360275fa546eacf76694f36eae7883c1823bcea91632f0eb743e59217383c2c4fa27b51c7bbeaf22479ebd3e7570b2917eadb94754cb152e97e42ec774525c54f538c5a58cbb17860fb878478b734f72fe5880f0fd3568415f01c80986e16d9bc50e72e80ee13025cfe516126cb259c0f4c7d45a7f4a83e1c39dd00bf65c96aec4f06b57f24a48297ea08579f32b03851b989380e460d6fec769a0871ecd17b99448fb47f5d6378284a2fe7972f01c3b691b6907a52d6cb52287cbd2f60fd222a8591cbd2459aef8a38dd04c08d8a04cbde1c4cff978dca7ac6629487c7d8a2a2a30a8eea7de9acea0fc70e83f773e3a03bae37631cfd50878f351f322c3c46f3f04b2970167110315bec795017fed8b3931b197a6c6386289b9e1868f621a9238e8fc91b47ff588d60f8272202c2882987f76beff533da2c6faaca82c1825a08f170881263a830b14dffc1f836d48d1e4a42ca9a2d04395a69d9a7ede33afd517af2d6a119defb42b03b9c685026ad22d31092a85fb1445bcd7020a930872e5572347420d6db872ec52febeb1bf0616ed9ecd7ff343e6da634c9fd6dca853d12d701ec9a970b31ed27bca234464d98f619495f29c6db4ee8e1923ad04c83cbb2a40911b413dde7706b1364d1e01b3c2fedcf80379185509bf761881888744c3a02e88dad0725cd512877f7047c51daa0b37ea5528e46cb665b7f6f6f704542bdc9ea7d4bdeb8a65157cd2f6c43d02828c2cd028d6112ac2efe2458cf1ec8e951e3aa35e4e457daf65ddc971fd4adf07a95225fe7467eb7948b75eab11287a2ef9005b52d008db9dcc0f71570a10836fbca53a658ed1a201a174c7dad5815307e3d9a536f2096b510ae25f7e6fa65deaf0f799e321f785fa3ac806a7dd32d8ec35cc2cff84385af09da33269a50938326e51ee228db3b31ad03eee891fa76f711fce22d868768b9cb7dab9dfdf1f0c14b6cf84b2fc7423341a93c2bbe511de72153377367c74090fecd60d5cd26007c7c72b64e9d2647f7a563abab0cf04d6834b144bb8a224b3033dfab98771fb793d94f6a4b38d63bb5cec7b36b8e8920eaaf49f46404e2f87ab5e48e06a6054db125829e910c1aca50e4df9998bc66355c9082f8e74ed9bc1264d25c05367c1802f69e51b275b5de71daaec7d200bc500384e731c23dfc7a6264974f2c15000c69c9a24b51b4ce97af339e70f14bbdddf1a0e6a4291b4f782e09497db67f8ea1b52c5377d9e66427c4b9fdde86beb884d77e67560c1824a0ac0ca3324fa5664c077a7d288638686d5a49beba6791cd27b8bd4aa6d72459761155f9eee4f9356f4393ca8ff0cdd7f4a03442971662977d6fec8801e156054fe2f09884a2b15be6a075d10d9505e3eb4bc4b14f399f112c021875d450fb7eb1762fa3338cdf253902c8fdc4c30d851e09a70bf3bfded957e8162f21c553010fa5a24df381bb8b00d08f2eee13792c61467f10533e1d85d2d9dfbe52ef7314f3d609bd812b85210e2c88acd661b848bc6ff507f0a3ab5de22f4d9569d734c6243c725bd26e8be94256ced6addc8d89000add5cfc986f1b02a31be41bbd4f8683982db36d1e8e822afcc3382c4fc323bf48e2b20a021891148d796ad2b904fbf0bd908f8e34171d19f800e39d1c61c2b1407d59eb8e3ba181bb7399af566241525d39c453f86b466642ac084bdb0d9c6923c8c17940664da38f32dcbd37a935d7c43d5d065b78b6639342e8d58733eef5890e94005854c0fe83b002d022c25f95b0a4196c665f02469a2486049314a41c9bfce6de1c37eb6f988137726ab2d097f3bdff37f49602b3ad4955be77e5f599a6e7bb115c7113f249bcb76704b0fbb52766343be854bd4720ed1720e509f1cdf354525a5b4e6e3ae6c8c602a13295c900a14dd3f612737850928cfb89e4dee2f7d3d541debbaff52795a113b1e4557fb3713c8a00d8955f6946edf0b01b6d0a0a5d69d178511795b6556fe9556f551b56690c506e689c347ebc730fed447ee2313452fe212676c5384437bcabde4e7d8dcb7772f8180f02d27dd600ccb6dbb4a51f4e6f6ed1b12b1d2caa54310c1fe9ed101ee85fac5a58b364cba930f20bdc301d1dcacf58ac9c3958fac063a9d95f83a11bf122c0f8dbee828978679d6bb1c9ec5c81ff4824a7f9de7efb724b34d6923db590f5f5764669cd0d481c015dfd15fe29c7fa3a614e02c2c5fbde3945fcd75f5f64a9eaa75c023056dcb9033f033cdbe99e31767ff7c11bae6d784a95cf059b0372f858aa0fd2b9e268f027573bf04e28fedc29051917e5a71dea90915889fc712fdb59aff099e93b81e2e5c2c45009c89bc9458051db044433bac4226cb87a5b137404bc69aa2d15e5aed7da870737d7d51a8d73834a0089c414b217c210772adaa3df8bb7f3dff6a5e1add59404d3a112d626822b7c5d0544ba9868adb5ffa99874ad8f28f80f1ab09302f1c59a3decc80e928326edc38c4f739bf898fcd3074f9b4cd4f0061910245a4c6be7de33f862a3e3d196205b8ec71ebef3082c13709d53bdfd20061759a0c90f0433cc62cfbe922d36becdfc44bbe88b7d046ffa548d6913be766f8af3e4d1ef2448c475e466b7b56f673eae0ac7cdd19d996967fcd46c0563d61ae91617d4534aca78f583f0bef4647311045f3b3224ad68d3d61d97a617f6c750b13a3199cb1a9b18350f406c657cb6f7139a2eb7ee2d460ebdda96742409767db59ef5da8876dbbfa8410967cc8475b96d136e93ccc85cd0538285c5311b12b52f58cf5cba736c575489c9c67bf0d934a1a81be59674102218f0244690bdb01a075e03ed712397f1763cc182b9a758716323f4e829f9ef9367457006c09633204ae3b7e429711d100ccdd4f97c13dfea7075e44d37d8f247d7c2fe8021527b025a3ea271e456e67220c352aa3ba92bcf0513fee3b7aefc873a75258e864f5a6c4ac24f5b2faf483ff64864c465db5a57d9c26690089e5b72fa13219c1c3856dd96a1c96f66793828d6b39fb1132e82254b9c6a8c08eb4a7a672947113fe68e9045385275ec42d3ffdd8735cb3573d4b7aedf0ca294c422775836097d14a8c0dc6e9b55c247774c726c31f8299eddb199f0fddc54369ce727654069450015dae74e3b046eda2a99af1b690ef2f4a6e25c816d73eb4d814a6affe9250679e2319764f664c0b7793da75b8ff3f9f2abeac92155e51c5a9628da6367d9002cffdc2907ee9e494ab105871e938137f70eafdb234d7e5eb6a781205bfc584b136e7dbd90eed74707faea30b3e540d661e3b25afb213ae697750267b9959cab8a7aefa9471af8724129286c6e3d0ee60d43a90189a0acec46d4632bb967acddf46f077a398903615cb518b28a1ad7d4ad45a37bcd395130c8f7d41321497a8a06366ab1af7361d2c81f2a48d1c209b413371f635c89c5ae24ce64b30401abfc8bf52ca1d4421543c1cbe0c2bc22028fcb6813cb4d513e8409ef12b29aebbc7f46b367adcd65bed78a7c213bbe13865f88e8eec61c415520951a5ad21419835727eb701ab5c6f6c19f36711767716fd0f10adcb9315196062603616d9c49fc263300d4016ab96cdd1f87cf917db1c734704c80f501b75c934769d8ead2c872a702d047242243b3e3c96eff21572b318ecf76cd60d438dab40c226c9e9f9e42beafa3eb9c25bc41c45824abf774d71c95eda4072b0ce6aa88934d7a4635a03df9c89d07036001235518bebd07bb433fe42dd7104e8bfd7ac58a1bcd9b805bf8c0dbc72158ae310a244a77b82f71cb8695e8a8f8736420ee1895b3c9b848cb6c0508bdd3c85c56055c77e13dabf5ddcc3c79db1ab74819f3ae78d555a832439c0095be95d0f05e1af202b202dd8f43decc57e098a2749cebfb0209aa72b0389587193517a66826f5e5333758ce648fcfa124ef4fc724a2bc97b6712731565dcc5bc4e2465daf334c0d30df90135fac206e86d3474182eabf31b3ed78b3a0de100f7c7758b4fb3675791763e92a847a379f98939ad28b4664e084fd4baa99ea5b7dba54896cff5224c8cd49091a799129b98457e6cd010e3c79caea501a5ae9b81ee807d3f739b262ce6ab6b7045566eb6acbe605f550daae143b69b22f500c1130227e47db728870170f919d5b5559db311c37371018dcccbfb7a66b09127fc1a9ef09da2c303f0b717c279a7111ecdbcf65c0398a2fb7f21a4317b86b85f5b9279d05cfedc98a78f71b600b1cff3320b5231fa4d867f6baf2564c6fb59e7ad423301adb1be35cc562c977caf4966b1c0d98f4f779530565d1be251cca06c3eedf7bf42e210ee25825c9668421c70a5b6b91834d08b02646895390cfda6b4e16435b6c58fb77665152a4458bdc5bcff21ef3f6a27e79452d457f57fccf2789771187fab68efd2d2db2dd7ba464ad8570f87522bca3ad8ae01266ad6841179e8c817d3e2ee2ea113cb09804bd0b2b987d3dc82860d05c88f3a64c806f23681ca7b05d99e5321e65d9c9e4b5314c462760f57edeec308a970bf1520182b48b1a2a666a2047aa03fc864634725c2c0dfcf20f9cc98f89b08f216b9374770a1bf02568cef086328be561d40f95d382e2771849c6c68985e8fccdde4786faaca6085183519b7037ce68017de7554c13db2bfabf886e25c013212b675d2d7c8d4d34c03c6109b8d2b6a7d7dd7e71c43bafd29ea766ef62c48ea69b86f0100a3c57d52ca5484b2f7cceea89e3196f024785f69078fc9ad5e87e7f658364b573d7e289b23b4f0e566006bca74a3d2d532e182d857b129962342eec5f5643724ef949cc07212bf43fda026ac95edb7ed05c6f00d29ee9d7325127e6a7db402ad984407e0920487d2f984ad2a7546b1a16c3c53f93d930983eef4053d42713ab4b945768c4e3fcb6ce4827de49bf9f55dc13a039f57ea7a592a86f86e0aa63e7913ca933f3bd9097d3ea9d5eaec8bd518bfe9841fa8c2cfa86df7a031814ca17cc10c2966310114deb397fcf48310436a91e9e34ea6835cbcaead25a491fe2057d2550a856f9c85ef454bef25230b45a57ac0a4b4f8161b58089b21059dbda6b99c4796a2e3b60c310cc63c504f54579cebb984ceef95c00eae1c55d62142ee56db6ade43411b5f705c46390fdd39aaf76d6c89d75c7c10b052741f06873adc7b3b9d3c62806d1a3cf6c8144d92c8581d3aa55f8b2f78f94f05e64dfef78db95ea4ab8e98c16fc0ede1e1c4c26251296a1689b16d43239951187ba2d106aae769dfa69d538b8b70faf60d4956f035c60ace8ac3d1d986c02268bf1d83648fb0383e5f18d80af2cef05e8096aafa886951cfe8911562253459b2dfbcfde7f05a31e9f61fe3098cde1431166c9b3b0aed6c839c728c14992986374b70be1bb60744da3638637e1e2cb2b86becee8318be185d4011f7b3868858f4b381d4731ffb50d7843a0c3996f4d1dd82ce9d88eebfb4c3d970d1f5ec8b59b6037aa37794b0d6ce588630d6364c8cd6e7782af855451b044253e64eee4c0339bc749401ece20e7fc00407602f14cef5fde55007fdc5bab416769e6d857303eaa95f59cb1e478771e89e3f6552c8b98100e9610eef20e1465577e5dfa79168fdf64acdd72d16cee0af453f0a4e93c871dda5b819c7a2fe6843b9d3216f41ccbaf9ac681701c9ba0c2c69016a030844ee2c9ce329e71cb5b5150ff644cdc0e925dd32fac8cc7a12c0a654efbcae8829c9dfa627f6e05477bbaf5ba6f24336253b46ac44700db099aa8b082a1debe786403a058ebc2eda38adf426141a12bf4f462413262b45b592ea662bb3c8a60c450ab5d0bbd37393e159f9783d47b1096af18ded7e87d21a868d82e6b57846bf2f2a8a40910a11e19c8901632a38fdc3f435dd9b92e7d8f9e3f284bb22186a8e96e4e9bd11d89c4561f1129ffc80c8d1c4b4488e7e29a6af11f96827ef9a3ac41ba88f820d14652a8c18d9230deb198c3914ac27b6dab622659d729e6a00b83c1086aa5445e18cacb5317db32d769d8d91f52cda32b9dc560ee08438b590a3863052e4fe739e21e9e8dc79c09dc4bf5a085fefe645d2f1e2a7cc9d818928e44b10d1aa57c19ff69f7e7eb992f9a30724a4750bf06b668a59c404e12fa5c8fd7cc1f1c7645a2a2eff348f63e455f3f7c4b8ce1636f8b8a6e7e9413b89a9cf175e659f795d01c6b3b0152502a54a22cb04af37a7d51005c29d225400617cc101dfae6f00be07d8fed04ee8897e13db465c84f52750f6b69f190b7a17b04fc0cbbe46339cfcf2ae56352643da2a2566abf79be977b0c3401d6ac82f104d70858b936a9e31d0c119f7f96371f3bbb9d1f9f806e028e2ffc69cdbb7be8da4437249484c388e5f8c9131f37b336b5c6063d2e0a630c3dfd0c36342c4f665cef653109e65eec505d04acb2e5e070a1702c09a04dd81da619823f0355475b7e43b2c29d9f564d7ef398941d0b8f2b640431a68da086d42f9f1bd938cd72fe96506449290b069b7b293044a56e740163ff312263edd97a24cdf22828314d8853ac546674eaa420cad2f1b2acda14497ccbed567b91c3028dd97a81290f22b155d23b594d508d3566929c2d7e9896fcec52c533d95bbd5362fdf4dc17312433ed813907dbd57dbd8767542408b5a36f1da50813156651fba91c2a95aea977a3aee3130245df6cfe9dc4ab133ebbe0aefbc63043afb5c47bcb755ee8a3b08d90d969d557f10304683723f1884d06d364020a8604776226f6cff2d4ba6a2f3b4c9fc62c11d07524a3bf6c7d90d0d589207d3c6d8ed964207dc2c7315aec17afa2f6dbe0c0c4bf079f290ef3a3956fddd096c4cda3999a862b633ffdb3dc25973ac2dad7c7a0631e176bf6b0a090381545a0289cb8d8048b0493abf450b0f8d971f08bc28db35c8537fded33913c228ef5ee462ebf6d7394409be805be9f6ecf88927e1b303ef88bcf6838e87d56ac1eafd37089e0e4718d3fba6da276a1c7dff95ce3b1cf33d9575b253ed333ef44658ff3f889ffc06dce05eefff188aa0d2067c669b6bcdf5ed927e047c03fa9c33fb0b7aac88df7d93219270a42687789f00daf65216ad6aa92e83442f1de701df403b11dd1bf078c33017f49c44d40e5f1651579ea8714bd85b61ef21c53a3928e32f8ed6bd28f5e0c117268416eb9b59a0e938b2818ebb302f8516a68cc22aa97484e5e4ac473b897507695072227ff74c6859f27154f514ed54dc61f40f841ff130d17169084057c8da2c0dc4b27cd344d05d9cb8fbc43be27ad192ec3a4a54c05b3e0c26a46d608b45cb3f6023a3e3d409604359f6993a0603373c5b0552a5406e9a70c54cf5e9d70223048c36dc0c42753571305bee2f7e48a411e18b6bb1a96879c318d6c88df37934af826517f678ceaa291c7214765e4b5997df6e60a018d05a0f06ef8e833c7369bf8f77285dcf73c334729bb69c631870c9c7e58729ac87714365b006701bf9c0d4f2fec806ef8d8ec6103ed327aa4bdaec8dd5021fe911f26f3bbcfc939235c25ff55f1fdf8d61ae8ca01a68354ae439e62309347dcae83edde6ca73e6f3e6dd2ce1bf61a42b326f2ad8a52fcbe825205b23a54515944c53c76b9a9967316ba3fcf4af1447e87496385e9344ef54cc6fe6e509eb3fe533e364357f08919fb8941e5e36597699a6010608dd83a31fff735098e0409ab407d4c24abc2caea1a4186016ae5beb53c444cf2b3b277355457997aa7920e6db821a81a582c324a8d2e7ecbf83f46511551319bb9a01f691d1a73839d8a38e1f96049099104d3d2c9a1b6e9473a260f9f986feba61972f8d2fe8e5b55ab82070be773b4a79a9d9beb0bef70573f520f45b08913cd32810cdb5978c33119e900b20790f75e6e4d9ddf89f196677ffec28473e6a13b2b9ee244beabbdd57e57985705a3f8a73f3c75e6297ef3eb506ced06efdfebce36f3af52a19b1bece066617390ea3f0264c4e46425168e6e6b951737046fe3e48e9d4a68e465f73688d612b8f4fcd2aeb8cb80d19a6caa120ea0a9298df228820cb01f304d4cd62774b3bd23e2cdcc20d9d5f3cb03dd4665352ba3777be83d1f4ae93ead5abf7e80b90d568d7d6b9990bc18d03750fd1e065d8984bdf630f538f64bbbe98fd8d2706ae50689223363a25fb85f5eaf02815544ec455ba51719923ef6498c23987c2e631d78ef7b2ba65be5d8f1d3da9745169cff327b03553cf2a527751de7f4bbbd286253db93c7236934d2d5941ae1d60a82169ce1cfad019e945de2a370a616a3ee4b0fdea75eb1270d941bf0b0dd2b8270a078021d59a35e44a7c6f698eed8fe6920e036208d3d26029e55dd4c9b4fad6fdfa43a233267fea5040ddc186cfcc141f719f4ed0f63f239c73b399408ef9e687e8a0869eae5aee334402a8d6ea352886ddb63a283bac6350bb582e895a9e8cb47589807ec9e1204fd36335e80f541baecf729adf5413adc950a64d2495adff9e3e386a68b295ff58c43a93300e94e9bd538d90bbefc3497d9e9c472fd49a9cb8d198c7203c090e433e9f2ce007cace1053c47f839ea7a0f0172935b7676611c13558fda63cf6824a8e3cb0c40665e36f06c722d730da7b11174d24a7b1e6af2792e5a59ffd08d4d8875dc73b21ec91498e41401c4f49400c1a7066295ef2c318f5a32be4530afd85561466dd92c62a70ec6e24b54ef1f7f8684bfceefb32b0606e27fb7cffb08175a2378fd5b111a60ff81f49f23b6f00c31cd182fec6708b39f3ab0d6364fd0b4b4d98cb0fe452766b6d8b1238420fddf281103fe83c06fcbb01fd72a3df382758bec657138788d7fa4e8928c71cadd1e1cf469088009d8461b88ad759f82f81f61c85ff56fee0cf1fed39a5a85070401331708be6bf02f4af205f608b9dc7a9994b34ff307f95cb6c0836865b42509871bbf6775bd524624a01cbdffbf9bb0a51be3818fd8eba6bf79e7cdb8cc961a81fa2b701829b4f92f05496d05c1294e77423779316fb0305cd96ab354f6ff69907394724fc9c23eb9a45d2ab4f85182dfef3834a2d0dd6990ba06e2426c4385800aeccf584ff0b630ac74c089767aa952606aad46fa6f8c52148299f215a87c885daf48e1ba8cf12cd38fa413c7b1bd1ccfa3784e890c7e0bb3d8c7c54cfb5e1b10b22dfe7cd9e7b1847f94cdb4226f63c6262d7eeeac67e898b347221f5d454f4060a8f7d9f6621c6c126d65c185e347073f1dc184b1737c57aaa34680eb56a0d65e0df8caeefe35e7cfd2b3a431228c10cb051c365d9d65fbf4083c96822913d76925510ee8e944880391e8676725ed8b40eb8840da036477e3c9bc5953b90a815a9f8548e628e2830be4a291fc35f9ce92c0734419ae1c2fa588b1eece8d3d93000da8bbce443d6d950a1f9aec297f90722c21fbb6688e2dd99d9d34df2167df073b8d210d16ebb181ba84da7eefd63fd879920f59019b17b6eb87eb5a6dba7866a290d847b378b26ba06b0866b1216b823cbc02bd099b368f21c88c5de7daeb7bb8bf1ac1c0364ba1df3ebc23e716f944b2accec072ba325bdcbceebf6b1c1c3dcaa2d992ba83299b0a62ea5e3704138b3647a5b14e7683e3270eb68aacd9f3f822d07bd599a5a1298d8f9a4bdd26e9a56229f26bc3a082ec54cb049a5af098829a9514686bcf174b75c3939ac96b03b5be6c06c1b235b5bbd810a396b078b216aa8e43aaaed782697fb0671e9ffb2902cc01cd2c3be510db7530aa5f141c8d88d5a7bfd889c7bd18f763eae7f1f9d393362a7dca0d757bb3c8defb5424674f1b41f1364df9dbe2a18b4b4096d2cdc0f4efdc1d4e0458e1b535d4b419fc809f64a7053b2abcc9929409c144d9dcc6972e13d553f33ec8b757132f4792c71b2c08a50cc103c1fe5884c3072d398363804e99c0d669f9378886c2989f83f588506010ba7d51d97407a976affc4083536bc9fdd36fb333bc6b2c2a31d7351767e24c5459387d014afd0b4940302be4ab9f9cd0b02a9fee5d945d09d0027eb7ecbea05f8a6f1c33969bb1a1f41432db6bf97e8528e97ed34a85f3457641793873443eb676d667f53335b58979285288d11799a8fe9ab061108b8b9b8a519bb83573a9a289ec0a2bde499d24b4c814ec96b374e30e2ef70ada65ec231699c695407adf9ee34fa6f0fdd426c2b726972274a1fdfb7f825347aeacdcdce8044f5ef9fffac8cf1648e251c8f24130ebc4eddafc65cc28123747bc54d7bd2056e52b935e1aaa610a483a3a5e35f2c70c52bd26e3c5e54f7347bf74b635021084fa635cf629bc8b3fdca5cf0a21a6a784e655d16729968200abca744a2adceee71942dc2385ee9c80ae5f7d3fcc23e47ccc5063e709831048d85ad9799ab86cfdab5f5e0cae0dcfc5e43dd978c553015f0277527efbaab6077c3fc62f46d940bcaf7cc93e96962ab5121f73b2e68cdaf3ce14d5158affa6ef9ec8a309a272ab4f1583fa2c68454a0fcdbb304c59c19060d6d6b8b413f1d304197be5dc405078cb90f77eb17d5c60a8b129db2bc58db81afc9f95e950982bb2483747a05cde1308df7e5ef72ee679ea3e7d5958a551db6b8f261de9d3ad299f10d38e386fa18bb993be5637f9460ce269b77dde8f964de4616a18e7c47cc4e996275c16ce1ae075250c53f7927b76143abda0daa86ba44914bb2454e35b2072a022e3d7a3b9f0170d9256482b8001adc0493d47c6e317cdaf58b81b0e728f36368d2d255a63ea94557724a3402185ee7fa359986cd411ce86cccb499ae99f4694d8691e3a506ce3bbbce07ef46284878dade053f6e131511801d3773ca3ecc58edde2a35a713e587966808362d6530b51faede2a41c20279ad6d360df3601af52e19e96a84a699ed94482f8c27846941380fb99d81d21a8ff6ccd1a73e76ddb99e817c0c8c5bfb05c343eae1ef2c7b7bed350324dd7ad7cfd60899d9687660c6b56458791ee62a271191e9ee916a81f3170213fe78913680a81013441e9bd13c55f2627bb59a816522d2f887fb47f644d6edfe1b8b2484c9ae070545a7e9fd5be8af8b137e0c1d044c7ec12178b2557e7cdb28e84094ccd3bc0b10ca3ac2c8059ca8bef13822ca4cd3cd855618a50ed19c36ba82b9bae2dcecfc5a216b017b289b6b21655b271cc197af7d6eb26f79ac7992d5cbed0e77df6c348af6e11da8dff83c824ceb397cae3cf32f4c69483147a68485fbabdd1a8ab757fdac98f44be3b114ddc5313360ac4c142b727efe978816e7874870dfccf107d9ac2ea651559147ef23372ba813536da06bae701bf1780967238b12e495a160bc49c2ddc750deaf45f4ece8cd49077307db4075b9c7450f5a7b40b4340848b1e8bf7f15fa077a16944dc483183cbd9e1699c5630ce9787ab5496447b40a87a5d974c7627889ca6d75159d8251022772143d35ca26553b92043fa23b71a6be79895a87112aaf215bc6cfefbad570bc81a81fe5053652f13e1093862298612c9377cf41c9efac90d08de5df6fa0846b348f903bb561ffb8e1dc1a9d1f57dc0aceffa0ae6d91d1abe97c9260d281f804f1fed5cf2361472d98d8e7a6555ae92d9a370c0f5f18270e03ce6d5f0ae6754366c3a2da0783ee9d198835b116e421a5934a30d4f5141edb9d2fcdecd4be6adb3d28a1f4a1182f93278436226763771a569c5f0c6db5a94be1216c4bc60437680c48b3843917fca42d6562c8cac16a66834e209e17ea3cd287b10e8be2df68b49b7bf300d89fd784034834c78974325515a6e60c93ffa302a1ecd6d28c482b4d88b0244f0c2f755c4936823ddc695b1654f17fdaee75a69d08af105877b9aa5257a1ba888e78f68e57018e65c4e841e03cfea1294c2d26feb85c75dc6d35144f17ad66cf982b2012bde21603ea5fbc6bfdf63b630cdb2dbcd49e39aa14c9594650495319ab97e14de9456197fd2bf6307743b25c441d29c83e4f829329eff58a28790c1f9583c71d9e6d28c34e1ce709390598836267e7c655a57cd9a6610d562e480b585ede669de11eff95e0e58868a2b90ff7a97cbe1b006b0936afd8d759399a06e511bdefa2092a4fa8b25c278f2d5260cc62976d891db6f0c0386f206f9c58c68e1b0861365860fb4235e4cafae185b9e49bb2124564f655e0e783b9c87ba4569fa68d0494c51dcae2fd167f37085b228d9b16d9bba4f20b43bc5c9a98daf7f777a4fdeeabead4aab090784eadd06fe7bfa85afcddbecd7a6681ac153b2b60cb1132255d1c0ad9dbe2f7e854a2054c48d9b0122a0246343170d26a0c94038b1da407082bb2cb68eb58310613dd25522d20afa38ed7ef22978d3f429f24e0de92218a39f84098633375133578ce38577b52c7e0ecdde66b918756a4f5786e5b55df308a4bf529cf4b4ce6899560339b945d5fd5189d112016d44bd50e1901dac5050228bc5f5eb52f732ad02e078856e694367777f99cbf1bb8f4aad87076ab079b327721573f7acc4767e060b8fa8eff4d783e6749a8536d0062693ab981c99fd69dac64fb1b071f0f17ba69556dd16f9d28381f73a64b1c40a3631715f898b81ff976ab10b3f581292106bee7e286ec6be579d6a7f8529f3bee717ba3b6de9412b9c599617ee94f343a3d5a6f144ac88e6c8269d47db97f64dd83e3f9225cd632eeb9a732a243a794280704d914d18c67baa036dc67768d7c591f1b1655b7b73e395e4cb4cdc19e1576803a67e6b9a0e400d1b9a347826aba56f4949dff6fac10f43edba28af88daea3c51541affb472496068dd1f7a8ede1fa7f019102f92f32f9a786e4ed22823ea98e918415ff960710c4a27d8b61133efb2c33a2d962bba793aca12a0e18400dd18239df4d6f62b46512e6f845ba05ca92af4dc54a4d22dec3cf5ddd135e9cbf4505cc16a77a085211a6356dbbc3c4ee2a29031f608485899bba26d30e0976015fb3f41a8652e0eb94d4ab13e200134d44e98d3bd01c0e9b3fbaf8696ded699384b64bf2352f812a040ab3b7e73b9ef88f4f142c990d215dadb1d34f61fbbbfa2681cdb93dc24023fb98f2e9997cb7f177aa935e2f8bf7a9eafd2502763f06ce569af67d0f60c5561cf5d5db99d0bbd8084c4d6f82b77df483677755f74b58e6db3eb4da3fb6cb11ee636f152dcc0a8174b7448f390513b2665284fca14141a9afa4e77f3de9de8f2be1c5b1878d5cf42c95190e33c29a78c43229fa9081d5446679583e67eaaf5b6dc6a88453217f4a81d783638fa86e16f7ff1a41d3063de4acbde3211427adfff8f4d09fec1f6ab45e7e74da757e9e242881ff4e2c842e20d93ea0a0613cfa121d6098d6ee897af5d0e7d3620bb927f5447c2082923b3bda41a9803e0fa8ae8ef8d6eb10e4b7812aa8262e858501b0ae2342bfeed7fff89329adb8236c79cb97e0416fc39221cc4fddf7b56033d4034f967981d9f7be0dc6eb5bdf110e37ab454c5bff59ea7c4ba3a53c6d1c1c42a64ab3ffc0bdfd7280cbb3c47661367a3dfaca489e316d0536f36bab22ccfbb51cd92485c452e82422984ca315a88033b712590e4916538783f2a224d7df0409d9150b513c99fcf98f1b6f9fbaa4d059411156dcf8142ec33913c498c5ed8e7091de4b1eb869ce3a40c398c223316a0c126fa48db2d1e2b741e62ab9565d04303a6ab1443b0735540fbaaddb81c5dcf5e3ad1d21318c3327cd0c1f2e22a85a07726d35bb2a43ad1bc1efd0ec917f975dc85f435ab63667a3d95da134e58a50df9abac4d949da2b1b5f91601fc84be896bdfaa0ea1bfc774800cb459b160003814308399d94c25b17dd609bfd455f54d93ccdd24af9b77efff2fb3c829fcb4ef961a3a10523685d8dd08e9e2494103c3a94dc2e456f26ffd9fa7d97d1e1b5eb05a194b24b379e26ef4abc35152f7286d8defde811757c30ab818cb5a0e65a369d6cd7deec58f35d8400b287e6e89a6041e5ed5e7eb44adc68be7445b014f5260ba5b257424fc0b625d4e3e6b521800a02974c7a2d51c32915b0b5d2faf41bee7423974d81b3e2fd67e91a3d9bbb6cd4a1eefec7dc3f121f31af6153abcf1963a4fa6958f5b1dba1e1c0410b587445b4a3f817946ebe1492e2c6281efef6ff94c6b593a92c8419b7ea145d97d627c46616a73d9ea6c369632d62c5f5619885d64c27112fddf3c675fe7282d7071abdee53d720fa7bb26a6302a45d77fa87831803d62b9eab408842d02717f06b6669cd7826e95c56ca35fe899919dd1330aab5e60dbae92536a8eb534325e7322c0555631ce969e08fdd4ac0a13ef205e59f9962f7cfe7f68e733910867aadb32c8eb8f938093abdee73e899a0bb929c1083fab200223d8c52609ab796b859063597d4cb90ac9aaaf5d6638dce509cf552f787ae4af9850f9e89174931c29fe9bee91c6ebb01b9f2c18de17be2fca6fc5a0110869089d79a0429ad88db4eafe54665bcc086251760a31391f1f6ec411e9f519c77dc7168b437364df37937211b0746ad41950b8282d765ee9a63b77c54ccd6a903aaf9c9c55cf935057150a936c75e6ec1220835e4517a389b2c0dde3359ea466c16ac72452367fdd12f73307fe4d2b3d227e5d3759ae5d46d04e698f3b4f3d334839a684ba42b2777af59b1186a76038604e8ba75b73dc404d5b1d51393ba74952a67f9360400661927fc5d8f4dc9cb35b0c5f6149f2f090d674fc579c7b3b759d20a8b34481bb6e8218f7aa988ba0958c6f1ce30bcd37f6776839158866cbc02bb4abf92d439913863bec368aaab598dbd41ce534fc395466e8755b82cf199495412fb8836f7e84ecb54e8f6326344e8256a088ee3a4b22dbcf6bd3614e1a557ed5fd2530ecf8dc977e0963d0bd959cc2b1f5d39c1919d2668a6e9b742a62f7340576b116948beeb5f5b1364b1a192f06c3dacfcecfd1727c85b630eb1763ae025fabf97fdec6e7aa70fd8448ba42e15f71276c7f689470917d78b202852d5121c0373da665dbd6e55825eb486f5dae73c6a2efe066d0456116faeefdaf3036eccd592d2c7b4478623a00038de1b8c713786590e3710deb2b52c9931220e2b33c2f2b3364b3120b530399903976d2b7e8a7bda0144c61bdff607994963dc06a16682a023898207997997d648774b06ba2fe9553f6d417e56e1363fb55af9727cd15d4bcdc666f5448026c61956e041e5eecdacf1342c1ac90998668eaa54c661f1d8414c29544811ca81c6d73fd3b77bded000a8bb400ce17e247dece6fc2e24f7273c9cfc5109d015fa0e8fe79b397b7e8e53e2016549c34bd8b2e06de66827f2c028ec5d52c7d120d41e37131e193b0d4a3dd9204b7304eb16672289912cfd9664275a3a4e6af823cdfdcd327e07bf3bd28b17a04fb73d77d0de970786b96d3fdf9838c900323e18d22f78dc82b9af4635f67fda62652d7853d912e76ee28a6372444561b7df167285cce65adcb40628dd538eb45a31e3387c8855401b6ddb3715ee177cfa2f68ce559e4d6511451a92d5b46a6c39563f8d473fbfdfc07a4e2f5170d3296d3dac5ac4206781252daa1641a63467824b208d6f8ae899f41f2364d56fcb63848390fde4154ebbfa8e73f63776da6a45d051bca27039ef7be608195aac55c1c5967e8d187602fbc57cc8165cb9af7f32430f6046c121092de041e7f3172423f61d7d05ff5432533eb3da3ee0ad962acc5df3f71020877a2f30fb25e2516b5564462c7482cbbedabbb02d11975b23e59265a582598a1d5e15be762b914db45239f4125dac6ed7c02baf984a7e6b231dc62412e0cf86e36f68d04321d3999f85ad34440032ff3b2892dffaa693b2917113f99b23f6be8b3586c12a402fafe6257edee8cbafcf8c0fd8bfae1ff540379358d1579dc899f578851d37379174a0bad3b5bc6e2cde2511d0f4c5edb8f4c40fe796711f63669df8494841ba04575cbf87f1936c4c16561c280984b41280b964a4c97b87b024317b1798c3d3c745452ade9a3a5c2e96764a229fa153eb7f4075602b727aa825f9e892b78a1de5dcb17d91a1d30cd2eaa4711c6160a68ee40aabdb7fc48b707ac95cc433511b66c7098e011d3e0e7cbf41d750e4c81a78d6be6bfd7546a0d628ea2fdd6ed4e09f83d0dc02ed39ed3dc7089ee79f7393b1202d76940f9c52fd1012c070450bdaca72069eb652199cc0e215c14cfdc93ad3d58b36d6bfd349d23c92d56e0d1e0fa3531ea2c3329d1b1336325c605d17f32939d1983c2ced4f98bc2f7ed009330134ab0354360a0f0ecb78216ddd120884581416393f1d8843151f732963345411b594f796f6e502778964edc1e3c1386fdbbfd68605083355b2f9f7087d1238b23b324ff7c8841ef2d138b0044ba204c713a4a830d443c028ddb7a66333713ff779fd96aa07c04dd7e0c2f6499e82ee303ab340590f49eb3a09fd88fcabe2c2eb0bdca91bd7e6eeb9bcca6fc7ae8164ba1a750fc2fe5d8796da108c5770929bc259be9e3c531a7e32d1657973e741a6bbe188cc4c8b78d1bb9781d5d2c0b1142d35e3e473371b9b6eec0de74e36387777bdeb3ed2c0ccf673fa0cd3c97aa5e8f05a82b5230365f2ebceee6f491bcafeb67a45480ff4568a976764a351d32453c0f0e4571138e2b4de84fdcb6d200b8e5b6d615240b654c052405d08918b61b4c8da427345ad39b7cf9503bdd4180ae54a8b88124e0c4acf5dfbf0779364e8db9b92dbec1c0659d001247516a58bc1ca810b7f31bd49209a1ad54508436a275cfc8617d92104f4c5e237d50c3ed1ca1564bd7fb1f49450290b6668abaec0a68b693fa766d3eee33ba9d1a6d02b6c257185b6718168d18afb9fbead89d130fd4503402ba24c80e1d3aeea924f7883039d62501d477f1942199943102d719bb6886cdfcb80b0def46083dcc16ebd1148718c30beffbf672a3dc2dfd71073a55a079ca7127254f39d63f8f03fec8575b07b189eec2e5d114d67f2f8df8ec0e8e98ff36272f66d45ef72e9153be055b79f767e68c0f1c12504995894ef928143a88f089b794739f5e1638baa191ba282881bfa5c7ca02db0dc18296afb239ed82b166a1b4040a1e599299b975f75330cfcf61589c865dfe10088eaf910b6253ac7529e89825d95fc54e4d025bf11320ca1439659993f9b7b97ce7e82eaf253d4688991866735eb651ca3aca1e6a63adaffe0dc0ec5a70c064a5b5566ec8cfe97390ff06958027e2a66c0b7c853f7d70417c928e984e413a5e56143cb898e98857901c0e34bb48cc3f9dd2187666f435ccf7f7298d5c37d5c92d6831369719686937feb2f807bbdeaf0ad1eacc65a4dbd8fd88c965ec3d45148d75574fde99dd6fcd7f17bd8c56ba73906cf29b443012a35959fd52c4e08093ced6768475a6b8659456b74b7b32edd8582ef5f069dea1be526cee69b0dd24fd7a2bbe325f42b69a118693c767153252f0b12296d6d397a9f051eb79cf027fe19d22b9ff5e805b044e7e84468191fcd5d8e6458de52333347730d206cae76ba88964b707dfe2f2009c392d772fc8fdc116aae2fbdbb5fa2461951a3c4a9fcc83a5f043908ee7d71d50578199fb54346b198eb61f8ab518145520082ee85d551ecc854ff2c516830c861e2da5e45ee5bb4e4750d20a2c1cbfdf4cc1238a630c6eee8f35bb059502be01527e5c3e589d536f4a1b0fb3ce1dd898cdcd7ec55bee511d5a4071745f37b1f4db55041f52ed6c27126c9c76b4d2e4d5ee9862d3035109e0c2d0a0154abeba20cbf134a9cd830a73da7f6cecc57de2d00b42c99c9373f77cc43699a9d41963319b6d9b972f81a3d3731cd2c67ab08fb7a4c04deff7bb3a8f8eb0b3ea45a6d3c9f52203d6e29a7a6bc8b2e2f257ea7c07621205a871ae2eddb82a359640c7eb87107ac87f86e289d3c9bb72e0e34f948d05f270d03e820cc50a5e4c6ae566ce5c3f3ddd6d5e6e5948935ada86048e843256fe6e185b45558e4dfc69ae5ad4af14444f81ff239f5d5a203696972221d63395f575efe34210454a8e618cb7de5482b8978108b5a4b6a061ce76744bac3193e88decbdeae82f315cd1c78e57fdcf001f787407a8932e0daa29b6ef42a4a66f35d7032ea3c3f779104795e8054c508740ecc54976c589b8ddd121ef0d4eeba275ab98cffc68c0b6af4c151dcab46c8844d8415b0f8c8d1425265466241bd74cce4551021efd72c16c67fae99ea97247db5afeadec83b3f3d3107be80e6aed2220477ebed8666ef9b96b081337f89ca8492197e0ef72f0061a10abf57ab20a495e4fc5f79c9b0776ad544fa598dc31fdca67482a9c0611bee70f35ea26f96fbcd4e9304c165dbabaafccc939613db3e276a73f3c7d4473f7d79f8e0f6c443a392536678c8a7855541979b00c4741b21095fb90469d9bc62e8d2a9cb087dd0c1057995ef6e1cc7ebf5b64601df3ee4860e48e69a4bd72e8884864f9645a32faffe317e34d301e335e6911fd60fd5aee98bc6587fbe3862e74314f577218333de05f150692bd318be4c17a74e1159ecec7ef32c98cab255e0ec397fc52d0cdf5657bf65981e8b88846deddae6e92159543162b972001dca64efd0ddc8e8d6ee5986acd58775472730a8ea34daa7284d63db8447c9d9e783b64d2ebc1ae15175972c2bf98ee07cb0e24dde452edb60d4c504504826bf295c2f8f47cc536675b1b99e91958569ed58644e2a75ec991eacc5b53c272be50b5cd9e593a060430d8f4075660649e679757220f07e32533327d14db00d2c3bdd0e5661a2746149f6363a71363c29bf1e94d2e79cd5ea6e61c4ebbdf15833b656dad0e01cbe08e90a4cea0fe4890071ebff4e530b55fa34535216b69131eeb1b72f83ebccf164c79ce9c1df9c91e580b789f7bdf12bc4f8a85b99a888d1d1eeba296997b26a14bc682fe831459ad30e09fd3f1df55bbc8395531cb5aa64029a9d805a91d2c2d1e7fc1a072c01f67b18477b3708b53b8534e21174c4e55bcdee0ca55d1e99f80fbc548b7f80e101c73d44a28c2d372ed132cb2f76ab9ac8f5fbe42581683369e70c39abdef207651b540dd79acebaa3ff44c5b156d3e2f6ebcb3e94ed73a4a462cbfd6b2927f496dd215cb31b91a0acf3a2b2378399f05c6f476c29b13a16790c55cf7a18c1d4ca6454a8267a312522af3e0a2e735745a3580250907683abe865c5219f457e86cdd0f07e156a71f17655d28f28077bffd34ff39488b0f751d22cfc48c06eaaf7b63bd5f220b8773e3e82212d9f0daa394f9e79c86b5cd0c646e7273bbd49769fa88aac88634f73bb61cf49dd9547b0c19413f2a2a1628a59e2b478d5a96db07795b227109c3e3eb8454ebb36b220ecec151f628c21a598fbc067f02f575d7f2db85f1cf89621ddf765820c0ec22d3b79b4cb946652bde933f9d40ec8c8c2076b98c9239cf8b339c75225003e9261f3faa87ae8f3067da6edf53fb5312cf72ee27a133760fa71e903d4954bcc4562620258e2363d0f202238e49b0bcb709f8fddd89892cf9bd6d59a406e2af5a0ce2d8b8a96d3ee3843ae5ba86cb6ae96868a4550f9d8b812f8aadad5224539b194744acc60a20ff09a06fda033f07390f4ad767d639d4268a622117b8b9d4106c28befe1e2519ed01c23fde9d369816a691caa4ff58dc2ded2451944d2c00491042324efd67a217afd3bcab1d80af06e2e39f90d4fd1df2c410cc204b1e0abca639c1c0d5f042c1047b17d4c6fe1236ff88925c1c5ee45b83f997db90b1c997acb498dbb7275bfd4ab6d4c20aec4dee01078f508a6ddf07e37fe9df24e50ed138f49b3b0e3a8b3b0319380eec61b11d72e6304014b02f9172b64cc94ad99afd73b349da501c7a87f5b9ef10cbbc85592390ebe3645f9e1c95ee6a66ed06d0a5cb1979e80f565ccc75193f2a113208c9bcec76eda738e8fd31fbb183b2b4e8e41bae20caf8ec15b47137c9ac280de4638970dc3ea5879582cc67c243dc370e5e047700c0a47af4e48b64a0983e81d221fac436d3b16b96e39617f7b50ad62e2316c21078e79e0bb2350873e5ecfca0b2ebed2a4a3b977403c0e5404372c98a952c0ce1eef63dbdb8fe8b8a5c0e9a36009f012c05a385a5f1202ef9cc4ab025a48ba7eec2da400fa1ce5891bfc2aef463b2fba6de315238da3b888574dd5847c1ec604ea30b532e48d0c9169b137106411f6a49180ef2bf53ba57881e9f502482090dbe76559ae833f2bf982b39c1a4159223f7d86e4104f88a96a07468ffe8220889627525a2f8803c1297a0e39e2e19e21f749d467826089cbbd9fa07ba325c0c0039624fe3708481240295afba35ed6e0762b96748912637121b433810cf1789e3ec18b0392477556b40b9a15c06f1db1c08cda2d1da2891ecc80cca531dafc2377808d6eb7d5ee00db612e3c57d94026bf1d4a6cc348e4112d5866f0c6958150a397e26f84005e708e627035951f2e5057249bab2a0ad42ddf209a4b9548706ce9cbb8bcbe16528f17d80babdc9a4c30f069b362d0691c7b969d487e14e975ccbfcaad7c46c0f903a126723a25976271b5061ff1443a6c6c9a15ce6f810d04f94f136b5345306886101bda4b26c304d5842036a5854ffe55a120a2764006e4b3e2829cbdcd176b9be1c2c43d4d2887c20c7382cfac0343fac23277fcabb91dc3533c2cd9ff25e8f6de266d5d2753603708ecd74205dde7083c50037929e20df3d5d34726a8f5151782679a01a329727cfe1c2fdd4d8ec2657f5c4766e63a65721ad87dbf09bc7c679fc058aa6b83839019253274c79b98096e9e786cbc43d05321358573f4f2e351ad2ed1d5b771c7ea2aaf7285a82a43278a134858dc389703c54e3162842f18e5c06c6b9e07be20e22c760c6e8d808db503fc4e1f40b75b4e753134195297a21ae97d0c7f0f5827cb5eb41cc0274a0be2145757710cad93472dd21fb31d647e84c502a07dcadaef5c0cf17eae9401af3780c3463ca693392a2bf311fa18cd7c0477d1b27355f136cc5eaff4dc3103331804525f4b5aa06616a8534c05784c115eac83b3050c7c0ed6c94412afdb61f768f3e155e9dd6a3a7aa9ccc6d0673cf5807dc1ee5d481ed6d897045326871ae273aecff155a6580798e641bcf3cc941b1ffd8ece48b1b41376769bde1b80d262fde3d36488f8726f0f918eb77834b7109709a0264d5d0536c207285e2629ddd5f7fe657d2e29bff01eb6555a0d4bcd89c608a1e39b562bf6c7042bde2447336a670f7bad2e0bb1fdef6f491d5beba031e668a50a3463d5d74ede53de5edd4ea8a8547614e2132d1b13d24132a0aa6c718c4537fe81d2f5258a3097ece39eac96e51b8ec0ff2f2af4b0835bcdccadd9205da4aa705b57facf79650e905d7ddcc3482157fb05903d94b20824580812c45dfe2c2e1b33eba0f552976f103faf62c9ca25e88540838597d05f4a545c92e31bf9fdd051a6a0f8ef5d06f9e712b315cf43f78a4f7113fea11916c3a35d39d91ca04f55cb9a552e234312e2957de318c16a05c0c807c9ce85f4a3232df0f98b0b5c91fa29111c3f0c8983df118a03447c84fa054749bc1c91b97252c6093b9d21836260f7d023011bb2e52ff1fdf8336a34e55457604527649c2d1a5ce852009e5af41ac8bfcc1ae721e723df8d59a3574cd68569e09c2f2c1c6295dd249eca576c5d882c2211751c64267d31a783ae8505a253886b3c92a47b514a250885367e59d74d19d75e0abe29de53591bfdd07dd840f4021fa0c7d5c97215cc6279f87322942401684488d99f41e8bbd322fd2ebac1a7070902521669eea93833747151a5237a3d897cd90b648814b30ebeb73da3f87e5bb61f9386dbb0f4edc135d17ae081da010cd0eda73b7490eb6f9368d213fdca93245a2fea6f067a037ba923ab07f85d54cb37db4724dbeac4475872d8ef306d2bc40bbd995e09d6ea3ca06dd097f2f2a294fd3d92d174a7bd3c88f5d9e2155e8c25a79bb93533072d54d3d9de6164ca05cacde46aa78cab4479ef1051c591be72507eb64a63d5c39667e548cbf7de7a405ecd3d815e47afe693093f6fc3e673dd33389b5fe8b6851374f2465c497a9e46475d6ea8390e8239ba8796412475f04e5dbdd4acdf6606a72a01fa690eb4b5bcabbf244984faa1fa7850fe8756d713f04a1f6dee4bc0283ca7dc2d94138739c36512b499364f154c31cc482465980f326bf8c622254443c6ccaba65b4b641b690c3cee93aa193344df7ac7902bf2ec3d4244ec1bd1d4e2bed52a527c7d6cd255cd09a390a4a2f8a97083224238a1b60943960c0ebbd944ec811b41cba0aa7a265e7a9ab01511e281bb745c41a80908741f4ce477ed3c50030a2db8b0b27fb402dcf172e7d2849b8a07fd2e28a868595cf00203889c51be1e7a75520076f53d6c9e9f069837f121ce8a552720ba3f8e89a278d26b647d5caa80ec7c3070c4e434500199c16cd6873d30d78cede8d5ac32e89d35b01453cace007b937c9db4c11a110ffa8b98708acb71113d86a250711ec02a1921f5f80d32281d8635a96e3f0fdb85fc529fd6e276bb6d0b5c7d3753f712592e825b291c31ddd1cf8bc3200b3163e9b10fffb651044743e0a3c2faf3350df6878fd255337c0e9c16d1738cae3ae59fd6fc2d129233982d52ba7b0168645520b2fc5ccf1978c9b8a29d67639caca12453dd161687c48ff55e42e3d0f95f63963b39ac272cb9b68e7fe473cd209ad747bd135bb78f96c18a94ced116ad3be8adfd6dd101831c493bec3c2b5ef810519aa093109af5ac8a5f510f936331aff23a212cc5e3c33e5c73a80a0563bbd1c139b1f17172d57e5e603c1bccf24a91326df151098c6e72b9c68a78b80d7c924d7c95276fc7758c02cceb9f19b92cbcc22e97fc9d03e81f7887bfefc2827b6f541208c00a80c8f6dacae7e77bf967e6f7d43f9f43269b1e45dda94e6ed3cf18cb7ef2047c400e0a40c8a2db36ed7b1e08d6e4b4917ee0543bca05232154b7066e8f5e4df8579b81234870330ad358842a11bf776247f98a3716c8589d79b573c74bebd01d6cc5cb03d3edbbb1e3f90446c93414216427029850c482296377ce62b0b4b8ab7a1ebc76341e338944e9b85d7b692338156e3768354137472299f60b258fdd4a07c2e7eba42376e583d7416079e0b4eba4faace0a7885aef5f0975e9fe587904352690b97cbe721c39b3acd016d4a1045a270bef37d2ca0d0b64531d86fe9da02ceab084de175e66411c52c441ecfb8f6876322a4fb2c2ae3f56fa4329191f37029024ba0fd9aa4a4259f650785deb9a3f83078859821948dec1dcf307d4f6f6c40abde9018837efdf0b4c187ecc425cf64d69f4c7d2e2cd5ef372865966a2be672165c62fd55336acd93b1d78e40f5c6dc4a762286a650f2b007e275ac634d8ab3522e19158a728f8132300f4bf46084cda9d5dc36a8aa052e6a8ecd5c7b40b973ca7fe8d07618ac985bcff2e44e86ac4ad62b2850cff442107136bb9e8a58035b305abec21d82d2f1f42a2d4cb5cb00f76068fd0ac6cc0dafae82098576cf9be9552fbdd2e51b8843bdf12b9ac3bf2d716b0b135828d6e35a7f896166b1e16e03e6b38654e75b0090b87f065802772d6852b4b0ad49655716165851a8bcd5c11e0efc20950f664fa1c986a817c09d8a2df1572007a4cc68cf5c1e9b1c94938cb886d116e5629d8ac503843f77ea487aed230016b5b5027c677534a987a9525492488ed6dd74eb37f1452b176bd669c7bf9519f741ddf80c2b3a63add359392ee65b5744547a1d5d00adaadf24b54a76bee8a042ee0b26fd454330ea24e5c706bc57b3d6ba3bfba0a1d8c91758d1128498bd22b191e24a5b7f8ed2a593c02cc0ea6f493649f497c4cd0fb2a6fa33a98142c7bb1c0c8162a0dbe00904109729be2065fd7cd28c3f874c8980d1259ce5f290b6adbf4248098e792950047de63c38aaee40bea754b64e032c85250cb2955200b8fd368713fc7356d3a7135cc95189aae8f70c5bcc72a2fca874167fbd48fbc35d255df0efced70c0ca0e384ecdf7c03c841de9081a4bdd6746817d8481a34f048ddaae7bce1b2bf6c9cac49afe1ed5045057cc147decef18eb4790f5109a2e079cbd7560fb56a93e9f3a8e1ae2bede796bf9031f69561cfe270d8fd594636e620a7725c989de83497edc664ba07a0073cafbd33fbbaa59e8ec0ee13411e94ed29fac09c98be9ca6cec3a06b9f65f25ff653673ad85bffb6fc3066f4b810bf4a5cce063029f4b72cc6dbf1d7932cfcb24cd3837f024ee7b77ec6edc713ef9c858d028103caa6858b153342095704e899a6d2aa83dee4f10e051b6dd1f766e15a892a67600ba42c24ef70a8ff8ebe6abd2d2c76e2de910a4be4d26c4ea5b06d53f01a5f00f83d1e185c2aadda2f22cc88a6197912358ea0d4c92a372087414b95794d8bfa8b19692bd27104230a408db7b7e8f6d217464053f4c36c15d313baf8df0b7078eeef18e8f4f63fe4afc67722bfeb2660de30e872a0e4340c42c80dd67ee28008fa5d36cfc97d1534a1a290ca2d12805ff04f5e69d38f8284748282b3f6cd35278fac39ebbc21c8664e6ce42ddc11e27eee8f5d5c5ef34456bf0d22c1425d37fe125ae9cffb1288a645d0727b678ad920b103022cb71fb368aca5504d5cb615270714e45d039e09ece30c681d5e0bc693b0aa3ad380db8db6730e6f3cbbb42fe69ac5213a70e80904cea418da0f73b64e42cdc8cd15136afb7890bc1c7aba54f3e3ef6ab13be046d05f37e2ed353c00a9102cbd48ffb190f0af0c0beebf165d2b8671d540bc4fa5935ce02fa80abfe62a433bfc67b61920366c0f34b08f54865a66242b8abc2d7a82df5cc3d226c4d3dc4495c75d9f8e5e0707b458c15266c4d47e126586bdc2ccb84571d0be2724c4c3b849428e6c9d3c54d09aafe19933d5133b0038dec21bebfd483e3a3387c5888baf80e15402b0c4976111602bb3fdffd234f709361983c4b38665738c2d941f44f74fa6f1d3b2203069a32aca5ee8944aaa47308251884b5a07d28af019dbcc4d2cc6e0cbcef94427559ce135a6685d923da62cc2ffbe3104a030118b4170d1ccf5547d4551982135c24c9bbb2cf74df45a136692f2853c06d30744030f1bf05a1f1cb6fceefafe89bf6aa6b49213ee0df4ea873d534f6fd8db740aba81453a9dd570576333ca847c0a1ccd352283a48feccd1ba9a00f0eabf8ce1af29dadb2f7f34e5abc06ccea284d1d064256faf6fb75096e981497974b0972a1912c3b535a7975a2fa396f9c61c8e2452917f1c236d07ac1dad04e85fc3425c4b043459e82cdd3b32bd3c1ef35c3fe661bb7a797d627ef29bbcec93d7b70ef37b0cc6c3ef3f60267ca0ed1d2c27244396934ab4a0607c7564f887bb52e97ac5d9b9907f5ed3b203e74b9a4147fe3edba7227ff2ba903dd89c6cf4444dfe9417442f53932804584ee99bd8d325ce6fc12753267d17c144435641a9082d98d5f145e262690b188e4a1d0387c5dc06ab04b39136386b9e9c0e365f9e5883c2d89d761351f26538a1c38bbd95e39e0e0f8dfe4bbafd7756725f7afb9fd678c00d2545eb1166ae2068d2326121adc3c6c84d78e786fa6fd2551b1642d300dff13c92865fdff2eda2c2551bc7cb9f129eb170a57b3a48437738133eb23d8d24023ca21d163006cfe538d74d494889293333a5bf82417a5be29b358fd823535ba80b35fe95f93ba8976a9a49156f955e0f7e0b05cf07421e3f430ddde47aba14f46c4afac4d0aee7ca22118357076ac7f4e05b32d23fc5af298a3ed66c9bb8834f6bb3ec5a5249af31934dafe7a1b848f2d903eaa195a1c85c39a1ef6492fc2a769ed0842964eedb3bc7c484dde1634de98a2796c7815b9b68b63dcb9aec8812814fdcb337153e3254075f1430de707e15069ecd22d2f24624048a213ed3f18fd4a8a51650e5a94853e063f3163ff59977f25d75842696da8702378df54f946b7f5fbcca6ed6d650204b5b6d17856c7e4ade276ccf9b127a865901d067ba24031fc345e4db3868091e5201e3134cf2b427fcb440fb768f43f18a0e84b5e6847fc13869e2407300d225740f885ef32ce4d39afcf917f7c617e32b58ea7cf5d1fe11002d1592e53f3ad649680680a7bacb54bc345c8b559b98128c9453d6c5d9ee9e397a505c9076b87752de52f2b7c441ac1114e388c535cada27975d7a2a366fb285f74c0249e94228a4ae1d7abe68976d221c643cb5a8249f368a80a4e47b6c7feab5f1526bec5a62f1a1a824e087193f2e7bda600ce3b2806da60d56e3b1d00ce44a2c36a867dc0f3f257716360ede3876b8accf491a6b41507682014d6cd5b39fd4309b06b1b782484c279ee37bbc89921b1afa2e30cc9eebea5daa7cfb0c021f87b4d79e5308cfaa5daf95192c3afd87e4c40386a13bfa03a5733a59a70641b8be53df439a6c691fa5249afd6c10def790d32b4d4fa6252bd34aefc97a66ce8dbdc1d598d539bc1bb42b3a62039eacf49c87da2ec86da292f9adc3ccd02fb5e38b3daf56fc97592bee68b7acfbc4babea1895075493952e115c68f8c75d647f8b9477d9820bebcb4d60ef1bc3b7371d561ef0f8536ac1422b7ea3511c052657226e352d78247f53950c55a9266a9180b273deb3db0be2f07178f26e0969d0f374dbda1d43ff2305154a663eaf6a0c42e8c1f481103ca5463b314bf308fd346175be5771fc99868625d9c60c79e3c29c53cf7233e2cd5f07cda84c2cc87d42facdca1c264163dfa9ff38d748d72ef8902154791d2ebf9835bf4e089c9a7379033800cdff4fd64cbcdabad0344f8f527e52d0677162cd52c156435be954fcbc61fd835f9fccbb22429e0aaf0e9d2a4eb529ed71e3a86d018b40788e6b19c70fc2796889ca464b013697301e5bc69619cd955e4d2a0fffc71dc550d4d1b9d82bde0d1c844c879edeca3feae745c7c657f11fbafba359745685107f2f7c097ffed49c829b413bde75855c686755621f7b68dfb9aba13a512da8f97e2eec0e04f814b318d15a12d6ae3dd67efc29c1bf4a1cf64c560059e0d97925769f739bf1f26e8e3a325c7c6f019560bc97f12c90fa8c85c17fe575838eee5f9ea7ef7b9adcc15e023427ca882b7fd37d14e5c2e6dc0f5f05f1150a20abfe1e4e9d26a9f212e47fcbbee60d4792386b69748c651847898af8ce841836d85468cdb7f235c10e7ccf991022455b7e92bc9f4228939fa10841e238ad9631b1868d4e1b7dadce31fbddcc3e08c5bb40d03017fd686850279ed3bb220df46bf60bec5e30b43fdc21b1e27b61b912d830790c17371fdfa9b1b5bc2dce25bc5f2bdf8eac1e1cd3366ade660325610ff8f35c082c5c5c85aff2335e666fb83bf977d7d9259d5a79618171ffad006e94fab5d1de6616f430e8fb39e27e9e2607af4bd157f5a9237b10ffdb8522abab78ff2df8235b17083dcac3f833e01f25ac18be89369af7cf46fbca2f1e4c61cc58cb006904e3447b47ce2006a7e80898acb1679f4860f86d726fab59dfeca87b46928f2d5648ed4e91ef6a0a98d9436e40eecfdc415738b2c291201812e963b0f681d71ea9e112078fd0c9d3c74e778f1343dd12f60b162cd327b95cd9d3d6ebc9a6e06621bc0493c46168ba93ce4917098c24512f2c821ae5e0a5355f51686590d20229b443a6fdce16e77728b673303cec077fb5fd274f84a1bc15237ad583e1b14271da2a40af2872192d7c41721b2de363ff25a75beabf4cecbd7d015338dce3e7e05f77f934522a84210dd807abb69555f69036c7e1dcf39b99eafcf53c9d60de41e13e221b55bf4781a5f991cfac5b71b1e50245afea4f91c3dcd75896e4eae03be4703c426d259227ec72512cf131162ab6adf69005177b19d3675a02be80867e6f26fd042b532d73233cea51faccd34970c65d9042a9ef84c6c064c30d0949c5fad9b6a60b730002857472764d9dbad51cc490be5f959b4212348eefd6426f8c450ac3bb474c01b1004c604ebdd1287a947c00475454f10c6398cdf44427a318919202521d87155c1b29706b6441a582aabbd7ddac085eab0e26c034d0db22553cb49d43110c5596948a8cd1254eab34929729f79ca3a9a911677d3ea116fba8359c4eed5f4a8bbdffa15aa103d07d1dfd2f0b033e70b73aec310feb9fc16eccc4131cc54b7dfd42826f1e227405fe520d6113afbbddfd1061701f8d632f1dda85406367085a61c0794208acec60334a443c59ad585bd11f182a9da8349f1bb568f36b114c5f7e0c02c6470e42da23fa4f94fe2e1f17b37f5b46dfa8507fb471cb71fb9b61b0884d80000f77cf193fa53ce07bf81009ce99287fd333394c0926490685f1eb4c780d9874d204ee3549296fb59e901ce9bec6457f1ddf6d9ce764bdc043befb409eb8d033039b778ac24d8c91c3f1eb548e9f9523b23d8488457bd1e675fa34c63373dd139b4ae9e5b156a8acedd15f1453a93fae0606de8584a4864e26d293ca7db26c3a22871e673c88161407e508a4e604ada44880f8cb7b349158545724b7936a89339b6fc87477e0bbf0cc03dbd2efad06ca54e60155062044f6aff556b11ae11185554ee689f4dd3ecf71b58af044ea0242cb774bea682ae7fcee7c743e97774b245e389117f0cc3716b492fcd0f82c179abe69bf5beb4a252bd837f0c57fa5cc0b39dbcbbced520bbc60527d2877762b9b9c1d02d7ea27d6230b7c7972cc87c4e7f6f187b2a9cca5625c318fd54171bebe6a364520c9f4117302ff77565c7217c3f73aa4703d0ae12f447fb6792fb0c5f55d5e0ceb7c31206c7f72db2aeee57b5ca56bf8466cee5e67e92821a8ec9a709d7db0f0bafee6e444ab688ce4f6028c06f4f84a46c231f066c70b99c397c7d025d883fd920326d0950d50db9aa4b41ae031e023a2121b08a95ec716130a7279a7e1d3c9f4fba7e33a5733791b210e74249c9e067d4302dd2b17c65323307b26b4b5b7e65989c3f7ef7053145e3de1343861ce49e2536d434bbf0a20c866e1d3c626a971d1b492816de308d0654977cd40007847da2d1dde59628408de646a96c1439f9c60e09dc9b53abb48ac31553066ef4e65cce4c1c8e57f4f1293a7363257130b5898c054a6cd5e5fd60e77e4766473e536530574842ff1ca7f330a480534dc7f4de1e4134f1cb204cdb183abe6818e088da99177d7a90da0e8f13dcb616330f8d332a19c7a296729032e0d40610fa0419f1faefac79172edfb1995c940aa2044e135aff698373ae3da33f05742a280511276ea02ad1ce78c74ad542712a7002372733580da89616ba67b74f92fa99cd88c19ce252bfd970b99160bd44a0c73747653c6a08ed297774b2d4da46f1f61ef641fa7e6241732d9e93fbe2265a73d48b8de6709286bc92ebdd13c333f43ecd940e4c125900bfda4845e60dbb3e1088f1e46c28ff9e7a9234e3972bfd127465c83a76e7f8ca425521cefc7dd93af7f40294cc2dd8870590faf74db6ce6885303cd6f12ec30b60f39e73ec6b331e634eb8fe1a00889eba396235921db63566a6a72431ece22f8dd581fff12884c4df3318967311c4ba559652fe4300e89ffc61d4fadffe6a85ef2d62065eba8232cf20c8467395b2000cb6723c30cb6f16285345893f007219a35dcd399447dbf94911b3f4973fac10cc41f0945758f5227999cdcc78d11dc4e0ff2125beaa9a75df44d631467aa981012cba71dc785e95ddd4c86227587603511d00489f903b7d643b23441eb1da6e883fe47e055725bcb78d7bbf5ae1139b0b724b71b772cdb3234e7e7d7d74c0f6fbb94575cd3c94fc25f9525ee802b24fa12e1cd0f63b3e61bfe0c76b8486a39d2c84e53f361cf9f511b4352d738cd23c0bc95202275d2eea0308ce872b05e13addb4552a6d7c71569da90a9c0a375822d4a1158d16c6143c69206a2f5ebd10de4ba6f4ac71370b9ab2c7f59bfaf9c7d6035e4cbdf4c187626d86659bf59923eeb1351f34869dbebedb0546ae84a56abb673b80d87925a30ea8fd1984d96c3c5a2c43450c59b9067e6699e264524e05f032ce9f3965c15fbfe4dfdaf766e483c9b80f42d0bf8b91984bd06527f22a7b9a4c1e1c48efad8c208e13f75511dc4075ee21cf0321846b7cfecf41e232d834a60900338776e48569525a00e1f4b40f46b6e57f4b128d93b7dfe6ad2c202f447f90adfddffc5df3e48921cd1edfc366f2bc497aab489f329ae76bbf466db5c3a3a9805ba08f3ef3f4f200f418a2c3b8b72e45d7546e6c79c2faa041adbd78df1d04f192da087502690e746ed19540c6ca5650ecc1f2f0e64aa7b083ed9e0caa14778171b7dd23bccf8d7be64c936aa039800f033c6c8eed3c50175e4a829d1590588f6ce06ba62f4c727c52c487f6776fc1f0d90947d2ec3f5a951fe4f385c8d47a991e4dade01076d6ec2b116255096c6922fa6518df5cc70217b031103c9e27fec82f839406ab82c5894aef168986e7690e024b08ca7b5e58c21a65a9cb7b12b27a05894e2a4b4adc4899a8af325760a7505f804f32fb73c1612f759d912d3d41419b436bfb6eed9579a28b5962164b93239ef25435bd77374c3ee8e73424bef272f2d8c96e934d2a437d47ed52e8c7cad2f48fda8eab0941d794b052995e4cd4ea37ebc9f194fd109294044df419c0a079a9c0cc5e395e03d61d5929b39d22f6ae5878c41ed14f238bd5f5d8baf1a48a275fc45900fe44590b90b3746cfe6d31f21e2ae527f0d5c53f13ec415f44938c6f53572375908003b681f1decbb1b8c4630ef10fd72ade38778eaecd26f6e93f1063331cc45123b4774105b0376561cb8607f4b4e5479c5d94b37dca7ea3b8b7da211719590e7552097c2391d6239ac31dff96eb2288252af54392baf2d3eeaa54b050e2ae2f5a3a477b013ebc4e27bc7d898bfdd7330843e0059dfc9c8c333d4b3cb316e004b99587a5e299699cbc0d5f70ba71b42962433c2719927b4c23b5a131feba08718efae51311facc3b01cd6681f28f79615eb76c99cbd04b835bb7d51c0c91974dc8fa792e79497e0ff5e49700187395f713342033c56bfea9220b490360ab0e6742d8647656d3f81a662e02fa10146b35be6fe12cbed370ea1b5fe13360b7439b6d31efaea4de9599a41b2f899732d456c88125a9dfd969ef82895a0d7b179195481a916a50080415aafa41f67af08f103e161054574ec4a0978bc74674336209c32d167808b0346be31282b06f5da49393bc1fc7543547838475e41351259319cbace9131729a9ec6798d83811fd28f81cd097191b736a8001522829a7afcacaf17f26407cc6a5f331b4f7b3b371375743bf421010d3a6789793f1a8e96f8ddeda572ec453adec61ad53999a8c67ae4de21036bdb00090bae3ba50ae67806cc1e2c51decadfc889c5502b957b0e2c16a5b81cef048cd51633396854c158bd3d2cdf02bb4d39ebf917ecdbc9d09901dc9a3d74ea548ea41b835980adadb7a75799da1141cfad1c1810bfde07509e07515e67e7e9b20e3c94ddb9219c91e127390effb7e59730ffea672612d68a8ba595a6189b05e00468ee9d3504b6d5cd7ae2d34e77704e3b40ebec0b9868974dbdc396100a347ec8f0d6104484454680a13f52dde9d014212c5a31ebf3a3f9155eb44399dc0cc9e55c9243b212e48ad587a1466684bf5f8484580c4f4c9afc34c42d62ed03329a58a9490919100dbcc0bec563141741354bd61bd4cad26f790aad5d93404dc36055d6a1a3a5503053aa1e61105680b4d74a3a291bd8844373bd4bb6018452600ed77a325d00d7179e1fc74436057d102a91d481b1b91c369772d3af88265d08f621cc242583ba50a38612ab9e6dee7291c7ab0546cf1ca5abb8d4bcdeed3655f82d0b6f1bb5ee032fa6ee61d94ecc12a3d1646b0b07e5ab7e7b2801ce4ca52750da2cc7132a43fbae8e66cc94f886d2e19df98b9d6f4c51762b0518af4f54db53b1aa712c0b4d8295ddc97186f6a2678f65d98744324ab7691cef8733c53653c987d398c9200307c61288e97876db7e3ce9b80054c6f80023a8b0921b076fd073feeeed30498724399f83562c7fcd9df5107bb5e4d360e8a3dca462cbc36a546e606492cd25f9695bbb6dc8ba9152559179f6f2beb845fc98f64e395e0c3b6fc915a6ddea0172626efbea0a085d88848959b9221875e012ea61b45edc2745c16f15a6275601b51db6297bfa5d94f376dc0551c5129d4c661e21ded00a922b6878dced84c2e74a03d566be5febee3ffd582332e0d4ff84a4f72c752aaa0c1d74cd0eda677768048debe767fda1baa83af2d7e77300317c692f4a348af26895183893c6c0df712308de9fc854335daf73f8c7353f8e5cf5629b41b63b6c96487bbc8260838b5f886cef271a65a4e6341bcb7b2a4f32209b8d4610a618e32074b347e1c4dc1175a55c79e86b7fccab558a37f34b073a4ccc436e2208f2cd6abd619e441deb125e3ed5faf03e7be070b2cbd2dfdc77779c7a57ee354e03c1e2b2ed35b1acaab03a0b84474e33507879bc9dfa1f59695715f13fd6582bcfdf8a4b7d15ac03ddb1661d1bb8bbc3149ab7d5978774a3c1acac8188bec219dd3fa213016ebb638a677e879bbb4652eaa882f065553578843323c4b7617fda19bb73ec749cb3d83acf1076efe3afc0ca5d11db8f13f1f026d39f82fbe735fefb60847618ed3e4e5daa024d5f0a6a384d7c5c9b632c96f0fbba0d251f455f8108bc8128b7807ed194f2078ef3bb771fca6e3908217fc2c37582f179bd3939a0ec50f6f19ab070d9b066f2285404b4b2ad8fdfa51ac2143af47832ea246337ee0e960e679c70b867812f2eb2a9f3fa184fdfbbe85e6930f5bc17b3b7ce4e9c0921e752872f6656a4a756c046d56b9a399bcaff75f44bfa576554527a53b25ee589fd33d77eed8501dcaae49c713f7206097f0c624f7e7a376858c374980ffaa8f95254e820e14c2331150e9b19f7996de2797f9a9cb7316719da1d7da9a8b8a124a1bf9e14b36dad8b7d680c4901eb4ac28cd1b1aeb6b9af3674cc0ddab8aac31fa5005dfab66f7b7d36fdfba63b36f368e36557e5e7767bf52f2fa26274fac9fdb88ffe4601961b1b7d40406384c4430dfe4df1cbc7fa407e524ce1cda48e8dd005374f67ffdcc7c4b576009960fab6e1e0e3cb93657ec3575d94d06fff039385c4a7ef5dffbe96d1e2168a99e5ccf1cfdca63c0e8f3de0a565f8ab447fdbf6c461df9427180fe9a9003f759c8d0f4330d3eb3f57bc40628501c2d8b1d380e3b5023735532aae8e72500f796693bb53b6c0743a1adced202e2760e21db85c5b48f7870e57c328d2859fb9e1f02ec4ed84441ceb14b2e14cb50b89e249a874a76f5e5e309d58d8b25229bb191aec436789c6049703e6ad803a81fea7daf45254fdafc6efb7b3fd9e438e6f0ddcd57ec9066bcf5edb160c4de06d2d23f46cb0018f9d8f70943f219c46ef181603eb27a6bc0c59256fb905f439527d1066d82c388917c448e820439e008a086f1233990c25818e7d6231964b2dce13cd1d4a5d27a23d0626febd95c36cfc78155d0708bf25dfede01680423dd581989b34aba5043421b84f4ac1710b504ed2867a913ec5b107c1745a024bac61b910b7968646c35f1a8785f1553bbfd0dfdc83f953e945d63b127a613b0f2b875f0d6648667d541c5f3ebfc94678ae6bf5be1d143229606f032de24c9f8c7a1be62a1bd40c401af8353cf302aa42214f63b7d9f71d82ca62fd67b486f2919545359ccba91aeb2bb170115d4d9252d23a49931d61ef9bca9702e605d3dd8bdc9623e514956330a141f0da34dfdf42d30141c16241d65d1bb917b34ec0a42c0ff030809cb98d17cd79d25bf84c5d898ade65e97fbaa536fedcb4ccc521e34f0ef80a876ff432f847f3ac991ce8b90795ec73df52158f6334ed04880cbf567b173744c7a7a60a2d53f7bf51863a76d2fcc7837c38de541a2d2db91127ff80231bfd4fdcce6663a54514cc4a53ebc702791880bafb4c850ef953b2d47c26a0130185596708c59087c44384c7cef77198284ec3faa39d165addf86418b26a7205fb55913bcc100edc44ee19631a4402dad8c7c524c2e521c2134a1c7819d3dbde2d9ae511ec5d48fb3118752e5ed446a07b1d11866b820c99a2f327b35e02b549d6a414ea2d10656528516e73ae0af8bd8ea72053ad02d7d0e737c38d7b9cd6cc64a0e061c2678f7fd115e78dc21a42c9f7717f4bb592e808a32da66696825483d2bebf5663bfa100a8c10262f35ae599208d8b9522202ed99cbad420850069649059c474200e6da38bb9ae15b55d59c312ce207e0a08eb62ad5ce26ad57bfe05dad313cb8563a310a71bf218d5d1a1a772ee41d1f1d4839b64f8120b882888a8f8585a53d2ce15903d19898c75c4f5f570c8fbda6cc4056bdc66841291dd9f30631a322ea7562b10cbc1a21b6cf0df2f1f1bfa6f9fbc6aa4b25dcfb2bdb450d1719b1c7799587e933615de1168d57b1edf9da339d4a4814a7c46876017f13a15237ebcce19ee3c23dae3e6135af27766b664a00926f618919f1df84bf0132657781e242851008d4785c5442384526596b1f39247018c5a344ce8f295b732921515f9aaedf64e3288c78867f6a9e3e1110a372a8d89813dd10d81d77e627198d373594e45c5b0e059e005e0d00ab253c18e38b4bd79a5a49331d3a7ea8b4fc5a7447c520363e56d1b210b6f14b3b6fa94d22babeca0ce47f74bb2918159c9c645f4d3534cb3a05ff404ac2b416f0aa59d0c2613eceb25db92b4f28983576aa71ac9f7b525a3154dc809f51268696d03bfdf92bc3a85237cc6ce5ff5aa4e38a560566f35d9ff9e9e9fdbfa2939994a3ff7d9d610d202b3a6ccfb308979e8c2662a40f2e55263120f91905fbe71f46269437e287f2b1a6715bf583630909eecf1b260f835bfe8a734cc84a47e93a695e7dfa26b6cd5e5d0b00cbedded1c56004c9cb8fda72758ebaccbd4edef312814c4dd8ea5e621439be4126a07800dbb6e993257745fe3323ec2ebaa3d2c8e4b55175e82272b87c72006242377eb3c640b698357224f3e5e8101efc60e556f7a7d9deb5f51b00f3ed3262300a6da15d32f4690b3ecd65febad7ff0145f31b60add93b0094b5057d75f367ae5e7298923ed7a1992e6886fdd53865cb423d6b88c689a027e1759e5716fe43e34ac70c201f7777548e5d246d57a38313e7908b769ec25eedde197a3312b1b7e4ef76b9dc72b0df460058b5e9ebafda36e95eccc4891e555ec3eedfea399e7e1ab286df50c1f6caee4591d92030c2c2cacd0a7fa0286b7d76e2c187549fdacc47c1478de0cbd843239297fef600182d85e51812c9ee439f9eb1d0e2d72ebf76900cd0a72d858ce39dd2b72f18946261108e51b9c9693262eddd99594eaf0a1d32b013b2525b7143be43cd6523a1155d23d8191aa95e1948846280f951b8e112395402206d4df01334ec0795ff3ef8ca14392493fd68a50f1800bd4ae600e27535385558d1a07b18fa158e637287ad99293aa0bb5eba773f8800287d3528e4e18625990d89e62b52d3bd995f00a5f07c936f45e071a4f4fbae76d9bb539f09b7df485189729713e34ec3e644328e7736d10474535412764ae3795606bc2e3303c28a4735880e638fcfdf6737f25faffad86f5b6a1f2446c57ba7b18196b23f496e706ee76d9a083e4d7578338a7d749e5867280f336bf464e27e6f2b2a322e442d11d754e5b8b06cc19522667be34fc457d536f52d50622ddbd942fa4ea2f567a12609d5625c53258d3aa1ebeda3fbc15667f3477fea7705e025a9743821a4b6f51b3b9a149158190b8b5cb7758beacdca51b8344e840c24e9be5ff71987f01c666e0d1e26abe513c14b6284c6ea9f200feca91067af7a1c5a1eab3549ecef71c19ee5033cc83a5b4c70769e760a988b96deaed5974ffa6fc27d24a2a4dfe8398494783f7afc8a8b6e4419aa4bfa061e17251db64e5b412d252b53cfd6989e710aaa4f05aa4dd24936d43a0d41d54a516fdec799847b25d5555362496bf8f18d832965e251c006f087e37c1a7891a7cd08c6a9b5522fb7ed13dabfb0fe53309b28368d5ab01c113ac1f2ca36a915c82621314f06da2219ea0835a46c06a2b2f4fe29bdf317ba1cf7a016acb7c669ad8347810adc2538f18bd2e9d8d447a9c7cc91c74ffe0242a99abf35e9d34daaa5aa97e603717c64070a11fe063166d6b75101b0a123ff24ec6361c037411123c4504c48fd61a9afd0bef76c8f4c8d9b6afab53dee9beadca9604cb7d7c9e2f297fffe158e28d9315d0e487ec6e0bd2da8edd65b2e35759041d43e6982ddc9b04175ca87aaa42d3b4dbf25979a34db7626def2a501db1d97c4e53fee53c8a41152f98baa2700c17d6fea8cbad6d484fb8d60b99410921585c15203a4ae3e62fcfea59253eb7d0009ccbfd60a1e52d06b27f3b1482f5203d6e851bc49372ed1912e849e1cad4de2272de5258de41fed826c83be1a82295265a6bc926edcae9fb4883c1f881d2b22ae57ddb0f0a0b25de7ee41a67f4ce18a00018901a23c4153f7cf6003c765ced922b9e7253119e2e2ccee9a5b48c7b94053e44a9228f393eea75005b5511ed06430d98bdbec39624be7b22ec900cb493124f43716519afb5c8a8c008bed20165990d9009ae64ee5bd9b060f27bedb2dc67031303a8b05c8fafb7d1f75a7760222d35389fb54677a1a367d70c21d2d19c025307539243770008b88471cf6143e228f5c6388f4600a74330868295289f3db798e32114e052f8821a18d4acfb6c8996dc8e81ed0a466815055b31205a67dd4cf65cdb040d6f2365035c98e710fd20f96b8d5d3b0fb452d04be20a5f5c2ca4a452bae109522e8f47dd400aaec6fec2551c2d84d4f156e7e39c0ee6a69adc4047484608cba354cdb3f6ee1351c05e7c91808a3c2df64858b5fa0b5ba2e823e3a21d4bd0caa4d562cb53e0421bdcca325d8d1c10dd8f4c10d4abd9c97f246b2a22be14bf7d3cd7eeaa1eb8a4fccdef7c0e4d1cfd95ab65bc1040d04744cd76cb146d1313182a634f96b23e57b6bec9d29e442783a7723adc9ae3cae57605f286d299d322548e59422c373182d16cb2dd7e0b07b0f69ac68f9c395660cc5d876964b08bf3fe3e30187d48001a8aa2b5cc7ac5efa54e9fbbe2b6f2aca7169ac722cba8cb27e0ea88b9456c178efd0be7dc1b038006f9b51826d4d48bb231be6663ac50a8745e38769b808f413264824b857f768329236bbad6405c5e44434f1982fd39a1b19d5d8707ce1c3e1999c97e8321ea5909db327ccc7fd47aa4a6ab88f1a925a511d9980d1c8d7adccba974f482c76d0026f988d4c6f4d190c0af653dee74180afcff4fdb62ae52e3ca1cbe4d17436db549287772c0bb10912f198e748c42a4c30a4058917aa0217fb8ab381b06daa1aeb2a7ca748ce2575039dfdab7ad0be8dd0f61a0e94c4095d5742bba67fe64a179ac22cf4a565583685ab6798bc43afd9061cb9a9d06f860bf1f26ffac0d93d5e7c86e3bfe15044c1041c46c464d28409faca9ea8a0c92434e397bfd68002d107a05482a8ab32ff556c1595539a041cdd2d5721022e70305e358e04d6bb6b1feecbf1cdef15d2c83cb2c9739a3c904cf9273edf07f2d68ca2f6160844776338c3135c23f68d88c4f08b3440746541d4cdfc05ef9dea8628c02439a0d4330bbff2918d0ebfcfb1aedb06c5ae0b63e582c63a30afc10326d7ab0d0487b08c1646eca8e99e1dde41f9152571ab14f408b92e42cb9ca1d0f012c8308609f9db62ab5ab877c40860f6f5d93437558e7188a60bf14bb58a758941444289a7942279ff4d06febe9b1c614b317486cee052ed5f0c8d7672074d4e28c64c6bd0ea7d9967b0b74a2d95d8db4a45762fcb435bbcdff69c059b824a0574773e758f78fc9fa6ac63620a532477ab19c90935f56dd24265037d4eec58e1ce769374ff83029a0296db217263fe18c2676a7e3f713890346702ed5f4d0aff0b0e7dd3ac2e845ef1b3fcbe89ce6e11191603cf22fb374008f51e36fdafcf971a280d5b94dc365883ed57c42e9712d0f17bcde81552357f3b080ece69e3cf0a3173c1766bcdb960ab138da591be796f984b0cdc25b94bf6c8a363f28ea742bcd5b268b53457e36cd06536f9ffa50df4380785eed5051e7b911c6ffe31bb23465ee6dd9ba8815715ca6c2c62d678064bb745a6901b9f03a50e3fba74bf8d04f7fa33d26a29400e416057c6a1e5e49b7ce72d2728b256f1c11e0cd38059dc6dda9d77e54cc9485cc0909896b0e3629421260cd83d8434359a36c0f3a5802355f3bdd83dd7225d9dc86aa0ecea6cfbe6e672f7511d43ad02e426815149b50cb5c20fec2f900be1de0efc6e16803060eb36889e6768d0aece6d49805c00c5f263dfd728c3947407b244690fd824ef902f22c6943579317af18283caf741cd0ad44c3aaf0f5ca6bc8fa14352203cd98d74dbdb7d2861f600791422bc24ec52d3935c8410e1d2ed89cd939c7d1e49bc27def0ffe78315bd5c6117de7f635413baeaf9e925b3735d7ced4a1a8215120b57fa56a7c8d02003f9d48b639546f823e07ead9647149bccd0d7b3449ce5400bdb5240e8edc7319f0e638c826a24d470aad6485ff75ace6d5adaa630dc3014f453bd94e42d109b29b362733d9d2070c954669317cca8daec0af41929a231a8aa3744199a8bd59597ecdd0e25026781170ad4fa667e2e0c26788e3545f0695bffd5483c71ecb26f1d4e1f3e7d1b5518cdde9c2881d1565f98337514c930013035d407a41b487df36490be5bbebe0036c64569549a4e4aec61bdcc2aefa504ff642e3738111b8878a0e33bc0bbd5a8ab2c36eeab0033dc3002fc2e3d871bfa402c722b3ac1d7c9a7616fc67fe8e6f090dead3854d44f82fa08aa153873db1a05a325942db8a6fc47ccd486e01f0316c6d3dcd082440c13c42a055ddb72a2ab81880f8b3727ad1594d1b2f0cd6f6bdd96730fed0d16495bd53e0c909240a56417788fda8987b0a71cb6e119552fd5e22619ca2167cbcaa5c524e9c9c4bb04e9bfe12edafa88fa1fe91e1fb2490ad99d02dade7d898660749b5177f723f782d7e30d2b8e4a96c13b22239743e34b51e81ceee55a602f56d35446ed79b9d2826da0e5136ed6e0cff9700edce6142bb41212d871ebb92257a0516e0fee433237a0cdae6edc7463b0fd67e25d7a56b653bd91987e918583826244375cde15ca6acf1ae4783aadddd1c3c71c8c7dc2b887c6cb68be6f8574e05ab21722a501097ed9783a19b8801082d47556f060d9012569f6226366fcca2d28a999f608fa2fe4f054a68c65f8abf168dd2dc0892dbfc36e0731dff6600fd5e0b9e563f4e5c5fce910a95dace5e5299de454507f8ea84b515405a182b204d1c4c55c257c4ae3716ac51a859aec428ea7e354ad915331e781388f68cfeeca6ef84aa6c466f3d21c6d21721acc630e6f8193c0e2c56315a5e11481482868bab117ecaf4109c9754c01d4aed35ed730899a3941946516b2a574edf2ab368286685e1216ec7bd3fbd38c395bc5298f9ee44e300b47477faa453c695574307be20bb8fd45b3d62453ca8eb697295b095472af0618e52d1c8f66b55478ab2c1942d68a6820a3e1e6d9317844d5e0b9bdb5ab3742a718c1c8e050bc943657f4029ebe8601a0fa3a4925818eca24b93205e7eacc69b36aaf293e7555cc10a91f9c37c0bac5630665648ed48e535bce7dec0d91c576d29ba7e877c1c9467155bab758ae04a73f2941d8659c1779e7baa3cd0d87e6f3e1eb9597c402735e07bb0a3058cdf9fee1b67a1004582a43d3d8a9274a778bed0d9021cb7629df280134d479c5ab4c845235ca267843f30a59538aa539f2ac40bb7f5ad4893d4a8f8ce7e8d11a4b38068f643e1297c8703b82fdcdaabb00f9887eb5d2d4498f90b1249e6456e54efadbc706314381908b6404fb97c8064e3da8b4a749c4d78070a17a862e05dac90fb90751db82f69458c9e31b56b8400905d6a0ba90cee6b9c8d70d2b821c281005c799c06d76f2c860276ab100c59902a68ac6fe7e6f613d2805a7934dc963a76681e871a0de4196a32ff439f352ffa71cdddeb59d9419feec3a374dc6e1e2768a9d5a5341041377c9a1e6d0a7d3dbc71a4947c21bcb6d3d5dc11fc8f19ade4f9378e58ce7951a4aea02d7be4e6f21ce82db6074415d488d54dc750079dfc19ac89af2bc96816d7786582a20b09cdf2e090d4141a5fe102167749e4d737b94a5ceb466eb0430b1ed349fca4f6ad1cc7493b435501c17335f9e2ab671f0740fa7163a21d6d9f7e2f74dcd701dde7791a61c5460483c0ca66f12255fee47959af857bcf3d3a18e5b1941e63262e4f5c9b81742eb6666f8bb7b84136638ea8475168b5e15b753547f4f9d73d009989413b1b11f84b8b9fb524be72f5ca942eb9cbb69fb6f57b24c055545ade38c42b55f3597a34baef680162e7202b6b79526f7049fd21ea62a53a33ea828c98fb863be9b628d0141b7a335921399a6dd42fc761c0841d654ac8d968a341c9aa7d4c4d3f9f335cb94fbb97e415d41f5c28e1f98e342d59249a224a7e761647c7246c3e422af350014a41dcf06feaac50132d6a0a5304011cd5694494a6881802e15bf30225b109815c969817f663a5581f271a545ad71633fb6c951194ad075425c00b2ee5053728835b8834d60ea06d9523eb2b18c7e2ac3d26d3f221b1f8b24f4f89d219dfa953de993e835c934b90adfafcfa48026dcbf3eb2f36da9ad89b86bd83566e3ae6db60631a53c384ff88bfb6b3c9b32b8c505d2d9365e3fab2c3c8887f3100a0394c2ca4ea4970797f47fac6694aa1acc5c70d8eaf602e0b0d0ceb86710675fa0d90d2e6b236a64588a288427d7bb869e2adc9ce6378ba5a7c67cf67d19e6896e9e303c8e1753b6ded5291210dbf8064472120e72b97e06c015b0d21488e35f89a525cd53a61607edd529e68246fb539809d0244f8b82575aaaef9f33e89bc29c725975700222c190ca5a1ad5a78e97d2ce39c2ab16bbd579658580f3868e5e69e18a529ff1d9cf720da140dbf04e23448797ca52be81e7160451e9c3bf3da2bb4660ba01f05c786390b8d3eb865655e06c247be3ba84577d0eea4db6568c9221f6fbce11a077ab3b432c181b1bc2356f708cfcb32363a63024cd62f1909b4b2dde2ae29c3e9b62153415f92e3ccda69856b1366904280e85554540fc84ae78167de3387f2b559c15c5b20aa6576777e04915e51d76a765565aab29419a34cb25f0a80f79137eb67594f9fda6db726b421512ee3405bfb6b4d7e406298510a75c6c435753de29d6d4ae2b839fdfc62d53ff2a9c723395b6e5e077b3080416aa7c974eadf9494c7a34ae15fca681f8cc831a20c24d98333ca595219ee929c7ae1d43992e7bf969387f87c5fe1fc2f7b896adaea0d87525f8bd8c24a31ba8da6784d488f74585b8892d7a9e99dfe0b92a6d01394f6061045489b846dec10586ad39d2bb84187785d321252dfb4c0d1673ef52dcc8f7a27dbec49a5acd97ffe76cba74fa5e12ab9b0452788b61efadbce90a3198c3fdb1ee9d24000711f149ac179a4dce9902e048636250e4d117aff45012a9e0bef8361c1c4f841b7a051b3fd0605c9993c784682ca44f1349c175f0514827605e194976d243b0f8067b14ddd70ec284218ec51149a6a731a609bb88d6dfc9a9da3589e943eb7475ad11082f6836bd02448da79afd70cd4e1fd6cfc0e48a948bfcf3e88bd76fa4557f822545476ab23323fe739135216a3164bd53697c7bdf5bf14de1880ca96f20c511417da21d54a8e4a18b6781f765ed97dda6d1a54cce1f8fee550ad8f1842412bfbed871b9c470ea20efbe1a56c94873ad75683e7f5f96d69605081f601e7c1542c4b2841390662c36fbb1319df508bccf610f4019937bae4694dcd55c10086192fdacb8b20922db945d675e7153fd8a5c163d7b5f5d5bf93659fd6b3ea044eb5a11fcbaf6c9adeb6c7834989f67887fe26f0bc226853cda385f0b832d7b3970b6451c118ac234bac08deb222f0ceecb7188384d36ff902c14ecba577cbeb68e45d101f4460f6de112ca40379ee3b60e08870a98db59a1b933a336316b1bb4255541e9fb0eca8aa9a892b3c125ae63ff52fa76e9dfef24ffba0765f593c3a1d85195d3b686df0ff233304894d754bbd6482b89a9390b70dd0b1fab5a7253a308afcd344c9fd55a59dc202532fffa304ee42de9ddd0915a75e969c8ee7eead84eac53bd546ca48f24393784c6722c314260e569a4ef592804d176eb673f7f4310127ea772d458f33702edf5e49752b9aa244760ea5d99cc69532bac57e3bdc75b1ea7c152779789c6e4a8f97b83ff7bd69e049f3410e901fe6e3a0b853ef883adcb000f92f277f735675f638762a947be5882cfbf408b09ac9ea5470bcbe1aa6bb485a6889e3035a597b347777c59d5397b0296994918d2ab0cb7e739bd4acc66c89ffdd2299b3db8f98464938f094ff9c657a11cd1178df6ddd38821b101b423e67a7efaa1262157fcdb67c7b2f85b812ff188359c471817388de43cf269aa4444aa8563e78689c18a289f7e40c3f0d1ed7c86e0cb0b6b73bd01f500d7ce6d7b5f937ce694ab301b4de284ef1410f38ae6707ca21bbf6fe2f9221ed5094fa2de1eaf3f8855933a601ceb3235069ba33edaabcb6eec325b65baf6ff09c462aa6dfb3d00109615aa20d8935634b77d5b01116a4b8ebcdbb8b4b3e135156a3d81782161fae1b406e3eed0102c325dfce63904f21216c2c92291a42b534d385f9e56209d0351803a80a970c6f7652a491d4d616b737754db9dde4bd8513e5a85e5ce43b680a58d4ef1297c3f77b5e751928848267f58d434bca2696827b87aea689b6aa3e12cb7f1b96a4db52eee1f995e3c7c2b1f792a20191578b1d7bb529e3747de51a2ab4be56ee704a44dd3c8bf1b3b8158dc113c82dc1670232004befb481d9b9a4a8f4d1d556127e1d109bec672da8fd0bf88413d3f0adb36803a3da4d6b547439125cb38c712a131dfbe1ea403101a509e4a9fdc55f6bdec88792179fbb5ad7744ad962d60cca9b2d5025955d316c17d7a3423de2f9164e86add9e4983e72b4829ff2d73bd4280a5fb78e0e543a7a471a166ab8f401ef962bd30c0db495c22bae4e9d56b64129fa5119aca84e01fe9283707981bf1a59dd3bf24cad5be3c11628eb8db9d699b27aeb02e9c31df0130112205dfc25d27adf16642d1304c6d8235a5a565fb9a1ac6f2e90d124c5e60a66e5441042cbbac5a8519a21924e9bda84cd0580c53ada04019972ef92dc4613c8cd744fa58a09803435fc58d39a66169263eea3403a90f4486958c8b15398f1b0a6e1e1cdcaa782f7fe8396f558e902e62923e789a2ab77a6cb9cddadf73c1b3092d2d1d96f0bbf52e23c88b184196b7bfc9637b4940f69df4f888e811a91c4e3392488329a7124401e07f91ef3d515a6d4751b980eb518d5638855aacfc693966a40e8b92e492503d0ea2d899e4108cc89b91a61198c3ec66f169b44a760a635f6ead43af6016b628612de04510fa569cd919dbf9c4642cac2d40bea92f458bf3eec41ade20f63c6b2b40b21896c7dfc00289a6953386fde3362abd61cd0b21fc2c225cb5f7d71eed71270da429b91f6525f7257b2bb9ce891b91ef3f0232ee105d8a5c6c41e70e10af94b078c4ba6a009812745de71d31b9d3e78c54f410dbb262c62629386bf161d4392062249f98e4b41f54e6e4094548a4bb60c0a9e5efa47afedb124b1930dd72d1d4472695a83e3dc5941ecdd9997b00a435d66cc286136b483d641879f4d56a6fcf1162c33e29791b7410dc9c35ccdb9c4a34300e883d92a4c009d3180c00025c48e8040219842d4b35aff6bdd0ae56a8f5e073d78182c077abd2078b951dca613fcb966a815d111d9d90df68b9f6f9794ad4641374618a24afd33dc277ad6d7281a045ed8797c3f90a41e97ef3b21f5c878b7eabfc1800e98fb670a423e61e26d90def31d7588bfe2a2ab5d4ffe667ecf7cce5ab09856c71c86f04b28f109872100b20b1c9b16abc407b9f8e84b4911271a55ffd162400b781036e34ae72f1e7eea7bbd45694f26348408b0aa52932e18cafab291397ddf549f2e8102ba049218c438a4ede73566ac9822c23a694a3f9a1368c1f0c8dedc583b78e19f76752a93394fe74c3b5958b50c0d8fe4e6ad058d904419009730c9d73997bacefef713b7f897ed7c82bf3ce676004c5fc7f0efbf5de92dab3ff7b1b3da17988eeae260c4766c9598bcb2d3caa3a643406a6ab8a6ad23ccbff2d7a243e3a26b6b24b29a8f3e2712ab87bd0de8f18e486343aed7e8b235a55e49d9fa63290f8d9d5d6fbb6d744f2ccdc33d596800d08b1eeab60886ad0681cab273fdc2f67416a45d9fb786a0d984c3810d953cd62fdd46989901963d6f1d3d6548b98b078da67f317128e8b711a93034356ed0ca4d0f8e78727bc111e9b174cd42f69bf8e2d693cc40335599d0ce6aceadb833e5d6dff88cb8863f5a345d585b029fbefddc48a8daf5c502fd45c47111d71f0c0489fe3cb32846e19dfff9fffc65db41481446d70017c8234fda32873dbb740b95681ba4c18fe725138dec0b04031e924f7f77d112323513c46f80714f80af9dab044f5b2e1951cac4ec9ab87e749e2b790b4c225c9f1c5d2c85f5326a9cfce205ff81d96a52e4e505d0df7580ab09f4f309733eabd67cdc2e82ebe71ea48d54ea7222c2c1a35d52805068580e8f9d3cc34c57629e03528240508d6fb54b7d9d075c10dd7fcbd5d3311e3b4f8e5098c31ef08e3b1b8bc84f681a1b21bc1a860b5c0acd10e4027a2611b1249b06b9a2835faf682abb1b65e4b77a2204960ad1ff4b8f27d3444a8b31e92fe6a720958051fc8040630df271eab0bded1be9d3bad8539d4fc9e4298c1fdf316c64e1079e0c8ec8874e771949088b0f70b83c4c0006b04c5fcbd03b10acfaceaf7588aceae5451b36277c71b7ec6ace8005825bdc11bed53b57a3cb55ac77f3d1a768f2bc3029c5f525bd12466f0fc8192ca0613afedbf8b6a41a8f6b4d9c80dbbfc530eb4ba0c227e451f15fcbb42b9ac15a2e5986c2ae1d3ed7b28ee7b8d61bf6183bff1a52a3ce0cbbc18b8844d9ec9cf8ec7c33450b8a3bdb1054d7f8078b3059c1602adffcb100dfe0f7a35b4ea1b84222363c87ff317c0310dd915b2b1009cd16340bb229237dc72c85047a453980d792772f2eb3c6e4e1d78d2409d42424ecda0f5de012eaa7ffbbfda73e3c4007ba131f1132a6726da5490625234158d1b848ad871432a3e6b8c6b1c8a5327d7f4f730d5fa2c3ecd8a91d28883f189c89f7095378f1783a4d11c49495c247a857b8d50b4f29b4006ef59faa8aa9a461cfbef0c7b370bf3c72a3b3ed0d158aac6042b73c2656d9f067626cf95c3e59258d512b548239826f2eb000c31d7e4b6b774b799dd461d4df21928102939dd0e15adb982c2f701969677d46c0998deac6e23ed11e12d9fe538aba1730dd86f37ce0895829cf577755b64f517e9bf9cdfdf447ededb09c690fea3c8b5811f7a08b1ccbcc4cd8338a1b8adf99d1bd0f216962e4dd92553e143549d6dcaa7c3680be61184c8f1eb15ae285752d18e5955fc3614d87f7ca17c53759ff2625f161346c1b3054378b4e978015a5eadcb77e269813cca251dd78b30def82d41f5af8216559f4af643e184318db58b07766e072aa904fe7b1071f301284853363ad9c1f7c76c75037b8830ddc1ca49b4f604959b737b54ebee61e3f90994814fc2714a2df85381205539cbf7d6e75ec80aee7f486be43851b91a88b2f6879d4def2744b1d66ee47f37a548d432f4e1bb6535b4fbc7ff7a672b62209a67f4566c024d4c8cbf8a1eaa09b40e097ff325d05ff5caa857afa8116e7aaa99ad950c39e312b5f5b65f7351528a9e7d705d4508ecc495a007e6af0c934044c442d94a11bf989500bd7a8fe64a49cc64726acf6a032369a2ed6d1d43188996e242ebb49539b21857e2fb4f85111108cafff2fd30dabd43877e5c67d8a5da3a313cfb696f57842b4083153026f093252d5e2b7d408c59c2c5d8ddbb98228aec42f5d4f8921d008f7c65577d7188ce4542ac30ef39af2229efb4a34eb4e7a7aba476d33c918b92c223492cb8dd55cab73a8c394a16c1765b910c6ab45cde64774bfe2c2a24bb829ebd795ae97fdbf1350a64aad22a631ed9466281fce16f6f451a42c9a0a76ea8e3952c2e047c2b88520448bd8da77b98102e0ec5e23224e4b6bd9d026523a2e7a6dcf086e4c4bcfa8d25065af448384e3d85377a6cef8f6112eae08aabbd3163fb27643eb170f54feb0a59649747ca1e17a5089636b7e84eee66cb7c4e92dbc6e33c45eaa1e1e646f241e017477358f95c2ec567d7d0c82fa563df5ca92098b9290e3ad247be219237c24918292f37a8d6af26e37c628c5a2c2f6ef0d48818e28a8bc356763b5d9ab67a51cb26f34e50288d716582464bccfecc6703678ade670c2f98e575c8b380a3885752a0e22e8a45092bb0f88684c4573a8e45ac67267832b4a336b852ee6e605e1467784e9374e31f826b4648c3b191bd1d29ee8ce32f9adab3830c37164131b62ab528634332038672a26384070d2d2bac95682e027e535b53012d655fde1c9a9b5da6254710da84ae3acf1d80d559cc42e75193c3057386bfed35a663e34b014af3f4fe8a030894a8514a029d4daca98640800a535dc6e8818bb11db43f0fef7e673adfd8b380e5e2adbff18012dd9ac9fc62b0af30d81287813066938158355913ff326f5854570657a3d79423cd0cadd2095412bed1a14167934fffd22fef6a97e64965d790640ffdec7cf00c3785441d28d33952ec7c839e76350c88811b9432925e1ae2a757a703ea291d8cfe75a84a2048541c91e183286db2c6b2f6a277ec5a4abb13d5b8d74ce683548733f96a9f8a164da8aee2b86385e2a44f3459cc2fe9577c24001fe885044aa7d4a5553a42dc0c64d4bfc5e05125c9626d6360f830453ea32b117b2a80c9a300f95bd8b1cb5849bc75036048db630cf4bb02457cc1650f33851716e3f9d0331743ec1d2b711fa4e07fab37d57544f2324bce6a016c9bb157905a563b616c6dfd492d627ab55a88c41ae3edda808b9cc1a8af6a6177f1067fdcd0bdb9e18ab64f957450ca221430fdf94c26239d914d9e3c8677297aabf7c8d93d0e80510a32b5ed80d0f400d1b92e4989b8945987377b71c4030d958c7fbe944b80e3c2d1716d3675c94e6df08b1ff20c54d2609e4d51409f5ba67537e5d492bc272ecf4f5051896a9b232ac589de1aabbdb31fbac826e657789c3ab29183b2bd6613daecf570158a384b8904f94bd754ac278fdad1fa90ef64981f8039656d5f20b37065b46d9fbbbb18cf3425456eb7091c0e527779efb0542271f4b01974c37a9751ff6acf404292a4c04b5d1d51fa53344540f29b251b00908fdbc81b851d532d6f3ac88b3bad42aa11e0ce44bfa009bed671d2d967e2f3a0574361e8ec6111bcfc03a7de5d547080c4f6fbbef0b18f2a3d932e090e0405384ea5e67f3d590048a6e28f8c8eb19cb868eee36aabd5b36f9c20f2c44ca9498354c04fde3b377cf96eb3b3121bddd50de8d2024909abf094270468734c6132985d1ea64096d93ca7ecc8a084fcabfa1318a365114e9346f9267fc85cb3b11949d5fdda91e5462bd85f7ed4d283e146368fb1e5fc4b755e259e7e4db5299630db130b9855ba7ac5e4a806028721e68dcb546684076584cd89c3ba7e97116328c0f55f9d436e9f4cc7bc79af1616ad2094068c21b6c5b616b9d10f88c1e4bbd916650773e45dc18236abe1d27213f35272e5826b5ab47d4890da6c66f053c512fa89b2dba25a788bc7141d4381f4646bd3c47328eee2ee6333ba8ccf35eb0d8badfe227ef2312bf6d91faab5d1850de93e86110bd4c3de57f9ab9feb1fc3e2a9ec758f367545268170871909a466ce5251382bc7f7b616dde5fe3bdd59136b1152b14f656cb3d2849daca0a918717e366df1c3b9c65cf73ac34e0153c1a31ba3187b4af5fd85cbe02901bc333a7a70e17a7d94b9ba22a02cdcd1506462da9694df275ae97aac13e69f84fbb5a80d1570f4e5c7772468b4b7822d6c963899a3723c0d8d3ff4f0c4f0dde98af7a9ca4154260b452337cdf70bd86166918144edae3791bfbcfccdd27c00a3970a39b14ed66e9fee9c7f333389f8c81f10758cda91ba02e24fdc14e3a143fded0a92802e4f044366883aa4f5dffd725d77edcb34b96c3da81c6c2fe35c102bd14aa143505ef14465f318f5ab20c723c155b15235d7f09d9b83eb32452cf8edf4748b94fccb1acbedb77b5c24154ba333e42395c877bc7a1b9a89c119161e8c28011855bc7f43f33440a546a62c95590b42eb3884671666ac22cfe401464054c7fc6d1ecfe5bf93c6ef533a37229fd9d3b7252b6d1b9b061e0f53b3491015e98f074332bce01178f8551eb36e34dbbbb030dade80ab4500b30e79bfb8e3687c1af061d4625e5e8e19343833ad3e26e603610f305583291bc29e0f3b5e09fedead95378a8892b602e9b7daadc9e3c18b5f95d4bfa8795fccf38b7906acb7e3af0729fdb07d774481dc4b6f3616782a4bcd912830fe84d1a52b5d5cd095c4e2f8848fb98a8990a0444f801337c6bcf31dbc864782678a9c2617809947f9077775685658d8248b2d1b885b948b23228d47ade47c17cfd7812ba827965e8be3de8b9010461b60550d966ed35369ac7f406ae8c3e12f274729560528c481a73b8ea749ebca074f255f232bab5eccc2a17c5c882a69129b63a7d319d6cee8271c67dc2bc8f7f5e0c3ea2846cadc40dfbb712922ef4106486750f636544dcaaa32279fe3ecd9108c791d02bc1fc111cfb90f591d0d08b4464b07f589846f8f4059960960ee75585427a8b974d7d8aea2314f9c2eefdbf7866fb448d4c3ccff97e6a46ae482029adc4dce3d6815d1bfeeb18eee0ef2b7cd4d0fe28b1aa7a8d45b4c341a98b4e98bfb155e10194081fb83a4f722b14554f1d5213d3f0ed4d4c6a595022068a050a944d82fe50ff08ebfb7609dcd168dd99d610a9192f8aa8c91b0ac40393aa67779d758d3281503e6e73dc982dcc7ebd8e4b8f27e76774ab6f1979504f4a54622b058c11bc35878483d266521f6c12cb34df0bac5065e86c13a3a96b20c8a2276e1a4ff3eb67156ff3d906eda0f147261bade977bdb8151e952091769c48b5d7cb5215162ad324d09b7e1990e94752e64eb99bf194495ecf6c233e5ed279d4800d6048960b21982d236fe8fe23c6491e439715650fc87dd238ad501e0e3b6e3def48d4bc34bd6e3654daf304417c1966750ce8cef6b527952824035997e4e7a75b99c6da57ea96dc59bb02ba5384052d3e2e06f5ec828ee8edf5b4b07fc6bc924904d59b5f9b493d0e63fa9924b4f8e4c1c350e6572d22804fe6d769f8588e51cabf4767beac6f4a373aba19324e55af1ed34f441261687a5fd3ff303e71aa1f101baaed5886f6604412f3a6dcaca1aefee68bb45720b08ba1faa223841685bdb2e319fc94711d3440a6f40bb9d46bdb6d93f72dceb5ce782b705b3538efc94e28813a74229a737af18c5e533d3232174ed95317dadd9518fe172d0b2e6a8601730097b2665704585d5310cff9842432d80d83d40f12d3e05389b7c89ac9c3ab4f628356e314909d498256fbd4b1f7364c7c0ecc566f8582424176e05d130b70cbc587931b63158727eb4ba473e21997660440d8b7ac985ab054acc5bee81a3e264a512e5bc62b882d98b2f7b59d9f4aa7cf348c69c34bb2949e15196f3ceb9e4af5ad254654d61be401cc4baa80dab38dfafb0a4cb8a6f5074330bb1b3c3fa6e49cab594aa01a59926871ee465ae3748414058a4bc4d27f9d3e7dcf52c6c6e9caaea2bccd4f543fe3d586bbcd0c9b18a126f88daccc1289bb9d1079a93757e26a866be998e39171a7ed76473e83cfc2e864cd3687295b076089fa2691d5819a66c5fe00a1dd4059ad992ebce43bd0bf09fb70194d95218994e0c24363e76b30e9211477ccf78472b05bd58849a7c75782535af9c2bfb17a32e190f378157374f6d48fb349baa56ba91b85e4675880d41594328de7df0b3aaeaa837abd1135bc185b397d821e0c55e72678da816bfe83615460782706c8a152df3b1712d3529190e1ac346b79b17a6a5a6a536a4b617a2998aa6fae976f636ef1cb1ff23772029041f52bc4e0085a4ab4a70fc909c26534b93ece849cfb8ff437fe5efb13410d9182a6aaede4103c0698202a5bab8db321357bed5ff0dbbfc7491944e9d4c4b29319b487ae5e8e3ca049c972369d24d748dafcaf8382d94294a432a20b8fe95f1763b5efb7b4c080de849d72c075ebb0e6fd2d13445ea58cff1d57f3430b554c671feab826a0365d3d7272683d75450e65308726d9e4740d8478425ce6256556c6726310ec2ce5c2c4dd31523e984ee5e1ac7d2ab3ca1d9851d3c7fb4b975bba946d48c6b28782682ee16cee757499c1f609d9710d563780404645db839f13a4583d56b275337a5b53a4a8ae124d319ddc2174bec1617dbcca2a3756664d046e041894f14439cd56d34c04f2044fc1b7eb1d965dc301c0d4e14e93093ad735bb3ee268959c571444ebce56d3f18d38c064b0b156908e7b19d0df432841c0be50f1b6a05dd5bb5e2b20c78be767fef462d9353822822ea3412cea21c4cfe708058df8230ef028cfec2338360a08a8af22c13824b4d920b6826ff3f3fdb1779637ebb561e17382f602db2d12899ae820e9efc8ebf0072f92ccb59b5cc65abce227f34f1b325fe94bdd076af3f921ab15f441f12a62d7ab6a5d2dc1f6748a295fe6282ed1fc6e7a147f65e6a1bc78c7c6d8a07cf00899aa00adf4e6be29f50363112c264359d0c27ce039f7caeaa8750318fc85b6795790a7e86e9779b884599d77375d2578bef186a65afe737904f3821a8035718ff740971e9ada596cf4dd1b0fd7f52aeba6518ee52d7db957f800958b5c182ef89f869a35740261720ced22792fab28e701bdaa54f9dfdecaa09eca124e09906acae71d7a7333248531de297c511f346914bd58fb85af96d4127c769b7116d27b2bae4560d0366208947ae3a2cdce16250427d18a33327ea33a75e9678900804f763340cc6c930db406b08be98fa076f45470e476763db97f6573bba5fe524852a4a7b49213d389d34522f3e75e13d6bb5f86292bc51299a7e3c89dcae084cda23f9713aa8b43616866c034805383a71d606b7b2c46189ffebab29e3ccc375bf1e81af8ee5b941524f37328b18ecdd2201102ae79a71f08b007ff2ef7afe21e29cd00b2f1bbfed807cfd56e789cfe4364404542e5d6c68b416655f776d41def76018ba13c0102622853e653a94224b5ffb473aa6aabeecfa17ee153676a3347d24e076714b805301d556d15908439210d6eca7ec62f3488b62ddc121dc15d11479804459c79dae6d8ef3f6b86023ce58cbcae6f73085e2ac6d85268871946f6dc263a108d8daf8a617520c8b12571af05a95467735b3b73e200186b5ac0d9036645164f94ee32bb89ed47076f38e44dadb5fe99fcd16439a9364b49b044824faf7bbf0695a498d6913ac820afa9af96595f0a6dd02a2682f5cd8d8d564531d6713ca84faa1955bbaff8200d225b8588ae3235d1ad7d7cc5dfd6b9022430570c2f32ac8121be569ef53aa730e5c9a4884467f95de5967dc3dbd436ca04ea30854bbf5f5dd80bdba4163b586329e08295aa51bb90100174f9ab4feaa63b2bfb3e6feadc0315d3c99519844d43d52c5a8026381a3ff57f9bd01d24f8f3905817d99248ec34c85f9bd057e56a06513097fbe4d731c255544d8768822f9d4c3d5f23ff97170b62090161379877b3d7a8efa234991c2f4d33b1498039695e4695ab536243cb2746838dbd2d4b41d505061c7ef65fa1108462733acefabae781c70f6288a7c3fdc96ba5aec63e3ab82e85ef88015470ce3feec8651bfad7973faef56a2b58513a69baea34bbf3f72226561ad3a59da5bc7f7e2318ad6721e80d6b607f23be65c057a13f908d79e175e6760c8d819950b6ce5987ff49a02084ad38f60095d9e25d75168de52cced6bfbfe51f70ba3977da9e08e59232f25e3ac0c92af873047778d78a316e6e3c7b2594f45e9b417518b2bad07c7ac4344e69b9e1e46cec0ce10dc27ab7ecc47059d90419cd198141bafc14cc04f87c27e245c7df94b5224f8a57bc73d56f3c3741493d3f47b89d24315a06526916e0ca820433adf6f39364526e3ca00b36c78cb23a7061db005cc1fb9865675ba8b8018ef9e9ab6dee7f8e037d05fd51696b37f0378a5e0ea4e5b7cba3202d3737d5967cc46ab25ea29ea55d465295168cdb53e36b087ba0293fd74f82d5814cfba7e2a7f3766edca416702d09f5af282e4e668ee5033607afcb0e8bfd12ebf8f3048d7061c6e40eec7ededf1a820d03c09be2c48982bebf288b730c436c33a05570509cb0374746178f84ab57b144e652a07c0514fa43c4d90f71832456c406c935157c517648e1d83951b4db1af65421d4bd648963f71cd1c48920cbe30030d5d9ce95faa921516a36a11cfb9d40babc7ddd1ecf76ab8303504f7eedac9740c2dffbf0c8c87265a10177c2990e849658b62a014241dcd444a29d3f30516f4dbdadb56ad8d6777f5d0bfb33e17d538aacecbf3c6e45ae2c9ebf0d7252ab25c617d0c26ee1686b2456b1e9cdcd0d5a44476715896ffef8da684c2cef7f6034ac3e1b78df39e381f1a7467e38c258d8d0a2e3205d9e9029ce5a4a2a9856a1127193cce9966d39d6ad55ac570a60d166f700313436bfc160044f46c2702a92fe03b395451b2530558083c7831c6be9afdb18977e1a5c0563172f120a7af38c777c9c5f4fd18f559b6a3c2ab6caffe329c59b3e9f534bae9fd163dc959454440fff1179178f3976661145f7d73d45157ab306d0cb4495528019e1e55b0add931bc7e18f041f9307c25994f99dc07ceae9dbaefeb29a037e91e18c04d3beb18682ba7fa2fd89d11274afbbce0e355563834775b870a692724f0d08545bfda88561598517c582c982cf20f09c05dc3c7f4f254f3dba47e548bced279b68fc921a508b15331f5548d1a93d915d167926f315a377d4127bd0df40e514c4b03a9f1b5fd8a878fd94a9ab36f7f020148ab297c6b2461325397535b570627c8189acde84acd8afd751eb13b4f1b253be4f9ee50858461971d505dbb846832f2f7f7f93102a0cedd0a264a22c7f1fdb1ae04f71e91f02f2fa253ae4447cc3679076d9aa3db4c536fd800992e5347ab112a45351ba645500eb159e5ee120a3aab769c71caa1540c0b62f9323004abcc931b6767fd635930391f39d40407844793a47b881c021b18b8342bd3e9ccdbbe7b1e7e78ef8f948adb311f87da5756c4c35de309d6b55c8a222cff40e47ae04ac45282dc925f701acd1fb21253b1e44596bcd6c8c78698fdbb6692c949cd6f30b6986539f87c81fd1b655f46a994fca3b0ffb2f058f6e936f8aebd4dfdc3a70581b43cd75566f24865d3b302d98fbba34ef37d6e1a2ff33378f5a38cc5324774f12aeb83733dec9561586cdf3f2b41702bd7eb32c9c450fada4ebdbd3bd81a222bfa010a49d45d30bc158771679860e6d20b914617320b0e991999f3fcdf8d8cb1a81f2c16bd1d921271dcb15f058ba6e79264990b5bb47d3d23425ea19a217d79ab8e6ff2749a80f4bc28ad2122e83dbb71bfab5881bcd7fb4f010a4d842ea895195251a47a256996201759f41a0e4f9a13277b8e8393b74d4b977fba70e9c2d321cfa7f06b26727423cfed41f1ec40c104ea5179c2f3f34598b0ebbd4cbfcbd7ec7387b3a6d7c63109dcb23e6490e3515ae245eac0dff7c119665f130926315f516b20b9a45f45b264409a1735fb2ddfc1eaf4dd0e8530af3b8f16ae756a1a4715de16ecb99349b4a87eaf7dd86cf801b7ddc2977076f3cf432a652a3d878e38df38cb84b4a0af0878f39371518fc0f1bd46772fb37ebd680ddb52f2465211de956172a45552cf298c84fd287285a1174d74224d6390c32d83392e155cfb4ff9377ab622db308f699a1d408ef4cfdb9a13892b494d4d5c741cec2aeaabeb79cd84ed52b105987a92a9044f6caedaf7513a3e6512030c3922b56bd92c13f5b15d2848db25de59e68ff3303e8ca7f935ef30b9986c674910420608e028a0f3db11173e1221b7a3c2e6a9e78e8d12f14b6fb61da2bdfa4d84a894ea6a1209ff3fb7cbad23331a09262ab863d62d00663996a7576154377fd87245ad77abf2f3a1f53558b485767f863a0089c99855abaffcade30ca11597feb3f5d873b5ca496053a4c49006354674f0b2e8b4b4c3573f7020b783f98825408cf87cd0b50cd6283fd881339641768a93240ae86c806b8735a8a570819ae3cc04ee5dccab8e47b09f0ca13199d7be72fb6f1f8bf1d17f12e986b8a3a645309a7f410ccd9047fb93eed95376865640d029a573569bde2d8acb516d621d8528347957265fe5de39a79a52cb0794a5868c4fae8b9d967d2c5551c6a34d51eff5d830ed50346d28e470a435b33219a08ba8897e6aa4721ca1c7b1b6f034ff77d99b5c6180d9da21e2df94d90f65fd73e1c50e315628c3f3e68ac60ae852e4dfa1ed332143b816d7653633f3dc49a38d0ee735dd2ad98e33a8b98500cb02fd97f6befdb117b6e8e1a684512c6cd55b4db77da8c713897f6450c1f1987b5b524f6189f062f1aec8afd182428d7f5fe03901ef3fd9a7e9f303e326d340224cb720310333a06a0cff196a748ad34b6a7dcc5a73e98e8ea23507f1cbcecd0f94214cf90a1ae24a707663b815f9309ea425e7a1c25d0630fb0865b270f19ff1518cb729f7e4dcf06b688333eb7d9ec03f505c979027c22224c539e3aeb7e24e1c93c976739a9e4b4af2cf69dca5f92e3ca61b7bf1ba83299bdf8d4eb9b336feb1f927db7ff5fbbd23dc3dec57cb2a513372810f94dc2c2a4cd0f336795cb14f29df7df5539454f5772bfab1bfe366724b312f827a4fab8f8c860934fc5ace71729bc02fd85923896cb2819a262b8e5310c3794e7431eb4e28824dd78ac9a10da15f18e52c7e25366981ff9a1b85747df4d93d65aaeb00db6d2d824e18921fce79554631272b54ab32e5f19c35fb96f0063058dea5f337f059dedb99ed55fcf8a43e26219252c4f7db7fae7246127c6d9010045cc5193dde66db3d46438bf793d2e9e96cfc53473c1b72d8351a06c8cce2902a49c387891d6ac0254680ceddcd158d7956595cb78499fc2aec1496bb7034c7e2b33d6f143d592f831030c1332d32cd766a615b99e858229a9f3cf7723f9549bb050af91edbe232f2756d8e1629a8f619ddd3ba8b71f3eb9fee6f30e3cdc1657584d806bb8c94a6fbc8086cbcaec5d428a5e37543dc50f3ed97da9b6c5a5d9fa44ccbbd18e78ea3ef17a8a86982882de4fd03a132574e2b14d913d5495240204a9fda9381d11cece057cb153a3aaaadef4fd43baeb8baa7c69efdec83c5c265d22409ab9f98284ba2f4e226fe922581d659dae290e372aa726ecca28e5e44ecf41f5919cb453cb5f499fdf1e7ab2c1ea8cca4e80ce14dc4a77159b9a8b01e424f4bfdef75fb6117a5da09781a41a36f011a6624e673f21a4a8b3f0fd41002def6d9b0137691743b20cdd26badad836a2637c09ddc718e9a9e5b0dfcb3c97bc61ad380f30d6b597789b5c3d44d55a7126d806b5b85b18dbdec563ec3a3f1a1cd1ef851a6d44a4b89cfe236f5c1cdc0a0dc638394918472784c37e101c1e656157b9f7e7389e9900414e69ffaad1c115d7b05d5b78ce8757aaee3af16a6e2c74a7b100724b6eb10b27c4924d20fc037d1ccd455d1af5be70fe379975c9b2a3336232048db116ab770a8ce0e0bc7b637c7980134c9f7f0d73191a65dcb130fa95ccd2af7ca583673b306b3714cd14357c12245d99178cb42ddb5af7767e249a02feeb41d4bdb36ac4d3b347fa90a8c669102d2bc446b95dc70ae67f3b484ee56e3cdb1ac914f520d7ec5f256b3e9cf1a6c44ddbf1ac05327c576140779f71cf390397632fa92b624e91699f9c404d922fd9e27d3435bf4a3115ad3c0bbfe270e942bbc8ed97fb327f9f41ab8aa50ffbd3d15f6ea4131d4806699de99d662e7ee1e5c66709ffa2e1e9f45bbfd6219b4ee60f276e420f527080dcfcc78ecfdab8b368437ca9f789d0fdf0d1ec439e619da426597d33d6d8dfb7f76ce3564a7020d44d3378b72caecf3d3b620cedcdb49a69e67dd8df2d32c031cbe235762e7ef415c60c076945c1b4a00d76153639df85b936a489df8870fdf06c0ce0913a61e8af4f63fa87a71e95ddfc58db39ea317cf847258d2c79fa3ff7ec30c023019ba5cf1e018ac571794d274198dff41157fe50d394c476f3dc5b6c6656bef48e706314493bca5fb8fbce10abfd2c153ac6931de4efa7068cafec6aec1262282993c2db7be3b83618dc6f38b18912a7fc24b2f8ae5da91b87150d66a7bfede3f3b359bc95fdc7baa8bee2fc6b170a1c09c5e0f6482fd04a577a97523230ad7d51e570988fbe7777fbfd9a8345dc47c7895896795a96644553f7dc3fcfa5497a8a1a21eb5c8022ab2400dfd1b07d0ee5bfad653987401daeb27f00e7bc02cac26e77f9f3d58ef43f5f7fd1fffaa416037a7e3eb3d12bf0132d4e570d6b24cbd44b3ecc2f65fc38e5c4210649de4b149cb6b26669150aedbdabbeebd078b3a58816e4c95b3e914654a0cdf69d9337b24f7be8db6217452301ba7499095cfac2ddff7470417cbf20807140d77afa3e163a88a9297dd2f0b6a8a6e4738f3eab4ec9e26fc17561adc3864cb32eea24812bf71b3e227a97a9e368f00acda2033d697dc2c82d9ef867f16721f1e754a53a19641390acdb04950e53816dcf42bcf2c67c2f2d11e7781457e6b3e5cf8d0709ca7776c011249d916cb6cdcebc2e6355576a06b0d0bb5d84291b549c1e10d207bf19442ef1fbafe1de5e16d54a0785eb00719f8c8c6eba46132be5c15cd8f7fc042d1c5a88451fbd182fdfad7be01b47cc481936f0794ddd81292867b9c0563546f3575c65be2faad43b5935b9c39ebf70c6a9684e64ddbc5650d61e4f7fc347ff9eeb785917d20af769135994092d07ed30d85f0f6351a9c8862eb94e0c35ea3e6ad4967ebbd11021e181c2c1c5fd26f9d6c76bf0cb34061aa4ff74acf18e41e68285efff14b0b044306bd0e4314d2198ae3cc822010dc970f8e5de3eb243480fbe560935da823078bdf336d44393a610d98313943f1fd2921481e076fdca768d4b009ff85dd2ab976971cf4a2db9bc94481f739f0e6fdeffb579299da7701c6049273af860b713a35834299dfd6ea0f33ebafb987f228bad6364ed8035183834a3d976317bc73d3eb49aecb1eaff0a5660a1bf6d5d64580ac87cdadad9c30e28ffd723c4971814259331665b8e46fe7b403165d02505ecf9d9cab376234b94761d082f73a4271d4bb5151a96c8e0b88587c661f287c997bd3ad8371927d97edfdae4b8e231772c453294821af90026a6acf035436e94b53a7c9648c744a8d24985481f60f4774efe5ee6f07cac0f9d7119fb0c3d1e9f8b622bba97729b7cd54c0547612637219175866f07a92f60576d60d0fbff0c4b61dec80b7d113815ec28078094fc3c997874199fd1dee149e641ea7834b7411d37a371d424fbc43ac51d06c7150c83ec32e24e0f88633d8997153ad4bd830eb64f0669e998f0a356573189a83f12c349f20ccba6f6373257dd654a2494597c51a1d56cec1384ad8f993fac0839766c9b64be572b4196393fd54493a2008cd7fe7608579b4c2b92695040b51d86acb30285fd76e3d4ec13421a070570e60cc840c9cbcad955e42c23307b7c758f52fc86470ddd680775b5a9c5924b8d5693a692f24c2a4a2869b0a8134df70b80c2808513112e1b67ff42472a7f682c6f5fd1ad41e938242ddef60957bea4174b0d865750346790cea28d187fa926491ed3f50e10d5074448bf9fd45856f4ebb4e72b3e7dff4d73e052fce49c54e5dd2953aa736d37c8736e6505cfbbd5b44bfdb728300d5c1b0e1fb59d3f37a3286578593dfeb5f2e23beac5009ad755029d3cd15f73e8474cb32126263f545d53d637f5684606f8a4ef91e6e4bd8539068c4356c71ce2cf30e66c6b591ce199d16410c59698a062fbf91c1ed6b4ecaa477535e44ef8f7a910ec292acb5b5bd4c33e681fa5a4183ce459be515dae589b84cbfef1af8acc186e70e745642957753ca59908fada0300ab33e796295a3317a4ba9a4bd2154b817ceee093e0dca598eba9dc6006bfab9ff9e8c4d5e6486db8e8661c204897c1e5ff4cfe44ae7d2ef78fbfc7f221fa6a992f5724d5d644a1d97fdd25b818e3e78c71c6836a7ee3bfd742d96dbb68f295f991ed29089d507bb94d1908f2037aec77862bf87e974e3e56c09a214de0edc0033cca7fdb262df0910b660464d81a4034d9fd04cf758307b85acbfcc84631084ad13ca8247920785a0b360307d1928206b528033476b684fdb75aa8e8b31edd1743a44ea296a81b7cf09aa5369f3f0f4641a3e3b643cbaadbaa142b9ba79c807d880abdbe4cf3326f76064edd254dd450bcd55bdcad1f3dadfa6517610774c8e65b40dceab8b099e2d39c6016942f3a086bfcd9b8dc0c7cc4022dd769f81dc6387f4e332a62d3e70b2017cdff6b9584bd5510abe13ab66a31269f32283cb1709a244454377e0a09895de05a132056f8e6c6002274497a7bb9b64d0984b1ec5f3d6246b9fcabaaf92bffbc474c66191021899c74dfcd3779aba326abc0b951fb0852f15f06fee484d930b2095230daf584cef19e88b5a1527d11774851440f6a3bac54590885d8cb954d3f2f7a19bdd7191f5775fea6ceab0fa08c7280305c5f5302be2d102c797906a57892de357c4a7edea60c0484cda4a558e4834095559464e6d375049ea1b8ee3b65e4b4fc430794743ac3317578a7efc929d890df3e911f1ac26951d1561c425ec0312fdad91f8dd6ea1bbcfa2a06086dce6828b1925cae27d48dbb4bf37fba6a87070698e7aa04a846038c8152f6b0a4c6d43fdd45be3518ef1ed47a840bae4f124d6832372836aebdeb34a24bc237606549b4734b44974e077d7ec75d2791e751eeccf37ffc3870280a8cc056880592f2d5b35bd337b04a829e2e15fc5b23c360045d3059add290dc0efe3835e6b3885561f9fdbe45c49e042798642e729fc2b3589675fd870d4f2c449ae717468328c81a06816a2f398167932bea3ab8ae477feada6951b66aba662359908b39b4948bc247d9568059967f48f6ad9ab5bd7981cd1fda383727901aaccf21c1b80f83d3bac0a529edaebf03d46b19ebf69c369d31130f2efb86eb2f04258a2911b60e91e19035c8b92dda23dfc284423be7ced3cc508839564deb18e23fe322a95bc7ef0430784e22764eb1fbd6f2e9ed761d18ea54c4554c12e88e05da664ee1af9c74a7132372d6cca734e1047c37ad19902eb83aee221905da0d3fd23b241ca0527150bdb8975720740d6575ab2fd26590077c020e3fe5cc7952b9efd86212282d02a15d0683f8f3b5649ab14bc86310aca250e2f3c824b4c4e3609ea4b91637b0bb06c5b78debe7fb6603a7be16578a1ae3c4e754f27fc6faaf12350fb90e5c81d2f8fecadae8bce679227440c2bc3ee651c2984a29e95aafc0fed0a79fe951e3204fd6b4fafc5b1b933a4279e4a752f7b04ae6db912fdfbbe9fc97b8bfcbbc612499ae5301bf2c3e5e492abd709b2899fcf36a8980842f0991ea61c142945a6770e22d5b7ef9f3b63808922c27db727ceb4026c999191d9783f83c5f9330dc306f4c7aeb96e7999627840d20ebee4b27e8ee7f805398eb63b355e75c8d35ffef49bd273040b7b6d74dc0100cafe40b96d2e13e2b664292e0a731f65b5eb1c31dcc43b149c1926a526e7a3994c061161d775c5f2914f80ebd615f7cbd5111fc1e1f48153147c2be1be5b2fbb8de092ed3e11451eb605b3e7587e8a88c1f9b9ca23d5e6e35bd1b367b448241d0db5795996889fcbf06a80e0faae44700c727de39f30da0992801a0c17e6d454d004d7479e6c8f00c88e9e49fc82fb8d40e79eda0654aacdc46b0e720a46ea71ce160393abfb6d024336ec6d4c60219c07ef6d5295aea06a47c331c7c7eddc830e97bd706934d021ae90a567286f90a6237929b87a7fddfb649bd2eb200a949aa0561a23bdf8a521243bf84f16c962b04f65836af3e78d72e66df028512f740d1b48ceee1ea9b1c3fe9781ff5c3dfaffcd6082606ca6e29b63deef357c3c5aa19bd80b4b8637ba994a3f8ab1f6958b19d04933b1fcb53a03c8b1cdb15f03a301a57dd31bba1cfb89ae9009d2d39a1f8735b3f029204528e5bde9a642d782b3a16dd1865b35e9ca79829f3c824e88a46e9caab3a701ad9eee3068b9e50e0c35c6244f6b76adf78d66d38e6f4cc3ae3763c11d11d0a69f1fa572e439a3520a70800b9d4dba7c27d261a55e06dab533955c000037897c3c1fdeeb29fb61c5b6c1fa04d49494a2fd0eba3c8727f83ea5845a19ac450943441913aebc226917f1f3f38fdafdd63404c63bf3794499408e569057476d3d15fd2a9647d6bfed162b96c179f2e3feb3d8c61460a31dd6bbd90858fb6b3a869457f298592de0697291fbbad05c6eeca760b5e2e4d5128aeb435b4f086d37bed659f515605ec55fb310824118f94071f59118140af0c7db07a077887626a78592808fb0f28f32700291dd60260c8cf45c8e2ac5ffefec3590e1a4dbe1984f6d94b99ed86980bce538322f69c8682b005709ace9585d7ff9e7783b46a8bfd60ba12919bccba427c4f9014fd2954565888402805b28e6a87011d757934dde8c8b3b363775a181b13173ffa7f8c487e8ab2f01df03f338dcccd9dfcf9936cddbf475a8cb1a383d5404d9dbcc9d22d308e5a552c40f04ab11fc0d6deb0ddc67d2ee6a4615944dd55bf1f88efaea54ad4316322a12a22afa0ae2b723aceb998a5770a6a9aa2bff42c82855f7251dd3ba9928e3845288b467a4a30057017275721f9adb4c0383d03eeed95111ff0d3529dcd57d33cdf930bbe312be20140887eb6b165c3db6121aedbbc5ef0ead1777d0a28821d63afec28fd667056b896a60d909aa1b54370d8b5bf4438dbe3fe4ad2c104296246b73a1fb87c009313a8e7ea20e3e17725ed48b30f53b4c4da44a8714141592d06f4edc42f8d6c191a904615bebb5918601bcbed557f2d82776edf6f93ed6c6cbeb8f461f296fed1857119e455bf2bc02d1e76c038c6997695be3e798fbd74a312fb5b3d301a67e4bef032c907f4622745730c319d04a88d30d02371a20e18dcf1289dc13db0433e4790e06aafd60d935e5aac0010297b0b9d7271ab5b25e5bb216b9c356d7e20ff4dde2fe6fe22c01e24e3e92ed889efdc49941b58c85428f361866bcd1f925fab4ea4ec0a7d63eb3f9b215c2b32083f1ba85f7cde2b58a5928047043dbe85674ff322c08c578b185ffd48448ed428ec18574022945bbe9e6f519f224b25a09348a9a7fccba797f30cf88acfc8dc56457231e170e821c72462d111886d7c53726042bf2fdd36918f8aa52b78eeccfaf8d4337883f513b6f7e7f38896de3eaa34c6a64a1d3d3bcce4a16bab55fe2b0df1846411f277780a81cf31aae99f7c4366ef9c8adccc4a1396448258ab6af4d5223f68ea40b13cbd7c2ec6a7ccbc7cf3e6aa3805b997db3da01642338d5b36d5e165acd3b66e1cfcec7610b1d4ac62868a687f0bec55b7fe2337d72abe7ed60fbb9b4a888d89ef64000f30294bb02ff085e5c6c3c2d0861b02a1784a5dd8c5faf397a180e5b694bcf2578ff0d47b0c149aafecf3f55059f2cf0dd428f6961b0e94608c6250ef25e27a3579f9d84acba8a5b42e8c4c7a11f6e3e2367fab662e21aefc3b5fd353f301a3ce57ae6c441454b3f2a9819514a44a0e13e3e66d3a1cb4a4cb802c26ad26d05202f592622fdc42a07c6ed5aa438c054c75f510e6fa2ecbbee3c9006171ffc58ca7a2373099e4cb308642ccc10f2a7fcf9f4afda65311220fffa02ff80401a1d8788899f65cd4bf19b9d2bf9ce6d37d780227fc5077030a77b9c7c955159327d7f86ae4745be0897b1ee7711168c0a4723f51220e4da05b88dafb2c9f9567beb5fe9525a9e39655d5fba32158941685a65ff55c1db8a3fbad4f72b3d9fb800dbb2fcd138e00f87bb23f32dc657842174004e510ab41626e83e065265a6db607162501ab8dcf5add203ca115cda255f6dc2f6782d10e78747240fb8e7fc4a9018cbd7ce9fb35f146e79b1aa2496340a874ae690a6512171de4c21b1cbbf47be4b3581121f3a1b2a20a274fb32f361bddda7e071c98867b764d0653420bb6282bfa52763910bdcadd07d5c6eb80b5298e8ae9ac0e43cdb75590fba9481bde17a58ddd01748f1297fe9e8450c104d00bc5feb3eff7576777d4e3f5148420ce626fa80c5ef943c018f95f8ac5fe9837f8a1e54e7597f8f872c81290cce2ebabcbc393565db7c729306973199155b4b7fecb5548bfa50dbb3865e6d36a6622f6dc855d6473c914882fcdc78e9fec73d6bc9073527505b7001fb9a19fe9d2834ac01a661c91f7e35631fea440f5a0f74a2d42231703045d99ef0165f8ba91fafbdc6697fecd1c0f16bc07e2e45bdb11445b21694b04ac809c8b628522ac40895b969fa03edd70a3d23b5112d951477970988e502cbaea05d3b7ab3120c62a708bb62513ca249c8d1fda6cf6aabffc88fed8effa47a4c299ed4ba36466c0a2819b4ddebf87600c770c3eec93a601aff9d33e54cc5ed923024102945a11ee176b7bc98cec80c0ea5c71488e517e445e5c71875275faabeeaf47b1d0423bd382aef7d02ee51339d3f5c9461e4d2d9558d04e44c6bcd7ffaa338cc3fe27ba11947a8f0dd63b312ecb9b6c7f005285dea85b0c1db1f336ead3a366e61367252f7800da2d4db8915487a3f6c64fa6c914abc4ad337e0bad5cc8a43aaf4ba10471b3d9fd0f10bcd3287335a5385cab979498c454f4bd5aa6a99e9818fe108e6d56fa4b332589a3e5cff569794df9ec3a1327d8e60521cd7ed6c7a1e1b44b54f35b7bf3cd408ed6dc2ab353976780f7fa7f1a6ac2200c858d2355567749d6f122b04c5c059ac7d08d806089a5641cde719155158265b3c344ed845877da30a6b83ba2221a02899380aa4e3adc76f1e6512e7eb9182e143de26f7e401b3c2e2528581a87d0ddea3bc06141ebfecb35c65d7efde4590a5adb73810f080fb299cb7f3bdae2f664ce80b44acec4456c938808a9e633bf30fc3a479bd1e6e6cab3b4a9504465d7fa93df735986d1e24415193075f17500a17bf7ae4a7d410d1fc05db5eac57ca725a7e63954a541fe40e4e9b1e550ad9a0ebf9dd3188958e331d0985dcbbc4473cf4927b993642fb9b7aa67eb0865d28ba2270b02389ac0fec6ee5976d7a91896e9b3772db2fff99cfd5bebf7a7b5649279cb168c2951275866edec0d3d732d85d99061fab45b0b859a0e460b8afebbe3fe2410177671fcf77120e3e743c75f27f65e89b7deb0577fc5ec35bb910b837bed5635ae0cdf360fd7518e6e3afab86f135a4880cbee8234be2978f6125a85726f582ead4ac3066da560cec760ee15637c9187cf72daffbbedeed26cc7a424a286615aa9c18e3a225b6c8f6c3202fc07abb6416c1e3326692277feac6fc52b18d5cd1bee1bb41e0e14e0da536a24d0a6ff5734fbcdc5ba4e38c87901c495548b936e6d11a121163968e2807d25a7f8301c81c4701a920540d1947f121d562266e843cd75225a397f5ca3c5aee327efd6c09c736699b71d236acd7f5a95c5b14f9bd8ec6a489ce8d0ae0c090e6f6eaa111b8f46c9188cf9c5dc9d36c671f1aa6c739756bb98941efbfa4f866637a278a47b0914ba36d9ff6fe6f6d038f84073fc9a93a96895a97b85c75436a87772b4934c3d57518a27c3b5a1e9d909fe4ec0b8fa0f76bfb6e49a43aeab02842a5996d50998aeceb9972a201daaded3ce805634e55c08f3273c15b5d26517a36fe6eca67fa33958e4b43a6d52660ae95eb16d858cc28e607ffc520b32093934f44064061c08c1d624d31d0fc58aeb6cf68fcb9f08566680e86e9cb45545af92b935f0758211c85e72192a51e4923bcb4bd960df6f9afe4950592c62907d45d4a7bdbec2c1bcf556f90eff2475aea5b4b122b283a8e32fe90778fa0454ca5bd066d36e152b98cc9c5ed3709359fd832398fe15b213e7bdf033f7d05945cd6b5979c4306ea2a32ea75a9bf6ed52e548a9fb9f668fed825f520f4645ea28db0e14eae4dc438cc60d979286045b2e2cb4195d621c12b0d0103a458e63916ea07e89a3db18c661871999acd507b2bf07f6908382b7e7945475caf68cd822545702ee63a89dbb09c867c6aecada159ed774ee32c01971bc486902f5d3a7b440baa514ba53c5c59bc8d91805c97b48ea31fdedf8b84e86955d0aea35fc33ec9d0c0fad68fdfce780c9a33c53748fe850fbdc0f3056425ad5b47f5ef6d9b4a605e2a92017f9664b8c123a840cc2b7e8db7da7a16340b8782a09cb958f8df4f147bb0e6c561eb04cc7c853c690e2d644db677a28c2980e0c1227ad1343efde4463ae443e9b1b748ef643565f30d6b5d68b62ea2ecd08670e7e6031b607e2508f2a915c06a359950839f9d05d0d81b2881ad667471cc867a1eec05ef8c27376eac4b8d72bc3dbfe4e5588d3fdc3377a3babe56ff36451d267851d430fa7bdee4a58cf97ff64c27f4061f87dcbbbdea8bc031f7e0edda0e9513139749aeb2a53361bcdd161bcaa5bc3a4158ce734f1b33e055c968669f3440aaa2b466701995173b2e4455f21269929952b92a8b891395b032947adfad0093a8d8b15b60fd5a03d352fb1a4f5d91839c466e3d9dc900cf564e70a3ade556ccf3f2b2e4e27a58ead09201d421c6b61b7b563533cdd15c3cc83a73670daa352b08e4bed1ca576928f01614010aae84bd7f800cb25d2cc7b9e35a2c49a5b9830440f1b6d47f59abdd1a800566edd92f5e86769e17ffabb0d2296f6fbb498dba80ef6aa60cdbcc52395ea082474b6071cfd67c60a73328a08b98cb0f2018f80454416d91fc95932d7ce5b4f54b1fce0f09a281a501056b42c3ac19d1ff0da29a76eaa4f9ba17e4dec3a580060562a5a481198e6cd23698b0733c336ce416061db82f9cc2faf9cba41eb0ec0e00a77bbd68f4b4cd5d605cdfc3206b44977be0d695022ea2de4a0d9a7907128a9562b4388a93c068981751daafeb62e4b10be8da28e82feac4952f4bd054c6fc0f59145622d10e4fc5b3c6fe04226fb52aca5043bbeabcca20ed6114a776378d94e7ad70322a3ad9b07890720851c0e2c54a737a5011aaa9b2128396ec74176c5ce5853be101cfcdfccf600d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码！提示：密码是考试日期，如：20220202</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
      <tag>课程笔记</tag>
      
      <tag>AI</tag>
      
      <tag>DL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通向 AGI 之路</title>
    <link href="/%E9%80%9A%E5%90%91%20AGI%20%E4%B9%8B%E8%B7%AF/"/>
    <url>/%E9%80%9A%E5%90%91%20AGI%20%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="通向-AGI-之路"><a href="#通向-AGI-之路" class="headerlink" title="通向 AGI 之路"></a>通向 AGI 之路</h1><p>很多人都想知道下一代GPT可能会发展到怎样的程度。极有可能的情况是，ChatGPT 可能会走向通用型 AIGC，这将是实现人工通用智能(AGI)的重要一步。</p><h2 id="可能实现-AGI-的技术路径"><a href="#可能实现-AGI-的技术路径" class="headerlink" title="可能实现 AGI 的技术路径"></a>可能实现 AGI 的技术路径</h2><ol><li><p><strong>ChatGPT 这类大模型直接实现 AGI 能力。</strong></p><p>也就是很多人想象的 GPT-5， 看完了这个世界上所有的文本、图像和视频，听完了这个世界上所有的语音，可以直接操作文本、图像、语音等多种模态。优点是实现的 AGI 能力上限比较高，缺点是实现难度大。</p></li><li><p><strong>ChatGPT 作为控制中枢（大脑）控制各种 AI 工具（肢体）</strong></p></li></ol><p>   以并行的方式将各种AIGC工具集成到一个共享 agent 中，让 ChatGPT 来设计和调度任务。优点是简单可行，思路直观，缺点是不同任务之间独立性太强，缺乏交互。</p><p>   目前已经有类似做法，微软的 HuggingGPT 思路就是使用 ChatGPT 去调度操作 HuggingFace 上的各种模型来完成各种复杂任务，他们将这个系统命名为 JARVIS。</p><h2 id="AutoGPT"><a href="#AutoGPT" class="headerlink" title="AutoGPT"></a>AutoGPT</h2><p><a href="https://github.com/Significant-Gravitas/Auto-GPT">https://github.com/Significant-Gravitas/Auto-GPT</a></p><p>prompt 工程的下一个前沿，通向 AGI 之路！</p><p>具体来说，AutoGPT 相当于给基于 GPT 的模型一个内存和一个身体。有了它，你可以把一项任务交给 AI 智能体，让它自主地提出一个计划，然后执行计划。此外其还具有互联网访问、长期和短期内存管理、用于文本生成的 GPT-4 实例以及使用 GPT-3.5 进行文件存储和生成摘要等功能。AutoGPT 用处很多，可用来分析市场并提出交易策略、提供客户服务、进行营销等其他需要持续更新的任务。</p><p>特斯拉前 AI 总监、刚刚回归 OpenAI 的 Andrej Karpathy 也大力宣传，并在推特赞扬：「AutoGPT 是 prompt 工程的下一个前沿。」</p><p>AutoGPT 正在互联网上掀起一场风暴，它无处不在。很快，已经有网友上手实验了，该用户让 AutoGPT 建立一个网站，不到 3 分钟 AutoGPT 就成功了。期间 AutoGPT 使用了 React 和 Tailwind CSS，全凭自己，人类没有插手。看来程序员之后真就不再需要编码了。</p><h2 id="BabyAGI"><a href="#BabyAGI" class="headerlink" title="BabyAGI"></a>BabyAGI</h2><p><a href="https://github.com/yoheinakajima/babyagi">yoheinakajima&#x2F;babyagi (github.com)</a></p><p>babyagi 是一个智能任务管理和解决工具，它结合了OpenAI GPT-4和Pinecone向量搜索引擎的力量，以自动完成和管理一系列任务，从一个初始任务开始，babyagi使用GPT4生成解决方案和新任务，并将解决方案存储在Pinecone中以便进一步检索。</p><h2 id="AgentGPT"><a href="#AgentGPT" class="headerlink" title="AgentGPT"></a>AgentGPT</h2><p>通过AgentGPT配置和部署“Autonomous AI agent”。命名你自己的自定义AI，让它开始任何你能想到的目标。它会通过思考要做的任务，执行它们，并从结果中学习来试图达到目标.</p><h2 id="视频脚本"><a href="#视频脚本" class="headerlink" title="视频脚本"></a>视频脚本</h2><p>一觉醒来，AI行业又变天了！</p><p>很多人都想知道下一代GPT可能会发展到怎样的程度，极有可能的情况是，ChatGPT 可能会走向通用型 AIGC。</p><p>目前来讲，有两种可能的方式：</p><p>一是ChatGPT 这类大模型直接实现 AGI 能力。也就是很多人想象的 GPT-5， 看完了这个世界上所有的文本、图像和视频，听完了这个世界上所有的语音，可以直接操作文本、图像、语音等多种模态。优点是实现的 AGI 能力上限比较高，缺点是实现难度大。</p><p>二是ChatGPT 作为“大脑”控制各种 AI 工具来完成任务，优点是简单可行，思路直观，缺点是不同任务之间独立性太强，缺乏交互。</p><p>目前已经有类似做法，微软的 HuggingGPT 思路就是使用 ChatGPT 去调度操作 HuggingFace 上的各种模型来完成各种复杂任务，他们将这个系统命名为 JARVIS。</p><p>还有一些使用提示工程技巧和目前的ChatGPT的来实现类似AGI的功能如：</p><p><strong>AutoGPT、BabyAGI、AgentGPT</strong></p><p><strong>AutoGPT</strong></p><p>AutoGPT 相当于给基于 GPT 的模型一个内存和一个身体。</p><p>有了它，你可以把一项任务交给 AI 智能体，让它自主地提出一个计划，然后执行计划。</p><p>更牛的是，它还可以自主访问互联网爬取需要的信息，并且保存下来使用。</p><p>AutoGPT 用处很多，不仅可以用来编写代码，也可用来分析市场并提出交易策略、提供客户服务、进行营销等其他需要持续更新的任务。</p><p><strong>BabyAGI</strong></p><p>babyagi 是一个智能任务管理和解决工具，它结合了OpenAI GPT-4和Pinecone向量搜索引擎的力量，以自动完成和管理一系列任务，从一个初始任务开始，babyagi使用GPT4生成解决方案和新任务，并将解决方案存储在Pinecone中以便进一步检索。</p><p><strong>AgentGPT</strong></p><p>AgentGPT通过配置和部署“Autonomous AI agent”。命名你自己的自定义AI，让它开始任何你能想到的目标。它会通过思考要做的任务，执行它们，并从结果中学习来试图达到目标.</p><p>可以说他们是生成性AI的一小步，却是通用人工智能的一大步！</p><p>本期内容就到这里，了解最新AI资讯，欢迎关注Chat Gap 说！</p><p>我自己也实验了一下：</p><p>首先给他指定角色：一名前端程序员（a front-end developer）</p><p><img src="/./img/image-20230416150359239.png" alt="image-20230416150359239"></p><p>设定目标1：用前端框架写一个飞机大战小游戏。</p><p>Develop a airplane shooting game using a frontend framework.</p><p><img src="/./img/image-20230416150438609.png" alt="image-20230416150438609"></p><p>设定目标2：完成后打开网站。</p><p>After completing, open the website.</p><p><img src="/./img/image-20230416150454907.png" alt="image-20230416150454907"></p><p>AI正在对此任务自动进行规划，期间他还会主动访问互联网爬取所需数据。</p><p><img src="/./img/image-20230416150539825.png" alt="image-20230416150539825"></p><p><img src="/./img/image-20230416150611353.png" alt="image-20230416150611353"></p><p>官方Demo视频：</p><p><a href="https://github.com/Significant-Gravitas/Auto-GPT#-usage">Significant-Gravitas&#x2F;Auto-GPT: An experimental open-source attempt to make GPT-4 fully autonomous. (github.com)</a></p><p>程序员的门槛又降低了！</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChatGPT</tag>
      
      <tag>prompt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新兴职业：提示工程师</title>
    <link href="/%E6%96%B0%E5%85%B4%E8%81%8C%E4%B8%9A%EF%BC%9A%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <url>/%E6%96%B0%E5%85%B4%E8%81%8C%E4%B8%9A%EF%BC%9A%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    
    <content type="html"><![CDATA[<h1 id="新兴职业：提示工程师"><a href="#新兴职业：提示工程师" class="headerlink" title="新兴职业：提示工程师"></a>新兴职业：提示工程师</h1><p>ChatGPT掀起抢人大战！“提示工程师”火了，年薪近34万美元，不是计算机专业的也能干！</p><h2 id="前景"><a href="#前景" class="headerlink" title="前景"></a>前景</h2><p>ChatGPT引发的资本盛宴还在持续上演，每个人都在谈论它背后的AI技术，每个人都在担心自己会不会被AI替代，但很少有人注意到，这项技术带来的新就业岗位。<strong>这种岗位被称为“提示工程师”（Prompt Engineer），年薪可高达33.5万美元（约合人民币230万元），但不要求员工必须持有计算机工程学位。</strong></p><p><strong>相关报道：</strong></p><p><a href="https://new.qq.com/rain/a/20230330A01JS300">ChatGPT掀起抢人大战！“提示工程师”火了，年薪近34万美元，不是计算机专业的也能干_腾讯新闻 (qq.com)</a></p><p><a href="https://www.msn.cn/zh-cn/news/other/%E8%B5%9A%E9%92%B1%E6%9C%BA%E4%BC%9A%E6%9D%A5%E4%BA%86-%E5%85%AC%E5%8F%B8%E6%AD%A3%E4%B8%BA%E6%93%85%E9%95%BF%E5%86%99chatgpt-prompt%E7%9A%84%E4%BA%BA%E6%89%8D%E6%94%AF%E4%BB%98%E9%AB%98%E8%96%AA/ar-AA19fiC1">赚钱机会来了！公司正为擅长写ChatGPT Prompt的人才支付高薪 (msn.cn)</a></p><h2 id="最简单的提问思路"><a href="#最简单的提问思路" class="headerlink" title="最简单的提问思路"></a>最简单的提问思路</h2><ol><li>为ChatGTP设定一个角色</li><li>告知需求</li><li>告诉它需要它做什么</li><li>添加更多具体信息</li></ol><p><strong>举例：</strong></p><ol><li><p><strong>设定角色</strong>：现在你是专业的马拉松教练</p></li><li><p><strong>告知需求：</strong>我想在一个月后参加半程马拉松比赛并取得不错的成绩</p></li><li><p><strong>提出问题</strong>：请您给我设定合适的目标并制定每天的训练计划</p></li><li><p><strong>具体信息：</strong>我现在能在25分钟内完成5km的跑步。</p></li></ol><p><strong>ChatGPT给我的计划：</strong></p><p>好的，如果你现在能够在25分钟内完成5公里的跑步，那么你已经有了一个不错的基础。为了在一个月内取得好成绩，我们需要制定一个具体的训练计划，并设定合适的目标。</p><table><thead><tr><th>日期</th><th>训练类型</th><th>距离&#x2F;时间</th><th>说明</th></tr></thead><tbody><tr><td>周一</td><td>距离训练</td><td>5 公里</td><td>时间控制在 25 分钟以内</td></tr><tr><td>周二</td><td>间歇性训练</td><td>-</td><td>5 组 30 秒全力加速冲刺+1分钟慢跑恢复</td></tr><tr><td>周三</td><td>距离训练</td><td>7 公里</td><td>时间控制在 35 分钟以内</td></tr><tr><td>周四</td><td>核心肌肉训练</td><td>-</td><td>腹部、臀部和背部的力量训练</td></tr><tr><td>周五</td><td>间歇性训练</td><td>-</td><td>5 组 30 秒全力加速冲刺+1分钟慢跑恢复</td></tr><tr><td>周六</td><td>距离训练</td><td>10 公里</td><td>时间控制在 50 分钟以内</td></tr><tr><td>周日</td><td>休息</td><td>-</td><td>-</td></tr></tbody></table><h2 id="进阶：借用提示词工具"><a href="#进阶：借用提示词工具" class="headerlink" title="进阶：借用提示词工具"></a>进阶：借用提示词工具</h2><p>下面推荐几个网站</p><h3 id="🛠️ChatGPT-Shortcut"><a href="#🛠️ChatGPT-Shortcut" class="headerlink" title="🛠️ChatGPT Shortcut"></a>🛠️ChatGPT Shortcut</h3><p>让生产力加倍的 ChatGPT 快捷指令</p><p><img src="/./img/image-20230401195847430.png" alt="image-20230401195847430"></p><ul><li>支持中文</li><li>提示词数量多，有<strong>202个</strong>覆盖各种专业领域的提示词，并且不断更新</li><li>方便，一键复制到ChatGPT。</li></ul><p><strong>链接：</strong><a href="https://ai.newzone.top/">ChatGPT Shortcut - 简单易用的 ChatGPT 快捷指令表，让生产力倍增！标签筛选、关键词搜索和一键复制 Prompts</a></p><h3 id="🧑‍💻Learn-Prompting"><a href="#🧑‍💻Learn-Prompting" class="headerlink" title="🧑‍💻Learn Prompting"></a>🧑‍💻Learn Prompting</h3><p>这个网站把如何和人工智能模型进行交流看为一个新兴的领域：<strong>提示工程</strong>，在这里可以学习到相关的<strong>开源课程</strong>。</p><ul><li>开源免费</li><li>注重实践，每个课程下面都会有<strong>具体例子</strong>，让你循序渐进地学习。</li><li>更新迭代快</li><li>中文支持不完全，需要英文基础</li></ul><p><strong>链接：</strong><a href="https://learnprompting.org/zh-Hans/docs/intro">欢迎 | Learn Prompting</a></p><h3 id="📖ChatGPT指令大全"><a href="#📖ChatGPT指令大全" class="headerlink" title="📖ChatGPT指令大全"></a>📖ChatGPT指令大全</h3><ul><li>支持中文</li><li>内容精简</li></ul><p><strong>链接：</strong><a href="https://docs.qq.com/pdf/DYnZWTE9Rc0tVS09w?&u=2616e0e8aed14749ac9177b9b51f8b8d">ChatGPT指令大全（建议收藏） (qq.com)</a></p><h3 id="🔬奇技淫巧"><a href="#🔬奇技淫巧" class="headerlink" title="🔬奇技淫巧"></a>🔬奇技淫巧</h3><p>这是主要分享通过一些Prompt技巧，诱导chatGPT回答一些被限制或禁止回答的问题</p><ul><li>不支持中文</li><li>越狱诱导</li></ul><p><strong>链接：</strong><a href="https://www.jailbreakchat.com/">Jailbreak Chat</a></p><p>视频链接：</p><p>视频脚本：</p><table><thead><tr><th>字幕</th><th>内容</th></tr></thead><tbody><tr><td>ChatGPT掀起抢人大战！“提示工程师”火了</td><td><a href="https://inews.gtimg.com/om_bt/OfxJZFVVTh2Z96DiO_Sm8_1EiKrY8CKWA6xx6VYprUQ44AA/1000">https://inews.gtimg.com/om_bt/OfxJZFVVTh2Z96DiO_Sm8_1EiKrY8CKWA6xx6VYprUQ44AA/1000</a></td></tr><tr><td>年薪近34万美元</td><td>钱</td></tr><tr><td>不是计算机专业的也能干！</td><td></td></tr><tr><td>所谓提示工程师，也就是AI训练师</td><td><a href="https://inews.gtimg.com/om_bt/OnlJJNPeEtpErFWTplqCUQVr5fASmBNIymXD_2SBflbqQAA/1000">https://inews.gtimg.com/om_bt/OnlJJNPeEtpErFWTplqCUQVr5fASmBNIymXD_2SBflbqQAA/1000</a></td></tr><tr><td>即通过与AI交互写出相关提示，以帮助用户操作AI生成更完美的内容</td><td></td></tr><tr><td>确实有很多人都没有正确地向ChatGPT提问</td><td>错误提问示例图</td></tr><tr><td>导致他每次回答的内容都看似正确但实际上无用的</td><td></td></tr><tr><td>下面为大家提示几个提示词相关的网站</td><td></td></tr><tr><td>第一个，ChatGPT Shortcut</td><td>网站截图</td></tr><tr><td>让生产力加倍的 ChatGPT 快捷指令</td><td>开始同步演示</td></tr><tr><td>它支持中文</td><td></td></tr><tr><td>提示词数量多，有<strong>202个</strong>覆盖各种专业领域的提示词，并且还在不断更新中</td><td></td></tr><tr><td>使用方便，可以一键复制到ChatGPT</td><td></td></tr><tr><td>第二个，Learn Prompting</td><td>网站截图</td></tr><tr><td>这个网站把如何和人工智能模型进行交流看为一个新兴的领域：提示工程。</td><td>开始同步演示</td></tr><tr><td>在这里可以学习到相关的开源课程。</td><td></td></tr><tr><td>开源免费 ，注重实践</td><td></td></tr><tr><td>每个课程下面都会有具体例子，让你循序渐进地学习。</td><td></td></tr><tr><td>更新迭代快，</td><td></td></tr><tr><td>但是中文支持不完全，需要英文基础。</td><td></td></tr><tr><td>第三个，ChatGPT指令大全</td><td>网站截图</td></tr><tr><td>是一个共享文档</td><td></td></tr><tr><td>支持中文，内容精简。</td><td></td></tr><tr><td>第四个，Jailbreak Chat</td><td>网站截图</td></tr><tr><td>这是主要分享通过一些Prompt技巧，诱导chatGPT回答一些被限制或禁止回答的问题。</td><td></td></tr><tr><td>缺点是不支持中文</td><td></td></tr><tr><td>了解最新AI资讯，欢迎关注Chat Gap 说！</td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChatGPT</tag>
      
      <tag>prompt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大数据基础</title>
    <link href="/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/"/>
    <url>/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="大数据基础"><a href="#大数据基础" class="headerlink" title="大数据基础"></a>大数据基础</h1><h2 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h2><p>三范式：</p><ol><li>第一范式(1NF)；原子性，字段不可分</li><li>第二范式(2NF)唯一性，有主键，非主键字段完全依赖主键</li><li>第三范式(3NF) ：非主键字段不能相互依赖</li></ol><h2 id="企业级数据仓库"><a href="#企业级数据仓库" class="headerlink" title="企业级数据仓库"></a>企业级数据仓库</h2><h3 id="为什么要构建数据仓库"><a href="#为什么要构建数据仓库" class="headerlink" title="为什么要构建数据仓库"></a>为什么要构建数据仓库</h3><p>历史数据积存</p><p>企业数据分析需要</p><ol><li>数据存储在互不兼容的系统中</li><li>关系型数据库一般不存储日志数据</li><li>决策者需要从业务角度观察分析数据，关系型数据库不支持。</li></ol><h3 id="什么是数据仓库"><a href="#什么是数据仓库" class="headerlink" title="什么是数据仓库"></a>什么是数据仓库</h3><p>数据仓库(DataWarehouse, DW, DWH)是<strong>面向主题的、集成的、相对稳定</strong>的、反应历史变化的数据集合，数<br>仓中的数据是有组织、有结构的存储数据集合,用于对管理决策过程的支持。</p><h2 id="数据仓库架构及建模"><a href="#数据仓库架构及建模" class="headerlink" title="数据仓库架构及建模"></a>数据仓库架构及建模</h2><h3 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h3><p><img src="/./img/image-20230310091909431.png" alt="image-20230310091909431"></p><h3 id="系统建模"><a href="#系统建模" class="headerlink" title="系统建模"></a>系统建模</h3><ul><li><p>OLTP(在线事务处理)</p></li><li><p>OLAP(在线联机分析)</p><ul><li>ROLAP (RelationOLAP， 关系型OLAP) ：使用关系模型构建，存储系统一般为RDBMS</li><li>MOLAP (Multidimensional OLAP，多维型OLAP)：预先聚合计算，使用多维数组的形式保存数据结果，加快查询分析时间</li><li>HOLAP (Hybrid OLAP,混合架构的OLAP)：ROLAP和MOLAP两者的集成；如低层是关系型的，高层是多维矩阵型的;查询效率高于ROLAP，低于MOLAP</li></ul></li></ul><h3 id="维度模型"><a href="#维度模型" class="headerlink" title="维度模型"></a>维度模型</h3><p>维度模型中，表被分为维度表、事实表，维度是对事实的一种组织。</p><ul><li>星型模型</li><li>雪花模型</li><li>星座模型</li></ul><p>模型对比</p><ol><li>星型模型违反范式建模，雪花模型符合范式建模</li><li>星型模型数据分析效率比雪花模型高</li><li>企业级数仓构建使用星型模型和星座模型居多</li></ol><h3 id="维度表设计"><a href="#维度表设计" class="headerlink" title="维度表设计"></a>维度表设计</h3><p>代理键</p><p>稳定维度</p><p>缓慢变化维度</p><p>拉链表</p><h3 id="事实表设计"><a href="#事实表设计" class="headerlink" title="事实表设计"></a>事实表设计</h3><h4 id="明细事实表"><a href="#明细事实表" class="headerlink" title="明细事实表"></a>明细事实表</h4><p>降维</p><h4 id="事实表存储S"><a href="#事实表存储S" class="headerlink" title="事实表存储S"></a>事实表存储S</h4><ul><li>增量存储</li><li>全量快照</li><li>拉链存储</li></ul><h4 id="聚合事实表"><a href="#聚合事实表" class="headerlink" title="聚合事实表"></a>聚合事实表</h4><p>DWS层</p>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件需求工程</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/"/>
    <url>/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="软件需求工程"><a href="#软件需求工程" class="headerlink" title="软件需求工程"></a>软件需求工程</h1><h2 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h2><p>做什么</p><h3 id="用户需求"><a href="#用户需求" class="headerlink" title="用户需求"></a>用户需求</h3><h3 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h3><ul><li>功能需求</li><li>非功能需求</li><li>领域需求</li></ul><h2 id="需求工程过程"><a href="#需求工程过程" class="headerlink" title="需求工程过程"></a>需求工程过程</h2><ol><li>获取需求</li><li>需求分析与建模</li><li>确认需求</li><li>进化需求</li></ol><p>最终得到<strong>需求规格说明书</strong></p><h2 id="需求的分析方法"><a href="#需求的分析方法" class="headerlink" title="需求的分析方法"></a>需求的分析方法</h2><p>数据流图</p>]]></content>
    
    
    <categories>
      
      <category>软件工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑回归</title>
    <link href="/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <url>/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><p>解决回归问题，经典的二分类算法</p><h2 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h2><p><img src="/./img/image-20230227104052076.png"></p><h2 id="预测函数"><a href="#预测函数" class="headerlink" title="预测函数"></a>预测函数</h2><p><img src="/./img/image-20230227105813579.png" alt="image-20230227105813579"></p><p>分类</p><p><img src="/./img/image-20230227110121845.png" alt="image-20230227110121845"></p><p>整合</p><p><img src="/./img/image-20230227110132108.png" alt="image-20230227110132108"></p><p>解释：对于二分类任务（0，1），整合后y取0只保留后者 y取1只保留前者</p><h2 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h2><p>似然函数：什么样的参数跟我们的数据组合后恰好是真实值</p><p><img src="/./img/image-20230227110407600.png" alt="image-20230227110407600"></p><p>对数似然</p><p><img src="/./img/image-20230227110425104.png" alt="image-20230227110425104"></p><p>似然函数求最大值（难求），引入</p><p><img src="/./img/image-20230227110521299.png" alt="image-20230227110521299"></p><p>转换为梯度下降任务。m为样本个数，似然函数要考虑每一个样本的概率。</p><p>求导</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
      <tag>课程笔记</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试复习</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="软件测试复习"><a href="#软件测试复习" class="headerlink" title="软件测试复习"></a>软件测试复习</h1><ul><li><a href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0">软件测试复习</a><ul><li><a href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95">黑盒测试</a><ul><li><a href="#%E7%AD%89%E4%BB%B7%E7%B1%BB">等价类</a></li><li><a href="#%E8%BE%B9%E7%95%8C%E5%80%BC">边界值</a></li><li><a href="#%E5%86%B3%E7%AD%96%E8%A1%A8">决策表</a></li><li><a href="#%E5%9B%A0%E6%9E%9C%E5%9B%BE">因果图</a></li><li><a href="#%E6%AD%A3%E4%BA%A4%E8%A1%A8">正交表</a></li></ul></li><li><a href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95">白盒测试</a><ul><li><a href="#%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96">逻辑覆盖</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95">基本路径测试</a></li></ul></li><li><a href="#%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86">测试管理</a><ul><li><a href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a></li><li><a href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95">集成测试</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95">系统测试</a></li><li><a href="#%E7%BC%BA%E9%99%B7%E5%B1%9E%E6%80%A7">缺陷属性</a></li></ul></li><li><a href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95">自动化测试</a></li><li><a href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95">性能测试</a></li><li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li></ul></li></ul><p><strong>什么是软件测试？</strong></p><p>软件测试是使用<strong>人工</strong>和<strong>自动</strong>手段来<strong>运行或测试</strong>某个系统的过程，目的在于检验其<strong>是否满足规定的需要</strong>或是弄清楚<strong>预期结果</strong>与实际结果之间的差别。</p><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><p>又称功能测试或数据驱动测试或基于规格说明书的测试。</p><p>方法：</p><ul><li>等价类</li><li>边界值</li><li>因果图</li><li>决策表</li><li>正交试验法</li></ul><h3 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a>等价类</h3><p>等价类是输入域的某个<strong>子集合</strong>，而所有的等价类的<strong>并集是整个输入域</strong>。在子集合中，各个输入数据对于揭露程序中的错误是<strong>等效</strong>的。</p><p>特点：</p><ul><li>完备性</li><li>无冗余</li><li>等价性</li></ul><p><strong>等价类划分</strong></p><ul><li>有效等价类（检验正常功能）</li><li>无效等价类（检验异常功能）</li></ul><p>从对等价类的<strong>覆盖程度</strong>，可以将等价类测试分为</p><ul><li>弱组合形式</li><li>强组合形式</li></ul><p>针对是否对<strong>无效数据</strong>进行测试，可以将等价类测试分为</p><ul><li><strong>一般</strong>等价类测试</li><li><strong>健壮</strong>等价类测试</li></ul><p>弱：单缺陷假设<br>强：多缺陷假设 </p><p>一般：<strong>只考虑有效值</strong><br>健壮：<strong>考虑无效值</strong></p><p><strong>等价类设计测试用例的一般步骤</strong></p><ol><li><strong>划分等价类</strong>，形成<strong>等价类表</strong>，为每一个等价类规定一个唯一的编号。 </li><li>设计一个新的测试用例，使它能够尽量覆盖尚未覆盖的<strong>有效等价类</strong>。重复这个步骤，直到所有的<strong>有效等价类</strong>均被测试用例所覆盖。 </li><li>设计一个新的测试用例，使它仅覆盖一个尚未覆盖的<strong>无效等价类</strong>。重复这一步骤，直到所有的<strong>无效等价类</strong>均被测试用例所覆盖</li></ol><p><strong>传统的等价类划分测试步骤</strong> </p><ol><li>划分等价类</li><li>设计相应的测试用例。</li></ol><p><strong>测试用例的概念及构成</strong></p><p>为某个业务目标，而编制的一组由<strong>测试输入</strong>，<strong>执行条件</strong>（<strong>测试环境</strong>）以及<strong>预期输出</strong>组成的案例。</p><p>用例编号、测试模块、用例标题、用例级别、前置条件、测试输入、执行操作、预期结果、实际结果</p><h3 id="边界值"><a href="#边界值" class="headerlink" title="边界值"></a>边界值</h3><p>针对各种边界情况设计测试用例</p><p>对于一个n变量的程序，边界值<strong>健壮性</strong>测试会产生<code>6n+1</code>个测试用例。</p><h3 id="决策表"><a href="#决策表" class="headerlink" title="决策表"></a>决策表</h3><p>决策表(Decision Table)，又叫<strong>判定表</strong>，是分析和表达<strong>多逻辑条件</strong>下执行<strong>不同操作</strong>的工具。</p><p><strong>决策表法主要为了发现以下两种类型的缺陷</strong></p><ol><li>某种条件组合的情况下，系统采取错误操作，即执行了不应该执行的操作</li><li>某种条件组合的情况下，系统没有执行正确的操作，即没有执行应该执行的操作</li></ol><p>决策表的构成</p><p><img src="/./img/image-20230218184533582.png" alt="image-20230218184533582"></p><blockquote><p>条件桩：列出了问题的所有条件。<br>条件项：针对条件桩给出的条件列出所有可能的取值。<br>动作桩：给出了问题规定的可能采取的操作。<br>动作项：和条件项紧密相关，指出在条件项的各组取值情况下应采取的动作。</p></blockquote><p><strong>决策表的化简</strong></p><p>有两条或多条规则具有相同的动作，并且其条件项之间存在着极为相似的关系，就可以将规则合并。</p><p><strong>维修机器问题的决策表测试</strong></p><p>维修机器问题描述：“……对于功率大于50马力并且维修记录不全的机器，或已运行10年以上的机器，应给予优先的维修处理……</p><ol><li>列出所有的条件桩和动作桩<ul><li>条件桩<ul><li>C1：功率大于50马力吗？</li><li>C2：维修记录不全吗？</li><li>C3：运行超过10年吗？</li></ul></li><li>动作桩<ul><li>A1：进行优先处理</li><li>A2：作其他处理</li></ul></li></ul></li><li>确定规则个数<ul><li>输入条件个数：3；</li><li>每个条件的取值：“是”或“否”；</li><li>规则个数：2*2*2 &#x3D;8；</li></ul></li><li>填入条件项，动作项，得到初始决策表</li></ol><p><img src="/./img/image-20230218203554144.png" alt="image-20230218203554144"></p><ol start="4"><li>化简（合并规则）</li></ol><p><img src="/./img/image-20230218203636146.png" alt="image-20230218203636146"></p><h3 id="因果图"><a href="#因果图" class="headerlink" title="因果图"></a>因果图</h3><p>因果图（Cuase-effect Graph）是一种描述<strong>输入条件</strong>的组合以及每种组合<strong>对应的输出</strong>的图形化工具。在因果图的基础上可以设计测试用例。</p><p>原因与结果之间的关系<br><strong>恒等、非、或、与</strong> </p><p>原因与原因之间的约束关系<br><strong>异、或、唯一、要求</strong> </p><p>结果与结果之间的关系<br><strong>M约束</strong></p><p><strong>四种符号</strong></p><p><img src="/./img/image-20230218203750101.png" alt="image-20230218203750101"></p><p><img src="/./img/image-20230218203802099.png" alt="image-20230218203802099"></p><p><strong>四种输入条件约束和一种输入约束</strong></p><p><img src="/./img/image-20230218203824663.png" alt="image-20230218203824663"></p><p><img src="/./img/image-20230218203935834.png" alt="image-20230218203935834"></p><p><strong>符号＋约束</strong></p><p><img src="/./img/image-20230218190553280.png" alt="image-20230218190553280"></p><h3 id="正交表"><a href="#正交表" class="headerlink" title="正交表"></a>正交表</h3><p>正交表是一个二维数字表格。其形式： $L_{行数}(水平数^{因子数})$</p><p>L表示正交表</p><blockquote><p>行数(Runs)：正交表中的行的个数，即试验的次数。<br>因子数(Factors)：正交表中列的个数。<br>水平数(Levels)：任何单个因素能够取得的值的最大个数。正交表中的包 含的值为从0到数“水平数-1”或从1到“水平数”</p></blockquote><p><img src="/./img/image-20230218190946054.png" alt="image-20230218190946054"></p><p><strong>特点</strong>：<strong>均匀分散，整齐可比</strong></p><p>用最少的实验覆盖最多的功能，测试用例设计很少，效率高，但是很复杂</p><h2 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h2><p>又称结构测试或逻辑驱动测试</p><h3 id="逻辑覆盖"><a href="#逻辑覆盖" class="headerlink" title="逻辑覆盖"></a>逻辑覆盖</h3><ol><li><strong>语句覆盖</strong>（Statement Coverage, SC）：可执行语句 </li><li><strong>判定覆盖</strong>（Decision Coverage, DC）：每个<strong>判定节点</strong>的取真和取假分支至少执行一次</li><li><strong>条件覆盖</strong>（Condition Coverage, CC）：每一判定语句中每个<strong>逻辑条件</strong>的可能取值至少满足一次</li><li><strong>条件判定覆盖</strong>（Condition&#x2F;Decision Coverage, C&#x2F;DC）：判定中的每个<strong>条件</strong>的所有可能（真&#x2F;假）至少出现一次，并且每个判定本身的判定<strong>结果</strong>也至少出现一次</li><li><strong>修正条件判定覆盖</strong>（Modified Condition &#x2F; Decision Coverage, MD&#x2F;CC）</li><li><strong>条件组合覆盖</strong>（Condition Combination Coverage，CCC）每个判定中条件无脑排列组合。</li><li><strong>路径覆盖</strong>：设计足够的测试用例，使得每条可能的<strong>路径</strong>都至少执行一次。</li></ol><p>几种逻辑覆盖标准发现错误的能力呈<strong>由弱至强</strong>的变化</p><p>&#x3D;&#x3D;达到100%判定条件覆盖标准一定能够达到100%条件覆盖、 100%判定覆盖 和100%语句覆盖&#x3D;&#x3D;</p><p>实现了某软件的路径覆盖，那么它一定同时实现了<strong>判定覆盖</strong></p><h3 id="基本路径测试"><a href="#基本路径测试" class="headerlink" title="基本路径测试"></a>基本路径测试</h3><p>在<strong>程序控制流图</strong>的基础上，通过分析控制结构的<strong>环路复杂性</strong>，导出<strong>基本可执行路径集合</strong>，从而设计出相应的<strong>测试用例</strong>的方法。</p><p>给定一个控制流图G，设其<strong>环形复杂度</strong>为V(G)</p><ul><li>V(G)＝E－N＋2，其中E是控制流图G中边的数量，N是控制流图中结点的数目。</li><li>V(G)＝P＋1，其中P是控制流图G中判断结点的数目</li><li>V(G)＝A，其中A是控制流图G中区域的数目。</li></ul><p>由边和结点围成的区域叫做区域， 当在控制流图中计算区域的数目时，控制 流图外的区域也应记为一个区域</p><p><strong>独立路径定义</strong>： 从控制流图来看，一条独立路径是至少包含有一条在其他独立路径中<strong>从未有过</strong>的边的路径。路径可以用控制流图中的结点序列来表示。</p><p><strong>程序的环形复杂度 &#x3D; 程序中独立路径的数量</strong></p><p><img src="/./img/image-20230218200501284.png" alt="image-20230218200501284"></p><p>步骤：</p><ol><li>画出程序的流程控制图</li><li>计算程序的圈复杂度</li><li>导出独立路径</li><li>准备测试用例</li></ol><p> <strong>做好测试用例设计工作的关键是什么？</strong></p><p>黑盒法用例设计的关键是以<strong>较少的用例覆盖模块输出和输入接口</strong>。不可能做到完全测试，<strong>以最少的用例在合理的时间内发现最多的问题</strong>。</p><p>白盒测试用例设计的关键同样也是<strong>以较少的用例覆盖尽可能多的内部程序逻辑结果</strong>。</p><h2 id="测试管理"><a href="#测试管理" class="headerlink" title="测试管理"></a>测试管理</h2><p><img src="/./img/image-20230218201059007.png" alt="image-20230218201059007"></p><p><strong>测试过程四个阶段划分</strong></p><ol><li>单元测试</li><li>集成测试</li><li>系统测试</li><li>验收测试</li></ol><p><strong>软件开发-软件测试的对用关系</strong></p><p><img src="/./img/wps1.png" alt="img"></p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>最小粒度的测试，以测试某个功能或代码块。</p><p><strong>JUnit 生命周期</strong></p><p><img src="/./img/image-20230218205444538.png" alt="image-20230218205444538"></p><p>桩模块和驱动模块</p><ul><li><strong>驱动程序（Driver），也称驱动模块</strong><br>用于模拟被测模块的上级模块，能够<strong>调用被测模块</strong>，驱模块接受测试数据，调用被测模块并把相关数据传送给被测模块。</li><li><strong>桩程序（Stub），也称桩模块</strong><br>用于模拟<strong>被测模块工作过程中所调用</strong>的下层模块，一般很少进行数据处理，一般只检测被测模块传输数据的正确性。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a,b</span>)<span class="hljs-comment"># 被测模块</span>c = a+bstub(c)<span class="hljs-keyword">def</span> <span class="hljs-title function_">stub</span>(<span class="hljs-params">c</span>)<span class="hljs-comment"># 桩程序</span><span class="hljs-built_in">print</span>(c)<span class="hljs-keyword">if</span> __name == <span class="hljs-string">&quot;__main__&quot;</span>:test(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-comment"># 驱动程序</span></code></pre></div><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>集成测试是在<strong>单元测试</strong>的基础上，将所有已通过单元测试的模块按照概要设计的要求<strong>组装</strong>为子系统或系统，进行集成测试，目的是确保各单元模块<strong>组合</strong>在一 起后能够按既定意图<strong>协作运行</strong>，并确保<strong>增量</strong>的行为正确。</p><h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><p>系统测试的定义 ： 系统测试是将整个软件，作为整个基于计算机系统的一个<strong>元素</strong>，与计算机硬件、外设、某些支持软件、数据和人员等其它系统元素<strong>结合</strong>在一起，在实际运行环境下，验证软件的功能和性能及其它特性是否与用户的要求一致。</p><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p>集成测试仅针对<strong>软件系统</strong>展开测试，系统测试中所涉及的系统则不仅包括被测试的软件本身，还包括<strong>硬件及相关外围设备</strong>。</p><h3 id="缺陷属性"><a href="#缺陷属性" class="headerlink" title="缺陷属性"></a>缺陷属性</h3><p>最大原因：编制说明书</p><p><strong>严重程度</strong></p><ul><li>微小的(Minor)</li><li>一般的(Major)</li><li>严重的(Critical)</li><li>致命的(Fatal)</li></ul><p><strong>优先级</strong></p><ul><li>低 Not Urgent</li><li>中 Normal Queue</li><li>高 Resolve Immediately</li></ul><p><strong>缺陷产生的原因</strong></p><ul><li>编写说明书存在问题</li><li>设计存在问题</li><li>代码存在问题</li></ul><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>Selenium WebDriver 中的元素定位方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 方法通过 id 属性定位来元素</span>findElement(By.id(<span class="hljs-string">&quot;kw&quot;</span>)).sendKeys(<span class="hljs-string">&quot;XXX&quot;</span>)<span class="hljs-comment">// 通过 name 属性来定位元素</span>findElement(By.name(<span class="hljs-string">&quot;kw&quot;</span>)).click()<span class="hljs-comment">// 通过 class 属性来定位元素</span>findElement(By.className())<span class="hljs-comment">// 通过元素的 tag name 来定位元素</span>findElement(By.tagName())<span class="hljs-comment">// 通过文本信息来定位元素</span>findElement(By.linkText())<span class="hljs-comment">// 通过部分文本信息定位元素</span>findElement(By.partialLinkText())<span class="hljs-comment">// 使用 XPath 语言来定位元素</span>findElement(By.xpath())<span class="hljs-comment">// 用于 CSS 选择器定位元素</span>findElement(By.cssSelector())</code></pre></div><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>指标：</p><ul><li>响应时间</li><li>系统处理能力</li><li>吞吐量</li><li>并发用户数</li><li>错误率</li></ul><p><strong>压力测试和负载测试有何区别？</strong></p><p>压力测试：是指持续不断的给被测系统增加压力，直到被测系统被<strong>压垮</strong>，从而确定系统能够承受的<strong>最大压力</strong>；</p><p>负载测试：通常是指让被测系统在其能够忍受的压力极限范围内（或<strong>临界状态</strong>下）连续<strong>运行</strong>，来测试系统的<strong>稳定性</strong>。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol><li><p>NextDate 函数是一个有 3 个输入变量 month（月份），day（日期）和 year（年）的函数， 其中 month、day 和 year 均为整数值，并且满足条件 1≤month≤12、1≤day≤31、1900≤ year≤2050，month、day、year 分别作为输入日期的月份、日、年份，通过程序可以输出该 输入日期在日历上下一天的日期。例如，输入为 2005 年 11 月 29 日，则该程序的输出为 2005 年 11 月 30 日。请用<strong>健壮性测试法</strong>设计测试用例。</p><table><thead><tr><th>输入条件</th><th>有效等价类</th><th>编号</th><th>无效等价类</th><th>编号</th></tr></thead><tbody><tr><td>month</td><td>6</td><td>1</td><td>非整数字符</td><td>4</td></tr><tr><td>month</td><td></td><td>-</td><td>0</td><td>5</td></tr><tr><td>month</td><td></td><td>-</td><td>13</td><td>6</td></tr><tr><td>day</td><td>15</td><td>2</td><td>非整数字符-</td><td>7</td></tr><tr><td>day</td><td></td><td>-</td><td>0</td><td>8</td></tr><tr><td>day</td><td></td><td>-</td><td>32</td><td>9</td></tr><tr><td>year</td><td>2023</td><td>3</td><td>非整数字符</td><td>10</td></tr><tr><td>year</td><td></td><td>-</td><td>1880</td><td>11</td></tr><tr><td>year</td><td></td><td>-</td><td>2070</td><td>12</td></tr></tbody></table><table><thead><tr><th>测试用例</th><th>month</th><th>day</th><th>year</th><th>预期输出</th></tr></thead><tbody><tr><td>1</td><td>6</td><td>15</td><td>2023</td><td>2023年6月16日</td></tr><tr><td>2</td><td>1.2</td><td>16</td><td>2024</td><td>错误</td></tr><tr><td>3</td><td>0</td><td>17</td><td>2025</td><td>错误</td></tr><tr><td>4</td><td>13</td><td>18</td><td>2026</td><td>错误</td></tr><tr><td>5</td><td>7</td><td>测试</td><td>2027</td><td>错误</td></tr><tr><td>6</td><td>8</td><td>0</td><td>2028</td><td>错误</td></tr><tr><td>7</td><td>9</td><td>32</td><td>2029</td><td>错误</td></tr><tr><td>8</td><td>10</td><td>19</td><td>？？？</td><td>错误</td></tr><tr><td>9</td><td>11</td><td>20</td><td>1880</td><td>错误</td></tr><tr><td>10</td><td>12</td><td>21</td><td>2070</td><td>错误</td></tr><tr><td>11</td><td>2</td><td>29</td><td>2023</td><td>错误</td></tr><tr><td>12</td><td>4</td><td>31</td><td>2023</td><td>错误</td></tr><tr><td>13</td><td>2</td><td>30</td><td>2024</td><td>错误</td></tr></tbody></table></li><li><p>假设有一个待测试的小程序，其 Java 源代码如下。使用白盒测试方法，画出流程图，并设计测试用例，分别实现：语句覆盖，判定覆盖，条件覆盖，判定&#x2F;条件覆盖。 代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> x)</span> &#123;    <span class="hljs-keyword">if</span>(a&gt;<span class="hljs-number">1</span> &amp;&amp; b==<span class="hljs-number">0</span>) &#123;        x = x/a;    &#125;    <span class="hljs-keyword">if</span> (a==<span class="hljs-number">2</span> || x&gt;<span class="hljs-number">1</span>) &#123;        x = x+<span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div><p><img src="/./img/image2.jpg" alt="image2"></p><p>语句覆盖：</p><table><thead><tr><th>a</th><th>b</th><th>x</th></tr></thead><tbody><tr><td>2</td><td>0</td><td>2</td></tr></tbody></table><p>判定覆盖：</p><table><thead><tr><th>a</th><th>b</th><th>x</th></tr></thead><tbody><tr><td>2</td><td>0</td><td>2</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>条件覆盖：</p><table><thead><tr><th>a</th><th>b</th><th>x</th></tr></thead><tbody><tr><td>2</td><td>0</td><td>2</td></tr><tr><td>0</td><td>1</td><td>2</td></tr></tbody></table><p>判定&#x2F;条件覆盖：</p><table><thead><tr><th>a</th><th>b</th><th>x</th></tr></thead><tbody><tr><td>2</td><td>0</td><td>2</td></tr><tr><td>0</td><td>1</td><td>2</td></tr><tr><td>1</td><td>0</td><td>1</td></tr></tbody></table></li><li><p>按照要求完成以下问题。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">getit</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span>&#123;    <span class="hljs-type">int</span> i, k;    k = <span class="hljs-built_in">sqrt</span>(m);    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt;= k; i++)        <span class="hljs-keyword">if</span> (m % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">if</span>(i &gt;= k + <span class="hljs-number">1</span>)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d is a selected number\n&quot;</span>, m);    <span class="hljs-keyword">else</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d is not a selected number\n&quot;</span>, m);&#125;</code></pre></div><p>问题 1、画出程序流程图</p><p><img src="/./img/image3-1676876027959-4.jpg" alt="image3"></p><p>问题 2、计算环形复杂度 </p><p>V(G) &#x3D; P+1 &#x3D; 3+1 &#x3D; 4</p><p>问题 3、导出独立路径（用语句编号）</p><p>路径（1）4 6 7 10</p><p>路径（2）4 6 9 10</p><p>路径（3）4 5 6 7 10</p><p>路径（4）4 5 4 6 7 10</p><p>问题 4、准备测试用例</p><ul><li><p>路径（1）</p><p>输出数据：m &#x3D; 1</p><p>预期数据：1 is a selected number</p></li><li><p>路径（2）</p><p>输入数据：m &#x3D; 4</p><p>预期数据：4 is not a selected number</p></li><li><p>路径（3）</p><p>输入数据：m &#x3D; 2.24</p><p>预期数据：4 is not a selected number</p></li><li><p>路径（4）</p></li><li><p>输入数据：m &#x3D; 9</p><p>预期数据：9 is not a selected number</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux复习</title>
    <link href="/Linux%E5%A4%8D%E4%B9%A0/"/>
    <url>/Linux%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux复习"><a href="#Linux复习" class="headerlink" title="Linux复习"></a>Linux复习</h1><ul><li><a href="#linux%E5%A4%8D%E4%B9%A0">Linux复习</a><ul><li><a href="#%E8%AE%A4%E8%AF%86-linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">认识 Linux 操作系统</a><ul><li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84linux%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC">常见的Linux系统版本</a></li><li><a href="#linux%E5%86%85%E6%A0%B8%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E5%8F%8A%E6%AF%8F%E4%B8%AA%E9%83%A8%E5%88%86%E7%9A%84%E4%BD%9C%E7%94%A8">Linux内核的组成部分及每个部分的作用</a></li><li><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA">虚拟机</a></li></ul></li><li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">文件管理</a><ul><li><a href="#%E5%A4%84%E7%90%86%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">处理目录的常用命令</a></li><li><a href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">文件属性</a></li></ul></li><li><a href="#%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B">文件内容查看</a><ul><li><a href="#%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%E7%BC%A9">文件解压缩</a></li><li><a href="#%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%E5%BF%85%E8%80%83">软链接和硬链接的区别(必考)</a></li></ul></li><li><a href="#%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86">软件包管理</a><ul><li><a href="#rpm%E5%AE%89%E8%A3%85">rpm安装</a></li><li><a href="#%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85">源码安装</a></li><li><a href="#yum%E5%AE%89%E8%A3%85">yum安装</a></li></ul></li><li><a href="#%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86">系统管理</a><ul><li><a href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86">用户管理</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86">服务管理</a></li></ul></li><li><a href="#vim">vim</a></li><li><a href="#shell%E7%BC%96%E7%A8%8B">Shell编程</a><ul><li><a href="#shell%E7%B1%BB%E5%9E%8B">shell类型</a></li><li><a href="#shell-%E5%8F%98%E9%87%8F">Shell 变量</a></li></ul></li><li><a href="#%E7%AE%A1%E7%90%86%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E4%B8%8E%E5%88%86%E5%8C%BA">管理磁盘存储与分区</a><ul><li><a href="#%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%9A%84%E5%91%BD%E5%90%8D">设备文件的命名</a></li><li><a href="#fdisk%E5%91%BD%E4%BB%A4">fdisk命令</a></li><li><a href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件系统</a></li></ul></li><li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li></ul></li></ul><h2 id="认识-Linux-操作系统"><a href="#认识-Linux-操作系统" class="headerlink" title="认识 Linux 操作系统"></a>认识 Linux 操作系统</h2><p>Linux操作系统作为一款<strong>免费、自由、开放</strong>的<strong>类UNIX</strong>操作系统, <strong>支持多任务、多用户</strong>。</p><p>Linux有<strong>内核</strong>版本和<strong>发布</strong>版本之分。</p><p>Linux 的版本号分为两部分，即内核版本与发行版本。内核版本号由3个数字组成：A.B.C。各数字含义如下：</p><blockquote><p>A：内核主版本号。这是很少发生变化，<br>只有当发生重大变化的代码和内核发生才会发生。<br>B：内核次版本号。是指一些重大修改的内核。<strong>偶数表示稳定版本；奇数表示开发中版本。</strong><br>C：内核修订版本号。是指轻微修订的内核。这个数字当有安全补丁，bug修复，新的功能或驱动程序，内核便会有变化。</p></blockquote><h3 id="常见的Linux系统版本"><a href="#常见的Linux系统版本" class="headerlink" title="常见的Linux系统版本"></a>常见的Linux系统版本</h3><p>CentOS，Ubuntu，FreeBSD，Debian</p><h3 id="Linux内核的组成部分及每个部分的作用"><a href="#Linux内核的组成部分及每个部分的作用" class="headerlink" title="Linux内核的组成部分及每个部分的作用"></a>Linux内核的组成部分及每个部分的作用</h3><ul><li>进程调度：控制进程对CPU的访问。</li><li>内存管理：允许多个进程安全的共享主内存区域；</li><li>虚拟文件系统：隐藏了各种硬件的具体细节，为所有的设备提供了统一的接口</li><li>网络接口：提供了对各种网络标准的存取和各种网络硬件的支持；</li><li>进程间通信： 支持进程间各种通信机制。</li></ul><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p><strong>虚拟机</strong>指通过<strong>软件模拟</strong>的具有完整<strong>硬件</strong>系统功能的、<strong>运行在</strong>一个完全<strong>隔离环境</strong>中的完整计算机<strong>系统</strong>。</p><p>特点：</p><ul><li>可同时在同一台PC上运行<strong>多个</strong>操作系统。</li><li>虚拟机之间<strong>共享</strong>文件、应用、网络资源等。 </li><li>同一服务器上的虚拟机若有一台故障或者中病毒, <strong>不会影响</strong>到其他虚批机的使用。</li><li>虚拟机的本质是以<strong>文件</strong>的形式存在于虚拟化系统中，可以通过移动文件或者复制粘贴的形式对虚拟机进行迁移。</li></ul><p><strong>快照</strong>是虚拟机磁盘文件（VMDK）在某个时间点的复本。</p><p><strong>快照作用</strong>： 快照可以保存虚拟机的状态， 当虚拟机出现问题的时候， 可以通过预先制作的快照恢复到制作时候的状态， 用作备份用。</p><p>虚拟机上网的三种主要方式是<strong>桥接</strong>、<strong>NAT</strong>和<strong>Host-Only</strong>(仅主机模式)。</p><p>对应的网卡分别是：VMnet0、VMnet8、VMnet1</p><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>参考<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NTAzMTExNg==&mid=2247483885&idx=1&sn=cf98ffb9698999abf950c55da75c60ec&scene=19%23wechat_redirect">狂神说Linux02：常用的基本命令</a></p><h3 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h3><ul><li>ls: 列出目录 <ul><li>-a 全部文件包括隐藏</li><li>-l 长数据串列出，包含文件的属性与权限</li></ul></li><li>cd：切换目录</li><li>pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp: 复制文件或目录</li><li>rm: 移除文件或目录</li><li>mv: 移动文件与目录，或修改文件与目录的名称</li></ul><div class="code-wrapper"><pre><code class="hljs shell">cp [-adfilprsu] 来源档(source) 目标档(destination)</code></pre></div><div class="code-wrapper"><pre><code class="hljs shell">rm [-fir] 文件或目录</code></pre></div><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除</li></ul><div class="code-wrapper"><pre><code class="hljs shell">mv [-fiu] source destination</code></pre></div><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p><img src="/./img/640.jpeg" alt="图片"></p><ul><li><p>chgrp：更改文件<strong>属组</strong>，R表示递归修改</p><div class="code-wrapper"><pre><code class="hljs shell">chgrp [-R] 属组名 文件名</code></pre></div></li><li><p>chown：更改文件<strong>属主</strong>，也可以同时更改文件<strong>属组</strong></p><div class="code-wrapper"><pre><code class="hljs shell">chown [–R] 属主名 文件名chown [-R] 属主名：属组名 文件名</code></pre></div></li><li><p>chmod：更改文件9个属性(权限)</p><div class="code-wrapper"><pre><code class="hljs shell">chmod [-R] xyz 文件或目录</code></pre></div><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><blockquote><ol><li><p>更改文件所有者的权限 chmod u&#x3D; filename</p></li><li><p>更改文件所属组的权限  chmod g&#x3D; filename</p></li><li><p>更改文件Other的权限 chmod o&#x3D; filename</p></li><li><p>同时更改三个组的权限 chmod a&#x3D; filename</p></li></ol></blockquote><p>Linux文件的基本权限就有九个，分别是owner&#x2F;group&#x2F;others三种身份各有自己的read&#x2F;write&#x2F;execute权限。</p><p>先复习一下刚刚上面提到的数据：文件的权限字符为：<code>-rwxrwxrwx</code>， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">r</span>:<span class="hljs-number">4</span>w:<span class="hljs-number">2</span>x:<span class="hljs-number">1</span></code></pre></div><p>每种身份(owner&#x2F;group&#x2F;others)各自的三个权限(r&#x2F;w&#x2F;x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：</p><ul><li>owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li><li>group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li><li>others&#x3D; — &#x3D; 0+0+0 &#x3D; 0</li></ul><div class="code-wrapper"><pre><code class="hljs shell">chmod 770 filename</code></pre></div></li></ul><p><img src="/./img/image-20230219151941359.png" alt="image-20230219151941359"></p><h2 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h2><ul><li><p>cat 由第一行开始显示文件内容</p><p>合并文件：<code>cat file1 file2 &gt; file3</code></p></li><li><p>tac 从最后一行开始显示，tac 是 cat 的倒写！</p></li><li><p>nl  显示的时候，顺道输出行号！</p></li><li><p>more 一页一页的显示文件内容</p></li><li><p>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</p></li><li><p>head 只看头几行</p></li><li><p>tail 只看尾巴几行</p></li></ul><p>查找文件或目录：<code>find</code> 和 <code>loacta</code></p><p>查看当前主机IP地址的命令是  <code>ipaddr</code></p><p><code>who</code>  命令的作用是查看当前在线用户</p><p><code>umask</code>查看系统默认文件和目录权限</p><p>请用命令完成新建目录 newdir，在该目录下新建文件 newfile 并将该文件复制到 &#x2F;tmp 目录下。</p><div class="code-wrapper"><pre><code class="hljs shell">mkdir newdircd newdirtouch newfilecp newfile /tmp</code></pre></div><h3 id="文件解压缩"><a href="#文件解压缩" class="headerlink" title="文件解压缩"></a>文件解压缩</h3><ol><li><p>tar</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">压缩文件 file1 和目录 dir2 到 test.tar.gz</span>tar -zcvf test.tar.gz file1 dir2<span class="hljs-meta prompt_"># </span><span class="language-bash">解压 test.tar.gz（将 c 换成 x 即可）</span>tar -zxvf test.tar.gz<span class="hljs-meta prompt_"># </span><span class="language-bash">列出压缩文件的内容</span>tar -ztvf test.tar.gz</code></pre></div><p>-z : 使用 gzip 来压缩和解压文件</p><p>-v : –verbose 详细的列出处理的文件</p><p>-f : –file&#x3D;ARCHIVE 使用档案文件或设备，这个选项通常是必选的</p><p>-c : –create 创建一个新的归档（压缩包）</p><p>-x : 从压缩包中解出文件</p></li><li><p>rar</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">压缩文件</span>rar a -r test.rar file<span class="hljs-meta prompt_"># </span><span class="language-bash">解压文件</span>unrar x test.rar</code></pre></div><p>a : 添加到压缩文件</p><p>-r : 递归处理</p><p>x : 以绝对路径解压文件</p></li><li><p>zip</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">压缩文件</span>zip -r test.zip file<span class="hljs-meta prompt_"># </span><span class="language-bash">解压文件</span>unzip test.zip</code></pre></div><p>-r : 递归处理</p></li></ol><h3 id="软链接和硬链接的区别-必考"><a href="#软链接和硬链接的区别-必考" class="headerlink" title="软链接和硬链接的区别(必考)"></a>软链接和硬链接的区别(必考)</h3><div class="code-wrapper"><pre><code class="hljs shell">ln -s [源文件] [软链接文件]ln -s /path/to/target link_name</code></pre></div><p>区别：</p><ul><li>删除源文件，软链接会失效，硬链接不会；</li><li>软链接可以为<strong>文件和目录</strong>（允许不存在）创建链接，硬链接只可以为<strong>文件</strong>创建链接；</li><li>软链接可以<strong>跨文件系统</strong>，硬链接必须是同一个文件系统；</li><li>软链接的<strong>文件权限</strong>可以和源文件不一样，硬链接的文件权限一定和源文件一样；</li></ul><h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><p><strong>Linux中软件的三种安装方式</strong></p><ul><li>源码编译安装（根据当前系统编译）</li><li>rpm安装（需要自己安装相应的依赖）</li><li>yum安装（自动安装依赖）</li></ul><h3 id="rpm安装"><a href="#rpm安装" class="headerlink" title="rpm安装"></a>rpm安装</h3><p>RPM 软件包的文件名中一般包括<strong>软件名 、版本号 、硬件平台和包后缀</strong>。</p><p>功能：</p><ul><li>安装，解压软件并安装</li><li>查询，查询已经安装的软件包</li><li>卸载</li><li>升级</li><li>验证，验证系统中软件与包的区别</li></ul><p>查询 RPM 软件包的命令<code>rpm -q</code></p><p>为卸载一个软件包<code>rpm -e</code></p><ul><li>-i：安装（install）;</li><li>-v：显示更详细的信息（verbose）;</li><li>-h：打印 #，显示安装进度（hash）;</li></ul><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><p>获取软件的源代码包之后，必须要先进行编译形成<strong>二进制文件</strong> ，然后才能在 Linux 上运行</p><p>Linux 系统维护中软件安装最大的问题就是就是软件包之间的 <strong>依赖性</strong> </p><p><strong>优点：</strong></p><ul><li>（1）开源，可以根据需求进行个性化定制</li><li>（2）可以自由安装</li><li>（3）稳定</li><li>（4）卸载方便</li></ul><p><strong>缺点：</strong></p><ul><li>安装步骤多</li><li>编译时间长</li><li>易报错</li><li>对技术要求高</li></ul><h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><p><strong>特点：</strong></p><ul><li>（1）自动解决依赖问题</li><li>（2）安装简单</li><li>（3）有详细日志</li><li>（4）可以方便地管理 rpm</li></ul><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>广义上来讲，Linux的账户包括  <strong>主账户</strong>  和  <strong>用户账户</strong> 两种。</p><p>Linux系统中的每个用户都在<code>/etc/passwd</code>文件记录了这个用户的一些基本属性。这个文件对所有用户都是可读的。</p><div class="code-wrapper"><pre><code class="hljs text">root:x:0:0:Superuser:/:daemon:x:1:1:System daemons:/etc:用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</code></pre></div><p><code>/etc/shadow</code>文件记录真正的加密后的用户口令。 有超级用户才拥有该文件读权限</p><div class="code-wrapper"><pre><code class="hljs shell">root:Dnakfw28zf38w:8764:0:168:7:::daemon:*::0:0::::登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</code></pre></div><p>当使用<code>useradd</code>命令新建了一个用户之后，将在<code>/etc/passwd</code>文件中写入一行新建用户信息，在<code>/etc/shadow</code>文件中写入一行用户密码信息。</p><p>通常用户标识号的取值范围是<code>0～65535</code>。0是超级用户root的标识号，1-99由系统保留作为管理账号，普通用户的标识号从<strong>100</strong>开始。在Linux系统中，这个界限是500。</p><p>记录<strong>用户组信息</strong>的文件有两个，分别是 <code>/etc/gshadow</code> 和 <code>/etc/group</code></p><p><code>/etc/group</code>:</p><div class="code-wrapper"><pre><code class="hljs shell">bin::2:root,bin组名:口令:组标识号:组内用户列表</code></pre></div><p>使用<code>passwd</code>命令可以设置用户密码，使用 passwd 命令修改用户自己的密码时必须符合复杂性要求。</p><blockquote><p>普通用户会要求输入原密码，密码长度不少于8个字符，root 用户可以无视则不需要输入原密码，密码长度及时不合规范也可以正常更新密码</p></blockquote><p>如何创建一个普通用户的时候，同时指定其主组group和附加组bin, root，并且自定义uid</p><div class="code-wrapper"><pre><code class="hljs shell">useradd -g group -G bin,root -u 100 zhangsan</code></pre></div><p>如果你是管理员，现在增加一个用户叫张三，密码是123456，把一个叫李四的用户给锁定，删除王五</p><div class="code-wrapper"><pre><code class="hljs shell">useradd zhangsanpasswd zhangsan123456123456passwd -l lisiuserdel wangwu</code></pre></div><h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p>查看服务的运行状态</p><p><code>systemctl status name.service</code></p><p>重启服务</p><p><code>systemctl restart name.service</code></p><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p> vi命令既可以编辑文件，也可以<strong>创建文件</strong></p><p><strong>vim有哪几种模式，之间该怎么切换：</strong></p><ul><li>任何情况下，不论用户处于什么模式，只要按一下<code>esc</code>键，就可以进入vi的<strong>命令模式</strong>。</li><li><strong>底行模式</strong>也叫<strong>末行模式</strong>，在<strong>命令模式</strong>下输入<code>:</code>或者<code>/</code>就会进入<strong>底行模式</strong>。</li><li>在<strong>底行模式</strong>模式下按<code>i</code>或者<code>a</code>键进入<strong>编辑模式</strong>。</li></ul><p><img src="/./img/vim_mode.jpeg" alt="vim模式切换"></p><p>进入<strong>底行模式</strong>，在<code>:</code>后面输入<code>wq</code>并回车，即可保存文件，强行退出<code>:q!</code>，</p><p>进入<strong>底行模式</strong>，输入内容<code>:set nu</code>，即可显示文本的行号</p><p>在<strong>命令模式</strong>下输入<code>nG</code>则可以  定位到第<code>n</code>行  </p><p>命令模式下：</p><ul><li><p>光标移动到行首<code>home</code></p></li><li><p>光标移动到行尾<code>end</code></p></li><li><p>光标移动到首行<code>gg</code></p></li><li><p>光标移动到末行<code>G</code></p></li><li><p>以当前光标为准，向上移动 n 行<code>nk</code></p></li><li><p>以当前光标为准，向下移动 n 行<code>nj</code>和<code>n&lt;Enter&gt;</code></p></li><li><p>以当前光标为准，向左&#x2F;右移动n个字符<code>nh/nl</code></p></li><li><p>复制光标所在行<code>yy</code></p></li><li><p>剪切&#x2F; 删除光标所在行<code>dd</code></p></li><li><p>撤销<code>u</code></p></li><li><p>恢复<code>Ctrl+R</code></p></li></ul><p>末行模式下：</p><ul><li><p>移动到指定的行<code>:n</code></p></li><li><p>搜索：<code>/关键词</code></p></li><li><p>替换</p><ul><li><code>:s/旧文本/新文本</code> 替换光标所在行的<strong>第一处</strong>符合条件的内容</li><li><code>:s/旧文本/新文本/g</code> 替换光标所在行的<strong>全部</strong>符合条件的内容</li><li><code>:%s/旧文本/新文本</code> 替换整个文档中每行<strong>第一个</strong>符合条件的内容</li><li><code>:%s/旧文本/新文本/g</code> 替换<strong>整个文档</strong>的符合条件的内容</li></ul><p><code>%</code>表示整个文件</p><p><code>g</code>表示全局(global)</p></li></ul><p>在末行模式下无法直接进入编辑模式，必须要通过命令模式进入编辑模式：</p><ul><li><code>i</code>在光标所在字符前开始插入</li><li><code>a</code>在光标所在字符后开始插入</li><li><code>o</code>在光标所在行的下面另起一新行插入</li><li><code>I</code>在光标所在行的行首开始插入， 如果行首有空格则在空格之后插入</li><li><code>A</code>在光标所在行的行尾开始插入</li><li><code>O</code>在光标所在行的上面另起一行开始插入</li><li><code>S</code>删除光标所在行并开始插入</li><li>退出方式：<code>[Esc]</code></li></ul><h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><h3 id="shell类型"><a href="#shell类型" class="headerlink" title="shell类型"></a>shell类型</h3><p>shell常用类型有<strong>bash、ash、ksh、csh、zsh</strong>等。默认的shell是每个用户帐号的一个参数。Linux中典型的默认shell是&#x2F;bin&#x2F;bash。</p><h3 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h3><p>局部变量：只能在函数内部使用</p><p>全局变量：可以在当前 Shell 进程中使用</p><p>用<code>export</code>定义</p><p>环境变量：可以在子进程中使用</p><p><strong>特殊变量：</strong></p><table><thead><tr><th align="left">名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>$0</code></td><td align="left">执行脚本的名称</td></tr><tr><td align="left"><code>$1-9</code></td><td align="left">脚本执行时的参数1到参数9</td></tr><tr><td align="left"><code>$?</code></td><td align="left">脚本的返回值，代表上一个命令是否执行成功，如果成功，则为0，否则不成功</td></tr><tr><td align="left"><code>$!</code></td><td align="left">代表最后执行的后台命令的PID</td></tr><tr><td align="left"><code>$#</code></td><td align="left">脚本执行时，输入的参数的个数</td></tr><tr><td align="left"><code>$@</code></td><td align="left">输入的参数的具体内容（将输入的参数作为一个多个对象，即是所有参数的一个列表）</td></tr><tr><td align="left"><code>$*</code></td><td align="left">输入的参数的具体内容（将输入的参数作为一个单词）</td></tr></tbody></table><h2 id="管理磁盘存储与分区"><a href="#管理磁盘存储与分区" class="headerlink" title="管理磁盘存储与分区"></a>管理磁盘存储与分区</h2><ol><li><p>Linux支持<strong>虚拟文件系统</strong>，其实质是Linux内核中的一个软件层，用于给用户空间的程序提供文件系统接口。</p></li><li><p><code> /root</code>目录存放内核和加载内核所需的文件。一般情况下，GRUB 或 LILO 系统引导管理器也位于这个目录。</p></li><li><p><code>fdisk -l</code>查看系统磁盘及分区情况</p><p><code>fdisk -n</code> 添加一个新分区</p></li><li><p><code>df</code>命令作用是列出文件系统的整体磁盘空间使用情况。</p></li><li><p><code>/etc</code>系统存放所有的系统配置文件。</p></li><li><p>一个硬盘最多可以分<strong>4</strong>个主分区。</p></li><li><p>使用<code>dd</code>命令可以实现磁盘对拷</p></li><li><p>执行<code>mkfs</code>命令格式化分区</p></li></ol><h3 id="设备文件的命名"><a href="#设备文件的命名" class="headerlink" title="设备文件的命名"></a>设备文件的命名</h3><p>Linux 系统和 Windows 操作系统不同，没有盘符的概念，磁盘对应分区存放在&#x2F;dev 目录中，命名格式为<code>/dev/xxyN</code>，请简述 xxyN 表示的含义。</p><blockquote><p>xx 表示分区所在<strong>设备的类型</strong>，其中IDE接口的的硬盘对应的是 hd </p><p>y 表示对应<strong>分区所在的设备</strong>，从 a 递增 ，例如第一个 SCSI 硬盘标记为<code>/dev/sda</code>，第二个 IDE 硬盘标记为<code>/dev/hdb</code> </p><p>N 表示分区前四个分区为<strong>主分区或者拓展分区</strong>，对应的是 1-4，<strong>逻辑分区</strong>从 5 开始，例如&#x2F;dev&#x2F;sda2 表示第一个 SCSI 硬盘上的第二个主分区或者扩展分区；&#x2F;dev&#x2F;hdb5 表示第二个 IDE 硬盘上的第一个逻辑分区。</p></blockquote><h3 id="fdisk命令"><a href="#fdisk命令" class="headerlink" title="fdisk命令"></a>fdisk命令</h3><p>使用fdisk 命令新增磁盘分区：</p>   <div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">给/dev/sdb分区</span>fdisk /dev/sdb <span class="hljs-meta prompt_"># </span><span class="language-bash">进入交互界面</span><span class="hljs-meta prompt_"># </span><span class="language-bash">新增一个分区</span>n<span class="hljs-meta prompt_"># </span><span class="language-bash">查看一下磁盘分区</span>p<span class="hljs-meta prompt_"># </span><span class="language-bash">选择分区号（这里注意一下，加上扩展分区，主分区只能有四个，所以只能选择1-4，一般按顺序输入分区号）</span>1<span class="hljs-meta prompt_"># </span><span class="language-bash">保存</span>w<span class="hljs-meta prompt_"># </span><span class="language-bash">将新的分区表变更同步至操作系统。</span>partprobe<span class="hljs-meta prompt_"># </span><span class="language-bash">设置新建分区文件系统格式</span>mkfs -t ext4 /dev/sdb1<span class="hljs-meta prompt_"># </span><span class="language-bash">将新建分区挂载到需要增加空间的目录下，以“/opt”为例</span>mount /dev/sdb1 /opt</code></pre></div><p>其他参数：</p><blockquote><p>n  add a new partition      &lt;&#x3D;&#x3D;新增一个分区</p><p>p  print the partition table   &lt;&#x3D;&#x3D;查看磁盘</p><p>t  change a partition’s system id指定分区类型</p><p>d  delete a partition       &lt;&#x3D;&#x3D;删除</p><p>q  quit without saving changes  &lt;&#x3D;&#x3D;不保存</p><p>w  write table to disk and exit  &lt;&#x3D;&#x3D;保存</p></blockquote><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ul><li>ext2</li><li>ext3</li><li>ext4</li><li>reiserFS</li><li>VFAT</li><li>ISO9600(光盘)</li></ul><p>mkfs：make filesystem</p><p><img src="/./img/1286512-20190206141059483-251392832.png" alt="img"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol><li><p>查看是否有&#x2F;etc&#x2F;password?</p><p><code>find /etc/password</code></p></li><li><p>把&#x2F;etc文件夹拷贝到&#x2F;home&#x2F;learn&#x2F;linux目录下？</p><p>   <code>cp -R /etc /home/learn/linux</code></p></li><li><p>打开此&#x2F;etc&#x2F;password，定位到153行，增加一句话：abc?</p></li></ol><p></p>  <div class="code-wrapper"><pre><code class="hljs shell">vim /etc/password153G按键字母i输入abc</code></pre></div><ol start="4"><li><p><strong>shell输出九九乘法表</strong></p><p><code>test</code> 和 <code>[ exp ]</code> 等价(注意两边<strong>空格</strong>)</p></li></ol><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span>for i in 1 2 3 4 5 6 7 8 9do        for j in 1 2 3 4 5 6 7 8 9        do                if(test $j -le $i)then                        echo -n &quot;$&#123;i&#125;*$&#123;j&#125;=$((i*j))  &quot;                fi        doneecho &quot;&quot;done</code></pre></div><ol start="5"><li><p>如果用<code>rmdir</code>命令删除某个已经存在的目录，但是无法成功，请给出原因和解决方法。</p><ul><li>此目录可能不存在;</li><li>目录不为空;</li><li>目录中有隐含文件存在;</li><li>目录没有权限操作;</li></ul><p>解决方法：先修改权限，在使用<code>rm -rf</code>命令删除。</p></li><li><p>请简单叙述新增一个用户系统所做的操作。</p><blockquote><p>在<code>/etc/passwd</code>文件中新增一条用户信息，<br>在<code>/etc/shadow</code>文件中增加一条该用户<strong>密码</strong>信息，<br>在<code>/etc/group</code>文件中新增一条用户<strong>组</strong>信息，<br>在<code>/etc/gshadow</code>文件中新增一条用户<strong>组密码</strong>信息,<br>在<code>/home</code>目录下新增一个与用户名相同的目录，<br><code>/var/spool/mail</code>目录下新建与用户名相同的<strong>邮件</strong>目录。</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python复习题</title>
    <link href="/Python/python%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
    <url>/Python/python%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Python复习题"><a href="#Python复习题" class="headerlink" title="Python复习题"></a>Python复习题</h1><p>1、用if分支结构完成程序设计(三选一):</p><ul><li><p>输入成绩，查询等级(90分及以上优秀、60-89合格、低于60不合格)</p><div class="code-wrapper"><pre><code class="hljs python">score = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Scroe:&quot;</span>))<span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">90</span> <span class="hljs-keyword">and</span> score &lt;= <span class="hljs-number">100</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;优秀&quot;</span>)<span class="hljs-keyword">elif</span> score &gt;= <span class="hljs-number">60</span> <span class="hljs-keyword">and</span> score &lt; <span class="hljs-number">90</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;合格&quot;</span>)<span class="hljs-keyword">elif</span> score &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> score &lt; <span class="hljs-number">60</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;不合格&quot;</span>)<span class="hljs-keyword">else</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Score must in 0-100&quot;</span>)</code></pre></div></li><li><p>输入年龄，查询公园门票价格(70岁以上老人免票，18岁以下儿童及60岁以上半票，18岁以上全价)</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):    age = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入年龄：&quot;</span>)    age = <span class="hljs-built_in">float</span>(age)    <span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">70</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;免票&quot;</span>)    <span class="hljs-keyword">elif</span> <span class="hljs-number">60</span> &lt; age &lt; <span class="hljs-number">70</span> <span class="hljs-keyword">or</span> <span class="hljs-number">0</span> &lt; age &lt; <span class="hljs-number">18</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;半票&quot;</span>)    <span class="hljs-keyword">elif</span> <span class="hljs-number">18</span> &lt;= age &lt;= <span class="hljs-number">60</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;全价&quot;</span>)    <span class="hljs-keyword">else</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;年龄不合法&quot;</span>)</code></pre></div></li><li><p>输入身高、体重，查询健康情况(BMI&#x3D;体重(kg) &#x2F;身高(m)的平方低于18.5偏瘦; 18.5-24 正常，超过24偏胖，超过28肥胖)</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 输入身高、体重</span>height = <span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入身高（m）：&quot;</span>))weight = <span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入体重（kg）：&quot;</span>))<span class="hljs-comment"># BMI = 体重（kg）/ 身高（m）的平方</span>BMI = weight / <span class="hljs-built_in">float</span>(height) ** <span class="hljs-number">2</span><span class="hljs-comment"># 低于18.5 偏瘦</span><span class="hljs-keyword">if</span> BMI &lt; <span class="hljs-number">18.5</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;偏瘦&quot;</span>)<span class="hljs-comment"># 18.5-24 正常</span><span class="hljs-keyword">elif</span> <span class="hljs-number">18.5</span> &lt;= BMI &lt;= <span class="hljs-number">24</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正常&quot;</span>)<span class="hljs-comment"># 超过24偏胖</span><span class="hljs-keyword">elif</span> <span class="hljs-number">24</span> &lt; BMI &lt;= <span class="hljs-number">28</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;偏胖&quot;</span>)<span class="hljs-comment"># 超过28肥胖</span><span class="hljs-keyword">elif</span> BMI &gt; <span class="hljs-number">28</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;肥胖&quot;</span>)</code></pre></div></li></ul><p>2、编程完成(三选一)：</p><ul><li><p>求1-100范围内所有3的倍数的和。如3+6+9+…</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>):    <span class="hljs-keyword">if</span> i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>:        <span class="hljs-built_in">sum</span> += i<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;result:&quot;</span> , <span class="hljs-built_in">sum</span>)<span class="hljs-comment"># 另法：用步长</span>ans = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">101</span>, <span class="hljs-number">3</span>):    ans = ans + i<span class="hljs-built_in">print</span>(ans)<span class="hljs-comment"># 另法：用sum</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, <span class="hljs-number">101</span>, <span class="hljs-number">3</span>))))</code></pre></div></li><li><p>一个数如果恰好等于它的因子(不包含自身)之和，则称之为”完数”。 例如6&#x3D;1+2+3。编程找出100以内的所有完数并输出。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">101</span>):    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, i):        <span class="hljs-keyword">if</span> i % n == <span class="hljs-number">0</span>:            <span class="hljs-built_in">sum</span> += n    <span class="hljs-keyword">if</span>(i == <span class="hljs-built_in">sum</span>):        <span class="hljs-built_in">print</span>(i)<span class="hljs-comment"># 0 6 28</span></code></pre></div></li><li><p>输出100以内的质数</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-number">100</span>):    num = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, i):        <span class="hljs-keyword">if</span> i % j == <span class="hljs-number">0</span>:            num += <span class="hljs-number">1</span>    <span class="hljs-keyword">if</span> num == <span class="hljs-number">0</span>:        <span class="hljs-built_in">print</span>(i)    num = <span class="hljs-number">0</span><span class="hljs-comment"># 25个</span><span class="hljs-comment"># 另法：用break</span><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">101</span>):    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, a):        <span class="hljs-keyword">if</span> a % b == <span class="hljs-number">0</span>:            <span class="hljs-keyword">break</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-built_in">print</span>(a)</code></pre></div></li></ul><p>3、编程完成(三选一)：</p><ul><li><p>己知字符串s&#x3D; ‘AbcDeFGhIJkmN’， 请计算该字符串中小写字母的数量。</p><div class="code-wrapper"><pre><code class="hljs python">s= <span class="hljs-string">&#x27;AbcDeFGhIJkmN&#x27;</span>num = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:    <span class="hljs-keyword">if</span> i.islower():        num += <span class="hljs-number">1</span><span class="hljs-built_in">print</span>(num) <span class="hljs-comment"># 7</span></code></pre></div></li><li><p>检查字符串”Life is short. I use python.”中是否包含字符串”python”，若包含则替换为 “Python”后输出新字符串，否则输出原字符串。</p><div class="code-wrapper"><pre><code class="hljs python">s = <span class="hljs-string">&quot;Life is short. I use python&quot;</span><span class="hljs-keyword">if</span> s.find(<span class="hljs-string">&quot;python&quot;</span>) != -<span class="hljs-number">1</span>:    <span class="hljs-built_in">print</span>(s.replace(<span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;Python&quot;</span>))<span class="hljs-keyword">else</span>:    <span class="hljs-built_in">print</span>(s)</code></pre></div></li><li><p>把“HAPPY BIRTHDAY”改成“Happy Birthday” 并输出。</p><div class="code-wrapper"><pre><code class="hljs python">s = <span class="hljs-string">&quot;HAPPY BIRTHDAY&quot;</span><span class="hljs-built_in">print</span>(s.title())<span class="hljs-comment"># Happy Birthday</span></code></pre></div></li></ul><p>4、编程实现(三选一)：<br>定义一个三角形类，输入三条边，判断能否构成三角形，如果能，计算并输出三角<br>形的面积，否则返回0。假设三角形三条边分别为a、 b、c，则周长的一半s&#x3D;(a+ b<br>+c)&#x2F;2，面积area&#x3D;√s*(s-a)*(s-b)*(s-c)。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">triangle</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a, b, c</span>):        <span class="hljs-variable language_">self</span>.a = a        <span class="hljs-variable language_">self</span>.b = b        <span class="hljs-variable language_">self</span>.c = c        <span class="hljs-variable language_">self</span>.s = (a + b + c) / <span class="hljs-number">2</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canTri</span>(<span class="hljs-params">self, a, b, c</span>) -&gt; <span class="hljs-built_in">bool</span>:        <span class="hljs-keyword">return</span> a + b &gt; c <span class="hljs-keyword">and</span> b + c &gt; a <span class="hljs-keyword">and</span> a + c &gt; b    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getArea</span>(<span class="hljs-params">self, a, b, c</span>) -&gt; <span class="hljs-built_in">float</span>:        s = <span class="hljs-variable language_">self</span>.s        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(s * (s - a) * (s - b) * (s - c), <span class="hljs-number">0.5</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getRes</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">float</span>:        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.canTri(<span class="hljs-variable language_">self</span>.a, <span class="hljs-variable language_">self</span>.b, <span class="hljs-variable language_">self</span>.c):            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.getArea(<span class="hljs-variable language_">self</span>.a, <span class="hljs-variable language_">self</span>.b, <span class="hljs-variable language_">self</span>.c)        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>tri = triangle(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<span class="hljs-built_in">print</span>(tri.getRes())</code></pre></div><p>5、逄7拍手游戏</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>):    <span class="hljs-keyword">if</span> i % <span class="hljs-number">7</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;7&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(i):        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;拍手&quot;</span>)    <span class="hljs-keyword">else</span>:        <span class="hljs-built_in">print</span>(i)<span class="hljs-comment"># 30 次</span></code></pre></div><p>6、菲波拉契数列前15项，例如: 0 1 1 2 3 5 8 13 21 … (递归兔子序列)</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a</span>):    <span class="hljs-keyword">if</span> a == <span class="hljs-number">0</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">if</span> a == <span class="hljs-number">1</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(a - <span class="hljs-number">1</span>) + <span class="hljs-built_in">sum</span>(a - <span class="hljs-number">2</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">15</span>):    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>(i))</code></pre></div><p>7、重写加减乘除运算符合</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumber</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, v</span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-variable language_">self</span>.data = v    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>):        v = <span class="hljs-variable language_">self</span>.data + other.data        <span class="hljs-keyword">return</span> MyNumber(v)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__sub__</span>(<span class="hljs-params">self, other</span>):        v = <span class="hljs-variable language_">self</span>.data - other.data        <span class="hljs-keyword">return</span> MyNumber(v)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__mul__</span>(<span class="hljs-params">self, other</span>):        <span class="hljs-keyword">return</span> MyNumber(<span class="hljs-variable language_">self</span>.data * other.data)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__truediv__</span>(<span class="hljs-params">self, other</span>):        <span class="hljs-keyword">return</span> MyNumber(<span class="hljs-variable language_">self</span>.data / other.data)        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(<span class="hljs-variable language_">self</span>.data)n1 = MyNumber(<span class="hljs-number">100</span>)n2 = MyNumber(<span class="hljs-number">200</span>)<span class="hljs-built_in">print</span>(n1 + n2)  <span class="hljs-comment"># 300</span><span class="hljs-built_in">print</span>(n1 - n2)  <span class="hljs-comment"># -100</span><span class="hljs-built_in">print</span>(n1 * n2)  <span class="hljs-comment"># 20000</span><span class="hljs-built_in">print</span>(n1 / n2)  <span class="hljs-comment"># 0.5</span></code></pre></div><p>9、重写两个点坐标的比较符</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">比较算术运算符的重载:</span><span class="hljs-string">        方法名                  运算符和表达式      说明</span><span class="hljs-string">        __lt__(self,rhs)       self &lt; rhs        小于</span><span class="hljs-string">        __le__(self,rhs)       self &lt;= rhs       小于等于</span><span class="hljs-string">        __gt__(self,rhs)       self &gt; rhs        大于</span><span class="hljs-string">        __ge__(self,rhs)       self &gt;= rhs       大于等于</span><span class="hljs-string">        __eq__(self,rhs)       self == rhs       等于</span><span class="hljs-string">        __ne__(self,rhs)       self != rhs       不等于</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):        <span class="hljs-variable language_">self</span>.x = x        <span class="hljs-variable language_">self</span>.y = y    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, p</span>):        <span class="hljs-keyword">return</span> Point(<span class="hljs-variable language_">self</span>.x + p.x, <span class="hljs-variable language_">self</span>.y + p.y)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__sub__</span>(<span class="hljs-params">self, p</span>):        <span class="hljs-keyword">return</span> Point(<span class="hljs-variable language_">self</span>.x - p.x, <span class="hljs-variable language_">self</span>.y - p.y)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, p</span>):        <span class="hljs-keyword">return</span> ((<span class="hljs-built_in">pow</span>(<span class="hljs-variable language_">self</span>.x, <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(<span class="hljs-variable language_">self</span>.y, <span class="hljs-number">2</span>)) - (<span class="hljs-built_in">pow</span>(p.x, <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(p.y, <span class="hljs-number">2</span>))) &lt; <span class="hljs-number">0</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;(<span class="hljs-subst">&#123;self.x&#125;</span>,<span class="hljs-subst">&#123;self.y&#125;</span>)&quot;</span>p1 = Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)p2 = Point(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)p3 = p1 + p2p4 = p1 - p2<span class="hljs-built_in">print</span>(p3) <span class="hljs-comment"># (4,6)</span><span class="hljs-built_in">print</span>(p4) <span class="hljs-comment"># (2,2)</span><span class="hljs-built_in">print</span>(p1 &lt; p2)  <span class="hljs-comment"># False</span></code></pre></div><p>10、编程，为二次方程式ax2+bx+c&#x3D;0设计一个名Equation 的类，判别方程有无实数解，并求解。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Equation</span>(<span class="hljs-title class_ inherited__">object</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a, b, c</span>):        <span class="hljs-variable language_">self</span>.a = <span class="hljs-built_in">float</span>(a)        <span class="hljs-variable language_">self</span>.b = <span class="hljs-built_in">float</span>(b)        <span class="hljs-variable language_">self</span>.c = <span class="hljs-built_in">float</span>(c)        <span class="hljs-variable language_">self</span>.e = <span class="hljs-variable language_">self</span>.b**<span class="hljs-number">2</span> - (<span class="hljs-number">4</span> * <span class="hljs-variable language_">self</span>.a * <span class="hljs-variable language_">self</span>.c)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getRes</span>(<span class="hljs-params">self</span>):        a, b, c, e = <span class="hljs-variable language_">self</span>.a, <span class="hljs-variable language_">self</span>.b, <span class="hljs-variable language_">self</span>.c, <span class="hljs-variable language_">self</span>.e        <span class="hljs-keyword">if</span> e &lt; <span class="hljs-number">0</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;无解&quot;</span>)        <span class="hljs-keyword">elif</span> e == <span class="hljs-number">0</span>:            <span class="hljs-built_in">print</span>(-b / <span class="hljs-number">2</span> * a)        <span class="hljs-keyword">else</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;x1 = <span class="hljs-subst">&#123;(-b-<span class="hljs-built_in">pow</span>(e,<span class="hljs-number">0.5</span>))/(<span class="hljs-number">2</span>*a)&#125;</span> , x2 = <span class="hljs-subst">&#123;(-b+<span class="hljs-built_in">pow</span>(e,<span class="hljs-number">0.5</span>))/(<span class="hljs-number">2</span>*a)&#125;</span>&quot;</span>)a = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入二次项系数&quot;</span>)b = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入一次项系数&quot;</span>)c = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入常数项系数&quot;</span>)equation = Equation(a, b, c)equation.getRes()</code></pre></div><ol start="11"><li>定义学生类，包括姓名、年龄、成绩(语文，数学，英语)等属性，包括获取姓名getName。获取年龄getAge、获取3门成绩最高分和平均分(保留小数点后2位)getScore等成员方法。</li></ol><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, *score</span>):        <span class="hljs-variable language_">self</span>.__name = name        <span class="hljs-variable language_">self</span>.__age = age        <span class="hljs-variable language_">self</span>.__score = score    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__name    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__age    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getScore</span>(<span class="hljs-params">self</span>):        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最高分：<span class="hljs-subst">&#123;<span class="hljs-built_in">max</span>(self.__score):<span class="hljs-number">.2</span>f&#125;</span>&quot;</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;平均分：<span class="hljs-subst">&#123;<span class="hljs-built_in">sum</span>(self.__score)/<span class="hljs-built_in">len</span>(self.__score):<span class="hljs-number">.2</span>f&#125;</span>&quot;</span>)student1 = Student(<span class="hljs-string">&quot;yorick&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-number">98</span>, <span class="hljs-number">88</span>, <span class="hljs-number">78</span>)<span class="hljs-built_in">print</span>(student1.getName())<span class="hljs-built_in">print</span>(student1.getAge())student1.getScore()</code></pre></div><p>12 . 定义一个圆类，包括半径属性，以及求面积和求周长两个方法，并创建2个圆对象,<br>分别求其面积和周长。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, radius</span>):        <span class="hljs-variable language_">self</span>.radius = radius    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getCircumference</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * math.pi * <span class="hljs-variable language_">self</span>.radius    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getArea</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> math.pi * <span class="hljs-variable language_">self</span>.radius**<span class="hljs-number">2</span>circle1 = Circle(<span class="hljs-number">4</span>)<span class="hljs-built_in">print</span>(circle1.getCircumference())<span class="hljs-built_in">print</span>(circle1.getArea())</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程概述</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
    <url>/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="软件工程概述"><a href="#软件工程概述" class="headerlink" title="软件工程概述"></a>软件工程概述</h1><p>概念：用工程化的思想指导软件开发</p><h2 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h2><p>软件危机的出现是由于软件的规模越来越大，复杂度不断增加，软件需求量增大。</p><p>主要表现：</p><ul><li>质量差</li><li>效率低，不满足需求</li></ul><h2 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h2><p>参考<a href="http://www.uml.org.cn/SoftWareProcess/201802062.asp">软件过程模型-过程改进 (uml.org.cn)</a></p><p>软件过程模型是描述软件开发过程中各种活动如何执行的模型，也叫软件过程模型或软件生命周期。</p><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>瀑布模型是一种线性的过程，瀑布模型要求有明确的需求分析，而要达到这一点在现实开发中几乎不可能。这种模型是最早也是应用最广泛的软件过程模型。</p><p>瀑布模型的优缺点</p><p><strong>优点</strong></p><ul><li>简单易行</li><li>可以进行阶段检查，能够及时发现问题</li><li>较好的分工协作，不同阶段不同职位，架构师，项目经理，开发工程师，测试工程师，运维工程师</li><li>对质量有一定的保障，因为每个阶段有详细的文档</li></ul><p><strong>缺点</strong></p><ul><li>难以响应需求的变更</li><li>工作量分配不均匀</li><li>前期阶段受阻压缩后期进展</li></ul><p><a href="https://www.cnblogs.com/lanjianhappy/p/11934284.html">https://www.cnblogs.com/lanjianhappy/p/11934284.html</a></p><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p>融合了瀑布模型的基本成分和原型实现的迭代特征。增量模型强调每一个增量均发布一个可操作的产品。增量模型在各个阶段并不交付一个可运行的完整产品，而是交付满足客户需求的一个子集的可运行产品。</p><p>优点：</p><ol><li><p>人员分配灵活</p></li><li><p>第一个可交付版本所需要的成本和时间很少</p></li></ol><p>缺点：</p><ol><li><p>软件具备开放式体系结构</p></li><li><p>容易退化为边做边改，使软件过程的控制失去整体性。</p></li><li><p>至始至终开发者和客户纠缠在一起，直到完全版本出来。</p></li></ol><h3 id="速成原型模型"><a href="#速成原型模型" class="headerlink" title="速成原型模型"></a>速成原型模型</h3><p>最大特点就是它采用了一种动态定义需求的方法。即不需要有明确的需求。被开发的原型应交付客户使用，并收集客户的反馈意见，可在下一轮中对原型进行改进。</p><p>是一种循环模型</p><p>优点：能够快速、低成本地构建原型</p><p>缺点：没有考虑软件的整体质量和长期的可维护性</p><p>适用对象：开发初期用户需求是不完整、不准确的</p><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>将瀑布模型和原型化模型结合起来，并加入<strong>风险分析</strong></p><p><img src="/./img/spiral_model.png" alt="螺旋模型（Spiral model） 大项目+需求不明确+明确的风险管理_沐雨金鳞-CSDN博客_需求不明确用什么模型"></p><p>优点：支持用户需求的动态变化。</p><p>缺点：</p><ol><li>需要开发人员具有相当丰富的风险评估经验和专门知识。</li><li>增加开发成本和延迟提交时间。</li><li>支持用户需求的动态变化</li></ol><p>使用对象：庞大、复杂且具有高风险的系统。</p><h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3><p>以用户需求为动力，已对象作为驱动的模型。适用<strong>面向对象</strong>的开发过程，最核心的特点是迭代性和无间隙性。所有的开发活动没有明显的边界，允许各种开发活动同步进行。</p><p>4个阶段</p><ul><li>分析</li><li>系统设计</li><li>软件设计</li><li>实现</li></ul><p>特点：各阶段相互重叠，反映了软件过程并行的特点</p><p>优点：提高软件项目的开发效率，节省开发时间。</p><p>缺点：</p><ol><li>需要大量的开发人员，不利于项目的管理。</li><li>要求严格管理文档，使得审核的难度加大。</li></ol><h2 id="软件开发方法"><a href="#软件开发方法" class="headerlink" title="软件开发方法"></a>软件开发方法</h2><h3 id="结构化开发方法"><a href="#结构化开发方法" class="headerlink" title="结构化开发方法"></a>结构化开发方法</h3><p>大问题分解为小问题，逐一解决。</p><p><strong>特点：自顶向下，逐步求精</strong></p><p>快速，自然，方便，容易理解。</p><p>具体分为</p><ul><li>结构化程序设计方法 SP </li><li>结构化设计方法 SD</li><li>结构化分析方法 SA</li></ul><h3 id="面向对象方法-OOSD"><a href="#面向对象方法-OOSD" class="headerlink" title="面向对象方法(OOSD)"></a>面向对象方法(OOSD)</h3><p>特点：封装，继承，多态</p><p>具体组成</p><ul><li>OOA 面向对象的分析</li><li>OOD 面向对象的设计</li><li>OOP 面向对象的程序设计</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能概论复习</title>
    <link href="/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/"/>
    <url>/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="人工智能概论复习"><a href="#人工智能概论复习" class="headerlink" title="人工智能概论复习"></a>人工智能概论复习</h1><ul><li><a href="#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0">人工智能概论复习</a><ul><li><a href="#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA">人工智能概论</a></li><li><a href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0">机器学习</a><ul><li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li><li><a href="#%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0">监督学习与无监督学习</a></li><li><a href="#%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B">特征工程</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E6%A0%87%E5%87%86%E5%8C%96">数据标准化</a></li><li><a href="#%E7%89%B9%E6%80%A7%E9%99%8D%E7%BB%B4">特性降维</a></li></ul></li><li><a href="#%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92">线性回归</a></li><li><a href="#%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92">逻辑回归</a></li><li><a href="#%E5%86%B3%E7%AD%96%E6%A0%91">决策树</a><ul><li><a href="#cart%E5%86%B3%E7%AD%96%E6%A0%91">CART决策树</a></li></ul></li><li><a href="#k%E8%BF%91%E9%82%BBknn">K近邻(KNN)</a></li><li><a href="#dbscan%E8%81%9A%E7%B1%BB">DBSCAN聚类</a></li><li><a href="#k%E5%9D%87%E5%80%BCk-means">K均值(K-Means)</a><ul><li><a href="#%E6%AD%A5%E9%AA%A4">步骤</a></li><li><a href="#%E8%81%9A%E7%B1%BB%E4%B8%AD%E5%BF%83">聚类中心</a></li></ul></li><li><a href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB">贝叶斯分类</a><ul><li><a href="#%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB">朴素贝叶斯分类</a></li></ul></li><li><a href="#%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BAsvm">支持向量机(SVM)</a><ul><li><a href="#%E6%A0%B8%E5%87%BD%E6%95%B0">核函数</a></li><li><a href="#%E8%BD%AF%E9%97%B4%E9%9A%94">软间隔</a></li></ul></li><li><a href="#%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0">集成学习</a></li><li><a href="#%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D">梯度下降</a></li><li><a href="#%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0">模型评估</a><ul><li><a href="#mse">MSE</a></li><li><a href="#r%E6%96%B9%E5%80%BC">R方值</a></li><li><a href="#%E4%BA%A4%E5%8F%89%E7%86%B5">交叉熵</a></li><li><a href="#%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5">混淆矩阵</a></li><li><a href="#roc%E6%9B%B2%E7%BA%BF">ROC曲线</a></li></ul></li><li><a href="#%E6%AC%A0%E6%8B%9F%E5%90%88%E5%92%8C%E8%BF%87%E6%8B%9F%E5%90%88">欠拟合和过拟合</a><ul><li><a href="#%E8%BF%87%E6%8B%9F%E5%90%88%E7%9A%84%E5%8E%9F%E5%9B%A0">过拟合的原因</a></li><li><a href="#%E8%BF%87%E6%8B%9F%E5%90%88%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">过拟合的解决办法</a></li><li><a href="#%E6%AC%A0%E6%8B%9F%E5%90%88%E7%9A%84%E5%8E%9F%E5%9B%A0">欠拟合的原因</a></li><li><a href="#%E6%AC%A0%E6%8B%9F%E5%90%88%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">欠拟合的解决办法</a></li></ul></li><li><a href="#%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96">模型优化</a><ul><li><a href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">常用方法</a></li><li><a href="#%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4">优化步骤</a></li></ul></li><li><a href="#%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81">交叉验证</a></li></ul></li><li><a href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0">深度学习</a><ul><li><a href="#%E4%BB%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%B0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0">从机器学习到深度学习</a><ul><li><a href="#%E6%B5%85%E5%B1%82%E5%AD%A6%E4%B9%A0shallow-learning">浅层学习(Shallow Learning)</a></li><li><a href="#%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0">表示学习</a></li><li><a href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5">深度学习概念</a></li><li><a href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%AD%A5%E9%AA%A4">深度学习步骤</a></li></ul></li><li><a href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">神经网络</a></li><li><a href="#%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%89%8D%E9%A6%88%E7%BD%91%E7%BB%9C">全连接前馈网络</a></li><li><a href="#bp%E7%AE%97%E6%B3%95backpropagation">BP算法(Backpropagation)</a></li><li><a href="#%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9Ccnn">卷积神经网络(CNN)</a></li><li><a href="#%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9Crnn">循环神经网络(RNN)</a></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89">计算机视觉</a></li><li><a href="#%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86">自然语言处理</a><ul><li><a href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B">文本处理流程</a></li></ul></li><li><a href="#%E5%B7%A5%E5%85%B7">工具</a><ul><li><a href="#scikit-learn">Scikit-Learn</a></li><li><a href="#numpy">Numpy</a></li><li><a href="#matplotlib">Matplotlib</a></li></ul></li></ul></li></ul><h2 id="人工智能概论"><a href="#人工智能概论" class="headerlink" title="人工智能概论"></a>人工智能概论</h2><p>提出时间： <strong>1956年</strong></p><p>标志性事件：<strong>达特茅斯会议</strong></p><p>4个发展阶段：</p><p><img src="/./img/image-20230214130706660.png" alt="image-20230214130706660"></p><p>3个主要学派：</p><ol><li><p><strong>符号主义</strong>(symbolicism)</p><p>认为人工智能源于<strong>数理逻辑</strong></p></li><li><p><strong>连接主义</strong>(connectionism)</p><p>认为人工智能源于<strong>仿生学</strong></p></li><li><p><strong>行为主义</strong>(actionism)</p></li></ol><p><strong>概念</strong>：人工智能是研究使<strong>计算机</strong>来<strong>模拟人</strong>的某些思维过程和智能行为的学科</p><p><strong>研究领域</strong>：</p><ul><li>机器感知(计算机视觉、语音信息处理、模式识别)</li><li>学习(机器学习、强化学习)</li><li>语言(自然语言处理)</li><li>记忆(知识表示)</li><li>决策(规划、数据挖掘)</li></ul><p><strong>图灵测试</strong>：艾伦·图灵认为，如果机器在拥有知识的观察者面前能够成功地伪装成人类，那么你就应该认为它具有智能。</p><p>麦卡锡等4人(1955年)提出<strong>首次提出“人工智能”这一术语</strong></p><p>研究主题：</p><ol><li><p>将信息理论概念应用到计算机器与大脑模型中。</p></li><li><p>与机器人相匹配的环境-大脑模型。</p></li></ol><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>机器学习( Machine Learning，ML)是指从<strong>有限的观测数据(训练数据)<strong>中</strong>学习(或“猜测”)出具有一般性的规律(Function)<strong>，并利用这些规律</strong>对未知数据进行预测</strong>的方法。</p><h3 id="监督学习与无监督学习"><a href="#监督学习与无监督学习" class="headerlink" title="监督学习与无监督学习"></a>监督学习与无监督学习</h3><p>监督学习(supervised learning) (预测)</p><ul><li>定义：输入数据是由输入<strong>特征值</strong>和<strong>目标值</strong>所组成。函数的输出可以是一个连续的值(称<br>为<strong>回归</strong>)，或是输出是有限个离散值(称作<strong>分类</strong>)。<ul><li><p>回归：线性回归、岭回归</p></li><li><p>分类：k-近邻算法、贝叶斯分类、决策树与随机森林、逻辑回归、神经网络</p></li></ul></li></ul><p>无监督学习(unsupervised learning)</p><ul><li>定义：输入数据是由输入<strong>特征值</strong>所组成。</li><li>聚类：K均值(k-means)</li></ul><h3 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h3><h4 id="数据标准化"><a href="#数据标准化" class="headerlink" title="数据标准化"></a>数据标准化</h4><p>将样本数据的属性缩放到某个指定的范围</p><p>（1）min-max标准化(归一化)</p><p>（2）z-score标准化(规范化)</p><p><img src="/./img/image-20230215182754216.png" alt="image-20230215182754216"></p><p>标准化的原因：</p><ul><li>某些算法要求样本具有零均值和单位方差；</li><li>需要消除样本不同属性具有不同量级时的影响；</li><li>数量级的差异将导致量级较大的属性占据主导地位；</li><li>数量级的差异将导致迭代收敛速度减慢；</li><li>依赖于样本距离的算法对于数据的数量级非常敏感。</li></ul><h4 id="特性降维"><a href="#特性降维" class="headerlink" title="特性降维"></a>特性降维</h4><p>目标：在某些限定条件下，降低随机变量(特征)个数,得到一组“不相关”主变量的过程。</p><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>通过两个或多个变量之间的<strong>线性关系</strong>来预测结果。</p><p>目标函数：</p><p><img src="/./img/image-20230214143648199.png" alt="目标函数"></p><h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><p>解决分类问题</p><p><a href="https://www.bilibili.com/video/BV1PJ411676g">讲解视频</a></p><p>用于解决分类问题的一种模型。根据数据特征或属性，计算其归属于某一类别的概率P(x)，根据概率数值判断其所属类别。主要应用场景：二分类问题。</p><p>逻辑回归 &#x3D; 线性回归+Sogmoid函数</p><p><strong>Sigmoid函数：</strong></p><p><img src="/./img/image-20230219185835082.png" alt="Sigmoid函数"></p><p>目标函数：</p><p><img src="/./img/image-20230214144025700.png" alt="image-20230214144025700"></p><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>分类问题</p><p>决策树的构建算法主要有<strong>ID3、C4.5、 CART</strong>三种，其中ID3和C4.5是分类树，CART是分类回归树。ID3是决策树最基本的构建算法，C4.5和CART是在ID3的基础上进行的优化算法。</p><h4 id="CART决策树"><a href="#CART决策树" class="headerlink" title="CART决策树"></a>CART决策树</h4><p>Classification and Regression Tree</p><p>以基尼系数（标准的不确定程度，越小越好）为核心</p><p><img src="/./img/image-20230223112021298.png" alt="image-20230223112021298"></p><h3 id="K近邻-KNN"><a href="#K近邻-KNN" class="headerlink" title="K近邻(KNN)"></a>K近邻(KNN)</h3><p>利用训练数据集对特征空间进行划分，以其作为分类的“模型”，不具有显性的学习过程。KNN的输入是测试数据和训练样本数据集，输出是测试样本的类别。</p><p>KNN的三个要素：</p><ul><li>距离度量</li><li>K值选择</li><li>分类决策规则</li></ul><h3 id="DBSCAN聚类"><a href="#DBSCAN聚类" class="headerlink" title="DBSCAN聚类"></a>DBSCAN聚类</h3><p>无标签信息，无监督</p><p><a href="https://www.bilibili.com/video/BV114411M7ci">动画演示</a></p><p><a href="https://www.bilibili.com/video/BV1aA4y1o7UG">具体讲解</a></p><p>DBSCAN (Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于<strong>密度</strong>的聚类方法。</p><p>簇：密度相连的点的最大集合。</p><ul><li><p>密度：某个点的领域空间里存在的其他点的数量</p></li><li><p>核心对象：若某个点的密度达到算法设定的阈值，则为核心点。(即r邻域内点的数量不小于minPts)</p></li><li><p>邻域的距离阈值：设定半径r</p></li><li><p>直接密度可达：若p在q的邻域内，且q是<strong>核心点</strong>，则称p到q直接密度可达</p></li><li><p><strong>密度可达</strong>：若存在一个点的序列$q_0$、$q_1$… $q_n$对任意$q_i$、$q_{i+1}$是直接密度可达的，则称$q_0$、$q_n$ 密度可达，实际上是直接密度可达的<strong>传播</strong></p></li><li><p><strong>密度相连</strong>：对于点p和点q，若点p点q都是从点k<strong>密度可达</strong>的，则称点p和q是密度相连的</p></li><li><p>边界点：属于某一个类的非核心点，不能再发展下线了</p><p>对象的邻域小于MinPts个对象，但是<strong>在某个核心对象的邻域</strong>中</p></li><li><p>噪声点：不属于任何一个类簇的点，从任何一个核心点出发都不是密度可达的</p></li></ul><h3 id="K均值-K-Means"><a href="#K均值-K-Means" class="headerlink" title="K均值(K-Means)"></a>K均值(K-Means)</h3><p>无标签信息，无监督</p><p>K-Means是一种基于相似距离的聚类算法，根据给定样本集中样本间距离的大小将样本集划分为k个簇（类），使得每个点都属于距离它最近的那个<strong>聚类中心</strong>（即均值means）对应的类。</p><ul><li>K值：要得到的簇的个数（样本的类别数）</li><li>质心：每个簇的均值，一般是向量各维取平均值</li><li>距离：常用欧几里得距离(先做标准化)</li><li>目标：选择距离最短的质心</li></ul><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>先定义总共有多少个类&#x2F;簇(cluster)</li><li>将每个簇心(cluster centers)随机定在一个点上</li><li>将每个数据点关联到最近簇中心所属的簇上</li><li>对于每一个簇找到其所有关联点的中心点(取每一个点坐标的平均值)</li><li>将上述点变为新的簇心</li><li>不停重复，直到每个簇所拥有的点不变</li></ol><h4 id="聚类中心"><a href="#聚类中心" class="headerlink" title="聚类中心"></a>聚类中心</h4><p>每个簇的均值，一般是向量各维取平均值</p><h3 id="贝叶斯分类"><a href="#贝叶斯分类" class="headerlink" title="贝叶斯分类"></a>贝叶斯分类</h3><p>贝叶斯(Bayes) 分类是一类分类算法的总称，该类算法均以<strong>贝叶斯定理</strong>为基础，所以统称为贝叶斯分类。而朴素贝叶斯分类是贝叶斯分类中最简单，也是常见的一种分类方法,同时朴素贝叶斯模型是一-组非常简单快速的分类算法，通常适用于维度非常高的数据集。</p><p>贝叶斯定理：<strong>P (A∩B) &#x3D; P (A)*P (B|A)&#x3D;P (B)*P (A|B)</strong></p><p>贝叶斯定理是一种逆概率思维。</p><p><strong>条件概率</strong>（客观事实）：根据已知结果去推测固有性质的可能性(likelihood)，是对固有性质的拟合程度。</p><p><strong>先验概率</strong>（主观判断）：指根据常识、生活经验所观测到的“原因”的概率。</p><p><strong>后验概率</strong>（最终结论）：指在知道“结果”之后，去推测“原因”的概率。</p><h4 id="朴素贝叶斯分类"><a href="#朴素贝叶斯分类" class="headerlink" title="朴素贝叶斯分类"></a>朴素贝叶斯分类</h4><p><strong>假设条件</strong>：实例特征之间<strong>相互独立</strong></p><p><img src="/./img/image-20230219190817960.png" alt="image-20230219190817960"></p><p>示例：计算实例点x &#x3D; (2, S)的类别</p><p><img src="/./img/image-20230215190417361.png" alt="image-20230215190417361"></p><h3 id="支持向量机-SVM"><a href="#支持向量机-SVM" class="headerlink" title="支持向量机(SVM)"></a>支持向量机(SVM)</h3><p><a href="https://www.bilibili.com/video/BV16T4y1y7qj">直觉理解</a></p><p>支持向量机（<code>support vector machines</code>，<code>SVM</code>）是一种二分类模型，它的目的是寻找一个超平面来对样本进行分割，分割的原则是间隔最大化，最终转化为一个凸二次规划问题来求解。由简至繁的模型包括：</p><ul><li>当训练样本<strong>线性可分</strong>时，通过<strong>硬间隔最大化</strong>，学习一个<strong>线性可分支持向量机</strong></li><li>当训练样本<strong>近似线性可分</strong>时，通过<strong>软间隔最大化</strong>，学习一个<strong>线性支持向量机</strong></li><li>当训练样本<strong>线性不可分</strong>时，通过<strong>核技巧和软间隔最大化</strong>，学习一个<strong>非线性支持向量机</strong></li></ul><p>简而言之：求最大化离超平面最近点（支持向量）的距离。</p><p>决策边界：选出来离雷区最远的（雷区就是边界上的点，要Large Margin )</p><h4 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h4><p><strong>解决计算复杂度问题</strong></p><p>由低维度空间向高维度空间作一个映射，使原本在低纬度上线性不可分数据变得在高维度上变得可分，并找到这个分割函数。</p><h4 id="软间隔"><a href="#软间隔" class="headerlink" title="软间隔"></a>软间隔</h4><p><strong>解决过拟合问题</strong></p><p>硬间隔强制要求包括噪音点或者离群点的所有样本点都满足约束，可能会导致使决策边界发生变化出现过拟合的问题，所以允许部分样本（离群点或者噪音点）不必满足该约束。</p><h3 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h3><p>集成学习(Ensemble Learning)方法通过组合和合并多个相同或者不同种类的机器学习分类器来完成学习任务，避免使用单一学习模型带来的学习模型缺陷， 从而尽可能的使得机器学习的效果达到尽可能的最优。</p><p>策略：</p><ul><li><p><strong>Bagging</strong>：训练多个分类器取平均值</p><p><strong>并联，少数服从多数</strong>，典型代表是<strong>随机森林</strong></p></li><li><p><strong>Boosting</strong>：从弱学习器开始加强，通过加权来进行训练</p><p><strong>串联，权重</strong>（错分类样本），每次迭代正确率要提高，典型算法<code>Adaboost</code></p></li><li><p><strong>Stacking</strong>：聚合多个分类或回归模型（可以分阶段来做）</p><p><strong>级联，裁判</strong>，分阶段：第一阶段各自分类，第二阶段用前一阶段的结果训练</p></li></ul><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>提高收敛速度的三种策略：</p><ol><li>批量梯度下降<br>每次迭代，均选择<strong>所有数据</strong>来计算梯度</li><li>随机梯度下降<br>每次迭代，<strong>随机</strong>选择<strong>一条数据</strong>来计算梯度</li><li>Mini-Batch GD<br>每次迭代，<strong>随机</strong>选择<strong>一部分数据</strong>来计算梯度</li></ol><h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><p>MSE，R2评估回归，交叉熵评估分类</p><h4 id="MSE"><a href="#MSE" class="headerlink" title="MSE"></a>MSE</h4><p>Mean Squared Error <strong>均方误差</strong></p><p><a href="https://www.bilibili.com/video/BV1wi4y157Tt">https://www.bilibili.com/video/BV1wi4y157Tt</a></p><p><img src="/./img/image-20230215194816842.png" alt="image-20230215194816842"></p><p><img src="/./img/image-20230215194311371.png" alt="image-20230215194311371"></p><h4 id="R方值"><a href="#R方值" class="headerlink" title="R方值"></a>R方值</h4><p>[0,1] 不定系数 R-squared (R方)，越接近1越好，但是等于1没有价值</p><p><a href="https://www.bilibili.com/video/BV1Qy4y1i7Le">https://www.bilibili.com/video/BV1Qy4y1i7Le</a></p><p><img src="/./img/image-20230215195149603.png" alt="image-20230215195149603"></p><h4 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h4><p><a href="https://www.bilibili.com/video/BV1mZ4y1R76t">https://www.bilibili.com/video/BV1mZ4y1R76t</a></p><p>输入为羊，输出为羊的概率0.8，输出为牛的概率0.1，输出为猴概率0.1</p><p><img src="/./img/wps1.jpg" alt="img"></p><h4 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h4><p><img src="/./img/image-20230215191114810.png" alt="image-20230215191114810"></p><p><img src="/./img/image-20230215191137030.png" alt="image-20230215191137030"></p><h4 id="ROC曲线"><a href="#ROC曲线" class="headerlink" title="ROC曲线"></a>ROC曲线</h4><p><img src="/./img/image-20230215191158222.png" alt="image-20230215191158222"></p><p>一种比较总体优劣的方法是采用AUG (Area Under ROC Curve)参数，表示为其ROC曲线之下和坐标横轴之间的面积。</p><h3 id="欠拟合和过拟合"><a href="#欠拟合和过拟合" class="headerlink" title="欠拟合和过拟合"></a>欠拟合和过拟合</h3><p>欠拟合：训练集上表现的不好，测试集上不好</p><p>过拟合：训练集上表现的好，测试集上不好</p><h4 id="过拟合的原因"><a href="#过拟合的原因" class="headerlink" title="过拟合的原因"></a>过拟合的原因</h4><ul><li>模型结构过于复杂（维度过高）</li><li>训练数据中噪音干扰过大，使得学习器认为部分噪音是特征从而扰乱学习规则。</li><li>建模样本选取有误，例如训练数据太少，抽样方法错误，样本label错误等，导致样本不能代表整体。</li><li>模型不合理，或假设成立的条件与实际不符。</li></ul><h4 id="过拟合的解决办法"><a href="#过拟合的解决办法" class="headerlink" title="过拟合的解决办法"></a>过拟合的解决办法</h4><ul><li>简化模型结构（使用低阶模型，比如线性模型）</li><li>数据预处理，保留主成分信息（数据PCA处理）</li><li>在模型训练时，增加<strong>正则化项</strong>（regularization）</li></ul><h4 id="欠拟合的原因"><a href="#欠拟合的原因" class="headerlink" title="欠拟合的原因"></a>欠拟合的原因</h4><ul><li>模型复杂度过低</li><li>特征量过少</li></ul><h4 id="欠拟合的解决办法"><a href="#欠拟合的解决办法" class="headerlink" title="欠拟合的解决办法"></a>欠拟合的解决办法</h4><p>欠拟合可以通过观察训练数据及时发现，优化模型结果解决。</p><ul><li>增加特征数；<br>当特征不足或者现有特征与样本标签的相关性不强时，模型易出现欠拟合。<br>可以通过挖掘上下文特征，ID类特征，组合特征等新的特征，可以取得较好的效果。这属于特征工程相关的内容，如因子分解机，梯度提升决策树，deep_crossing都可以丰富特征。</li><li>增加模型复杂度；<br>模型简单时其表达能力较差，容易导致欠拟合，因此可以适当地增加模型复杂度，使模型拥有更强的拟合能力。<br>如线性模型中添加高次项，神经网络中增加网络层数或神经元个数。尝试非线性模型，比如核SVM 、决策树、DNN等模型。</li><li>减小<a href="https://so.csdn.net/so/search?q=%E6%AD%A3%E5%88%99%E5%8C%96&spm=1001.2101.3001.7020">正则化</a>系数。<br>正则化是用于防止过拟合的，但是当出现欠拟合时，就有必要针对性地减小正则化系数。</li></ul><h3 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>PCA思路(最大可分性和最低重构性)</li><li>正则化(L1、L2)</li></ul><h4 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h4><ol><li>优化数据(异常数据、数据量级、数据维度)</li><li>优化模型(模型选择与调参)</li><li>测试评估(交叉验证)</li></ol><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><p>常用方法：</p><ul><li><p>数据分离</p></li><li><p>LOOCV方法(Leave-one-out cross-validation留一交叉验证)</p><p>每次取出一个数据作为测试集的唯一元素，其他n - 1个数据都作为训练集用于训练模型和调参。结果是最终训练了n个模型，每次都能得到一个均方误差(Mean-Square Error MSE)。而计算最终测试集MSE则就是将这n个MSE取平均值。</p></li><li><p>K折交叉验证(K-fold Cross Validation)</p><p>和LOOCV的不同在于，每次的测试集将不再只包含一个数据，而是多个，具体数目将根据K的选取决定。<br>比如，如果K&#x3D;3，那么我们利用三折交叉验证的步骤就是：</p><ul><li>将所有数据集分成3份</li><li>不重复地每次取其中一份做测试集，用其他两份做训练集训练模型，之后计算该模型在测试集上的MSE</li><li>将3次的MSE取平均得到最后的MSE</li></ul></li></ul><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><h3 id="从机器学习到深度学习"><a href="#从机器学习到深度学习" class="headerlink" title="从机器学习到深度学习"></a>从机器学习到深度学习</h3><p><strong>机器学习 &#x3D; 特征工程 + 预测</strong></p><p><strong>深度学习 &#x3D; 表示学习 + 预测</strong></p><h4 id="浅层学习-Shallow-Learning"><a href="#浅层学习-Shallow-Learning" class="headerlink" title="浅层学习(Shallow Learning)"></a>浅层学习(Shallow Learning)</h4><p>不涉及特征学习，其特征主要靠人工经验或特征转换方法抽取。(特征工程)</p><h4 id="表示学习"><a href="#表示学习" class="headerlink" title="表示学习"></a>表示学习</h4><p>如何自动从数据中学习好的表示<br>通过构建具有一定“深度”的模型，可以让模型来自动学习好的特征表示(从底层特征，到中层特征，再到高层特征)，从而最终提升预测或识别的准确性</p><p><img src="/./img/image-20221117092346589.png" alt="image-20221117092346589"></p><p>表示形式：如何在计算机中表示语义</p><p>局部(符号)表示:</p><ul><li>离散表示、符号表示</li><li>One-Hot向量</li></ul><p>分布式(Distributed) 表示:</p><ul><li>压缩、低维、稠密向量</li><li>用O(N)个参数表示O(2^k)区间，k为非0参数, k&lt;N</li></ul><p>以颜色表示为例，一种表示颜色的方法是以不同名字来命名不同的颜色，这种表示方式叫做<strong>one-hot局部表示</strong>。</p><p>另一种表示颜色的方法是用RGB值来表示颜色，不同颜色对应R、G、B三维空间中一个点，这种表示方式叫做<strong>分布式表示</strong>。</p><p><strong>特征提取 vs 表示学习</strong></p><ul><li>特征提取：基于任务或先验去除无用特征</li><li>表示学习：通过深度模型学习高层语义特征</li></ul><h4 id="深度学习概念"><a href="#深度学习概念" class="headerlink" title="深度学习概念"></a>深度学习概念</h4><p><strong>深度学习 &#x3D; 表示学习 + 决策(预测)学习</strong></p><p><img src="/./img/image-20230216143206169.png" alt="image-20230216143206169"></p><p>深度学习需要解决的关键问题是<strong>贡献度分配问题</strong>（Credit Assignment Problem，CAP），即<strong>一个系统中不同的组件 (component)或其参数对最终系统输出结果的贡献或影响</strong>。</p><p>神经网络模型可以使用误差反向传播算法，从而可以比较好地解决贡献度分配问题。</p><h4 id="深度学习步骤"><a href="#深度学习步骤" class="headerlink" title="深度学习步骤"></a>深度学习步骤</h4><p><img src="/./img/image-20230216145144425.png" alt="image-20230216145144425"></p><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p>参考生物神经元以下特征：</p><ul><li>两种状态：兴奋和抑制</li><li>输入达到一定值激活兴奋状态</li><li>记忆储存在连接之中</li></ul><p><strong>单个神经元模型结构</strong></p><p><img src="https://img-blog.csdnimg.cn/20200308143208133.png" alt="img"></p><p>上面的x是神经元的输入，相当于树突接收的多个外部刺激。w是每个输入对应的权重，代表了每个特征的重要程度，它对应于每个输入特征，影响着每个输入x的刺激强度。假设只有3个特征，那么x就可以用（x1，x2，x3）。b表示阈值，用来影响预测结果。z就是预测结果。</p><p><strong>多个神经元组成神经网络</strong></p><p><strong>神经网络分类</strong></p><ol><li><strong>前馈网络</strong>，整个网络中的信息朝一个方向传播，没有反向的信息传播。如<strong>全连接前馈网络</strong>，<strong>卷积神经网络</strong>。</li><li><strong>记忆网络</strong>，神经元不仅可以接受其他神经元的信息，也可以接受自己的历史信息，如<strong>循环神经网络</strong>。</li><li><strong>图网络</strong>，是前两者的泛化，如图卷积网络</li></ol><h3 id="全连接前馈网络"><a href="#全连接前馈网络" class="headerlink" title="全连接前馈网络"></a>全连接前馈网络</h3><p>全连接前馈网络、多层感知器</p><ul><li>各神经元分别属于不同的层，层内无连接</li><li>相邻两层之间的神经元全部两两连接</li><li>整个网络中无反馈,信号从输入层向输出层单向传播，可用一个有向无环图表示</li></ul><p>神经元之间两两都连接，<strong>链式结构</strong>，前后次序给定；上一层的输出为下一层的输入。</p><p><img src="/./img/image-20230216145514119.png" alt="image-20230216145514119"></p><p><strong>应用：</strong></p><ul><li>数据压缩</li><li>模式识别</li><li>计算机视觉</li><li>声纳目标识别</li><li>语音识别</li><li>手写字符识别</li></ul><h3 id="BP算法-Backpropagation"><a href="#BP算法-Backpropagation" class="headerlink" title="BP算法(Backpropagation)"></a>BP算法(Backpropagation)</h3><p>误差反向传播</p><p>用来高效寻找最优参数</p><ol><li>权重初始化</li><li>前向计算</li><li>反向传播</li></ol><p><img src="/./img/image-20230216145941069.png" alt="image-20230216145941069"></p><h3 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络(CNN)"></a>卷积神经网络(CNN)</h3><p>受生物学上<strong>感受野</strong>(Receptive Field)的机制而提出的，选不同的卷积核提取需要的特征</p><p><strong>特性</strong>：</p><ul><li>局部连接</li><li>权重共享</li><li>空间或时间上的次采样</li></ul><p><strong>应用</strong>：图像特征识别</p><p><strong>为什么用于图像</strong>：</p><ol><li>彩色图片维度很大</li><li>特征往往小于图片</li><li>特征会出现在图片的任何位置</li><li>图片压缩大小不会改变特征</li></ol><p>下采样→保留特征+减小图片尺寸→网络中节点数变少→参数变少→加快训练</p><p><strong>计算方法及输出长度</strong></p><p><img src="/./img/image-20230216151753192.png" alt="image-20230216151753192"></p><p><strong>卷积输出长度</strong></p><p><code>1,1,-1,1...,1</code>是输入信号，经过卷积<code>[1,-2,1]</code>的计算，输出<code>-2,4,-2,0...</code><br><code>-2 = 1*1 + 1* -2 + -1 * 1</code></p><p><img src="/./img/image-20230219195627192.png" alt="image-20230219195627192"></p><h3 id="循环神经网络-RNN"><a href="#循环神经网络-RNN" class="headerlink" title="循环神经网络(RNN)"></a>循环神经网络(RNN)</h3><ul><li>样本间存在顺序关系，每个样本和它之前的样本存在关联。</li><li>引入“记忆”的概念，来处理前后数据的相关性。</li></ul><p>适合<strong>序列数据</strong>，如文本，语音，视频，气象观测数据，股票交易数据。</p><p><strong>计算方法</strong></p><p>在计算时，把上一次隐藏层的结果数据，作为下一次的一个输入源，与下一次的x合并后，再传入隐藏层。</p><p><img src="/./img/image-20230216153526519.png" alt="image-20230216153526519"></p><p><img src="/./img/image-20230216154207341.png" alt="image-20230216154207341"></p><p><strong>应用：</strong></p><ul><li>机器翻译</li><li>机器人控制</li><li>时间序列预测</li><li>语音识别</li><li>语音合成</li><li>时间序列异常检测</li><li>节奏学习</li><li>音乐创作</li></ul><h2 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h2><p>用摄像机等设备替代人眼对目标进行识别，跟踪和测量，并使用计算机对获取的图像或视频进行处理，分析和理解。</p><p><img src="/./img/image-20230216161158288.png" alt="image-20230216161158288"></p><p><strong>应用类型：</strong></p><ul><li>图像分类</li><li>目标检测 定位 识别 R-CNN 区域卷积神经网络</li><li>目标跟踪 分布式视觉网络 摄像头协作</li><li>语义分割 一类颜色一样</li><li>实例分割 一类可能有不同颜色</li></ul><p><strong>像素</strong>：像素是分辨率的单位。像素是构成位图图像最基本的单元，每个像素都用自己的颜色。</p><p><strong>分辨率</strong>(解析度) ：</p><ul><li><p>图像分辨率是单位英寸内的像素点数，单位为PPI (Pixels Per Inch)</p></li><li><p>PPI表示的是每英寸对角线上所拥有的像素数量(每英寸密度) :</p><p><img src="/./img/image-20230216161308145.png" alt="image-20230216161308145"></p></li></ul><p><strong>灰度</strong>：表示图像像素<strong>明暗程度</strong>的数值，即<strong>黑白图像中点的颜色深度</strong>。范围0-255，白色是255，黑色是0</p><p><strong>通道</strong>：把图像分解成一个或多个颜色成分：</p><ul><li><p>单通道：一个像素点只需一 个数值表示， 只能表示灰度, 0表示黑色(二值图&amp;灰度图)</p></li><li><p>三通道：RGB模式，把图像分为红绿蓝三个通道，可以表示彩色，全0表示黑色</p></li><li><p>四通道：RGBA模式，在RGB基础上加上Alpha通道， 表示透明度，Alpha&#x3D;0表示全透明</p></li></ul><p>对比度：不同颜色之间的差别，对比度&#x3D;最大灰度值&#x2F;最小灰度值</p><p>一副尺寸为800x600的黑白图像，假设采用8bit像素，需要占用多大存储空间?</p><p>800 x 600黑白图像，有480000个像素，每个像素包含1个数值，每个数值8-bit，保存这一副图像需要<br><code>800 X 600 X 1 X 8-bit = 3840000-bit = 3750Kb = 468.75KB = 0.4578MB</code></p><p>一副尺寸为800x 600的彩色图像，需要占用多大存储空间?<br>800 x 600彩色图像，有480000个像素，每个像素包含3个数值，每个数值8-bit，保存这一副图像需要<br><code>800 X 600 X 3 X 8-bit = 11520000-bit = 11250Kb = 1406.25KB = 1.373MB</code></p><h2 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h2><p>自然语言处理(Natural Language Processing: NLP)是研究用机器处理人类语言的理论和技术以实现在人与人以及人与计算机之间利用自然语言进行交互的一门学科。</p><ul><li>自然语言理解</li><li>自然语言生成</li></ul><h3 id="文本处理流程"><a href="#文本处理流程" class="headerlink" title="文本处理流程"></a>文本处理流程</h3><p><img src="/./img/image-20230216162204463.png" alt="image-20230216162204463"></p><p>标准化：套规则</p><p>特征提取：共现矩阵</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="Scikit-Learn"><a href="#Scikit-Learn" class="headerlink" title="Scikit-Learn"></a>Scikit-Learn</h3><p>常用函数</p><p><a href="https://blog.csdn.net/HNU_Csee_wjw/article/details/89218305">scikit-learn常用库与函数整理</a></p><p><a href="https://blog.csdn.net/weixin_45485946/article/details/106627416">sklearn常用函数</a></p><p>导入数据集</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_winewine = load_wine()</code></pre></div><p>分割测试集数据和训练集数据</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> model_selectionX_train, X_test, y_train, y_test = train_test_split(train_data, train_target, test_size, random_state，shuffle)</code></pre></div><h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><p><a href="https://www.runoob.com/numpy/numpy-array-manipulation.html">Numpy 数组操作</a></p><h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><p><a href="https://blog.csdn.net/geek64581/article/details/106241522">Matplotlib常见图形绘制(折线图、散点图 、柱状图 、直方图 、饼图 、条形图)</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
      <tag>课程笔记</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python复习</title>
    <link href="/Python/Python%E5%A4%8D%E4%B9%A0/"/>
    <url>/Python/Python%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#python%E5%A4%8D%E4%B9%A0">Python复习</a><ul><li><a href="#%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80">语法基础</a><ul><li><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97">标识符和关键字</a><ul><li><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6">标识符</a></li><li><a href="#%E5%85%B3%E9%94%AE%E5%AD%97">关键字</a></li></ul></li><li><a href="#%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">变量和数据类型</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li><li><a href="#%E5%8F%98%E9%87%8F">变量</a></li></ul></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a><ul><li><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96">格式化</a></li><li><a href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%A0%87">索引(下标)</a></li><li><a href="#%E5%88%87%E7%89%87%E9%A1%BE%E5%A4%B4%E4%B8%8D%E9%A1%BE%E5%B0%BE">切片(顾头不顾尾)</a></li><li><a href="#%E8%B7%B3%E5%8F%96">跳取</a></li><li><a href="#%E9%A6%96%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%86%99">首字母大写</a></li><li><a href="#%E5%85%A8%E9%83%A8%E5%A4%A7%E5%86%99">全部大写</a></li><li><a href="#%E5%85%A8%E9%83%A8%E5%B0%8F%E5%86%99">全部小写</a></li><li><a href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E4%BA%92%E6%8D%A2">大小写互换</a></li><li><a href="#%E6%A0%87%E9%A2%98%E5%8C%96">标题化</a></li><li><a href="#%E6%9F%A5%E6%89%BE">查找</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E5%90%8E%E7%9A%84%E7%A9%BA%E6%A0%BC%E5%AD%97%E7%AC%A6">删除字符串前后的空格&#x2F;字符</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9F%90%E5%AD%97%E7%AC%A6%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%AA%E6%95%B0">计算某字符&#x2F;字符串的个数</a></li><li><a href="#%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2">分割字符串</a></li><li><a href="#%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2">替换字符串</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5">字符串拼接</a></li></ul></li><li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a></li><li><a href="#%E5%88%97%E8%A1%A8list">列表(list)</a><ul><li><a href="#%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0">插入元素</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0">删除元素</a></li><li><a href="#%E6%8E%92%E5%BA%8F">排序</a></li><li><a href="#%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F">列表推导式</a></li></ul></li><li><a href="#%E5%85%83%E7%BB%84tuple">元组(tuple)</a></li><li><a href="#%E5%AD%97%E5%85%B8dict">字典(dict)</a><ul><li><a href="#%E5%A2%9E%E5%8A%A0%E5%85%83%E7%B4%A0">增加元素</a></li><li><a href="#%E8%AE%BF%E9%97%AE%E9%94%AE%E5%92%8C%E5%80%BC">访问键和值</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-1">删除元素</a></li></ul></li><li><a href="#%E9%9B%86%E5%90%88set">集合(set)</a><ul><li><a href="#%E5%88%9B%E5%BB%BAset">创建set</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0">添加元素</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-2">删除元素</a></li></ul></li></ul></li><li><a href="#%E5%87%BD%E6%95%B0">函数</a><ul><li><a href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">匿名函数</a></li></ul></li><li><a href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99">文件读写</a><ul><li><a href="#%E8%AF%BB%E6%96%87%E4%BB%B6">读文件</a></li><li><a href="#%E5%86%99%E6%96%87%E4%BB%B6">写文件</a></li><li><a href="#%E5%BC%82%E5%B8%B8">异常</a></li></ul></li></ul></li></ul><h1 id="Python复习"><a href="#Python复习" class="headerlink" title="Python复习"></a>Python复习</h1><p>一种解释型动态语言，语法简洁优雅但是性能低。</p><h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><h3 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h3><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><ol><li><p>区分大小写</p></li><li><p>关键字不能作为标识符。</p></li><li><p>标识符首位可以用下画线“_”但是<strong>不可以是数字</strong>。</p></li><li><p>除去首字母，其他位可以使用下画线“_”，数字和字母。</p></li><li><p>不能使用内置函数作为标识符。</p></li></ol><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> keyword<span class="hljs-meta">&gt;&gt;&gt; </span>keyword.kwlist[<span class="hljs-string">&#x27;False&#x27;</span>, <span class="hljs-string">&#x27;None&#x27;</span>, <span class="hljs-string">&#x27;True&#x27;</span>, <span class="hljs-string">&#x27;__peg_parser__&#x27;</span>, <span class="hljs-string">&#x27;and&#x27;</span>, <span class="hljs-string">&#x27;as&#x27;</span>, <span class="hljs-string">&#x27;assert&#x27;</span>, <span class="hljs-string">&#x27;async&#x27;</span>, <span class="hljs-string">&#x27;await&#x27;</span>, <span class="hljs-string">&#x27;break&#x27;</span>, <span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;continue&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>, <span class="hljs-string">&#x27;del&#x27;</span>, <span class="hljs-string">&#x27;elif&#x27;</span>, <span class="hljs-string">&#x27;else&#x27;</span>, <span class="hljs-string">&#x27;except&#x27;</span>, <span class="hljs-string">&#x27;finally&#x27;</span>, <span class="hljs-string">&#x27;for&#x27;</span>, <span class="hljs-string">&#x27;from&#x27;</span>, <span class="hljs-string">&#x27;global&#x27;</span>, <span class="hljs-string">&#x27;if&#x27;</span>, <span class="hljs-string">&#x27;import&#x27;</span>, <span class="hljs-string">&#x27;in&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;lambda&#x27;</span>, <span class="hljs-string">&#x27;nonlocal&#x27;</span>, <span class="hljs-string">&#x27;not&#x27;</span>, <span class="hljs-string">&#x27;or&#x27;</span>, <span class="hljs-string">&#x27;pass&#x27;</span>, <span class="hljs-string">&#x27;raise&#x27;</span>, <span class="hljs-string">&#x27;return&#x27;</span>, <span class="hljs-string">&#x27;try&#x27;</span>, <span class="hljs-string">&#x27;while&#x27;</span>, <span class="hljs-string">&#x27;with&#x27;</span>, <span class="hljs-string">&#x27;yield&#x27;</span>]</code></pre></div><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>False</td><td>None</td><td>True</td><td>and</td><td>assert</td><td>as</td><td>async</td><td>await</td><td>break</td><td>class</td></tr><tr><td>continue</td><td>def</td><td>elif</td><td>else</td><td>except</td><td>finally’</td><td>for</td><td>from</td><td>global</td><td>if</td></tr><tr><td>import</td><td>in</td><td>is</td><td>lambda</td><td>nonlocal</td><td>not</td><td>or</td><td>pass</td><td>raise</td><td>try</td></tr><tr><td>while</td><td>with</td><td>yield</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="变量和数据类型"><a href="#变量和数据类型" class="headerlink" title="变量和数据类型"></a>变量和数据类型</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li><p>整数 ，允许在数字中间以<code>_</code>分隔<code>10_000_000_000</code>&#x3D;<code>10000000000</code></p></li><li><p>浮点数，运算可能会有四舍五入的误差</p></li><li><p>字符串，<code>&quot;&quot;</code>和<code>&#39;&#39;</code>等价，常用转义：</p><div class="code-wrapper"><pre><code class="hljs txt">\&#x27;表示单引号\&quot;表示双引号\n表示换行\t表示制表符\\表示的\%%表示一个%</code></pre></div><p><code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义</p><p>用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容</p></li><li><p>布尔值：<code>True</code> or <code>False</code> </p><p>使用或<code>or</code>且<code>and</code>非<code>not</code>运算</p></li><li><p>空值：<code>None</code></p></li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li><p>变量可以是任意数据类型。</p></li><li><p>变量本身类型不固定。</p></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><ol><li><p>占位符</p> <div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hi, %s, you have $%d.&#x27;</span> % (<span class="hljs-string">&#x27;Yorick&#x27;</span>, <span class="hljs-number">1000000</span>)<span class="hljs-string">&#x27;Hi, Yorick, you have $1000000.&#x27;</span></code></pre></div><table><thead><tr><th align="left">占位符</th><th align="left">替换内容</th></tr></thead><tbody><tr><td align="left">%d</td><td align="left">整数</td></tr><tr><td align="left">%f</td><td align="left">浮点数</td></tr><tr><td align="left">%s</td><td align="left">字符串</td></tr><tr><td align="left">%x</td><td align="left">十六进制整数</td></tr></tbody></table></li><li><p>format()</p> <div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">17.125</span>)<span class="hljs-string">&#x27;Hello, 小明, 成绩提升了 17.1%&#x27;</span></code></pre></div></li><li><p>f-string</p> <div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>r = <span class="hljs-number">2.5</span><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-number">3.14</span> * r ** <span class="hljs-number">2</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;The area of a circle with radius <span class="hljs-subst">&#123;r&#125;</span> is <span class="hljs-subst">&#123;s:<span class="hljs-number">.2</span>f&#125;</span>&#x27;</span>)The area of a circle <span class="hljs-keyword">with</span> radius <span class="hljs-number">2.5</span> <span class="hljs-keyword">is</span> <span class="hljs-number">19.62</span></code></pre></div></li></ol><h4 id="索引-下标"><a href="#索引-下标" class="headerlink" title="索引(下标)"></a>索引(下标)</h4><div class="code-wrapper"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;ABCDEFGHIJKLMN&#x27;</span>s1 = s[<span class="hljs-number">0</span>]<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;s[0] = &#x27;</span> + s1)   <span class="hljs-comment">#s[0] = A</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;s[3] = &#x27;</span>+ s[<span class="hljs-number">3</span>])  <span class="hljs-comment">#s[3] = D</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;倒数第三个数为：&#x27;</span> + s[-<span class="hljs-number">3</span>])   <span class="hljs-comment">#倒数第三个数为：L</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;最后一个数为：&#x27;</span> + s[-<span class="hljs-number">1</span>])     <span class="hljs-comment">#最后一个数为：N</span></code></pre></div><h4 id="切片-顾头不顾尾"><a href="#切片-顾头不顾尾" class="headerlink" title="切片(顾头不顾尾)"></a>切片(顾头不顾尾)</h4><p>截取一部分字符串</p><div class="code-wrapper"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;ABCDEFGHIJKLMN&#x27;</span>s2 = s[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;s[0:3] = &#x27;</span> + s2)     <span class="hljs-comment"># s[0:3] = ABC</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;整个字符串如下：&#x27;</span> + s[:])    <span class="hljs-comment"># 整个字符串如下：ABCDEFGHIJKLMN</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;整个字符串如下：&#x27;</span> + s[<span class="hljs-number">0</span>:])   <span class="hljs-comment"># 整个字符串如下：ABCDEFGHIJKLMN</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;前两个字符：&#x27;</span> + s[:<span class="hljs-number">2</span>])      <span class="hljs-comment"># 前两个字符：AB</span></code></pre></div><h4 id="跳取"><a href="#跳取" class="headerlink" title="跳取"></a>跳取</h4><p><code>s[首:尾:步长]</code></p><div class="code-wrapper"><pre><code class="hljs python">s3 = <span class="hljs-string">&#x27;ABCDEFGHIJKLMN&#x27;</span><span class="hljs-built_in">print</span>(s3[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>:<span class="hljs-number">2</span>])    <span class="hljs-comment">#ACE</span><span class="hljs-built_in">print</span>(s3[::<span class="hljs-number">2</span>])      <span class="hljs-comment">#ACEGIKM</span><span class="hljs-built_in">print</span>(s3[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>])   <span class="hljs-comment">#倒着取:EDCB</span><span class="hljs-built_in">print</span>(s3[<span class="hljs-number">3</span>::-<span class="hljs-number">1</span>])    <span class="hljs-comment">#DCBA</span><span class="hljs-built_in">print</span>(s3[-<span class="hljs-number">1</span>::-<span class="hljs-number">1</span>])   <span class="hljs-comment">#NMLKJIHGFEDCBA</span></code></pre></div><h4 id="首字母大写"><a href="#首字母大写" class="headerlink" title="首字母大写"></a>首字母大写</h4><p><code>capitalize()</code></p><div class="code-wrapper"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;yorick&#x27;</span>s4_1 = s.capitalize()  <span class="hljs-comment">#首字母大写</span><span class="hljs-built_in">print</span>(s4_1)   <span class="hljs-comment">#Yorick</span></code></pre></div><h4 id="全部大写"><a href="#全部大写" class="headerlink" title="全部大写"></a>全部大写</h4><p><code>upper()</code></p><div class="code-wrapper"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;yorick&#x27;</span>s4_2 = s.upper() <span class="hljs-comment">#全部大写</span><span class="hljs-built_in">print</span>(s4_2)   <span class="hljs-comment">#YORICK</span></code></pre></div><h4 id="全部小写"><a href="#全部小写" class="headerlink" title="全部小写"></a>全部小写</h4><p><code>lower()</code></p><div class="code-wrapper"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;YoRick&#x27;</span>s4_3 = s.lower() <span class="hljs-comment">#全部小写</span><span class="hljs-built_in">print</span>(s4_3)   <span class="hljs-comment">#yorick</span></code></pre></div><h4 id="大小写互换"><a href="#大小写互换" class="headerlink" title="大小写互换"></a>大小写互换</h4><p><code>swapcase()</code></p><div class="code-wrapper"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;alexWUsir&#x27;</span>s4_4 = s.swapcase() <span class="hljs-comment">#大小写互换</span><span class="hljs-built_in">print</span>(s4_4)   <span class="hljs-comment">#ALEXwuSIR</span></code></pre></div><h4 id="标题化"><a href="#标题化" class="headerlink" title="标题化"></a>标题化</h4><p><code>title()</code></p><p>非字母后的第一个字母将转换为大写字母</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;this is string example from yorick....wow!!!&quot;</span><span class="hljs-built_in">print</span> (<span class="hljs-built_in">str</span>.title())<span class="hljs-comment"># This Is String Example From Yorick....Wow!!!</span>s = <span class="hljs-string">&quot;HAPPY BIRTHDAY&quot;</span><span class="hljs-built_in">print</span>(s.title())<span class="hljs-comment"># Happy Birthday</span></code></pre></div><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p><code>find()</code>通过元素找索引，找到返回索引，找不到返回<code>-1</code><br><code>index()</code>通过元素找索引，找到返回索引，找不到返回<code>error</code></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;yorick&quot;</span>res1 = <span class="hljs-built_in">str</span>.find(<span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;str.find(&#x27;c&#x27;) =&quot;</span>,res1)<span class="hljs-comment"># str.find(&#x27;c&#x27;) = 4</span>res2 = <span class="hljs-built_in">str</span>.find(<span class="hljs-string">&#x27;p&#x27;</span>)<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;str.find(&#x27;p&#x27;) =&quot;</span>,res2)<span class="hljs-comment"># str.find(&#x27;p&#x27;) = -1</span>res3 = <span class="hljs-built_in">str</span>.index(<span class="hljs-string">&#x27;c&#x27;</span>)<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;str.index(&#x27;c&#x27;) =&quot;</span>,res3)<span class="hljs-comment"># str.index(&#x27;c&#x27;) = 4</span>res4 = <span class="hljs-built_in">str</span>.index(<span class="hljs-string">&#x27;p&#x27;</span>)<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;str.index(&#x27;p&#x27;) =&quot;</span>,res4)<span class="hljs-comment"># ValueError: substring not found</span></code></pre></div><p><code>if i in str:</code></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;----------------检验非法（敏感）字符-------------------&#x27;</span>)s = <span class="hljs-string">&#x27;gcu木木gckhb&#x27;</span><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;木木&#x27;</span> <span class="hljs-keyword">in</span> s:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;您的评论有敏感字符&#x27;</span>)</code></pre></div><h4 id="删除字符串前后的空格-字符"><a href="#删除字符串前后的空格-字符" class="headerlink" title="删除字符串前后的空格&#x2F;字符"></a>删除字符串前后的空格&#x2F;字符</h4><div class="code-wrapper"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;  alexW%Usir  %2%  &#x27;</span>s9_1 = s.strip()   <span class="hljs-comment"># 删除字符串前后的空格</span><span class="hljs-built_in">print</span>(s9_1)   <span class="hljs-comment">#alexW%Usir  %2%</span>ss = <span class="hljs-string">&#x27;% alexW%Usir  %2%  %&#x27;</span>s9_2 = ss.strip(<span class="hljs-string">&#x27;%&#x27;</span>)   <span class="hljs-comment"># 删除字符串前后的%</span><span class="hljs-built_in">print</span>(s9_2)  <span class="hljs-comment"># alexW%Usir  %2%　　</span></code></pre></div><h4 id="计算某字符-字符串的个数"><a href="#计算某字符-字符串的个数" class="headerlink" title="计算某字符&#x2F;字符串的个数"></a>计算某字符&#x2F;字符串的个数</h4><div class="code-wrapper"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;alexaa wusirl&#x27;</span>s10 = s.count(<span class="hljs-string">&#x27;a&#x27;</span>)<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;此字符串中有&#x27;</span> + s10 + <span class="hljs-string">&#x27;个a&#x27;</span>)   <span class="hljs-comment"># 报错：TypeError: must be str, not int</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;此字符串中有&#x27;</span> + <span class="hljs-built_in">str</span>(s10) + <span class="hljs-string">&#x27;个a&#x27;</span>)    <span class="hljs-comment"># 此字符串中有3个a</span></code></pre></div><h4 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h4><p><code>split() : str -&gt; list</code></p><div class="code-wrapper"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;alex wusir taibai&#x27;</span>s1 = <span class="hljs-string">&#x27;ale:x wus:ir :taibai&#x27;</span>s11_1 = s.split()<span class="hljs-built_in">print</span>(s11_1)    <span class="hljs-comment">#[&#x27;alex&#x27;, &#x27;wusir&#x27;, &#x27;taibai&#x27;]</span>s11_2 = s1.split(<span class="hljs-string">&#x27;:&#x27;</span>)<span class="hljs-built_in">print</span>(s11_2)   <span class="hljs-comment">#[&#x27;ale&#x27;, &#x27;x wus&#x27;, &#x27;ir &#x27;, &#x27;taibai&#x27;]</span></code></pre></div><h4 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h4><p><code>replace()</code></p><div class="code-wrapper"><pre><code class="hljs python">s13_0 = <span class="hljs-string">&#x27;小明，哈喽你好，我是小明&#x27;</span>s13_1 = s13_0.replace(<span class="hljs-string">&#x27;小明&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)s13_2 = s13_0.replace(<span class="hljs-string">&#x27;小明&#x27;</span>,<span class="hljs-string">&#x27;张三&#x27;</span>)s13_3 = s13_0.replace(<span class="hljs-string">&#x27;小明&#x27;</span>,<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">1</span>)<span class="hljs-built_in">print</span>(s13_1)<span class="hljs-comment"># ，哈喽你好，我是</span><span class="hljs-built_in">print</span>(s13_2)<span class="hljs-comment"># 张三，哈喽你好，我是张三</span><span class="hljs-built_in">print</span>(s13_3)<span class="hljs-comment"># 张三，哈喽你好，我是小明</span></code></pre></div><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>使用<code>,</code>拼接，会用空格分隔</p><p>使用<code>+</code>拼接，不会用空格分隔</p><div class="code-wrapper"><pre><code class="hljs python">str1 = <span class="hljs-string">&quot;hello&quot;</span>str2 = <span class="hljs-string">&quot;yorick&quot;</span><span class="hljs-built_in">print</span>(str1,str2)<span class="hljs-comment"># hello yorick</span><span class="hljs-built_in">print</span>(str1+str2)<span class="hljs-comment"># helloyorick</span></code></pre></div><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>条件判断</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> &lt;条件判断<span class="hljs-number">1</span>&gt;:    &lt;执行<span class="hljs-number">1</span>&gt;<span class="hljs-keyword">elif</span> &lt;条件判断<span class="hljs-number">2</span>&gt;:    &lt;执行<span class="hljs-number">2</span>&gt;<span class="hljs-keyword">elif</span> &lt;条件判断<span class="hljs-number">3</span>&gt;:    &lt;执行<span class="hljs-number">3</span>&gt;<span class="hljs-keyword">else</span>:    &lt;执行<span class="hljs-number">4</span>&gt;</code></pre></div><h3 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h3><p>有序</p><p><code>classmates = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]</code></p><h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p>追加元素到末尾</p><div class="code-wrapper"><pre><code class="hljs python">classmates.append(<span class="hljs-string">&#x27;Adam&#x27;</span>)classmates.append(<span class="hljs-string">&#x27;Adam&#x27;</span>)<span class="hljs-built_in">print</span>(classmates)<span class="hljs-comment"># [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</span></code></pre></div><p>插入到指定的位置</p><div class="code-wrapper"><pre><code class="hljs python">classmates.insert(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>)<span class="hljs-built_in">print</span>(classmates)<span class="hljs-comment"># [&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</span></code></pre></div><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>删除list末尾的元素，用<code>pop()</code>方法：</p><div class="code-wrapper"><pre><code class="hljs python">classmates.pop()<span class="hljs-built_in">print</span>(classmates)[<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Tracy&#x27;</span>]</code></pre></div><p>要删除指定位置的元素，用<code>pop(i)</code>方法，其中<code>i</code>是索引位置：</p><div class="code-wrapper"><pre><code class="hljs python">classmates.pop(<span class="hljs-number">1</span>)<span class="hljs-built_in">print</span>(classmates)[<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Tracy&#x27;</span>]</code></pre></div><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p><code>sort()</code></p><div class="code-wrapper"><pre><code class="hljs python">s = [<span class="hljs-number">93</span>,<span class="hljs-number">95</span>,<span class="hljs-number">86</span>,<span class="hljs-number">98</span>,<span class="hljs-number">99</span>,<span class="hljs-number">99</span>,<span class="hljs-number">89</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">97</span>]<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;原列表：&quot;</span>,s)s.sort()<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;升序：&quot;</span>,s)s.sort(reverse=<span class="hljs-literal">True</span>)<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;降序：&quot;</span>,s)<span class="hljs-comment"># 原列表： [93, 95, 86, 98, 99, 99, 89, 100, 100, 97]</span><span class="hljs-comment"># 升序： [86, 89, 93, 95, 97, 98, 99, 99, 100, 100]</span><span class="hljs-comment"># 降序： [100, 100, 99, 99, 98, 97, 95, 93, 89, 86]</span></code></pre></div><h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><p>效率&gt;普通for循环</p><p><code>[表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] ]</code></p><div class="code-wrapper"><pre><code class="hljs python">a_range = <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)<span class="hljs-comment"># 对a_range执行for表达式</span>a_list = [x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a_range]<span class="hljs-comment"># a_list集合包含10个元素</span><span class="hljs-built_in">print</span>(a_list)<span class="hljs-comment"># [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs python"> <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">语法一：</span><span class="hljs-string">    exp1：在for循环中，如果x的值满足条件表达式condition(即条件表达式成立)，返回exp1；条件表达式不成立则不返回</span><span class="hljs-string">    x：for循环中变量</span><span class="hljs-string">    data：一个序列（比如：列表/元组/字符串等）</span><span class="hljs-string">    condition：条件表达式</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>[exp1 <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data <span class="hljs-keyword">if</span> condition]<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">语法二：</span><span class="hljs-string">    exp1：在for循环中，如果x的值满足条件表达式condition(即条件表达式成立)，返回exp1；条件表达式不成立则返回exp2</span><span class="hljs-string">    condition：条件表达式</span><span class="hljs-string">    exp2：在for循环中，如果x的值满足条件表达式condition(即条件表达式成立)，返回exp1；条件表达式不成立则返回exp2</span><span class="hljs-string">    x：for循环中变量</span><span class="hljs-string">    data：个序列（比如：列表/元组/字符串等）</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>[exp1 <span class="hljs-keyword">if</span> condition <span class="hljs-keyword">else</span> exp2 <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data]</code></pre></div><p> 示例：获取 0 ~ 20 的所有偶数并且乘以 10，并返回所有计算之后的结果</p><div class="code-wrapper"><pre><code class="hljs python">list1 = [x*<span class="hljs-number">10</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">21</span>) <span class="hljs-keyword">if</span> x%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>] <span class="hljs-built_in">print</span>(list1)<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(list1))<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">输出结果：</span><span class="hljs-string">[0, 20, 40, 60, 80, 100, 120, 140, 160, 180, 200]</span><span class="hljs-string">&lt;class &#x27;list&#x27;&gt;</span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre></div><p> 将 0 ~ 20 的偶数乘以 10 ，奇数乘以 100 ，并返回所有计算之后的结果。</p><div class="code-wrapper"><pre><code class="hljs py">list2 = [x*<span class="hljs-number">10</span> <span class="hljs-keyword">if</span> x%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> x*<span class="hljs-number">100</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">21</span>) ]<span class="hljs-built_in">print</span>(list2)<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(list2))<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">输出结果：</span><span class="hljs-string">[0, 100, 20, 300, 40, 500, 60, 700, 80, 900, 100, 1100, 120, 1300, 140, 1500, 160, 1700, 180, 1900, 200]</span><span class="hljs-string">&lt;class &#x27;list&#x27;&gt;</span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre></div><h3 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h3><p>有序，tuple和list非常类似，但是tuple一旦初始化就不能修改。没有append()，insert()这样的方法。其他获取元素的方法和list一样。</p><p><code>classmates = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)</code></p><h3 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典(dict)"></a>字典(dict)</h3><p>键值对形式存储数据，键不可重复（相同键会重写值）。</p><div class="code-wrapper"><pre><code class="hljs python">d = &#123;<span class="hljs-string">&#x27;Michael&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>: <span class="hljs-number">75</span>, <span class="hljs-string">&#x27;Tracy&#x27;</span>: <span class="hljs-number">85</span>&#125;<span class="hljs-built_in">print</span>(d[<span class="hljs-string">&#x27;Michael&#x27;</span>]) <span class="hljs-comment"># 95</span><span class="hljs-built_in">print</span>(d.get(<span class="hljs-string">&#x27;Michael&#x27;</span>)) <span class="hljs-comment"># 95</span></code></pre></div><p>也可以这样创建字典</p><div class="code-wrapper"><pre><code class="hljs python">thisdict = <span class="hljs-built_in">dict</span>(name = <span class="hljs-string">&quot;John&quot;</span>, age = <span class="hljs-number">36</span>, country = <span class="hljs-string">&quot;Norway&quot;</span>)<span class="hljs-built_in">print</span>(thisdict)</code></pre></div><h4 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h4><div class="code-wrapper"><pre><code class="hljs python">d[<span class="hljs-string">&#x27;Yorick&#x27;</span>] = <span class="hljs-number">99</span><span class="hljs-built_in">print</span>(d)<span class="hljs-comment"># &#123;&#x27;Michael&#x27;: 95, &#x27;Bob&#x27;: 75, &#x27;Tracy&#x27;: 85, &#x27;Yorick&#x27;: 99&#125;</span></code></pre></div><h4 id="访问键和值"><a href="#访问键和值" class="headerlink" title="访问键和值"></a>访问键和值</h4><p><code>d.keys()</code></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>d = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">30</span>&#125;<span class="hljs-meta">&gt;&gt;&gt; </span>d&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">30</span>&#125;<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(d.keys())[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]</code></pre></div><p><code>d.values()</code></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>d = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">30</span>&#125;<span class="hljs-meta">&gt;&gt;&gt; </span>d&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">30</span>&#125;<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(d.values())[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]</code></pre></div><h4 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h4><div class="code-wrapper"><pre><code class="hljs python">d.pop(<span class="hljs-string">&#x27;Bob&#x27;</span>)<span class="hljs-built_in">print</span>(d)<span class="hljs-comment"># &#123;&#x27;Michael&#x27;: 95, &#x27;Tracy&#x27;: 85, &#x27;Yorick&#x27;: 99&#125;</span></code></pre></div><h3 id="集合-set"><a href="#集合-set" class="headerlink" title="集合(set)"></a>集合(set)</h3><p>set和dict类似，也是一组key的集合，但不存储value。在set中，没有重复的key。</p><h4 id="创建set"><a href="#创建set" class="headerlink" title="创建set"></a>创建set</h4><p>要创建一个set，需要提供一个list作为输入集合：</p><div class="code-wrapper"><pre><code class="hljs python">s = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>])<span class="hljs-built_in">print</span>(s)<span class="hljs-comment"># &#123;1, 2, 3&#125;</span></code></pre></div><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p><code>s.add()</code></p><h4 id="删除元素-2"><a href="#删除元素-2" class="headerlink" title="删除元素"></a>删除元素</h4><p><code>s.remove(key)</code></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><div class="code-wrapper"><pre><code class="hljs python">L = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> n: n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>, <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>)))<span class="hljs-built_in">print</span>(L)<span class="hljs-comment"># [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</span></code></pre></div><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>hello.txt</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">Hello World</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;C:\Users\yurui\Desktop\test\py\hello.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)content = f.read()<span class="hljs-built_in">print</span>(content)f.close()<span class="hljs-comment"># Hello World</span></code></pre></div><p>使用with，自动调用<code>close()</code></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;C:\Users\yurui\Desktop\test\py\hello.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:    content = f.read()    <span class="hljs-built_in">print</span>(content)    <span class="hljs-comment"># Hello World</span></code></pre></div><p>要读取非UTF-8编码的文本文件，需要给<code>open()</code>函数传入<code>encoding</code>参数，例如，读取GBK编码的文件：</p><div class="code-wrapper"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;C:\Users\yurui\Desktop\test\py\hello.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;gbk&#x27;</span>)</code></pre></div><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>写文件和读文件是一样的，唯一区别是调用<code>open()</code>函数时，传入标识符<code>&#39;w&#39;</code>或者<code>&#39;wb&#39;</code>表示写文本文件或写二进制文件：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>f.write(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>f.close()</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:    f.write(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>)</code></pre></div><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><a href="https://zhuanlan.zhihu.com/p/321408784">python 异常捕获方法总结</a></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;try...&#x27;</span>)    r = <span class="hljs-number">10</span> / <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;2&#x27;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;result:&#x27;</span>, r)<span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ValueError:&#x27;</span>, e)<span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ZeroDivisionError:&#x27;</span>, e)<span class="hljs-keyword">else</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;no error!&#x27;</span>)<span class="hljs-keyword">finally</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;finally...&#x27;</span>)<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;END&#x27;</span>)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
      <tag>课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性回归算法</title>
    <link href="/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    <url>/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="线性回归算法"><a href="#线性回归算法" class="headerlink" title="线性回归算法"></a>线性回归算法</h1><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p><img src="/./img/image-20230227081749262.png" alt="image-20230227081749262"><br>$$<br>h_{\theta}(x)&#x3D;\sum_{i&#x3D;0}^{n}\theta_{i}x_{i} &#x3D; \theta^{T}x<br>$$</p><h2 id="误差"><a href="#误差" class="headerlink" title="误差"></a>误差</h2><p><img src="/./img/image-20230227082419902.png" alt="image-20230227082419902"></p><p><img src="/./img/image-20230227083626427.png" alt="image-20230227083626427"></p><h2 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h2><p>样本数 * 单个样本误差</p><p><img src="/./img/image-20230227085712494.png" alt="image-20230227085712494"></p><p><strong>对数似然</strong></p><p>两边取对数，化简</p><p><img src="/./img/image-20230227090806923.png" alt="image-20230227090806923"></p><p>偏导求极小值</p><p><img src="/./img/image-20230227092357871.png" alt="image-20230227092357871"></p><h2 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h2><p><img src="/./img/image-20230227092708283.png" alt="image-20230227092708283"></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
      <tag>线性回归</tag>
      
      <tag>课程笔记</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习入门</title>
    <link href="/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
    <url>/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习入门"><a href="#机器学习入门" class="headerlink" title="机器学习入门"></a>机器学习入门</h1><h2 id="机器学习概述"><a href="#机器学习概述" class="headerlink" title="机器学习概述"></a>机器学习概述</h2><p>机器学习的含义是基于样本数据(即已有的“训练数据”)建立数学模型，以便做出预测或决策，从而给出人们指导性的建议和意见。</p><h3 id="常用应用"><a href="#常用应用" class="headerlink" title="常用应用"></a>常用应用</h3><p><img src="/./img/image-20230213082305737.png" alt="image-20230213082305737"></p><h3 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h3><p><img src="/./img/image-20230213082341521.png" alt="image-20230213082341521"></p><p>用的最广泛：回归和分类</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>机器学习是从数据中自动分析获得模型，并利用模型对未知数据进行预测。机器学习一般流程大致分为<strong>数据采集</strong>、<strong>预处理数据</strong>、<strong>特征提取</strong>以及<strong>训练模型</strong>和<strong>评估模型</strong>，然后优化模型等步骤，如图所示。</p><p><img src="/./img/image-20230213082648977.png" alt="image-20230213082648977"></p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><h3 id="（1）数据集、特征和标签"><a href="#（1）数据集、特征和标签" class="headerlink" title="（1）数据集、特征和标签"></a>（1）数据集、特征和标签</h3><table><thead><tr><th>Housing Median Age（房龄 特征）</th><th>Total Rooms（总数 特征）</th><th>Total Bedrooms（卧室 特征）</th><th>MedianHouseValue（价格 标签）</th></tr></thead><tbody><tr><td>15</td><td>5612</td><td>1283</td><td>66900</td></tr><tr><td>19</td><td>7650</td><td>1901</td><td>80100</td></tr><tr><td>17</td><td>720</td><td>174</td><td>85700</td></tr><tr><td>14</td><td>1501</td><td>337</td><td>73400</td></tr><tr><td>20</td><td>1454</td><td>326</td><td>65500</td></tr></tbody></table><p>数据集：表中全部信息</p><p>特征：自变量</p><p>标签：因变量</p><p><img src="/./img/image-20230213084428305.png" alt="image-20230213084428305"></p><h3 id="（2）训练集、验证集和测试集"><a href="#（2）训练集、验证集和测试集" class="headerlink" title="（2）训练集、验证集和测试集"></a>（2）训练集、验证集和测试集</h3><p><strong>训练集（Train set）</strong>—— 用于训练模型，拟合的数据样本。</p><p><strong>验证集（Development set）</strong>—— 是模型训练过程中单独留出的样本集，它可以用于调整模型的超参数和优化算法。</p><p><strong>测试集（Test set）</strong>—— 对于已经构建和训练好的机器学习模型进行各方面的性能评估。</p><h3 id="（3）数据预处理"><a href="#（3）数据预处理" class="headerlink" title="（3）数据预处理"></a>（3）数据预处理</h3><p>一个数据集中通常会存在以下问题：</p><ul><li>数据缺失（Incomplete） 是属性值为空的情况。</li><li>数据噪声（Noisy）是数据值不合常理的情况。</li><li>数据不一致（Inconsistent）是数据前后存在矛盾的情况。</li><li>数据冗余（Redundant）是数据量或者属性数目超出数据分析需要的情况。</li><li>数据集不均衡 （Imbalance）是各个类别的数据量相差悬殊的情况。</li><li>离群点&#x2F;异常值 （Outliers）是远离数据集中其余部分的数据。</li><li>数据重复（Duplicate）是在数据集中出现多次的数据。</li></ul><p>对于数据中存在的问题，数据的预处理主要有以下方法与步骤，包括：</p><ul><li>(1)数据清洗 (Data Cleansing)</li><li>(2)数据转换 (Data Transformation)</li><li>(3)数据描述 (Data Description)</li><li>(4)特征选择 (Feature Selection)</li><li>(5)特征抽取 (Feature Extraction)</li></ul><h4 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h4><p>占用50%—80%时间</p><p>（1）缺失值清洗</p><ul><li>确定缺失值范围。</li><li>去除不需要的字段。</li><li>填充缺失内容。</li></ul><p>（2）格式内容清洗</p><ul><li>时间、日期、数值、全半角等显示格式不一致</li><li>内容中有不该存在的字符</li><li>内容与该字段应有内容不符</li></ul><p>（3）第三步：逻辑错误清洗</p><ul><li>去除冗余数据</li><li>去除不合理值</li><li>修正矛盾内容</li></ul><h4 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h4><p><strong>原因</strong>：某些算法要求样本具有零均值和单位方差；需要消除样本不同属性具有不同量级时的影响。</p><p>①数量级的差异将导致量级较大的属性占据主导地位；</p><p>②数量级的差异将导致迭代收敛速度减慢；</p><p>③依赖于样本距离的算法对于数据的数量级非常敏感。</p><p><strong>常用方法</strong></p><ol><li><p>min-max标准化（归一化）</p></li><li><p>z-score标准化（规范化）</p></li></ol><h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>选择相关特征，合并离散特征，去除无关特征。</p><p><strong>常用算法</strong></p><p>熵增益(Entropy information ain)，分支定界（Branch and bound，Sequential forward(序列前向选择), Sequential backward(序列反向选择), Simulated annealing(模拟退火), Tabu search(竞技搜索), Genetic algorithms(遗传算法)。</p><h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>在对于数据集进行<strong>预处理</strong>和<strong>特征提取</strong>以后，需要利用<strong>训练集</strong>建立<strong>预测模型</strong>，然后将这种训练好的模型应用于<strong>测试集</strong>（即作为新的、未见过的数据）上进行预测。根据模型在测试集上的表现来选择最佳模型，为了获得最佳模型，还需要进行<strong>参数优化</strong>。</p><p><img src="/./img/image-20230213091840071.png" alt="机器学习算法构建过程"></p><p><strong>泛化：</strong>使算法模型的应用场景更普遍</p><h2 id="模型拟合"><a href="#模型拟合" class="headerlink" title="模型拟合"></a>模型拟合</h2><h3 id="模型的过（欠）拟合"><a href="#模型的过（欠）拟合" class="headerlink" title="模型的过（欠）拟合"></a>模型的过（欠）拟合</h3><p>衡量算法模型泛化能力的好坏，最直观的表现就是模型的过拟合（Overfitting）和欠拟合（Underfitting）</p><p><img src="/./img/image-20230213093231014.png" alt="image-20230213093231014"></p><p>过拟合是指训练误差和测试误差之间的差距太大，模型复杂度高于实际问题，模型在训练集上表现很好，但在测试集上却表现很差。</p><p>欠拟合一般是由于训练样本被提取的特征比较少，样本数理不足，导致训练出来的模型不能很好地匹配算法模型，数据预测表现得很差，甚至样本本身都无法高效的识别。</p><p>在机器学习与深度学习中，对于模型欠拟合，一般是由于训练数据量太少，我们只有再去增加训练数据的数据量来避免模型欠拟合。对于模型过拟合，我们一般使用<strong>交叉验证</strong>(Cross-Validation)和正则化来避免模型过拟合。</p><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><p><strong>LOOCV方法，即（Leave-one-out cross-validation留一交叉验证）</strong></p><p>LOOCV方法包含将数据集分为训练集和测试集，只用一个数据作为测试集，其他的数据都作为训练集，并将此步骤重复N次（N为数据集的数据数量）。计算量大。</p><p><strong>K折交叉验证(K-fold Cross Validation)</strong></p><p>和LOOCV的不同在于，我们每次的测试集将不再只包含一个数据，而是多个，具体数目将根据K的选取决定。</p><h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><p>混淆矩阵(Confusion matrix)是机器学习中总结分类模型预测结果的情形分析表，以矩阵形式将数据集中的记录按照真实的类别与分类模型预测的类别判断两个标准进行汇总。其中矩阵的行表示预测值，矩阵的列表示真实值，以二分类为例，看下矩阵表现形式，如表：</p><table><thead><tr><th align="center">混淆矩阵</th><th align="center"></th><th align="center">预测值</th><th align="center">预测值</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"><strong>P</strong></td><td align="center"><strong>N</strong></td></tr><tr><td align="center"><strong>真实值</strong></td><td align="center"><strong>P</strong></td><td align="center">TP</td><td align="center">FN</td></tr><tr><td align="center"><strong>真实值</strong></td><td align="center"><strong>N</strong></td><td align="center">FP</td><td align="center">TN</td></tr></tbody></table><p>(1) 准确率(Accuracy)&#x3D;所有预测正确的样本&#x2F;总的样本（TP+TN）&#x2F;总样本数<br>$$<br>Accuracy&#x3D;\frac{TP+TN}{TP+TN+FP+FN}<br>$$</p><p>(2) 精确率(Precision)&#x3D;将正类预测为正类&#x2F;所有预测为正类 TP&#x2F;（TP+FP）<br>$$<br>Precision&#x3D;\frac{TP}{TP+FP}<br>$$</p><p>(3) 召回率(Recall) &#x3D; 将正类预测为正类&#x2F;所有正真的正类 TP&#x2F;（TP+FN）<br>$$<br>Recall&#x3D;\frac{TP}{TP+FN}<br>$$<br>(4) F-Measure（又称为F-Score）<br>$$<br>F&#x3D;\frac{(a^2+1)P<em>R}{a^2(P+R)}<br>$$<br>特别的：当参数α&#x3D;1时，就是最常见的F1值测量,即为：<br>$$<br>F&#x3D;\frac{2</em>P*R}{P+R}<br>$$</p><h3 id="ROC曲线"><a href="#ROC曲线" class="headerlink" title="ROC曲线"></a>ROC曲线</h3><p>ROC(Receiver Operating Characteristic 受试者操作特征曲线)是一个画在二维平面上的曲线—ROC Curve。<br>$$<br>TPR&#x3D;\frac{TP}{TP+FN}<br>$$<br>在所有实际为阳性的样本中，被正确地判断为阳性之比率<br>$$<br>FPR&#x3D;\frac{FP}{FP+TN}<br>$$<br>在所有实际为阴性的样本中，被错误地判断为阳性之比率</p><p><img src="/./img/image-20230213104128560.png" alt="image-20230213104128560"></p><p>对于一个预测模型来说，我们希望：</p><ol><li>分类正确的数量越多越好，TPR越大越好。</li><li>分类错误的数量越少越好，FPR越小越好。</li><li>最理想的情况是经过坐标（0，1）。</li><li>当TPR&#x3D;FPR,无论是输入是正例还是负例， 都预测为正例和负例各一半（图中虚线的部分）。</li></ol><h3 id="AUC曲线"><a href="#AUC曲线" class="headerlink" title="AUC曲线"></a>AUC曲线</h3><p>AUC（Area Under ROC Curve）是一种用来度量分类模型好坏的另一个标准。虽然用ROC Curve来表示分类器的性能很直观，但是一般希望能有一个数值来标志分类器的好坏，于是Area Under roc Curve(AUC)就出现了。顾名思义，AUC的值就是处于ROC Curve下方的那部分面积的大小。通常，AUC的值介于0.5到1.0之间，较大的AUC代表了分类器较好的性能，如图3-6。AUC被定义为ROC曲线下的面积(ROC的积分)，通常大于0.5小于1。随机挑选一个正样本以及一个负样本，分类器判定正样本的值高于负样本的概率就是 AUC 值。AUC值(面积)越大的分类器，性能越好。</p><p><img src="/./img/image-20230213105902502.png" alt="image-20230213105902502"></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
      <tag>课程笔记</tag>
      
      <tag>AI</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>酷客工具箱使用文档</title>
    <link href="/Project/CookTools-doc/"/>
    <url>/Project/CookTools-doc/</url>
    
    <content type="html"><![CDATA[<h1 id="酷客工具箱使用文档"><a href="#酷客工具箱使用文档" class="headerlink" title="酷客工具箱使用文档"></a>酷客工具箱使用文档</h1><ul><li><a href="#%E9%85%B7%E5%AE%A2%E5%B7%A5%E5%85%B7%E7%AE%B1%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3">酷客工具箱使用文档</a><ul><li><a href="#%E6%BB%A1%E8%A1%80%E5%85%85%E7%94%B5%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97">满血充电使用指南</a><ul><li><a href="#%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6">前提条件</a></li><li><a href="#%E6%BF%80%E6%B4%BBshizuku%E5%B9%B6%E6%8E%88%E6%9D%83">激活Shizuku并授权</a></li><li><a href="#%E9%99%8D%E7%BA%A7%E5%AE%89%E8%A3%85%E7%BB%84%E4%BB%B6">降级安装组件</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%BB%A1%E8%A1%80%E5%85%85%E7%94%B5">使用满血充电</a><ul><li><a href="#%E6%96%87%E5%AD%97%E6%95%99%E7%A8%8B">文字教程</a></li><li><a href="#%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B">视频教程</a></li></ul></li></ul></li><li><a href="#%E7%94%B5%E9%87%8F%E7%BB%9F%E8%AE%A1">电量统计</a></li><li><a href="#%E9%94%81%E9%A2%91%E6%AE%B5">锁频段</a><ul><li><a href="#%E5%AE%89%E8%A3%85%E7%BB%84%E4%BB%B6">安装组件</a></li><li><a href="#%E5%85%B7%E4%BD%93%E6%95%99%E7%A8%8B">具体教程</a></li></ul></li><li><a href="#%E7%8A%B6%E6%80%81%E6%A0%8F%E6%98%BE%E7%A7%92">状态栏显秒</a></li><li><a href="#%E5%86%BB%E7%BB%93%E5%BA%94%E7%94%A8">冻结应用</a></li><li><a href="#%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD">资源下载</a><ul><li><a href="#%E5%8A%A0%E7%BE%A4%E4%B8%8B%E8%BD%BD">加群下载</a></li><li><a href="#github%E4%B8%8B%E8%BD%BD">Github下载</a></li></ul></li><li><a href="#%E5%85%8D%E8%B4%A3%E5%A3%B0%E6%98%8E">免责声明</a></li><li><a href="#%E9%9A%90%E7%A7%81%E5%8D%8F%E8%AE%AE">隐私协议</a></li><li><a href="#%E5%8F%AF%E7%94%A8%E5%90%8D%E5%8D%95">可用名单</a></li></ul></li></ul><h2 id="满血充电使用指南"><a href="#满血充电使用指南" class="headerlink" title="满血充电使用指南"></a>满血充电使用指南</h2><p><strong>仅部分vivo&#x2F;iqoo手机可用</strong>，<a href="#%E5%8F%AF%E7%94%A8%E5%90%8D%E5%8D%95">可用名单</a>正在更新中…</p><p>这个功能就是借助系统的<strong>开发测试工具</strong>解除系统充电功率限制，实现<strong>满血充电</strong>，但是可能会带来<strong>发热</strong>等不可预知的问题。视频教程注意，最后要<strong>点充放</strong>防止因为异常降低功率！</p><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul><li>使用<strong>原装</strong>充电器和数据线良好的<strong>散热环境</strong>，建议使用<strong>散热背夹</strong>。</li><li>系统应用<strong>电源信息</strong>版本符合条件(1.2或1.6，不同机型不同版本)。</li></ul><p><img src="/./img/image-20230215212701019.png" alt="image-20230215212701019"></p><p>出现这个问题<strong>很正常</strong>，请<strong>严格</strong>按照以下步骤启用：</p><h3 id="激活Shizuku并授权"><a href="#激活Shizuku并授权" class="headerlink" title="激活Shizuku并授权"></a>激活Shizuku并授权</h3><ol><li><p>下载Shizuku</p><p>(<a href="https://shizuku.rikka.app/zh-hans/download/">下载 | Shizuku (rikka.app)</a>)</p></li><li><p>激活SHizuku</p><p>激活方法：<a href="https://shizuku.rikka.app/zh-hans/guide/setup/">用户手册 | Shizuku (rikka.app)</a></p></li></ol><p>下图为<strong>激活正常界面</strong>：<strong>只有出现这个界面才能正常使用工具箱的功能</strong></p><p><img src="/./img/image-20230215214000030.png" alt="image-20230215214000030"></p><h3 id="降级安装组件"><a href="#降级安装组件" class="headerlink" title="降级安装组件"></a>降级安装组件</h3><ol><li><p>下载组件，两个版本<strong>二选一</strong>，详见<a href="#%E5%8F%AF%E7%94%A8%E5%90%8D%E5%8D%95">可用名单</a></p><table><thead><tr><th>名称</th><th>版本</th><th>链接</th></tr></thead><tbody><tr><td>电源信息</td><td>1.2</td><td><a href="https://yorick.love/file/%E7%94%B5%E6%BA%90%E4%BF%A1%E6%81%AF-com.vivo.fuelsummary-1.2.apk">点此下载</a></td></tr><tr><td>电源信息</td><td>1.6</td><td><a href="https://yorick.love/file/%E7%94%B5%E6%BA%90%E4%BF%A1%E6%81%AF-com.vivo.fuelsummary-1.6.apk">点此下载</a></td></tr></tbody></table></li><li><p>下载后找到<strong>安装包</strong>，点击后选择<strong>降级安装</strong>：</p><p><img src="/./img/image-20230215212820439.png" alt="image-20230215212820439"></p><p>如果找不到上面这个界面，进入<strong>酷客工具箱—Shell界面—点击安装应用</strong>，找到安装包并安装。</p><p><img src="/./img/image-20230215214322048.png" alt="image-20230215214322048"></p></li></ol><h3 id="使用满血充电"><a href="#使用满血充电" class="headerlink" title="使用满血充电"></a>使用满血充电</h3><p>完成<a href="#%E6%BF%80%E6%B4%BBShizuku%E5%B9%B6%E6%8E%88%E6%9D%83">激活Shizuku并授权</a>、<a href="#%E9%99%8D%E7%BA%A7%E5%AE%89%E8%A3%85%E7%BB%84%E4%BB%B6">降级安装组件</a>后，你就可用正式使用<strong>满血充电</strong>。</p><h4 id="文字教程"><a href="#文字教程" class="headerlink" title="文字教程"></a>文字教程</h4><p>感谢群友<a href="">@张三</a>提供的文字教程</p><p><img src="/./img/IMG_20221003_000108.jpg" alt="IMG_20221003_000108"></p><h4 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h4><p>注意，最后要<strong>点充放</strong>，防止因为异常降低充电功率！（视频没提到）</p><blockquote><p><a href="https://www.bilibili.com/video/BV1Fj411K7G4/">教程视频点此</a></p></blockquote><iframe src="//player.bilibili.com/player.html?aid=436962585&bvid=BV1Fj411K7G4&cid=1010286469&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="400px" width="100%"> </iframe><hr><h2 id="电量统计"><a href="#电量统计" class="headerlink" title="电量统计"></a>电量统计</h2><p>对于电量统计看不了的<strong>vivo&#x2F;iqoo</strong>手机</p><p>在shell界面</p><ul><li>iqoo 冻结<code>com.iqoo.powersaving</code></li><li>vivo 冻结<code>com.iqoo.powersaving</code></li></ul><p><img src="/./img/image-20230216131730019.png" alt="image-20230216131730019"></p><hr><h2 id="锁频段"><a href="#锁频段" class="headerlink" title="锁频段"></a>锁频段</h2><p>通过手动锁定 Band 来提高某些场景下的网络速度。</p><h3 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h3><p>如果出现以下界面或者<strong>打开失败</strong>弹窗，说明您的<strong>组件版本不匹配</strong>，</p><p>请下载组件，<a href="https://yorick.love/file/NetworkState.apk">NetworkState.apk</a></p><p>参考<a href="#%E9%99%8D%E7%BA%A7%E5%AE%89%E8%A3%85%E7%BB%84%E4%BB%B6">降级安装组件</a>安装即可。</p><p><img src="/./img/image.png" alt="image"></p><h3 id="具体教程"><a href="#具体教程" class="headerlink" title="具体教程"></a>具体教程</h3><p>选择<strong>锁 Band</strong>，进入后勾选要锁定频段，然后点击<strong>确定</strong>。</p><p><img src="/./img/image_1.png" alt="image_1"></p><p><img src="/./img/image_2.png" alt="image_2"></p><p>下面是一些参考，<strong>具体还要看你的环境</strong>，正常来讲手机自动选择最佳频段。但在是某些情况下，比如学校宿舍这种无线网络设备很多的地方，大量设备抢占最优频段，导致网络卡顿，这是选择<strong>次优</strong>的频段反而更快。</p><p><img src="/./img/image_3.png" alt="image_3"></p><p><img src="/./img/image_4.png" alt="image_4"></p><p class="note note-warning">以上数据仅供参考</p> <hr><h2 id="状态栏显秒"><a href="#状态栏显秒" class="headerlink" title="状态栏显秒"></a>状态栏显秒</h2><p>这个功能就是让你的状态栏显示<strong>实时秒数</strong>，这是安卓自带的功能，但是在很多定制系统被隐藏了，这里提供入口。</p><p>小米手机由于系统魔改无法使用这个功能！</p><p>点击<strong>状态栏</strong></p><p><img src="/./img/image_5.png" alt="点击状态栏"></p><p>​下滑找到<strong>时间</strong></p><p><img src="/./img/image_6.png" alt="下滑找到时间"></p><p>选中<strong>显示小时、分钟和秒</strong></p><p><img src="/./img/image_7.png" alt="选择显示小时、分钟和秒"></p><hr><h2 id="冻结应用"><a href="#冻结应用" class="headerlink" title="冻结应用"></a>冻结应用</h2><p>就是禁用这个应用，让他不会消耗系统资源，也无法使用，可以冻结一些不需要的应用，达到省电的目的。</p><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><h3 id="加群下载"><a href="#加群下载" class="headerlink" title="加群下载"></a>加群下载</h3><p>本站流量资源有限，无法支撑大的下载量。</p><p>建议<strong>加入 QQ 群-群文件-组件下载获取，群号：641096366</strong></p><p>群里还有老哥帮你解决问题，但是在问问题之前，一定要<strong>先在文档中找一下</strong>。99%的答案都在本篇文档中了。</p><h3 id="Github下载"><a href="#Github下载" class="headerlink" title="Github下载"></a>Github下载</h3><table><thead><tr><th>组件名称</th><th>下载地址</th><th>作用&#x2F;功能</th></tr></thead><tbody><tr><td>电源信息1.2</td><td><a href="https://github.com/Yorick-Ryu/CokoTools/tree/master/data">点击此处</a></td><td>满血充电</td></tr><tr><td>电源信息1.6</td><td><a href="https://github.com/Yorick-Ryu/CokoTools/tree/master/data">点击此处</a></td><td>满血充电</td></tr><tr><td>工厂测试1.5</td><td><a href="https://github.com/Yorick-Ryu/CokoTools/tree/master/data">点击此处</a></td><td></td></tr><tr><td>NetworkState</td><td><a href="https://github.com/Yorick-Ryu/CokoTools/tree/master/data">点击此处</a></td><td>锁频段</td></tr></tbody></table><p>进去找到所需的组件进行下载</p><hr><h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>本软件（酷客工具箱）和本文档仅供学习交流使用，使用本软件所造成的一切后果请用户自行承担，使用本软件即代表用户同意此声明。</p><hr><h2 id="隐私协议"><a href="#隐私协议" class="headerlink" title="隐私协议"></a>隐私协议</h2><p>本软件所需的互联网访问权限仅用于：</p><ul><li>获取服务器的工具数据</li><li>采用Bugly采集应用崩溃信息，完善应用功能。<a href="https://bugly.qq.com/v2/contract">Bugly隐私协议</a></li></ul><p>使用本软件代表您同意本软件的隐私协议。</p><hr><h2 id="可用名单"><a href="#可用名单" class="headerlink" title="可用名单"></a>可用名单</h2><p>满血充电</p><p>正在统计中，欢迎评论区留言</p><p><strong>名单上没有不代表不可用</strong><br><strong>名单上没有不代表不可用</strong><br><strong>名单上没有不代表不可用</strong></p><table><thead><tr><th>机型</th><th>系统版本</th></tr></thead><tbody><tr><td>iQOO</td><td>OriginOS 2.0</td></tr><tr><td>IQOO 3</td><td>OriginOS 3.0</td></tr><tr><td>IQOO 7</td><td>8.9.5</td></tr><tr><td>IQOO 8 &#x2F; 8 Pro</td><td>最新</td></tr><tr><td>IQOO 9 Pro</td><td>最新</td></tr><tr><td>IQOO 10 &#x2F; 10 Pro</td><td>最新</td></tr><tr><td>IQOO 11</td><td>7.19</td></tr><tr><td>IQOO Z3</td><td>OriginOS 2.0</td></tr><tr><td>IQOO Z5 &#x2F; Z5x</td><td>OriginOS 2.0</td></tr><tr><td>IQOO Neo5 &#x2F; 5s &#x2F; 活力版</td><td>OriginOS 3.0</td></tr><tr><td>IQOO Neo6</td><td>OriginOS 3.0</td></tr><tr><td>IQOO Neo7</td><td>13.1.9.1</td></tr><tr><td>vivo X90 Pro+</td><td>19.1</td></tr></tbody></table><hr><p><strong>如何您觉得软件或者文档有用，可以请我喝杯冰镇快乐水。</strong></p><p><img src="/./img/wechat_donate_code.png" alt="微信扫码赞赏"></p><hr><p><strong>支付宝每日红包，每天都有，建议保存下来每日扫码领红包。</strong></p><p><img src="/./img/alipay.jpg" alt="扫码每日领红包！"></p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>doc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android使用Proto_DataStore</title>
    <link href="/Android/Android%E4%BD%BF%E7%94%A8Proto-DataStore/"/>
    <url>/Android/Android%E4%BD%BF%E7%94%A8Proto-DataStore/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Proto-DataStore存储数据"><a href="#使用Proto-DataStore存储数据" class="headerlink" title="使用Proto DataStore存储数据"></a>使用Proto DataStore存储数据</h1><p>摘自：</p><p><a href="https://developer.android.com/topic/libraries/architecture/datastore?hl=zh-cn">应用架构：数据层 - DataStore - Android 开发者  | Android Developers</a></p><p><a href="https://developer.android.com/codelabs/android-proto-datastore?hl=zh-cn">使用 Proto DataStore  | Android Developers</a></p><h2 id="什么是-DataStore？"><a href="#什么是-DataStore？" class="headerlink" title="什么是 DataStore？"></a><strong>什么是 DataStore？</strong></h2><p>DataStore 是经过改进的新版数据存储解决方案，旨在取代 SharedPreferences。DataStore 基于 Kotlin 协程和 Flow 构建，提供以下两种不同的实现：<strong>Proto DataStore</strong>，用于存储<strong>类型化对象</strong>（由<a href="https://developers.google.com/protocol-buffers?hl=zh-cn">协议缓冲区</a>支持）；<strong>Preferences DataStore</strong>，用于存储<strong>键值对</strong>。DataStore 以异步、一致的事务方式存储数据，克服了 SharedPreferences 的一些缺点。</p><h2 id="DataStore-基础知识"><a href="#DataStore-基础知识" class="headerlink" title="DataStore - 基础知识"></a>DataStore - 基础知识</h2><p>您可能经常需要存储较小或简单的数据集。为此，您过去可能使用过 SharedPreferences，但此 API 也存在一系列缺点。Jetpack DataStore 库旨在解决这些问题，从而创建一个简单、安全性更高的异步 API 来存储数据。它提供 2 种不同的实现：</p><ul><li>Preferences DataStore</li><li>Proto DataStore</li></ul><table><thead><tr><th><strong>功能</strong></th><th><strong>SharedPreferences</strong></th><th><strong>PreferencesDataStore</strong></th><th><strong>ProtoDataStore</strong></th></tr></thead><tbody><tr><td>异步 API</td><td>✅（仅用于通过<a href="https://developer.android.com/reference/android/content/SharedPreferences.OnSharedPreferenceChangeListener?hl=zh-cn">监听器</a>读取已更改的值）</td><td>✅（通过 <code>Flow</code> 以及 RxJava 2 和 3 <code>Flowable</code>）</td><td>✅（通过 <code>Flow</code> 以及 RxJava 2 和 3 <code>Flowable</code>）</td></tr><tr><td>同步 API</td><td>✅（但无法在界面线程上安全调用）</td><td>❌</td><td>❌</td></tr><tr><td>可在界面线程上安全调用</td><td>❌(1)</td><td>✅（这项工作已在后台移至 <code>Dispatchers.IO</code>）</td><td>✅（这项工作已在后台移至 <code>Dispatchers.IO</code>）</td></tr><tr><td>可以提示错误</td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td>不受运行时异常影响</td><td>❌(2)</td><td>✅</td><td>✅</td></tr><tr><td>包含一个具有强一致性保证的事务性 API</td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td>处理数据迁移</td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td>类型安全</td><td>❌</td><td>❌</td><td>✅ 使用<a href="https://developers.google.com/protocol-buffers?hl=zh-cn">协议缓冲区</a></td></tr></tbody></table><p>(1) SharedPreferences 有一个看上去可以在界面线程中安全调用的同步 API，但是该 API 实际上执行磁盘 I&#x2F;O 操作。此外，<code>apply()</code> 会阻断 <code>fsync()</code> 上的界面线程。每次有服务启动或停止以及每次 activity 在应用中的任何地方启动或停止时，系统都会触发待处理的 <code>fsync()</code> 调用。界面线程在 <code>apply()</code> 调度的待处理 <code>fsync()</code> 调用上会被阻断，这通常会导致 <a href="https://developer.android.com/topic/performance/vitals/anr?hl=zh-cn">ANR</a>。</p><p>(2) SharedPreferences 会将解析错误作为运行时异常抛出。</p><h3 id="Preferences-DataStore-与-Proto-DataStore"><a href="#Preferences-DataStore-与-Proto-DataStore" class="headerlink" title="Preferences DataStore 与 Proto DataStore"></a><strong>Preferences DataStore 与 Proto DataStore</strong></h3><p>虽然 Preferences DataStore 和 Proto DataStore 都允许保存数据，但它们保存数据的方式不同：</p><ul><li>与 SharedPreferences 一样，<strong>Preferences DataStore</strong> 根据键访问数据，而无需事先定义架构。</li><li><strong>Proto DataStore</strong> 使用<a href="https://developers.google.com/protocol-buffers?hl=zh-cn">协议缓冲区</a>来定义架构。使用协议缓冲区可<strong>持久保留强类型数据</strong>。与 XML 和其他类似的数据格式相比，协议缓冲区速度更快、规格更小、使用更简单，并且更清楚明了。虽然使用 Proto DataStore 需要学习新的序列化机制，但我们认为 Proto DataStore 有着强大的类型优势，值得学习。</li></ul><h3 id="Room-与-DataStore"><a href="#Room-与-DataStore" class="headerlink" title="Room 与 DataStore"></a><strong>Room 与 DataStore</strong></h3><p>如果您需要实现部分更新、引用完整性或大型&#x2F;复杂数据集，您应考虑使用 Room，而不是 DataStore。DataStore 非常适合小型或简单的数据集，但不支持部分更新或引用完整性。</p><h2 id="Proto-DataStore-概览"><a href="#Proto-DataStore-概览" class="headerlink" title="Proto DataStore - 概览"></a>Proto DataStore - 概览</h2><p>SharedPreferences 和 Preferences DataStore 的一个缺点是无法定义架构，保证不了存取键时使用了正确的数据类型。Proto DataStore 可利用<a href="https://developers.google.com/protocol-buffers?hl=zh-cn">协议缓冲区</a>定义架构来解决此问题。通过使用协议，DataStore 可以知道存储的类型，并且无需使用键便能提供类型。</p><h2 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a><strong>添加依赖项</strong></h2><p>为了使用 Proto DataStore，让协议缓冲区为我们的架构生成代码，我们需要对 build.gradle 文件进行一些更改：</p><ul><li>添加协议缓冲区插件</li><li>添加协议缓冲区和 Proto DataStore 依赖项</li><li>配置协议缓冲区</li></ul><div class="code-wrapper"><pre><code class="hljs groovy">plugins &#123;    ...    id <span class="hljs-string">&quot;com.google.protobuf&quot;</span> version <span class="hljs-string">&quot;0.8.17&quot;</span>&#125;dependencies &#123;    implementation  <span class="hljs-string">&quot;androidx.datastore:datastore-core:1.0.0&quot;</span>    implementation  <span class="hljs-string">&quot;com.google.protobuf:protobuf-javalite:3.18.0&quot;</span>    ...&#125;protobuf &#123;    protoc &#123;        artifact = <span class="hljs-string">&quot;com.google.protobuf:protoc:3.14.0&quot;</span>    &#125;    <span class="hljs-comment">// Generates the java Protobuf-lite code for the Protobufs in this project. See</span>    <span class="hljs-comment">// https://github.com/google/protobuf-gradle-plugin#customizing-protobuf-compilation</span>    <span class="hljs-comment">// for more information.</span>    generateProtoTasks &#123;        all().each &#123; task -&gt;            task.builtins &#123;                java &#123;                    option <span class="hljs-string">&#x27;lite&#x27;</span>                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="使用Proto-DataStore"><a href="#使用Proto-DataStore" class="headerlink" title="使用Proto DataStore"></a>使用Proto DataStore</h2><h3 id="定义架构"><a href="#定义架构" class="headerlink" title="定义架构"></a>定义架构</h3><h4 id="定义和使用-protobuf-对象"><a href="#定义和使用-protobuf-对象" class="headerlink" title="定义和使用 protobuf 对象"></a>定义和使用 protobuf 对象</h4><p>协议缓冲区是一种对结构化数据进行序列化的机制。您只需对数据结构化的方式进行一次定义，编译器便会生成源代码，轻松写入和读取结构化数据。</p><h4 id="创建-proto-文件"><a href="#创建-proto-文件" class="headerlink" title="创建 proto 文件"></a><strong>创建 proto 文件</strong></h4><p>您可以在 proto 文件中定义架构。在此 Codelab 中，我们有两个用户偏好设置：<code>show_completed</code> 和 <code>sort_order</code>；目前两者以两种不同的对象来表示。因此，我们的一个目标是将这两个标志统一到存储在 DataStore 中的一个 <code>UserPreferences</code> 类下。我们将在协议缓冲区架构而非 Kotlin 中定义该类。</p><p>请查看 <a href="https://developers.google.com/protocol-buffers/docs/overview?hl=zh-cn">Proto 语言指南</a>，深入了解关于语法的信息。在此 Codelab 中，我们仅关注我们需要使用的类型。</p><p>在 <code>app/src/main/proto</code> 目录中创建一个名为 <code>user_prefs.proto</code> 的新文件。如果您未看到此文件夹结构，请切换到<strong>项目视图</strong>。在协议缓冲区中，每个结构都使用一个 <code>message</code> 关键字进行定义，并且结构中的每一个成员都会根据类型和名称在消息内进行定义，从而获得从 1 开始的排序。</p><p>示例：</p><div class="code-wrapper"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<span class="hljs-keyword">option</span> java_package = <span class="hljs-string">&quot;com.example.application&quot;</span>;<span class="hljs-keyword">option</span> java_multiple_files = <span class="hljs-literal">true</span>;<span class="hljs-keyword">message </span><span class="hljs-title class_">Settings</span> &#123;  <span class="hljs-type">int32</span> example_counter = <span class="hljs-number">1</span>;&#125;</code></pre></div><p class="note note-warning">注意：您的存储对象的类在编译时由 proto 文件中定义的 message 生成。请务必重新构建您的项目。</p><h3 id="创建-Proto-DataStore"><a href="#创建-Proto-DataStore" class="headerlink" title="创建 Proto DataStore"></a>创建 Proto DataStore</h3><p>创建 Proto DataStore 来存储类型化对象涉及两个步骤：</p><ol><li>定义一个实现 <code>Serializer&lt;T&gt;</code> 的类，其中 <code>T</code> 是 proto 文件中定义的类型。此序列化器类会告知 DataStore 如何读取和写入您的数据类型。请务必为该序列化器添加默认值，以便在尚未创建任何文件时使用。</li><li>使用由 <code>dataStore</code> 创建的属性委托来创建 <code>DataStore&lt;T&gt;</code> 的实例，其中 <code>T</code> 是在 proto 文件中定义的类型。在您的 Kotlin 文件顶层调用该实例一次，便可在应用的所有其余部分通过此属性委托访问该实例。<code>filename</code> 参数会告知 DataStore 使用哪个文件存储数据，而 <code>serializer</code> 参数会告知 DataStore 第 1 步中定义的序列化器类的名称。</li></ol><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> SettingsSerializer : Serializer&lt;Settings&gt; &#123;  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> defaultValue: Settings = Settings.getDefaultInstance()  <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readFrom</span><span class="hljs-params">(input: <span class="hljs-type">InputStream</span>)</span></span>: Settings &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">return</span> Settings.parseFrom(input)    &#125; <span class="hljs-keyword">catch</span> (exception: InvalidProtocolBufferException) &#123;      <span class="hljs-keyword">throw</span> CorruptionException(<span class="hljs-string">&quot;Cannot read proto.&quot;</span>, exception)    &#125;  &#125;  <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">writeTo</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    t: <span class="hljs-type">Settings</span>,</span></span><span class="hljs-params"><span class="hljs-function">    output: <span class="hljs-type">OutputStream</span>)</span></span> = t.writeTo(output)&#125;<span class="hljs-keyword">val</span> Context.settingsDataStore: DataStore&lt;Settings&gt; <span class="hljs-keyword">by</span> dataStore(  fileName = <span class="hljs-string">&quot;settings.pb&quot;</span>,  serializer = SettingsSerializer)</code></pre></div><h3 id="从-Proto-DataStore-读取内容"><a href="#从-Proto-DataStore-读取内容" class="headerlink" title="从 Proto DataStore 读取内容"></a>从 Proto DataStore 读取内容</h3><p>使用 <code>DataStore.data</code> 显示所存储对象中相应属性的 <code>Flow</code>。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> exampleCounterFlow: Flow&lt;<span class="hljs-built_in">Int</span>&gt; = context.settingsDataStore.<span class="hljs-keyword">data</span>  .map &#123; settings -&gt;    <span class="hljs-comment">// The exampleCounter property is generated from the proto schema.</span>    settings.exampleCounter  &#125;</code></pre></div><h3 id="将内容写入-Proto-DataStore"><a href="#将内容写入-Proto-DataStore" class="headerlink" title="将内容写入 Proto DataStore"></a>将内容写入 Proto DataStore</h3><p>Proto DataStore 提供了一个 <a href="https://developer.android.com/reference/kotlin/androidx/datastore/core/DataStore?hl=zh-cn#updatedata"><code>updateData()</code></a> 函数，用于以事务方式更新存储的对象。<code>updateData()</code> 为您提供数据的当前状态，作为数据类型的一个实例，并在原子读-写-修改操作中以事务方式更新数据。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">incrementCounter</span><span class="hljs-params">()</span></span> &#123;  context.settingsDataStore.updateData &#123; currentSettings -&gt;    currentSettings.toBuilder()      .setExampleCounter(currentSettings.exampleCounter + <span class="hljs-number">1</span>)      .build()    &#125;&#125;</code></pre></div><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><a href="https://developer.android.com/topic/libraries/architecture/datastore?hl=zh-cn#synchronous">在同步代码中使用 DataStore</a></p><p><a href="https://developer.android.com/topic/libraries/architecture/datastore?hl=zh-cn#multiprocess">在多进程代码中使用 DataStore</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jetpack</tag>
      
      <tag>DataStore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android开屏动画</title>
    <link href="/Android/Android%E5%BC%80%E5%B1%8F%E5%8A%A8%E7%94%BB/"/>
    <url>/Android/Android%E5%BC%80%E5%B1%8F%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Android开屏动画-Splash-Screen"><a href="#Android开屏动画-Splash-Screen" class="headerlink" title="Android开屏动画(Splash Screen)"></a>Android开屏动画(Splash Screen)</h1><p>摘自：<a href="https://developer.android.com/guide/topics/ui/splash-screen?hl=zh-cn">启动画面  | Android 开发者  | Android Developers</a></p><p>从 Android 12 开始，在搭载 Android 12 或更高版本的设备上运行时，所有应用都将拥有启动动画。这包括启动时的进入应用动作、显示应用图标的启动画面，以及向应用本身的过渡。</p><h2 id="启动画面的工作原理"><a href="#启动画面的工作原理" class="headerlink" title="启动画面的工作原理"></a>启动画面的工作原理</h2><p>当用户启动应用而应用的进程未运行（<a href="https://developer.android.com/topic/performance/vitals/launch-time?hl=zh-cn#cold">冷启动</a>）或 activity 尚未创建（<a href="https://developer.android.com/topic/performance/vitals/launch-time?hl=zh-cn#warm">温启动</a>）时，会发生以下事件。（在<a href="https://developer.android.com/topic/performance/vitals/launch-time?hl=zh-cn#hot">热启动</a>期间从不显示启动画面。）</p><ol><li>系统使用主题以及您已定义的任何动画显示启动画面。</li><li>当应用准备就绪时，系统会关闭启动画面并显示应用。</li></ol><h2 id="启动画面的元素和机制"><a href="#启动画面的元素和机制" class="headerlink" title="启动画面的元素和机制"></a>启动画面的元素和机制</h2><p>启动画面的元素由 Android 清单中的 XML 资源文件定义。每个元素都有浅色模式和深色模式版本。</p><p>启动画面的可自定义元素包括应用图标、图标背景和窗口背景：</p><p>关于这些元素，请注意以下几点：</p><ol><li><strong>应用图标</strong>应该是矢量可绘制对象，它可以是静态或动画形式。虽然动画的时长可以不受限制，但我们建议不超过 1000 毫秒。默认情况下，使用启动器图标。</li><li>可以选择添加<strong>图标背景</strong>；在图标与窗口背景之间需要更高的对比度时图标背景很有用。如果您使用一个<a href="https://developer.android.com/guide/practices/ui_guidelines/icon_design_adaptive?hl=zh-cn">自适应图标</a>，当该图标与窗口背景之间的对比度足够高时，就会显示其背景。</li><li>与自适应图标一样，前景的三分之一被遮盖。</li><li><strong>窗口背景</strong>由不透明的单色组成。如果窗口背景已设置且为纯色，则未设置相应的属性时默认使用该背景。</li></ol><h3 id="启动画面尺寸"><a href="#启动画面尺寸" class="headerlink" title="启动画面尺寸"></a>启动画面尺寸</h3><p>启动画面图标使用的规范与<a href="https://developer.android.com/guide/practices/ui_guidelines/icon_design_adaptive?hl=zh-cn">自适应图标</a>相同，如下所示：</p><ul><li>品牌图片：尺寸应为 200×80 dp。</li><li>带有图标背景的应用图标：尺寸应为 240×240 dp，并且位于直径 160 dp 的圆圈内。</li><li>无图标背景的应用图标：尺寸应为 288×288 dp，并且位于直径 192 dp 的圆圈内。</li></ul><p>例如，如果图片的完整尺寸为 300×300 dp，则图标需要位于直径 200 dp 的圆圈内。圆圈以外的所有内容将不可见（被遮盖）。</p><h3 id="启动画面动画和启动序列"><a href="#启动画面动画和启动序列" class="headerlink" title="启动画面动画和启动序列"></a>启动画面动画和启动序列</h3><p>额外的延迟时间通常与在冷启动时启动应用有关。向启动画面添加动画图标具有明显的美感，并提供更优质的体验，除此之外，还有额外的好处：用户研究表明，在观看动画时，用户感知到的启动时间会缩短。</p><p>启动画面动画会嵌入到以下启动序列组件中。</p><ol><li>进入动画：由系统视图到启动画面组成。这由系统控制且不可自定义。</li><li>启动画面：您可以对启动画面进行自定义，从而提供自己的徽标动画和品牌形象。它必须满足本文档中所述的<a href="https://developer.android.com/guide/topics/ui/splash-screen?hl=zh-cn#splash-screen-animate-reqs">要求</a>，才能正常运行。</li><li>退出动画：由隐藏启动画面的动画运行组成。如果您要<a href="https://developer.android.com/guide/topics/ui/splash-screen?hl=zh-cn#customize-animation">对其进行自定义</a>，您将可以访问 <a href="https://developer.android.com/reference/android/window/SplashScreenView?hl=zh-cn"><code>SplashScreenView</code></a> 及其图标，并且可以在它们之上运行任何动画（需要设置转换、不透明度和颜色）。在这种情况下，当动画完成时，需要手动移除启动画面。</li></ol><p>运行图标动画时，如果应用先前已准备就绪，应用启动功能可让您选择跳过相应序列。应用会触发 <code>onResume()</code> 或者启动画面会自动超时，因此确保用户能够轻松跳过启动画面动画。只有当从视觉角度来看应用稳定后，才应通过 <code>onResume()</code> 关闭启动画面，因此无需额外的旋转图标。引入不完整的界面可能会给用户带来不快，并让用户感觉不可预知或不够完善。</p><h4 id="启动画面动画要求"><a href="#启动画面动画要求" class="headerlink" title="启动画面动画要求"></a>启动画面动画要求</h4><p>启动画面应符合以下规范：</p><ul><li>设置不透明的单一窗口背景颜色。<a href="https://developer.android.com/reference/kotlin/androidx/core/splashscreen/SplashScreen?hl=zh-cn">SplashScreen compat 库</a>同时支持日间模式和夜间模式。</li><li>确保动画图标符合以下规范：<ul><li><strong>格式</strong>：必须是<a href="https://developer.android.com/reference/android/graphics/drawable/AnimatedVectorDrawable?hl=zh-cn">动画形式的矢量可绘制对象 (AVD)</a> XML。</li><li>尺寸：AVD 图标的大小必须是自适应图标大小的四倍，如下所示：<ul><li>图标面积必须是 432 dp（即 108 dp 的 4 倍，108 dp 是无遮盖自适应图标的面积）。</li><li>图片内部三分之二的区域在启动器图标上可见，并且必须是 288 dp（即 72 dp 的四倍，72 dp 是自适应图标内部遮盖区域的面积）。</li></ul></li><li><strong>时长</strong>：我们建议在手机上的时长不超过 1,000 毫秒。您可以使用延迟启动，但不能超过 166 毫秒。如果应用启动时间超过 1000 毫秒，请考虑使用循环动画。</li></ul></li><li>确定合适的时间来关闭启动画面，这发生在应用绘制第一帧时。您可以按照本文档中<a href="https://developer.android.com/guide/topics/ui/splash-screen?hl=zh-cn#suspend-drawing">让启动画面在屏幕上显示更长时间</a>部分的说明进一步自定义此设置。</li></ul><h2 id="自定义应用中的启动画面"><a href="#自定义应用中的启动画面" class="headerlink" title="自定义应用中的启动画面"></a>自定义应用中的启动画面</h2><p>默认情况下，<code>SplashScreen</code> 使用主题的 <code>windowBackground</code>（如果它是单色）和启动器图标。启动画面的自定义通过向应用主题添加属性来完成。</p><p>您可以通过以下任一方式自定义应用的启动画面：</p><ul><li>设置主题属性以更改其外观</li><li>让其在屏幕上显示更长时间</li><li>自定义用于关闭启动画面的动画</li></ul><h3 id="设置启动画面的主题以更改其外观"><a href="#设置启动画面的主题以更改其外观" class="headerlink" title="设置启动画面的主题以更改其外观"></a>设置启动画面的主题以更改其外观</h3><p>您可以在 activity 主题中指定以下属性来自定义应用的启动画面。如果您已有使用 <code>android:windowBackground</code> 等属性的旧版启动画面实现，不妨考虑为 Android 12 及更高版本提供替代资源文件。</p><ol><li><p>使用 <a href="https://developer.android.com/reference/android/R.attr?hl=zh-cn#windowSplashScreenBackground"><code>windowSplashScreenBackground</code></a> 以特定的单色填充背景：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowSplashScreenBackground&quot;</span>&gt;</span>@color/...<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></code></pre></div></li><li><p>使用 <a href="https://developer.android.com/reference/android/R.attr?hl=zh-cn#windowSplashScreenAnimatedIcon"><code>windowSplashScreenAnimatedIcon</code></a> 替换起始窗口中心的图标。如果该对象可通过 <a href="https://developer.android.com/reference/android/graphics/drawable/AnimationDrawable?hl=zh-cn"><code>AnimationDrawable</code></a> 和 <a href="https://developer.android.com/reference/android/graphics/drawable/AnimatedVectorDrawable?hl=zh-cn"><code>AnimatedVectorDrawable</code></a> 呈现动画效果和进行绘制，那么您还需要设置 <code>windowSplashScreenAnimationDuration</code>，以在显示起始窗口的同时播放动画。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowSplashScreenAnimatedIcon&quot;</span>&gt;</span>@drawable/...<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></code></pre></div></li><li><p>使用 <a href="https://developer.android.com/reference/android/R.attr?hl=zh-cn#windowSplashScreenAnimationDuration"><code>windowSplashScreenAnimationDuration</code></a> 指示启动画面图标动画的时长。设置该时长对显示启动画面的实际时间不会产生任何影响，但您可以在自定义启动画面退出动画时使用 <a href="https://developer.android.com/guide/topics/ui/splash-screen/reference/android/window/SplashScreenView?hl=zh-cn#getIconAnimationDuration()"><code>SplashScreenView#getIconAnimationDuration</code></a> 检索图标动画的时长。如需了解详情，请参阅下一部分中的<a href="https://developer.android.com/guide/topics/ui/splash-screen?hl=zh-cn#suspend-drawing">让启动画面显示更长时间</a>。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowSplashScreenAnimationDuration&quot;</span>&gt;</span>1000<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></code></pre></div></li><li><p>使用 <code>windowSplashScreenIconBackgroundColor</code> 设置启动画面图标后面的背景。当窗口背景与图标之间的对比度不够高时，这很有用。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowSplashScreenIconBackgroundColor&quot;</span>&gt;</span>@color/...<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></code></pre></div></li><li><p>（可选）您可以使用 <a href="https://developer.android.com/reference/android/R.attr?hl=zh-cn#windowSplashScreenBrandingImage"><code>windowSplashScreenBrandingImage</code></a> 设置要显示在启动画面底部的图片。设计准则建议不要使用品牌图片。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowSplashScreenBrandingImage&quot;</span>&gt;</span>@drawable/...<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ktor配置SSL</title>
    <link href="/BackEnd/Ktor%E9%85%8D%E7%BD%AESSL/"/>
    <url>/BackEnd/Ktor%E9%85%8D%E7%BD%AESSL/</url>
    
    <content type="html"><![CDATA[<h1 id="Ktor配置SSL实现https"><a href="#Ktor配置SSL实现https" class="headerlink" title="Ktor配置SSL实现https"></a>Ktor配置SSL实现https</h1><p>参考：</p><p><a href="https://ktor.io/docs/ssl.html">SSL and certificates | Ktor</a></p><p><a href="https://ktor.kotlincn.net/quickstart/guides/ssl.html">SSL - 快速入门 - Ktor (kotlincn.net)</a></p><h2 id="生成SSL证书"><a href="#生成SSL证书" class="headerlink" title="生成SSL证书"></a>生成SSL证书</h2><p>我直接在阿里云白嫖了免费SSL证书：<a href="https://promotion.aliyun.com/ntms/act/sslbuy.html">选购SSL证书 (aliyun.com)</a></p><p>选择<code>jks</code>格式并下载解压</p><p>应该有一个<code>xxx.jks</code>文件和一个<code>jks-password.txt</code>密钥文件</p><h2 id="查看证书别名-keyAlias"><a href="#查看证书别名-keyAlias" class="headerlink" title="查看证书别名(keyAlias)"></a>查看证书别名(keyAlias)</h2><ol><li>找到电脑的JDK路径</li><li>在<code>\bin</code>中找到<code>keytool.exe</code>复制到证书所在目录</li><li>在证书所在目录运行cmd</li><li>输入<code>keytool -list -v -keystore file.jks -storepass password</code>，其中<code>file.jks</code>是证书名字，<code>password</code>要用密钥来代替。</li></ol><h2 id="在Ktor中配置SSL"><a href="#在Ktor中配置SSL" class="headerlink" title="在Ktor中配置SSL"></a>在Ktor中配置SSL</h2><p>首先，打开<code>application.conf</code></p><ol><li><p>添加<code>sslPort</code></p><div class="code-wrapper"><pre><code class="hljs conf">ktor &#123;    deployment &#123;        sslPort = 8443    &#125;&#125;</code></pre></div></li><li><p>添加security组，<code>keyStore</code>为证书路径，本地放在项目根目录，服务器和Jar包同级。</p><p><code>keyAlias</code>填入证书别称</p><p><code>keyStorePassword</code>和<code>privateKeyPassword</code>填入证书密码</p><div class="code-wrapper"><pre><code class="hljs conf">ktor &#123;    security &#123;        ssl &#123;            keyStore = keystore.jks            keyAlias = sampleAlias             keyStorePassword = foobar            privateKeyPassword = foobar        &#125;    &#125;&#125;</code></pre></div></li><li><p>重新生成Jar包并上传到服务器，同时上传jks证书文件，和Jar包在同级目录。</p><p>参考：[Ktor部署到云服务器](<a href="https://yorick.love/2023/01/26/BackEnd/Ktor%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/">https://yorick.love/2023/01/26/BackEnd/Ktor部署到云服务器/</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>BackEnd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ktor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ktor部署到云服务器</title>
    <link href="/BackEnd/Ktor%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/BackEnd/Ktor%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Ktor部署到云服务器-Linux"><a href="#Ktor部署到云服务器-Linux" class="headerlink" title="Ktor部署到云服务器(Linux)"></a>Ktor部署到云服务器(Linux)</h1><p>部署 Ktor 项目有很多种方式，包括 <strong>war、jar 或是打包在 Docker 容器内</strong>。 jar 是一种 Java 档案文件，可以将类文件打包成一个单一可运行的文件。 生成 jar 文件后，就可以通过 java -jar *.jar 的方式将程序运行起来。</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>一个准备部署的<a href="https://ktor.io/">Ktor</a>项目</li><li>一台Linux服务器（CentOS7.6），如果没有服务器可以点击<a href="https://www.aliyun.com/minisite/goods?userCode=cucsy8ip">这里</a>购买，新用户超低价！</li></ul><h2 id="打包为Jar"><a href="#打包为Jar" class="headerlink" title="打包为Jar"></a>打包为Jar</h2><p>参考：<a href="https://ktor.io/docs/fatjar.html">Creating fat JARs using the Ktor Gradle plugin | Ktor</a></p><p>To build a fat JAR, you need to configure the Ktor plugin first:</p><p>在打包为<code>fat Jar</code>之前，你需要先配置<code>Ktor plugin</code></p><ol><li><p>打开<code>build.gradle.kts</code>，在plugins中添加插件：</p><div class="code-wrapper"><pre><code class="hljs kotlin">plugins &#123;    id(<span class="hljs-string">&quot;io.ktor.plugin&quot;</span>) version <span class="hljs-string">&quot;2.2.2&quot;</span>&#125;</code></pre></div></li><li><p>确保<code>application</code>中填入<a href="https://ktor.io/docs/server-dependencies.html#create-entry-point">main</a>方法所在类名：</p><div class="code-wrapper"><pre><code class="hljs kotlin">application &#123;    mainClass.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;com.example.ApplicationKt&quot;</span>) <span class="hljs-comment">// main方法所在类名</span>&#125;</code></pre></div></li><li><p>可选项，配置打包后的文件名称 ：</p><div class="code-wrapper"><pre><code class="hljs kotlin">ktor &#123;    fatJar &#123;        archiveFileName.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;fat.jar&quot;</span>)    &#125;&#125;</code></pre></div></li><li><p>点击<code>Gradle</code>同步项目，找到buildFatJar并双击构建Jar包：</p><p><img src="/./img/image-20230126174449384.png" alt="image-20230126174449384"></p></li><li><p>打包好的文件在<code>build/libs</code>：</p><p><img src="/./img/image-20230126174735567.png" alt="image-20230126174735567"></p></li></ol><h2 id="上传Jar包并运行"><a href="#上传Jar包并运行" class="headerlink" title="上传Jar包并运行"></a>上传Jar包并运行</h2><p>服务器配置和Jar包上传参考<a href="https://blog.jetbrains.com/zh-hans/2020/05/29/ktor-cloud/#%E5%88%9B%E5%BB%BA%E9%98%BF%E9%87%8C%E4%BA%91_ECS_%E5%AE%9E%E4%BE%8B">部署 Ktor 应用至云服务器 | The JetBrains Blog</a></p><ol><li><p>服务器安装JDK，版本与项目版本一致</p><div class="code-wrapper"><pre><code class="hljs shell">yum install java-11-openjdk-devel</code></pre></div></li><li><p>上传打包好的Jar包，运行Jar包，输出日志<code>msg.log</code></p><div class="code-wrapper"><pre><code class="hljs shell">nohup java -jar ktor-sample-all.jar &gt;msg.log 2&gt;&amp;1 &amp;</code></pre></div></li><li><p>查看日志或者访问Api测试，可以直接关闭shell后台运行</p></li><li><p>停止项目</p><p>查找进程：</p><div class="code-wrapper"><pre><code class="hljs shell">ps -ef|grep java</code></pre></div><p>输出：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>     <span class="hljs-number">26847</span>     <span class="hljs-number">1</span>  <span class="hljs-number">0</span> <span class="hljs-number">16</span>:<span class="hljs-number">55</span> ?        <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">12</span> java -jar ktor-sample-<span class="hljs-literal">all</span>.jar</code></pre></div><p>找到进程ID:26847，杀死进程：</p><div class="code-wrapper"><pre><code class="hljs shell">kill -9 26847</code></pre></div></li></ol><p>参考：</p><p><a href="https://ktor.io/docs/fatjar.html">Creating fat JARs using the Ktor Gradle plugin | Ktor</a></p><p><a href="https://blog.jetbrains.com/zh-hans/2020/05/29/ktor-cloud/#%E5%88%9B%E5%BB%BA%E9%98%BF%E9%87%8C%E4%BA%91_ECS_%E5%AE%9E%E4%BE%8B">部署 Ktor 应用至云服务器 | The JetBrains Blog</a></p><p><a href="https://www.cnblogs.com/lzg-blog/p/15013598.html">Java部署jar包并后台运行 - 李宗光 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>BackEnd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ktor</tag>
      
      <tag>Linux</tag>
      
      <tag>CentOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓使用Retrofit获取网络数据</title>
    <link href="/Android/%E4%BD%BF%E7%94%A8Retrofit%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE/"/>
    <url>/Android/%E4%BD%BF%E7%94%A8Retrofit%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Retrofit获取网络数据"><a href="#使用Retrofit获取网络数据" class="headerlink" title="使用Retrofit获取网络数据"></a>使用Retrofit获取网络数据</h1><p>参考：<a href="https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-getting-data-internet">从互联网获取数据 (google.cn)</a></p><p>Retrofit官方文档：<a href="https://square.github.io/retrofit/">Retrofit (square.github.io)</a></p><h2 id="添加Retrofit依赖项"><a href="#添加Retrofit依赖项" class="headerlink" title="添加Retrofit依赖项"></a>添加Retrofit依赖项</h2><p>Android Gradle 允许您将外部库添加到项目中。除了库依赖项之外，您还需要添加托管库的代码库。</p><ol><li><p>打开模块级 Gradle 文件 <code>build.gradle</code> <code>(Module: MarsPhotos.app)</code>。</p></li><li><p>在 <code>dependencies</code> 部分，为 Retrofit 库添加以下几行代码：</p><div class="code-wrapper"><pre><code class="hljs groovy"><span class="hljs-comment">// Retrofit</span>implementation <span class="hljs-string">&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;</span><span class="hljs-comment">// Retrofit with Scalar Converter</span>implementation <span class="hljs-string">&quot;com.squareup.retrofit2:converter-scalars:2.9.0&quot;</span></code></pre></div></li></ol><p>这两个库协同工作。第一个依赖项用于 Retrofit 2 库本身，而第二个依赖项则用于 Retrofit 标量转换器。Retrofit2 是 Retrofit 库的更新版本。此标量转换器允许 Retrofit 将 JSON 结果作为 <code>String</code> 返回。</p><h2 id="添加数据层"><a href="#添加数据层" class="headerlink" title="添加数据层"></a>添加数据层</h2><p>添加一个数据层，供 <code>ViewModel</code> 用来与网络服务通信。您将按照以下步骤实现 Retrofit 服务 API。</p><ul><li>创建一个数据源：<code>XxxxApiService</code> 类。</li><li>使用基准网址和转换器工厂创建 Retrofit 对象，以转换字符串。</li><li>创建一个可说明 Retrofit 如何与网络服务器通信的接口。</li><li>创建一个 Retrofit 服务，并向应用的其余 API 服务公开实例。</li></ul><p>示例：</p><ol><li><p>右键点击 Android 项目窗格中的 <code>com.example.android.marsphotos</code> 软件包，然后依次选择 <strong>New &gt; Package</strong>。</p></li><li><p>在弹出式窗口中，将 <strong>network</strong> 附加到建议软件包名称的末尾。</p></li><li><p>在新软件包“network”下创建新的 Kotlin 文件。将该文件命名为 <code>MarsApiService</code>。</p></li><li><p>打开 <code>network/MarsApiService.kt</code>。</p></li><li><p>为网络服务的基准网址添加以下常量。</p> <div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> BASE_URL =   <span class="hljs-string">&quot;https://android-kotlin-fun-mars-server.appspot.com&quot;</span></code></pre></div></li><li><p>在该常量正下方添加 Retrofit 构建器，用于构建和创建 Retrofit 对象。</p> <div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> retrofit2.Retrofit<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> retrofit = Retrofit.Builder()</code></pre></div></li></ol><p>Retrofit 需要网络服务的基本 URI 和转换器工厂来构建网络服务 API。转换器会告知 Retrofit 如何处理它从网络服务获取的数据。在这种情况下，您需要 Retrofit 从网络服务提取 JSON 响应，并将该响应作为 <code>String</code> 返回。Retrofit 包含一个 <code>ScalarsConverter</code>，它支持字符串和其他基元类型。</p><ol start="7"><li><p>使用 <code>ScalarsConverterFactory</code> 实例对构建器调用 <code>addConverterFactory()</code>。</p> <div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> retrofit2.converter.scalars.ScalarsConverterFactory<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> retrofit = Retrofit.Builder()   .addConverterFactory(ScalarsConverterFactory.create())</code></pre></div></li><li><p>使用 <code>baseUrl()</code> 方法为网络服务添加基准网址。</p></li><li><p>调用 <code>build()</code> 以创建 Retrofit 对象。</p> <div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> retrofit = Retrofit.Builder()   .addConverterFactory(ScalarsConverterFactory.create())   .baseUrl(BASE_URL)   .build()</code></pre></div></li><li><p>在对 Retrofit 构建器的调用的下方，定义一个名为 <code>MarsApiService</code> 的接口，该接口定义 Retrofit 如何使用 HTTP 请求与网络服务器通信。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MarsApiService</span> &#123;&#125;</code></pre></div></li><li><p>向 <code>MarsApiService</code> 接口添加一个名为 <code>getPhotos()</code> 的函数，以从网络服务中获取响应字符串。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MarsApiService</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getPhotos</span><span class="hljs-params">()</span></span>&#125;</code></pre></div></li><li><p>使用 <code>@GET</code> 注解告知 Retrofit 这是 GET 请求，并为该网络服务方法指定端点。在这种情况下，端点为 <code>photos</code>。如上个任务中所述，您将在此 Codelab 中使用 <a href="https://android-kotlin-fun-mars-server.appspot.com/photos">&#x2F;photos</a> 端点。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> retrofit2.http.GET<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MarsApiService</span> &#123;    <span class="hljs-meta">@GET(<span class="hljs-string">&quot;photos&quot;</span>)</span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getPhotos</span><span class="hljs-params">()</span></span>&#125;</code></pre></div></li></ol><p>调用 <code>getPhotos()</code> 方法时，Retrofit 会将端点 <code>photos</code> 附加到您用于启动请求的基准网址（由您在 Retrofit 构建器中定义）。</p><ol start="13"><li><p>将函数的返回值类型添加到 <code>String</code>。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MarsApiService</span> &#123;    <span class="hljs-meta">@GET(<span class="hljs-string">&quot;photos&quot;</span>)</span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getPhotos</span><span class="hljs-params">()</span></span>: String&#125;</code></pre></div></li><li><p>创建MarsApi对象</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> MarsApi &#123;    <span class="hljs-keyword">val</span> retrofitService: MarsApiService <span class="hljs-keyword">by</span> lazy &#123;        retrofit.create(MarsApiService::<span class="hljs-keyword">class</span>.java)    &#125;&#125;</code></pre></div></li></ol><h2 id="在-ViewModel-中调用网络服务"><a href="#在-ViewModel-中调用网络服务" class="headerlink" title="在 ViewModel 中调用网络服务"></a>在 ViewModel 中调用网络服务</h2><p>前提：使用ViewModel管理状态。</p><h3 id="ViewModelScope"><a href="#ViewModelScope" class="headerlink" title="ViewModelScope"></a>ViewModelScope</h3><p><a href="https://developer.android.google.cn/topic/libraries/architecture/coroutines#viewmodelscope"><code>viewModelScope</code></a> 是为应用中的每个 <code>ViewModel</code> 定义的内置协程作用域。在此作用域内启动的协程会在 <code>ViewModel</code> 被清除时自动取消。</p><p>您可以使用 <code>viewModelScope</code> 启动协程，并在后台发出网络服务请求。由于 <code>viewModelScope</code> 属于 <code>ViewModel</code>，因此，即使应用发生配置更改，请求也会继续发出。</p><ol><li><p>在 <code>MarsApiService.kt</code> 文件中，将 <code>getPhotos()</code> 设置为挂起函数，使其异步，并且不会阻塞发起调用的线程。您可以从 <a href="https://developer.android.google.cn/topic/libraries/architecture/coroutines#viewmodelscope"><code>viewModelScope</code></a> 内调用此函数。</p> <div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@GET(<span class="hljs-string">&quot;photos&quot;</span>)</span><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getPhotos</span><span class="hljs-params">()</span></span>: String</code></pre></div></li><li><p>打开 <code>ui/screens/MarsViewModel.kt</code> 文件。向下滚动到 <code>getMarsPhotos()</code> 方法。删除用于将状态响应设置为 <code>&quot;Set the Mars API Response here!&quot;</code> 的代码行，使 <code>getMarsPhotos()</code> 方法为空。</p> <div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMarsPhotos</span><span class="hljs-params">()</span></span> &#123;&#125;</code></pre></div></li><li><p>在 <code>getMarsPhotos()</code> 中，使用 <code>viewModelScope.launch</code> 启动协程。</p> <div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> androidx.lifecycle.viewModelScope<span class="hljs-keyword">import</span> kotlinx.coroutines.launch<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMarsPhotos</span><span class="hljs-params">()</span></span> &#123;    viewModelScope.launch &#123;&#125;&#125;</code></pre></div></li><li><p>在 <code>viewModelScope</code> 中，使用单例对象 <code>MarsApi</code> 从 <code>retrofitService</code> 接口调用 <code>getPhotos()</code> 方法。将返回的响应保存在名为 <code>listResult</code> 的 <code>val</code> 中。</p> <div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> com.example.marsphotos.network.MarsApiviewModelScope.launch &#123;    <span class="hljs-keyword">val</span> listResult = MarsApi.retrofitService.getPhotos()&#125;</code></pre></div></li><li><p>将刚刚从后端服务器收到的结果分配给 <code>marsUiState</code>。<code>marsUiState</code> 是一个可变状态对象，表示最近的网络请求的状态。</p> <div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> listResult = MarsApi.retrofitService.getPhotos()marsUiState = listResult</code></pre></div></li><li><p>运行应用。请注意，该应用会立即关闭，不一定会显示错误弹出窗口。应用发生了崩溃。</p></li><li><p>点击 Android Studio 中的 <strong>Logcat</strong> 标签页，并记下日志中以如下所示的代码行开头的错误消息：“<code>------- beginning of crash</code>”。</p> <div class="code-wrapper"><pre><code class="hljs kotlin">    --------- beginning of crash<span class="hljs-number">22803</span>-<span class="hljs-number">22865</span>/com.example.android.marsphotos E/AndroidRuntime: FATAL EXCEPTION: OkHttp Dispatcher    Process: com.example.android.marsphotos, PID: <span class="hljs-number">22803</span>    java.lang.SecurityException: Permission denied (missing INTERNET permission?)...</code></pre></div></li></ol><p>此错误消息表示应用可能缺少 <code>INTERNET</code> 权限。下一步添加互联网权限并解决此问题。</p><h2 id="添加互联网权限和异常处理"><a href="#添加互联网权限和异常处理" class="headerlink" title="添加互联网权限和异常处理"></a>添加互联网权限和异常处理</h2><p>应用需要 <code>INTERNET</code> 权限才能访问互联网。</p><h3 id="添加互联网权限"><a href="#添加互联网权限" class="headerlink" title="添加互联网权限"></a>添加互联网权限</h3><p>在 <code>AndroidManifest.xml</code> 文件中添加 <code>&lt;uses-permission&gt;</code> 标签来声明它所需的权限。</p><ol><li>打开 <code>manifests/AndroidManifest.xml</code>。将下面这行代码添加到 <code>&lt;application&gt;</code> 标签的前面：</li></ol><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></code></pre></div><ol start="2"><li>编译并再次运行应用。</li></ol><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h3><p>如果没有进行异常处理，执行以下步骤，应用会崩溃：</p><ol><li><p>将设备或模拟器设为飞行模式，以模拟网络连接错误。</p></li><li><p>从“最近”菜单中重新打开应用，或从 Android Studio 中重启应用。</p></li><li><p>点击 Android Studio 中的 <strong>Logcat</strong> 标签页，并记下日志中如下所示的严重异常：</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">3302</span>-<span class="hljs-number">3302</span>/com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.marsphotos</span> E/AndroidRuntime: FATAL EXCEPTION: <span class="hljs-selector-tag">main</span>    Process: com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.marsphotos</span>, PID: <span class="hljs-number">3302</span></code></pre></div></li></ol><p>此错误消息表示应用尝试连接并超时。在现实环境中，诸如此类的异常非常常见。与权限问题不同，此错误无法解决，但您可以自行处理。在下一步中，您将了解如何处理此类异常。</p><p>连接到服务器时可能出现的问题包括：</p><ul><li>在 API 中使用的网址或 URI 不正确。</li><li>服务器不可用，应用无法连接到服务器。</li><li>网络延迟问题。</li><li>设备的互联网连接状况不佳或无互联网连接。</li></ul><p>这些异常无法在编译时进行处理，但您可以使用 <code>try-catch</code> 代码块在运行时处理异常。</p><p>在 <code>try</code> 代码块中，您可以在预期会引发异常的位置添加代码。在您的应用中，这会是一次网络调用。在 <code>catch</code> 代码块中，您需要实现用于防止应用突然终止的代码。如果存在异常，系统会执行 <code>catch</code> 代码块，以从错误中恢复，而不是突然终止应用。</p><ol><li><p>在 <code>getMarsPhotos()</code> 中的 <code>launch</code> 代码块内，围绕 <code>MarsApi</code> 调用添加一个 <code>try</code> 代码块来处理异常。</p></li><li><p>在 <code>try</code> 代码块之后添加一个 <code>catch</code> 代码块。</p> <div class="code-wrapper"><pre><code class="hljs kotlin">viewModelScope.launch &#123;   <span class="hljs-keyword">try</span> &#123;       <span class="hljs-keyword">val</span> listResult = MarsApi.retrofitService.getPhotos()       marsUiState = listResult   &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;   &#125;&#125;</code></pre></div></li><li><p>再次运行该应用。请注意，应用这次不会崩溃。</p></li></ol><h3 id="添加状态界面"><a href="#添加状态界面" class="headerlink" title="添加状态界面"></a>添加状态界面</h3><p>在 <code>MarsViewModel</code> 类中，最近的网络请求的状态 <code>marsUiState</code> 会保存为可变状态对象。但是，这个类缺乏保存如下不同状态的功能：正在加载、成功和失败。</p><ul><li><strong>Loading</strong>状态表示应用正在等待数据。</li><li><strong>Success</strong>状态表示已成功从网络服务检索到数据。</li><li><strong>Error</strong>状态表示存在网络或连接错误。</li></ul><p>如需表示应用中的这三种状态，您将使用封装接口。<code>sealed interface</code> 通过限制可能的值来轻松管理状态。在 Mars Photos 应用中，您将 <code>marsUiState</code> 网络响应限制为三种状态（数据类对象）：正在加载、成功和错误，如以下代码所示：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// No need to copy over</span><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MarsUiState</span> &#123;   <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Success</span> : <span class="hljs-type">MarsUiState</span>   <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Loading</span> : <span class="hljs-type">MarsUiState</span>   <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Error</span> : <span class="hljs-type">MarsUiState</span>&#125;</code></pre></div><p>在上述代码段中，如果返回成功响应，您会从服务器收到火星照片信息。为了存储数据，请向 <code>Success</code> 数据类添加一个构造函数参数。</p><p>对于 <code>Loading</code> 和 <code>Error</code> 状态，您无需设置新数据和创建新对象；只需传递网络响应即可。将 <code>data</code> 类更改为 <code>Object</code>，以便为网络响应创建对象。</p><ol><li><p>打开 <code>ui/MarsViewModel.kt</code> 文件。在 import 语句后，添加 <code>MarsUiState</code> 封装接口。添加后，<code>MarsUiState</code> 对象的值就会变得详尽。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MarsUiState</span> &#123;    <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Success</span>(<span class="hljs-keyword">val</span> photos: String) : MarsUiState    <span class="hljs-keyword">object</span> Error : MarsUiState    <span class="hljs-keyword">object</span> Loading : MarsUiState&#125;</code></pre></div></li><li><p>在 <code>MarsViewModel</code> 类中，更新 <code>marsUiState</code> 定义。将类型更改为 <code>MarsUiState</code>，将 <code>MarsUiState.Loading</code> 作为其默认值。将 setter 设为不公开，以保护写入 <code>marsUiState</code> 的内容。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> marsUiState: MarsUiState <span class="hljs-keyword">by</span> mutableStateOf(MarsUiState.Loading)  <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span></code></pre></div></li><li><p>向下滚动到 <code>getMarsPhotos()</code> 方法。将 <code>marsUiState</code> 值更新为 <code>MarsUiState.Success</code>，并传递 <code>listResult</code>。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> listResult = MarsApi.retrofitService.getPhotos()marsUiState = MarsUiState.Success(listResult)</code></pre></div></li><li><p>在 <code>catch</code> 代码块内部，处理故障响应。将 <code>MarsUiState</code> 设为 <code>Error</code>。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">catch</span> (e: IOException) &#123;   marsUiState = MarsUiState.Error&#125;</code></pre></div></li><li><p>您可以从 <code>try-catch</code> 代码块中取出 <code>marsUiState</code> 分配。完成后的函数应如以下代码所示：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMarsPhotos</span><span class="hljs-params">()</span></span> &#123;   viewModelScope.launch &#123;       marsUiState = <span class="hljs-keyword">try</span> &#123;           <span class="hljs-keyword">val</span> listResult = MarsApi.retrofitService.getPhotos()           MarsUiState.Success(listResult)       &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;           MarsUiState.Error       &#125;   &#125;&#125;</code></pre></div></li><li><p>在 <code>screens/HomeScreen.kt</code> 文件中，对 <code>marsUiState</code> 添加一个 <code>when</code> 表达式。如果 <code>marsUiState</code> 为 <code>MarsUiState.Success</code>，则调用 <code>ResultScreen</code> 并传入 <code>marsUiState.photos</code>。现阶段，请忽略错误。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">HomeScreen</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">   marsUiState: <span class="hljs-type">MarsUiState</span>,</span></span><span class="hljs-params"><span class="hljs-function">   modifier: <span class="hljs-type">Modifier</span> = Modifier</span></span><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;    <span class="hljs-keyword">when</span> (marsUiState) &#123;        <span class="hljs-keyword">is</span> MarsUiState.Success -&gt; ResultScreen(marsUiState.photos, modifier)    &#125;&#125;</code></pre></div><p class="note note-success">注意：marsUiState 属性不再是字符串。您已将其更改为 MarsUiState 封装接口，该接口有三个不同的对象值：MarsUiState.Loading、MarsUiState.Success 和 MarsUiState.Error。</p></li><li><p>在 <code>when</code> 代码块内，为 <code>MarsUiState.Loading</code> 和 <code>MarsUiState.Error</code> 添加检查项。让该应用显示 <code>LoadingScreen</code>、<code>ResultScreen</code> 和 <code>ErrorScreen</code> 可组合项，稍后您会实现这些可组合项。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">HomeScreen</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">   marsUiState: <span class="hljs-type">MarsUiState</span>,</span></span><span class="hljs-params"><span class="hljs-function">   modifier: <span class="hljs-type">Modifier</span> = Modifier</span></span><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;    <span class="hljs-keyword">when</span> (marsUiState) &#123;        <span class="hljs-keyword">is</span> MarsUiState.Loading -&gt; LoadingScreen(modifier)        <span class="hljs-keyword">is</span> MarsUiState.Success -&gt; ResultScreen(marsUiState.photos, modifier)        <span class="hljs-keyword">is</span> MarsUiState.Error -&gt; ErrorScreen(modifier)    &#125;&#125;</code></pre></div><p class="note note-success">如果实现 MarsUiState interface 时未使用 sealed 关键字，则需要添加一个 Success、Error、Loading 和 else 分支。由于没有第四个选项 (else)，因此，您可以使用 sealed 接口告知编译器只有三个选项（这会使条件语句变得详尽）</p></li><li><p>打开 <code>res/drawable/loading_animation.xml</code>。该可绘制对象是围绕中心点旋转图片可绘制对象 <code>loading_img.xml</code> 的动画。（您在预览中看不到这段动画。）</p><p><img src="/./img/92a448fa23b6d1df.png" alt="loading.png"></p></li><li><p>在 <code>screens/HomeScreen.kt</code> 文件中的 <code>HomeScreen</code> 可组合项下方，添加以下 <code>LoadingScreen</code> 可组合函数以显示加载动画。起始代码中包含 <code>loading_img</code> 可绘制资源。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> androidx.compose.ui.res.painterResource<span class="hljs-keyword">import</span> androidx.compose.ui.unit.dp<span class="hljs-keyword">import</span> androidx.compose.foundation.layout.size<span class="hljs-keyword">import</span> androidx.compose.foundation.Image<span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">LoadingScreen</span><span class="hljs-params">(modifier: <span class="hljs-type">Modifier</span> = Modifier)</span></span> &#123;    Box(        contentAlignment = Alignment.Center,        modifier = modifier.fillMaxSize()    ) &#123;        Image(            modifier = Modifier.size(<span class="hljs-number">200.</span>dp),            painter = painterResource(R.drawable.loading_img),            contentDescription = stringResource(R.string.loading)        )    &#125;&#125;</code></pre></div></li><li><p>在 <code>LoadingScreen</code> 可组合项下方，添加以下 <code>ErrorScreen</code> 可组合函数，以便应用显示错误消息。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ErrorScreen</span><span class="hljs-params">(modifier: <span class="hljs-type">Modifier</span> = Modifier)</span></span> &#123;    Box(        contentAlignment = Alignment.Center,        modifier = modifier.fillMaxSize()    ) &#123;        Text(stringResource(R.string.loading_failed))    &#125;&#125;</code></pre></div></li><li><p>再次运行应用，保持飞行模式开启状态。应用这次不会突然关闭，而是会显示错误消息：</p></li><li><p>在手机或模拟器上，关闭飞行模式。运行并测试您的应用，确保一切正常，并且您能够看到 JSON 字符串。</p></li></ol><h2 id="使用-kotlinx-serialization-解析-JSON-响应"><a href="#使用-kotlinx-serialization-解析-JSON-响应" class="headerlink" title="使用 kotlinx.serialization 解析 JSON 响应"></a>使用 kotlinx.serialization 解析 JSON 响应</h2><h3 id="添加-kotlinx-serialization-依赖项"><a href="#添加-kotlinx-serialization-依赖项" class="headerlink" title="添加 kotlinx.serialization 依赖项"></a>添加 <code>kotlinx.serialization</code> 依赖项</h3><ol><li><p>打开 **build.gradle (Module: app)**。</p></li><li><p>在 <code>plugins</code> 代码块中，添加 <code>kotlinx serialization</code> 插件。</p>   <div class="code-wrapper"><pre><code class="hljs groovy">id <span class="hljs-string">&#x27;org.jetbrains.kotlin.plugin.serialization&#x27;</span> version <span class="hljs-string">&#x27;1.7.10&#x27;</span></code></pre></div></li><li><p>在“dependencies”部分，添加以下代码以包含 <code>kotlinx.serialization</code> 依赖项。此依赖项可为 Kotlin 项目提供 JSON 序列化。</p>   <div class="code-wrapper"><pre><code class="hljs groovy"><span class="hljs-comment">// Kotlin serialization</span>implementation <span class="hljs-string">&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.4.1&quot;</span></code></pre></div></li><li><p>在 <code>dependencies</code> 代码块中，找到 Retrofit 标量转换器所在的代码行，并将其更改为使用 <code>kotlinx-serialization-converter</code>：</p><p><strong>将以下代码</strong></p><div class="code-wrapper"><pre><code class="hljs groovy"><span class="hljs-comment">// Retrofit with scalar Converter</span>implementation <span class="hljs-string">&quot;com.squareup.retrofit2:converter-scalars:2.9.0&quot;</span></code></pre></div><p><strong>替换为以下代码</strong></p><div class="code-wrapper"><pre><code class="hljs groovy"><span class="hljs-comment">// Retrofit with Kotlin serialization Converter</span>implementation <span class="hljs-string">&quot;com.jakewharton.retrofit:retrofit2-kotlinx-serialization-converter:0.8.0&quot;</span></code></pre></div></li><li><p>点击 <strong>Sync Now</strong>，以使用新的依赖项重建项目。</p></li></ol><h3 id="实现数据类"><a href="#实现数据类" class="headerlink" title="实现数据类"></a>实现数据类</h3><p>例如：</p><p>您从网络服务中获取的 JSON 响应的示例条目类似于您之前看到的内容：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">[</span>    <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;424906&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;img_src&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://mars.jpl.nasa.gov/msl-raw-images/msss/01000/mcam/1000ML0044631300305227E03_DXXX.jpg&quot;</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>...<span class="hljs-punctuation">]</span></code></pre></div><p>请注意，在上面的示例中，每个火星照片条目都具有以下 JSON 键值对：</p><ul><li><code>id</code>：资源的 ID，用字符串表示。由于它封装在英文引号 (<code>&quot; &quot;</code>) 中，因此它是 <code>String</code> 类型，而不是 <code>Integer</code>。</li><li><code>img_src</code>：图片的网址，用字符串表示。</li></ul><p>kotlinx.serialization 会解析此 JSON 数据并将其转换为 Kotlin 对象。为此，kotlinx.serialization 需要一个 Kotlin 数据类来存储解析后的结果。在此步骤中，您将创建数据类 <code>MarsPhoto</code>。</p><ol><li><p>右键点击 <strong>network</strong> 软件包，然后依次选择 <strong>New &gt; Kotlin File&#x2F;Class</strong>。</p></li><li><p>在对话框中，选择 <strong>Class</strong>，然后输入 <code>MarsPhoto</code> 作为类的名称。系统将在 <code>network</code> 软件包中创建一个名为 <code>MarsPhoto.kt</code> 的新文件。</p></li><li><p>在类定义前添加 <code>data</code> 关键字，使 <code>MarsPhoto</code> 成为数据类。</p></li><li><p>将英文大括号 <code>&#123;&#125;</code> 更改为英文圆括号 <code>()</code>。此更改会引发错误，因为数据类必须至少定义一个属性。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MarsPhoto</span>()</code></pre></div></li><li><p>将以下属性添加到 <code>MarsPhoto</code> 类定义中。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MarsPhoto</span>(    <span class="hljs-keyword">val</span> id: String,  <span class="hljs-keyword">val</span> img_src: String)</code></pre></div></li><li><p>使 <code>MarsPhoto</code> 类可序列化，并为其添加 <code>@Serializable</code> 注解。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> kotlinx.serialization.Serializable<span class="hljs-meta">@Serializable</span><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MarsPhoto</span>(    <span class="hljs-keyword">val</span> id: String,  <span class="hljs-keyword">val</span> img_src: String)</code></pre></div><p>请注意，<code>MarsPhoto</code> 类中的每个变量都对应于 JSON 对象中的一个键名。为了匹配特定 JSON 响应中的类型，您可以为所有值使用 <code>String</code> 对象。</p><p><code>kotlinx serialization</code> 解析 JSON 时，它会按名称匹配键，并用适当的值填充数据对象。</p></li></ol><p><strong>@SerialName 注解</strong></p><p>有时，JSON 响应中的键名可能会使 Kotlin 属性混淆，或者可能与建议的编码样式不匹配。例如，在 JSON 文件中，<code>img_src</code> 键使用下划线，而 Kotlin 惯例使用大写和小写字母（“驼峰式大小写”）。</p><p>如需在数据类中使用与 JSON 响应中的键名不同的变量名称，请使用 <code>@SerialName</code> 注解。在以下示例中，数据类中变量的名称为 <code>imgSrc</code>。可以使用 <code>@SerialName(value = &quot;img_src&quot;)</code> 将该变量映射到 JSON 属性 <code>img_src</code>。</p><ol><li><p>将 <code>img_src</code> 键所在的代码行替换为如下所示的代码行。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> kotlinx.serialization.SerialName<span class="hljs-meta">@SerialName(value = <span class="hljs-string">&quot;img_src&quot;</span>)</span><span class="hljs-keyword">val</span> imgSrc: String</code></pre></div></li></ol><h3 id="更新-MarsApiService-和-MarsViewModel"><a href="#更新-MarsApiService-和-MarsViewModel" class="headerlink" title="更新 MarsApiService 和 MarsViewModel"></a>更新 MarsApiService 和 MarsViewModel</h3><p>在此任务中，您将使用 <code>kotlinx.serialization</code> 转换器将 JSON 对象转换为 Kotlin 对象。</p><ol><li><p>打开 <code>network/MarsApiService.kt</code>。</p></li><li><p>请注意 <code>ScalarsConverterFactory</code> 的未解析引用错误。这些错误是由上一部分中的 Retrofit 依赖项更改导致的。</p></li><li><p>删除 <code>ScalarConverterFactory</code> 的导入作业。</p> <div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> retrofit2.converter.scalars.ScalarsConverterFactory</code></pre></div></li><li><p>在 <code>retrofit</code> 对象声明中，将 Retrofit 构建器更改为使用 <code>kotlinx.serialization</code> 而不是 <code>ScalarConverterFactory</code>。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> com.jakewharton.retrofit2.converter.kotlinx.serialization.asConverterFactory<span class="hljs-keyword">import</span> kotlinx.serialization.json.Json<span class="hljs-keyword">import</span> okhttp3.MediaType<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> retrofit = Retrofit.Builder()    .addConverterFactory(Json.asConverterFactory(<span class="hljs-string">&quot;application/json&quot;</span>.toMediaType()))    .baseUrl(BASE_URL)    .build()<span class="hljs-comment">// 这里我一直引入失败，改为了：Json.asConverterFactory(MediaType.get(&quot;application/json&quot;))</span></code></pre></div><p><strong>如果<code>toMediaType()</code>报错</strong>：<br> 在<code>build.gradle(app)</code>的<code>dependencies</code>中导入okhttp3依赖并同步.</p> <div class="code-wrapper"><pre><code class="hljs groovy">dependencies &#123;...implementation <span class="hljs-string">&quot;com.squareup.okhttp3:okhttp:4.10.1&quot;</span>&#125;</code></pre></div><p> 就可以使用了：</p> <div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> okhttp3.MediaType.Companion.toMediaType   <span class="hljs-keyword">val</span> contentType = <span class="hljs-string">&quot;application/json&quot;</span>.toMediaType()</code></pre></div></li></ol><p>现在，您已具备 <code>kotlinx.serialization</code>，可以要求 Retrofit 从 JSON 数组中返回 <code>MarsPhoto</code> 对象列表，而不是返回 JSON 字符串。</p><ol start="5"><li><p>更新 <code>MarsApiService</code> 接口，以便 Retrofit 返回 <code>MarsPhoto</code> 对象列表，而不是返回 <code>String</code>。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MarsApiService</span> &#123;    <span class="hljs-meta">@GET(<span class="hljs-string">&quot;photos&quot;</span>)</span>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getPhotos</span><span class="hljs-params">()</span></span>: List&lt;MarsPhoto&gt;&#125;</code></pre></div></li><li><p>对 <code>viewModel</code> 进行类似的更改。打开 <code>MarsViewModel.kt</code>，并向下滚动到 <code>getMarsPhotos()</code> 方法。</p><p>在 <code>getMarsPhotos()</code> 方法中，<code>listResult</code> 是 <code>List&lt;MarsPhoto&gt;</code>，而不再是 <code>String</code>。该列表的大小就是已接收和解析的照片数。</p></li><li><p>如需输出检索的照片数，请按如下方式更新 <code>marsUiState</code>：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> listResult = MarsApi.retrofitService.getPhotos()marsUiState = MarsUiState.Success(   <span class="hljs-string">&quot;Success: <span class="hljs-subst">$&#123;listResult.size&#125;</span> Mars photos retrieved&quot;</span>)</code></pre></div></li><li><p>确保在设备或模拟器中关闭飞行模式，编译并运行应用。</p><p>这一次，消息应显示网络服务返回的资源数，而不是较大的 JSON 字符串。</p></li></ol><p>示例应用完整代码：</p><p><a href="https://github.com/google-developer-training/basic-android-kotlin-compose-training-mars-photos">google-developer-training&#x2F;basic-android-kotlin-compose-training-mars-photos: Solution code for Android Basics in Kotlin course (github.com)</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="REST-网络服务"><a href="#REST-网络服务" class="headerlink" title="REST 网络服务"></a>REST 网络服务</h3><ul><li>网络服务是通过互联网提供的基于软件的功能，可让您的应用发出请求并获取返回的数据。</li><li>常见网络服务使用的是 <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a> 架构。提供 REST 架构的网络服务称为 RESTful 服务。RESTful 网络服务是使用标准网络组件和协议构建的。</li><li>您可通过 URI 以标准化方式向 REST 网络服务发出请求。</li><li>若要使用网络服务，应用必须建立网络连接，然后与该服务进行通信。然后，应用必须接收响应数据，并将该数据解析成应用可以使用的格式。</li><li><a href="https://square.github.io/retrofit/">Retrofit</a> 库是一个客户端库，可让应用向 REST 网络服务发出请求。</li><li>使用转换器指示 Retrofit 如何处理它发送至网络服务的数据，以及它从网络服务获取的返回数据。例如，<code>ScalarsConverter</code> 会将网络服务数据视为 <code>String</code> 或其他基元。</li><li>如需让应用能够连接到互联网，请在 Android 清单中添加 <code>&quot;android.permission.INTERNET&quot;</code> 权限。</li><li>延迟初始化会将对象创建操作委派为在首次使用时执行。它会创建引用，但不会创建对象。在首次访问对象后，此后每次访问都会创建并使用引用。</li></ul><h3 id="JSON-解析"><a href="#JSON-解析" class="headerlink" title="JSON 解析"></a>JSON 解析</h3><ul><li>网络服务的响应通常会采用 <a href="https://www.json.org/">JSON</a> 格式（一种表示结构化数据的通用格式）。</li><li>JSON 对象是键值对的集合。</li><li>JSON 对象集合是一个 JSON 数组。作为网络服务的响应，您会得到一个 JSON 数组。</li><li>键值对中的键会用英文引号引起来。值可以是数字或字符串。</li><li>在 Kotlin 中，数据序列化工具位于单独的组件 <a href="https://github.com/Kotlin/kotlinx.serialization">kotlinx.serialization</a> 中。kotlinx.serialization 提供了一系列库，用于将 JSON 字符串转换为 Kotlin 对象。</li><li>Kotlin 序列化转换器库是一个社区开发的库，适用于 Retrofit：<a href="https://github.com/JakeWharton/retrofit2-kotlinx-serialization-converter#kotlin-serialization-converter">retrofit2-kotlinx-serialization-converter</a>。</li><li>kotlinx.serialization 可将 JSON 响应中的键与具有相同名称的数据对象中的属性进行匹配。</li><li>如需为键使用不同的属性名称，请使用 <code>@Serializable</code> 注解和 JSON 键 <code>value</code> 为该属性添加注解。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Retrofit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于软件工程他们没有教你的事情</title>
    <link href="/career/things-they-didnt-teach-you/"/>
    <url>/career/things-they-didnt-teach-you/</url>
    
    <content type="html"><![CDATA[<p>转载并翻译自<a href="https://vadimkravcenko.com/shorts/things-they-didnt-teach-you/">Things they didn’t teach you about Software Engineering (vadimkravcenko.com)</a>，侵权立删。</p><h1 id="关于软件工程他们没有教你的事情"><a href="#关于软件工程他们没有教你的事情" class="headerlink" title="关于软件工程他们没有教你的事情"></a>关于软件工程他们没有教你的事情</h1><p>与往常一样，由于这篇文章充满主观性，在开始之前我们先来个免责声明。无论您是经验丰富的专业人士还是刚刚踏足该领域的新人，我都希望这些见解将提供有价值的观点。</p><p>自 2022 年年中以来，我一直在考虑写这篇文章——但我担心写的不够全面。所以在过去的一年里，我一直在收集想法并把它们写下来，现在我有足够的观点可以与你分享。</p><h2 id="你很少从头开始写东西"><a href="#你很少从头开始写东西" class="headerlink" title="你很少从头开始写东西"></a>你很少从头开始写东西</h2><p>在大学里，他们教你如何编写一个 400 行的程序来解决从 A-Z 的问题。你有一张空白的画布，你可以炫耀你对那些花哨算法的了解，以找到一种生成迷宫的方法。最后，你有一个很好的解决方案来解决一个简单的问题。</p><p>听起来这就是真实世界，对吧？但事实并非如此。在现实工作中，您会面临成千上万行的代码库（屎山），并且您会情不自禁地想知道您的同事在编写这些奇异的代码时吸的到底是什么烟。您会在文档和更了解代码库的大佬之间来回穿梭。在一周结束的时候，你写了十行代码来修复一些 bug，然后不断重复这个循环，直到有人来找你解释为什么你要这样写。</p><p><img src="https://vadimkravcenko.com/wp-content/uploads/2023/01/1_RHbmuBKmpjh1JBwV1-gmtQ-1024x417.png" alt="开发人员的日常生活 来源: xkcd"></p><h2 id="领域知识比您的编码技能更重要"><a href="#领域知识比您的编码技能更重要" class="headerlink" title="领域知识比您的编码技能更重要"></a>领域知识比您的编码技能更重要</h2><p>令我惊讶的是，当你理解了它如何运作的基本原则，更重要的是，为什么它需要运作时，编写他们的业务代码是多么容易。</p><p>在开发移动银行应用程序时，您最好了解交易是如何进行的、资金是如何进行结算的、账簿是如何进行的等等。</p><p>在为餐厅开发销售网点系统时，您最好弄清楚服务员是如何工作的，如何在烹饪中管理存货清单，以及信用卡授权是如何进行的。基本上，这个领域的来龙去脉就是你的软件的业务逻辑所在。</p><p>为医学、物流和记账领域开发软件也是如此。</p><p>没有这些知识，个人可能很难做出有意义的贡献，并且可能对他们的雇主没有那么有价值。例如，如果您有开发银行应用程序的经验，那么您更有可能找到另一份金融工作，因为您已经熟悉该领域。</p><h2 id="编写文档没有得到足够的强调"><a href="#编写文档没有得到足够的强调" class="headerlink" title="编写文档没有得到足够的强调"></a>编写文档没有得到足够的强调</h2><p>大学通常为学生提供软件开发职业所需的基本技术技能，例如算法和数据结构。但是，他们通常不会优先考虑编写整洁的、文档齐全且可维护的代码。</p><p><img src="https://vadimkravcenko.com/wp-content/uploads/2023/01/documentation_room-1.png" alt="这就是我们保存文档的房间"></p><p>通常只有在处理其他人编写的代码，经历尝试理解和修改它的痛苦之后，开发人员才开始意识到编写可维护代码的重要性。哦，天哪，当我现在看到详略得当的文档时，我是多么高兴。这一般不是在课堂环境中学习到的，而是有过因为好的文档和易于理解的代码节省了时间和精力的实际经历才学习到。</p><h2 id="业务价值高于代码本身"><a href="#业务价值高于代码本身" class="headerlink" title="业务价值高于代码本身"></a>业务价值高于代码本身</h2><p>没有人会走过来对你说，“哦，哇，那行代码写的真好，太棒了！”他们只会说，“用户对你写的功能很满意”，或者“你的代码毁了整个网站”，这取决于你的运气。</p><p>虽然这听起来令人惊讶，但软件工程师工作的主要目标不是编写代码，而是通过使用开发的软件创造价值。代码只是实现此最终目标的工具。<strong>代码 -&gt; 软件 -&gt; 业务价值。</strong></p><p>你写的软件需要满足社会上的一些需求——一些方便用户使用的工具，一些降低成本的自动化程序，人们会费时费力的事情。我们可以简化它。如果你用不成熟的技术开发了一些东西，但是为用户提供了巨大的价值——那么你已经实现了你作为软件工程师的价值。如果你用高深的技术开发了一些东西，但是为用户提供了很糟糕的体验——你就没有。</p><p>优雅的代码、充分的实践、智能的解决方案、设计模式——这些都是为了你的软件工程师同事，他们将在你之后处理代码库，而不是帮助你实现带来价值的目的。（请注意，带来价值也可能意味着构建一个不会崩溃的可扩展解决方案，这需要代码至少在某种程度上还不错。）</p><h2 id="你需要和无能的人一起工作"><a href="#你需要和无能的人一起工作" class="headerlink" title="你需要和无能的人一起工作"></a>你需要和无能的人一起工作</h2><p>在你互动的大多数工作环境中，都会有不称职的人。他可能不是你的经理；它可以是为您提供 API 的合作伙伴公司的经理，也可以是甲方的一些高管。</p><p>这处理起来非常令人懊恼和疲惫。他们创造了一个有害且低效的工作环境。他们需要很长时间才能做出决策或做出对团队和项目产生负面影响的糟糕决策。这会导致不断的延误和返工，浪费宝贵的时间和资源。</p><p>我花了相当多的时间找出有效的方法来对待无能之辈，而不是成为他们那样令人讨厌的人。我认为这是一项绝对应该在大学里教授的技能。</p><p><img src="https://vadimkravcenko.com/wp-content/uploads/2023/01/dilbert-incompetence-in-spite-of.png" alt="来源: Dataedo"></p><p>我发现一种有效的方法就是不管别人怎么想，专注于自己的工作效率。我试图找到可能更有效的解决方案&#x2F;替代方案来摆脱无能的人。记录一切也很有帮助。这可以提供具体的证据，证明他们的无能对工作流程的影响。</p><p>归根结底，对待无能者的最好方法是积极主动，并找到解决其局限性的方法。这可能涉及：</p><ol><li>寻求其他资源或支持。</li><li>想方设法将任务委派给更有能力的人。其他人可以做需要做的事情吗？</li><li>实施故障保险和回退机制，避免东西在您这边损坏。</li><li>与该人设定 1：1，告诉他们他们正在阻碍这个工作进程。</li><li>再说一遍——不要同流合污。</li></ol><h2 id="你大部分时间都在不确定性中工作"><a href="#你大部分时间都在不确定性中工作" class="headerlink" title="你大部分时间都在不确定性中工作"></a>你大部分时间都在不确定性中工作</h2><p>与人打交道很难。处理不确定性也很难。与不确定的人打交道更难。这就是你作为软件开发人员要做的事情。</p><p>人们并不总是知道他们想要什么，有时他们没有意识到一个简单的改变可能非常复杂——“哦，你的意思是我们不能只是改变支付提供商？信用卡也要这样处理，对吧？</p><p>他们在大学里告诉你的一个大谎言是，你的项目经理会给你合适的、结构清晰的、简单的说明，告诉你需要做什么，然后你再编写代码。“绘制Mandelbrot（一种可以无限循环放大的程序）”或“使用环境光遮蔽渲染钢网”。在一天结束时，你解决了它们，你和你的经理击掌，然后微笑着回家。</p><p>实际发生的事情是，您的上司会向您简要概述任务“我们需要一些东西，将我们从 A 点带到 B 点，但我们还没有任何设计，第三方集成不会交付，除非我们告诉他们我们想要什么，老板 X 希望它是红色的，Y 老板希望它是绿色的。这就是软件工程师的“真正工作”开始的地方——收集需求，弄清楚需要做什么。</p><p>需求收集并不是编程中容易的部分。这并不像编写代码那么有趣。但是，作为一名程序员，这需要你花费大量的时间，因为它需要与人合作，而不是机器——打电话给提供第三方集成的机构，并与他们的开发人员聊天，以了解什么是可行的，什么是不可行的。与股东坐下来告诉他们，他们的想法没有意义，我们可以这样做，而不是那样做。</p><p>在任务上编写第一行代码可能需要数周时间。你弄清楚需求，然后你弄清楚它需要达成什么样的目标，然后你弄清楚它需要如何开发，然后你弄清楚它可能出错的地方，然后你写下你的第一行。</p><h2 id="始终假设一切都有bug"><a href="#始终假设一切都有bug" class="headerlink" title="始终假设一切都有bug"></a>始终假设一切都有bug</h2><p>很多开发人员对信任有一些普遍的错觉:</p><ol><li>你很少完全信任你的代码，因为你知道你只是人类，可能会犯错误。</li><li>您使用的第三方库可能包含错误，但它们是由比您更有能力的人编写的，对吧？</li><li>标准操作系统库不应该有任何错误，对吧？它们是由更聪明的人编写的。</li><li>CPU&#x2F;硬件永远不会出现故障，对吧？他们花了数年时间研发这个东西；它不应该坏掉吧。</li><li>电力应该始终存在，是吧。</li></ol><p>但事实是——我们永远无法完全确定我们的代码、库甚至硬件不会在某个时候出现故障；相反，我们需要假设它会。再聪明的人也只是人。</p><p><img src="https://vadimkravcenko.com/wp-content/uploads/2023/01/bad-code-941x1024.png"></p><p>如果您查看任何流行库（操作系统或应用程序级别）的 GitHub issue，您将看到大量未阐明的行为等待修复。我的上帝，我的 Linux 机器因分段错误而崩溃了多少次？太疯狂了。</p><p>通过假设一切都可能中断并出现错误，我们可以采取措施防止或减轻潜在问题，这最终有助于确保我们系统的可靠性和稳定性。</p><h2 id="这不是一份梦寐以求的工作"><a href="#这不是一份梦寐以求的工作" class="headerlink" title="这不是一份梦寐以求的工作"></a>这不是一份梦寐以求的工作</h2><p>无论您的大学或培训班告诉您一旦开始从事 IT 工作，您将拥有什么美好的生活，这都只不过是一张空头支票。</p><p><img src="https://vadimkravcenko.com/wp-content/uploads/2023/01/dream-job-in-it-1024x1024.png"></p><ul><li>这是艰苦的工作。您一天中的大部分时间都坐在电脑后面。</li><li>很难将工作与生活平衡。在其他职业中，您的工作日于 18：00 结束，然后将工作抛之脑后。但是这里不同，即使在晚上，您也很可能长期在线并检查代码。</li><li>你很少在开发你喜欢的东西。通常情况下，你面对的是乏味的工作。</li><li>职业发展机会有限。即使你是一个表现最好的人，可能也没有空间让你在公司里晋升。</li><li>压抑的环境、交付日期、bug和满足客户期望的压力都会使你血压升高。</li><li>远程工作可能有孤独感。根据公司和团队结构的不同，软件工程师可能会长时间单独工作（不包括视频通话），导致缺乏真正的社交互动。</li><li>工作保障有限。随着技术的不断发展，软件工程师可能会面临被更新、更高效的技术所取代的风险。</li></ul><h2 id="美学是无法培养的"><a href="#美学是无法培养的" class="headerlink" title="美学是无法培养的"></a>美学是无法培养的</h2><p>大学课程教我们优秀代码的基础知识，但软件开发中真正的美学不能在课堂上教授。</p><p>软件开发中的美学是指代码的整体观感。这关乎可读性、易于理解和维护的难易程度。美观的代码整洁简练、条理清晰，并且逻辑分明。好的代码让人拍案叫绝，坏的代码让人心生厌恶。</p><p>不幸的是，美学不是一个学期的课程中就能教会的。它是通过经历和阅读大量优秀代码以及维护糟糕代码获得的。</p><h2 id="即使您不想给出评估，也会被询问"><a href="#即使您不想给出评估，也会被询问" class="headerlink" title="即使您不想给出评估，也会被询问"></a>即使您不想给出评估，也会被询问</h2><p>经理们喜欢数字、估算，以及在餐巾纸上写一个想法来询问估算。这就是现实世界的运作方式——企业有一些金钱目标，但在承诺之前，他们需要了解它将花费多少。</p><p>在大学里很难教这个，因为准确性在很大程度上取决于你在开发系统方面的经验。多年来您解决的问题越多样化，就越容易评估未来的工作。</p><p><img src="https://vadimkravcenko.com/wp-content/uploads/2023/01/dilbert-estimates.gif" alt="来源: dilbert"></p><p>我不打算讨论进行评估的最佳方式；有几十种方法可以做到。但我要说的是，估算是企业唯一能够理解的事情。如果你开始谈论“我们有长期规划，但我不知道我们什么时候会完成”，那么企业很难在这样的情况下生存。</p><p>在 <a href="https://mindnow.io/?utm_source=vadimkravcenko.com&utm_campaign=blog">Mindnow</a>，我们通常对整个项目进行粗略估计，以衡量需要分配多少预算ーー这是长期优先事项。之后，我们从基于快速评估的计划开始，整个团队讨论、确定优先级并承诺——短期交付成果，使我们更接近长期目标。</p><h2 id="并非所有会议都是糟糕的"><a href="#并非所有会议都是糟糕的" class="headerlink" title="并非所有会议都是糟糕的"></a>并非所有会议都是糟糕的</h2><p>如此看来，软件工程师的工作不仅仅是编程，那么时间会花在什么上呢？会议。</p><p>会议确保一切顺利和按计划进行。他们围绕一个共同的目标协调人们，让每个人都走上正轨。市场营销部门知道正在开发某些内容，他们可以为该功能的最终发布做准备。项目经理可以观察到开发人员的工作方向，并在需要时进行轻微的路线修正。客户支持带来最新的客户需求。质量保证部门分享他们的调查结果和找到的问题。管理层与股东分享最新资讯。</p><p><img src="https://vadimkravcenko.com/wp-content/uploads/2023/01/dilbert-meetings.webp"></p><p>这一切都是相互关联的，会议是共享信息的地方。作为软件工程师，您要对这种共享信息的某些部分负责，因此阻碍它是不负责任的。您可能不喜欢它，但必须共享信息才能使系统保持高效。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果您正在考虑从事软件工程职业，请准备好直面这些事实，并拥抱成长的机会。你不太可能对世界产生有意义的改变，归根结底，这只是一份工作，你可以通过其他方式做出有意义的贡献。</p><p>最重要的是——记得开心。</p><p>我敢肯定还有更多我没有提到的宝贵观点，请自由地在评论区留言。</p>]]></content>
    
    
    <categories>
      
      <category>career</category>
      
    </categories>
    
    
    <tags>
      
      <tag>development</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用nginx强制https</title>
    <link href="/%E7%8E%AF%E5%A2%83/%E4%BD%BF%E7%94%A8nginx%E5%BC%BA%E5%88%B6https/"/>
    <url>/%E7%8E%AF%E5%A2%83/%E4%BD%BF%E7%94%A8nginx%E5%BC%BA%E5%88%B6https/</url>
    
    <content type="html"><![CDATA[<p>如果没有服务器可以点击<a href="https://www.aliyun.com/minisite/goods?userCode=cucsy8ip">这里</a>购买，新用户超低价！</p><p>ssl证书购买及安装请参考：</p><p><a href="https://help.aliyun.com/document_detail/98728.htm?spm=a2c4g.11186623.0.0.4c58310323WzTm#concept-n45-21x-yfb">在Nginx或Tengine服务器上安装证书 (aliyun.com)</a></p><ol><li><p>进入nginx的服务器配置文件夹，默认在<code>/etc/nginx</code></p><div class="code-wrapper"><pre><code class="hljs shell">cd /etc/nginx</code></pre></div></li><li><p>安装tree（非必要，可略过）</p><div class="code-wrapper"><pre><code class="hljs shell">sudo yum install tree</code></pre></div></li><li><p>使用tree查看nginx的目录结构</p><div class="code-wrapper"><pre><code class="hljs shell">tree</code></pre></div><p>我的输出如下：</p><div class="code-wrapper"><pre><code class="hljs shell">.├── cert # 这里放证书和密钥│   ├── yorick.love.key│   └── yorick.love.pem├── conf.d # 这里是配置文件夹，放各个应用的服务器配置│   └── hexo.conf├── default.d ├── fastcgi.conf├── fastcgi.conf.default├── fastcgi_params├── fastcgi_params.default├── koi-utf├── koi-win├── mime.types├── mime.types.default├── nginx.conf # 这里是主配置├── nginx.conf.default├── scgi_params├── scgi_params.default├── uwsgi_params├── uwsgi_params.default└── win-utf</code></pre></div></li><li><p>由于我这里就一个应用，直接在主配置修改，应用配置注释掉。</p><p>用vim命令编辑主配置</p><div class="code-wrapper"><pre><code class="hljs shell">vim nginx.conf</code></pre></div><p>注释掉原来监听80端口的server</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">   server &#123;</span><span class="hljs-meta prompt_"># </span><span class="language-bash">       listen       80;</span><span class="hljs-meta prompt_"># </span><span class="language-bash">       listen       [::]:80;</span><span class="hljs-meta prompt_"># </span><span class="language-bash">       server_name  _;</span><span class="hljs-meta prompt_"># </span><span class="language-bash">       root         /usr/share/nginx/html;</span><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><span class="language-bash"><span class="hljs-comment">#        # Load configuration files for the default server block.</span></span><span class="hljs-meta prompt_"># </span><span class="language-bash">       include /etc/nginx/default.d/*.conf;</span><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><span class="language-bash"><span class="hljs-comment">#        error_page 404 /404.html;</span></span><span class="hljs-meta prompt_"># </span><span class="language-bash">       location = /404.html &#123;</span><span class="hljs-meta prompt_"># </span><span class="language-bash">       &#125;</span><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><span class="language-bash"><span class="hljs-comment">#        error_page 500 502 503 504 /50x.html;</span></span><span class="hljs-meta prompt_"># </span><span class="language-bash">       location = /50x.html &#123;</span><span class="hljs-meta prompt_"># </span><span class="language-bash">       &#125;</span><span class="hljs-meta prompt_"># </span><span class="language-bash">   &#125;</span></code></pre></div><p><strong>如何注释多行：</strong></p><ul><li><p>首先按<code>esc</code>进入命令行模式下，按下<code>Ctrl + V</code>，进入列（也叫区块）模式;</p></li><li><p>在行首使用上下键选择需要注释的多行;</p></li><li><p>按下键盘（大写）<code>“I”</code>键，进入插入模式；</p></li><li><p>然后输入注释符（<code>“//”、“#”</code>等）;</p></li><li><p>最后按下<code>“Esc”</code>键，稍等一会。</p></li></ul></li><li><p>修改监听443端口的配置：</p><div class="code-wrapper"><pre><code class="hljs shell">server &#123;    listen       443 ssl http2;    server_name  yorick.love; // 网站域名或者ip    root         /var/www/hexo; // 静态资源目录    ssl_certificate cert/yorick.love.pem; // 证书相对路径    ssl_certificate_key cert/yorick.love.key; // 密钥相对路径    ssl_session_cache shared:SSL:1m;    ssl_session_timeout 5m;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;    ssl_prefer_server_ciphers on;    # Load configuration files for the default server block.    include /etc/nginx/default.d/*.conf;    error_page 404 /404.html;    location = /40x.html &#123;    &#125;    error_page 500 502 503 504 /50x.html;    location = /50x.html &#123;    &#125;&#125;</code></pre></div></li><li><p>最后，转发80端口的请求：</p><div class="code-wrapper"><pre><code class="hljs shell">server &#123;    listen  80;    server_name  yorick.love; // 域名或者IP    return 301 https://$host$request_uri; // 固定不用修改&#125;</code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>BackEnd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯回形取数</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%9E%E5%BD%A2%E5%8F%96%E6%95%B0/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%9E%E5%BD%A2%E5%8F%96%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　回形取数就是沿矩阵的边取数，若当前方向上无数可取或已经取过，则左转90度。一开始位于矩阵左上角，方向向下。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入第一行是两个不超过200的正整数m, n，表示矩阵的行和列。接下来m行每行n个整数，表示这个矩阵。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出只有一行，共mn个数，为输入矩阵回形取数得到的结果。数之间用一个空格分隔，行末不要有多余的空格。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 获取m,n</span>m, n = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<span class="hljs-comment"># 获取数组</span>arr = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):    arr.append(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())))<span class="hljs-comment"># 存放结果</span>res = []<span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(arr) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> arr[<span class="hljs-number">0</span>] != []:    <span class="hljs-comment"># 最左列向下</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr)):        res.append(arr[i].pop(<span class="hljs-number">0</span>))    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> arr[<span class="hljs-number">0</span>] == []:        <span class="hljs-keyword">break</span>    <span class="hljs-comment"># 最下行向右</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr[<span class="hljs-number">0</span>])):        res.append(arr[<span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span>][i])    arr.pop(<span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span>)    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> arr[<span class="hljs-number">0</span>] == []:        <span class="hljs-keyword">break</span>    <span class="hljs-comment"># 最右列向上</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr)):        res.append(arr[<span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span> - i].pop(<span class="hljs-built_in">len</span>(arr[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>))    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> arr[<span class="hljs-number">0</span>] == []:        <span class="hljs-keyword">break</span>    <span class="hljs-comment"># 最上行向左</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr[<span class="hljs-number">0</span>])):        res.append(arr[<span class="hljs-number">0</span>][<span class="hljs-built_in">len</span>(arr[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span> - i])    arr.pop(<span class="hljs-number">0</span>)<span class="hljs-comment"># 输出结果</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android屏幕旋转ScreenOrientation</title>
    <link href="/Android/Android%E5%B1%8F%E5%B9%95%E6%97%8B%E8%BD%ACScreenOrientation/"/>
    <url>/Android/Android%E5%B1%8F%E5%B9%95%E6%97%8B%E8%BD%ACScreenOrientation/</url>
    
    <content type="html"><![CDATA[<h1 id="屏幕旋转ScreenOrientation"><a href="#屏幕旋转ScreenOrientation" class="headerlink" title="屏幕旋转ScreenOrientation"></a>屏幕旋转ScreenOrientation</h1><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>对于ConstraintLayout，如果使用绝对布局，旋转可能会导致控件显示异常。</li><li>对于相对位置的控件，在大多数情况下还可以正常显示，但是有可能存在异常。</li><li>屏幕旋转时，Activity会重新加载。</li></ol><h2 id="控制旋转"><a href="#控制旋转" class="headerlink" title="控制旋转"></a>控制旋转</h2><p>在manifest文件中为Activity添加属性：</p><ul><li><code>android:screenOrientation=&quot;portrait&quot;</code> 保持竖屏</li><li><code>android:screenOrientation=&quot;landscape&quot;</code> 保持横屏</li></ul><h2 id="实现横屏竖屏两种布局"><a href="#实现横屏竖屏两种布局" class="headerlink" title="实现横屏竖屏两种布局"></a>实现横屏竖屏两种布局</h2><p><img src="/./img/orientation_land.png" alt="orientation_land"></p><p>在这里新建一个Landscape的副本，可以重新调整控件位置。</p><h2 id="实现状态保存"><a href="#实现状态保存" class="headerlink" title="实现状态保存"></a>实现状态保存</h2><p>实现横竖屏切换时的状态保存</p><ol><li><p>在Activity中重写父类的<code>onSaveInstanceState</code>方法，Bundle是一种采用键值对方式存储的数据类型，这里使用它的<code>putString</code>方法存放数据。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(outState: <span class="hljs-type">Bundle</span>)</span></span> &#123;    <span class="hljs-keyword">super</span>.onSaveInstanceState(outState)    outState.putString(<span class="hljs-string">&quot;title&quot;</span>, textView.text.toString())&#125;</code></pre></div></li><li><p>在<code>onCreate</code>方法中添加，使用<code>getString</code>方法获取数据。</p><div class="code-wrapper"><pre><code class="hljs kotlin">textView.text = savedInstanceState?.getString(<span class="hljs-string">&quot;title&quot;</span>) ?: textView.text<span class="hljs-comment">// savedInstanceState为空则不执行getString方法，?: 前为空则使用后面的内容</span></code></pre></div></li></ol><p>这里只能临时保存数据，当Activity被销毁后，数据仍然会丢失。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>view</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android应用图标</title>
    <link href="/Android/Android%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87/"/>
    <url>/Android/Android%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h1 id="应用图标"><a href="#应用图标" class="headerlink" title="应用图标"></a>应用图标</h1><p><a href="https://developer.android.google.cn/guide/practices/ui_guidelines/icon_design_adaptive?hl=zh-cn">自适应图标  | Android 开发者  | Android Developers (google.cn)</a></p><p><a href="https://developer.android.google.cn/develop/ui/views/graphics/vector-drawable-resources?hl=en">Vector drawables overview  | Android Developers (google.cn)</a></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">vector</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:width</span>=<span class="hljs-string">&quot;108dp&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:height</span>=<span class="hljs-string">&quot;108dp&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:tint</span>=<span class="hljs-string">&quot;@color/color_ic_back&quot;</span> // </span><span class="hljs-tag">    <span class="hljs-attr">android:viewportWidth</span>=<span class="hljs-string">&quot;108&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:viewportHeight</span>=<span class="hljs-string">&quot;108&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">path</span></span><span class="hljs-tag">        <span class="hljs-attr">android:fillColor</span>=<span class="hljs-string">&quot;#96C8FF&quot;</span> // <span class="hljs-attr">填充颜色</span>，<span class="hljs-attr">切换夜间模式会变成此色</span></span><span class="hljs-tag">        <span class="hljs-attr">android:pathData</span>=<span class="hljs-string">&quot;</span></span><span class="hljs-string"><span class="hljs-tag">        M0,0</span></span><span class="hljs-string"><span class="hljs-tag">        L108,108</span></span><span class="hljs-string"><span class="hljs-tag">        H0</span></span><span class="hljs-string"><span class="hljs-tag">        V0</span></span><span class="hljs-string"><span class="hljs-tag">        H108</span></span><span class="hljs-string"><span class="hljs-tag">        V108</span></span><span class="hljs-string"><span class="hljs-tag">&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">vector</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Icon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android可视化UI设计</title>
    <link href="/Android/Android%E5%8F%AF%E8%A7%86%E5%8C%96UI%E8%AE%BE%E8%AE%A1/"/>
    <url>/Android/Android%E5%8F%AF%E8%A7%86%E5%8C%96UI%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="可视化UI设计"><a href="#可视化UI设计" class="headerlink" title="可视化UI设计"></a>可视化UI设计</h1><p>[TOC]</p><h2 id="约束布局ConstraintLayout"><a href="#约束布局ConstraintLayout" class="headerlink" title="约束布局ConstraintLayout"></a>约束布局ConstraintLayout</h2><p>约束布局ConstraintLayout是一个使用“相对定位”灵活地确定控件的位置和大小的一个布局，在 2016 年 Google I&#x2F;O 中面世，它的出现是为了解决开发中过于复杂的页面层级嵌套过多的问题——层级过深会增加绘制界面需要的时间，影响用户体验，以灵活的方式定位和调整小部件。</p><h3 id="基本位置约束"><a href="#基本位置约束" class="headerlink" title="基本位置约束"></a>基本位置约束</h3><ol><li><p><strong>直接拖动蓝点</strong>。首先认识各个位置的定义，（注意：这里每个词指的不是具体的点，而是该点所在的红色直线！）</p><p><img src="/./img/image-20221104183622446.png" alt="image-20221104183622446"></p><p>下图显示布局约束，➡️代表指向，意思是控件的某个位置相对于其他控件或者布局的位置。例如：控件底部在父布局的底部，但是控件顶部又在父布局的顶部，这是两个约束拉扯，控件最终居中，但是我们仍然可以拖动控件调整位置，这里修改的是控件在两个约束之间的比重，默认是50</p><p><img src="/./img/image-20221104182427025.png" alt="image-20221104182427025"></p><p>查看生成的代码</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag"><span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/textView2&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;TextView&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;34sp&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span> // <span class="hljs-attr">代表控件底部在父布局的底部</span></span><span class="hljs-tag"><span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span>// <span class="hljs-attr">代表控件结束位置在父控件的结束位置</span></span><span class="hljs-tag"><span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span></code></pre></div><p>若我们拖动控件，则会增加如下代码：</p><div class="code-wrapper"><pre><code class="hljs xml">app:layout_constraintHorizontal_bias=&quot;0.35&quot; // 代表控件在受到水平约束时到两端的比例，范围0~1app:layout_constraintVertical_bias=&quot;0.65&quot; // 代表控件在受到竖直约束时到两端的比例，范围0~1</code></pre></div></li><li><p><strong>点击魔法棒🪄</strong>，会自动添加约束，同时以外边距的形式添加距离。</p><p><img src="/./img/image-20221104192615537.png" alt="image-20221104192615537"></p><div class="code-wrapper"><pre><code class="hljs xml">android:layout_marginStart=&quot;96dp&quot;android:layout_marginBottom=&quot;240dp&quot;app:layout_constraintBottom_toBottomOf=&quot;parent&quot;app:layout_constraintStart_toStartOf=&quot;parent&quot;</code></pre></div></li></ol><h3 id="对多个控件操作"><a href="#对多个控件操作" class="headerlink" title="对多个控件操作"></a>对多个控件操作</h3><h4 id="Pack"><a href="#Pack" class="headerlink" title="Pack"></a>Pack</h4><ol><li><p>选择多个控件</p><p><img src="/./img/image-20221104193649706.png" alt="image-20221104193649706"></p></li><li><p>点击<code>Pack</code></p><p><img src="/./img/image-20221104193845078.png" alt="image-20221104193845078"></p></li><li><p>Pack Horizontally，会以最Start位置的Start边界为基准水平紧凑对齐</p><p><img src="/./img/image-20221104193954355.png" alt="image-20221104193954355"></p><p>下面是有阻挡得情况</p><p><img src="/./img/image-20221104194800428.png" alt="image-20221104194800428"></p></li><li><p>Pack Vertically，同理，Buttom</p><p><img src="/./img/image-20221104194533125.png" alt="image-20221104194533125"></p><p><img src="/./img/image-20221104194859939.png" alt="image-20221104194859939"></p></li><li><p>Expand Horizontally，水平拉伸</p><p><img src="/./img/image-20221104195145603.png" alt="image-20221104195145603"></p></li><li><p>Expand Vertically，竖直拉伸</p><p><img src="/./img/image-20221104195319243.png" alt="image-20221104195319243"></p></li><li><p>Distribute Horizontally，添加水平方向相互约束</p><p><img src="/./img/image-20221104195748648.png" alt="image-20221104195748648"></p></li><li><p>Distribute Vertically，添加竖直方向相互约束</p><p><img src="/./img/image-20221104195933250.png" alt="image-20221104195933250"></p></li></ol><p>所有操作都会通过修改控件绝对位置来改变位置，坐标原点在Start与Top交点处。</p><div class="code-wrapper"><pre><code class="hljs xml">tools:layout_editor_absoluteX=&quot;123dp&quot; // 绝对x轴位置tools:layout_editor_absoluteY=&quot;456dp&quot; // 绝对Y轴位置</code></pre></div><p>Expend操作会修改控件大小</p><div class="code-wrapper"><pre><code class="hljs xml">android:layout_width=&quot;400dp&quot;android:layout_height=&quot;200dp&quot;</code></pre></div><p>Distribute操作会添加约束，如：</p><div class="code-wrapper"><pre><code class="hljs xml">app:layout_constraintStart_toEndOf=&quot;@+id/button4&quot;</code></pre></div><h4 id="Align"><a href="#Align" class="headerlink" title="Align"></a>Align</h4><p>多选后点击Align，直接看图标就能理解作用。</p><p><img src="/./img/image-20221104202313658.png" alt="image-20221104202313658"></p><p>注意点：</p><ol><li><p>与Pack不同，这里的对齐是是通过添加约束实现，而且控件可能重叠。</p><p><img src="/./img/image-20221104202740560.png" alt="image-20221104202740560"><img src="/./img/image-20221104202810457.png" alt="image-20221104202810457"></p></li><li><p>Baselines是文字基线对齐，选中控件，右键菜单选择显示</p><p><img src="/./img/image-20221104203110925.png" alt="image-20221104203110925"></p><p>然后拖到想要约束的位置，一般是另一个控件的基线</p><p>   <img src="/./img/image-20221104203338181.png" alt="image-20221104203338181"></p></li></ol><h4 id="清除控件所有约束"><a href="#清除控件所有约束" class="headerlink" title="清除控件所有约束"></a>清除控件所有约束</h4><p>所有约束都会被清除</p><p><img src="/./img/image-20221104203611415.png" alt="image-20221104203611415"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>layout</tag>
      
      <tag>view</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android本地化</title>
    <link href="/Android/Android%E6%9C%AC%E5%9C%B0%E5%8C%96/"/>
    <url>/Android/Android%E6%9C%AC%E5%9C%B0%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h1><h2 id="实现多语言"><a href="#实现多语言" class="headerlink" title="实现多语言"></a>实现多语言</h2><p>在<code>/res/values/strings.xml</code>打开Translation Editor，点击地球图标，选择语言，进行翻译</p><p>软件语言会根据系统环境自动适配</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android自定义视图</title>
    <link href="/Android/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE/"/>
    <url>/Android/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="自定义视图"><a href="#自定义视图" class="headerlink" title="自定义视图"></a>自定义视图</h1><p><a href="https://developer.android.google.cn/guide/topics/ui/custom-components?hl=zh_cn">自定义视图组件  | Android 开发者  | Android Developers (google.cn)</a></p><p><a href="https://developer.android.google.cn/training/custom-views/create-view?hl=zh_cn">创建视图类  | Android 开发者  | Android Developers (google.cn)</a></p><h2 id="系统如何绘制View"><a href="#系统如何绘制View" class="headerlink" title="系统如何绘制View"></a>系统如何绘制View</h2><p>下图是布局树</p><p><img src="/./img/image-20221124172128201.png" alt="image-20221124172128201"></p><p>视图的每一次刷新都是完整地遍历布局树的过程，这个过程比较耗时</p><p><a href="https://www.jianshu.com/p/a978a6250f9e">Android系统显示原理简介 - 简书 (jianshu.com)</a></p><p><img src="/./img/image-20221124185323496.png" alt="image-20221124185323496"></p><p>要在<code>16ms</code>内画完每一个界面</p><p><img src="/./img/image-20221124185524584.png" alt="image-20221124185524584"></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyView</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(    context: Context, attrs: AttributeSet? = <span class="hljs-literal">null</span>, defStyleAttr: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>) : View(context, attrs, defStyleAttr) &#123;    <span class="hljs-comment">// xml加载完毕时调用</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFinishInflate</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">super</span>.onFinishInflate()        Log.d(<span class="hljs-string">&quot;yu&quot;</span>,<span class="hljs-string">&quot;onFinishInflate：&quot;</span>)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAttachedToWindow</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">super</span>.onAttachedToWindow()        Log.d(<span class="hljs-string">&quot;yu&quot;</span>, <span class="hljs-string">&quot;onAttachedToWindow: &quot;</span>)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(widthMeasureSpec: <span class="hljs-type">Int</span>, heightMeasureSpec: <span class="hljs-type">Int</span>)</span></span> &#123;        <span class="hljs-keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec)        Log.d(<span class="hljs-string">&quot;yu&quot;</span>, <span class="hljs-string">&quot;onMeasure: &quot;</span>)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLayout</span><span class="hljs-params">(changed: <span class="hljs-type">Boolean</span>, left: <span class="hljs-type">Int</span>, top: <span class="hljs-type">Int</span>, right: <span class="hljs-type">Int</span>, bottom: <span class="hljs-type">Int</span>)</span></span> &#123;        <span class="hljs-keyword">super</span>.onLayout(changed, left, top, right, bottom)        Log.d(<span class="hljs-string">&quot;yu&quot;</span>, <span class="hljs-string">&quot;onLayout: &quot;</span>)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>?)</span></span> &#123;        <span class="hljs-keyword">super</span>.onDraw(canvas)        Log.d(<span class="hljs-string">&quot;yu&quot;</span>, <span class="hljs-string">&quot;onDraw: &quot;</span>)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSizeChanged</span><span class="hljs-params">(w: <span class="hljs-type">Int</span>, h: <span class="hljs-type">Int</span>, oldw: <span class="hljs-type">Int</span>, oldh: <span class="hljs-type">Int</span>)</span></span> &#123;        <span class="hljs-keyword">super</span>.onSizeChanged(w, h, oldw, oldh)        Log.d(<span class="hljs-string">&quot;yu&quot;</span>, <span class="hljs-string">&quot;onSizeChanged: &quot;</span>)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDetachedFromWindow</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">super</span>.onDetachedFromWindow()        Log.d(<span class="hljs-string">&quot;yu&quot;</span>, <span class="hljs-string">&quot;onDetachedFromWindow: &quot;</span>)    &#125;&#125;</code></pre></div><p>启动输出</p><div class="code-wrapper"><pre><code class="hljs pf"><span class="hljs-keyword">on</span>FinishInflate：   <span class="hljs-keyword">on</span>AttachedToWindow:<span class="hljs-keyword">on</span>Measure:         <span class="hljs-keyword">on</span>Measure:         <span class="hljs-keyword">on</span>SizeChanged:     <span class="hljs-keyword">on</span>Layout:          <span class="hljs-keyword">on</span>Draw:</code></pre></div><ul><li><strong>DashPathEffect</strong>：将Path的线段虚线化，intervals为虚线的ON和OFF的数组，数组中元素数目需要 &gt;&#x3D; 2； 而phase则为绘制时的偏移量。</li></ul><p><a href="https://juejin.cn/post/6999603842845261860">Android自定义view之利用PathEffect实现动态效果 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>layout</tag>
      
      <tag>view</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo_Fluid_Tag插件的使用</title>
    <link href="/%E7%8E%AF%E5%A2%83/HexoFluidTag%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/%E7%8E%AF%E5%A2%83/HexoFluidTag%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-Fluid-Tag插件的使用"><a href="#Hexo-Fluid-Tag插件的使用" class="headerlink" title="Hexo Fluid Tag插件的使用"></a>Hexo Fluid Tag插件的使用</h1><p><a href="https://hexo.fluid-dev.com/docs/guide/#tag-%E6%8F%92%E4%BB%B6">配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)</a></p><h3 id="Tag-插件"><a href="#Tag-插件" class="headerlink" title="Tag 插件"></a>Tag 插件</h3><h4 id="便签"><a href="#便签" class="headerlink" title="#便签"></a><a href="https://hexo.fluid-dev.com/docs/guide/#%E4%BE%BF%E7%AD%BE">#</a>便签</h4><p>在 markdown 中加入如下的代码来使用便签：</p><div class="code-wrapper"><pre><code class="hljs markdown">&#123;% note success %&#125;文字 或者 <span class="hljs-code">`markdown`</span> 均可&#123;% endnote %&#125;</code></pre></div><p>或者使用 HTML 形式：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>&gt;</span>标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><p>可选便签：</p><p class="note note-primary">primary</p><p class="note note-secondary">secondary</p><p class="note note-success">success</p><p class="note note-danger">danger</p><p class="note note-warning">warning</p><p class="note note-info">info</p><p class="note note-light">light</p><div class="code-wrapper"><pre><code class="hljs autohotkey">WARNING使用时 `&#123;% note primary %&#125;` 和 `&#123;% endnote %&#125;` 需单独一行，否则会出现问题</code></pre></div><h4 id="行内标签"><a href="#行内标签" class="headerlink" title="#行内标签"></a><a href="https://hexo.fluid-dev.com/docs/guide/#%E8%A1%8C%E5%86%85%E6%A0%87%E7%AD%BE">#</a>行内标签</h4><p>在 markdown 中加入如下的代码来使用 Label：</p><div class="code-wrapper"><pre><code class="hljs markdown">&#123;% label primary @text %&#125;</code></pre></div><p>或者使用 HTML 形式：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;label label-primary&quot;</span>&gt;</span>Label<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div><p>可选 Label：</p><p><span class="label label-primary">primary</span><br><span class="label label-default">default</span><br><span class="label label-info">info</span><br><span class="label label-success">success</span><br><span class="label label-warning">warning</span><br><span class="label label-danger">danger</span></p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-built_in">WARNING</span>若使用 `&#123;% label <span class="hljs-keyword">primary</span> @<span class="hljs-type">text</span> %&#125;`，<span class="hljs-type">text</span> 不能以 @ 开头</code></pre></div><h4 id="勾选框"><a href="#勾选框" class="headerlink" title="#勾选框"></a><a href="https://hexo.fluid-dev.com/docs/guide/#%E5%8B%BE%E9%80%89%E6%A1%86">#</a>勾选框</h4><p>在 markdown 中加入如下的代码来使用 Checkbox：</p><div class="code-wrapper"><pre><code class="hljs markdown">&#123;% cb text, checked?, incline? %&#125;</code></pre></div><ul><li>text：显示的文字</li><li>checked：默认是否已勾选，默认 false</li><li>incline: 是否内联（可以理解为后面的文字是否换行），默认 false</li></ul><p>示例：</p><div>            <input type="checkbox" disabled >普通示例          </div><div>            <input type="checkbox" disabled checked="checked">默认选中          </div>            <input type="checkbox" disabled >内联示例           后面文字不换行  <input type="checkbox" disabled > 也可以只传入一个参数，文字写在后边（这样不支持外联）<h4 id="按钮"><a href="#按钮" class="headerlink" title="#按钮"></a><a href="https://hexo.fluid-dev.com/docs/guide/#%E6%8C%89%E9%92%AE">#</a>按钮</h4><p>你可以在 markdown 中加入如下的代码来使用 Button：</p><div class="code-wrapper"><pre><code class="hljs markdown">&#123;% btn url, text, title %&#125;</code></pre></div><p>或者使用 HTML 形式：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div><ul><li>url：跳转链接</li><li>text：显示的文字</li><li>title：鼠标悬停时显示的文字（可选）</li></ul><p><a class="btn" href="yorick.love" title="title">Button</a></p>]]></content>
    
    
    <categories>
      
      <category>Environment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android应用架构指南</title>
    <link href="/Android/Android%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%8C%87%E5%8D%97/"/>
    <url>/Android/Android%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Android应用架构指南"><a href="#Android应用架构指南" class="headerlink" title="Android应用架构指南"></a>Android应用架构指南</h1><p>[TOC]</p><p><a href="https://developer.android.google.cn/jetpack/guide?hl=zh-cn">应用架构指南  | Android 开发者  | Android Developers (google.cn)</a></p><h2 id="移动应用用户体验"><a href="#移动应用用户体验" class="headerlink" title="移动应用用户体验"></a>移动应用用户体验</h2><p>典型的 Android 应用包含多个<a href="https://developer.android.google.cn/guide/components/fundamentals?hl=zh-cn#components">应用组件</a>，包括 <a href="https://developer.android.google.cn/guide/components/activities/intro-activities?hl=zh-cn">Activity</a>、<a href="https://developer.android.google.cn/guide/fragments?hl=zh-cn">Fragment</a>、<a href="https://developer.android.google.cn/guide/components/services?hl=zh-cn">Service</a>、<a href="https://developer.android.google.cn/guide/topics/providers/content-providers?hl=zh-cn">内容提供程序</a>和<a href="https://developer.android.google.cn/guide/components/broadcasts?hl=zh-cn">广播接收器</a>。您需要在<a href="https://developer.android.google.cn/guide/topics/manifest/manifest-intro?hl=zh-cn">应用清单</a>中声明其中的大多数应用组件。Android 操作系统随后会使用此文件来决定如何将您的应用集成到设备的整体用户体验中。鉴于典型的 Android 应用可能包含多个组件，并且用户经常会在短时间内与多个应用进行互动，因此应用需要适应不同类型的用户驱动型工作流和任务。</p><p>请注意，移动设备的资源也很有限，因此操作系统可能随时终止某些应用进程以便为新的进程腾出空间。</p><p>鉴于这种环境条件，您的应用组件可以不按顺序地单独启动，并且操作系统或用户可以随时销毁它们。由于这些事件不受您的控制，因此您不应在内存中存储或保留任何应用数据或状态，并且应用组件不应相互依赖。</p><h2 id="常见的架构原则"><a href="#常见的架构原则" class="headerlink" title="常见的架构原则"></a>常见的架构原则</h2><p>如果您不应使用应用组件存储应用数据和状态，那么您应该改为如何设计应用呢？</p><p>随着 Android 应用大小不断增加，您定义的架构务必要能允许应用扩缩、提升应用的稳健性并且方便对应用进行测试。</p><p>应用架构定义了应用的各个部分之间的界限以及每个部分应承担的职责。为了满足上述需求，您应该按照某些特定原则设计应用架构。</p><h3 id="分离关注点"><a href="#分离关注点" class="headerlink" title="分离关注点"></a>分离关注点</h3><p>要遵循的最重要的原则是<a href="https://en.wikipedia.org/wiki/Separation_of_concerns">分离关注点</a>。 一种常见的错误是在一个 <a href="https://developer.android.google.cn/reference/android/app/Activity?hl=zh-cn"><code>Activity</code></a> 或 <a href="https://developer.android.google.cn/reference/android/app/Fragment?hl=zh-cn"><code>Fragment</code></a> 中编写所有代码。这些基于界面的类应仅包含处理界面和操作系统交互的逻辑。您应使这些类尽可能保持精简，这样可以避免许多与组件生命周期相关的问题，并提高这些类的可测试性。</p><p>请注意，您并非拥有 <code>Activity</code> 和 <code>Fragment</code> 的实现；它们只是表示 Android 操作系统与应用之间关系的粘合类。操作系统可能会根据用户互动或因内存不足等系统条件随时销毁它们。为了提供令人满意的用户体验和更易于管理的应用维护体验，最好尽量减少对它们的依赖。</p><h3 id="通过数据模型驱动界面"><a href="#通过数据模型驱动界面" class="headerlink" title="通过数据模型驱动界面"></a>通过数据模型驱动界面</h3><p>另一个重要原则是您应该通过数据模型驱动界面（最好是持久性模型）。数据模型代表应用的数据。它们独立于应用中的界面元素和其他组件。这意味着它们与界面和应用组件的生命周期没有关联，但仍会在操作系统决定从内存中移除应用的进程时被销毁。</p><p>持久性模型是理想之选，原因如下：</p><ul><li>如果 Android 操作系统销毁应用以释放资源，用户不会丢失数据。</li><li>当网络连接不稳定或不可用时，应用会继续工作。</li></ul><p>如果您的应用机构以数据模型类为基础，您的应用会更便于测试、更稳定可靠。</p><h2 id="推荐的应用架构"><a href="#推荐的应用架构" class="headerlink" title="推荐的应用架构"></a>推荐的应用架构</h2><p>本部分将演示如何按照建议的最佳做法构建应用。</p><div class="note note-info">            <p><strong>注意</strong>：本页中提供的建议和最佳实践可应用于广泛的应用。遵循这些建议和最佳实践可以提升应用的可扩缩性、质量和稳健性，并可使应用更易于测试。不过，您应该将这些提示视为指南，并视需要进行调整来满足您的要求。</p>          </div><p>基于上一部分提到的常见架构原则，每个应用应至少有两个层：</p><ul><li>界面层 - 在屏幕上显示应用数据。</li><li>数据层 - 包含应用的业务逻辑并公开应用数据。</li></ul><p>您可以额外添加一个名为“网域层”的架构层，以简化和重复使用界面层与数据层之间的交互。</p><p><img src="/./img/mad-arch-overview.png" alt="在典型的应用架构中，界面层会从数据层或可选网域层（位于界面层和数据层之间）获取应用数据。"></p><p><strong>图 1.</strong> 典型应用架构的示意图。</p><div class="note note-info">            <p><strong>注意</strong>：本指南中示意图中的箭头表示各个类之间的依赖关系。例如，网域层依赖于数据层类。</p>          </div><h3 id="界面层"><a href="#界面层" class="headerlink" title="界面层"></a>界面层</h3><p>界面层（或呈现层）的作用是在屏幕上显示应用数据。无论是因为用户互动（例如按下按钮）还是外部输入（例如网络响应）导致数据发生变化时，界面都应更新以反映相应的变化。</p><p>界面层由以下两部分组成：</p><ul><li>在屏幕上呈现数据的界面元素。您可以使用 View 或 <a href="https://developer.android.google.cn/jetpack/compose?hl=zh-cn">Jetpack Compose</a> 函数构建这些元素。</li><li>用于存储数据、向界面提供数据以及处理逻辑的状态容器（如 <a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh-cn">ViewModel</a> 类）。</li></ul><p><img src="/./img/mad-arch-overview-ui.png" alt="在典型架构中，界面层的界面元素依赖于状态容器，而状态容器又依赖于来自数据层或可选网域层的类。"></p><p>**图 2.**界面层在应用架构中的作用。</p><p>如需详细了解此层，请参阅<a href="https://developer.android.google.cn/jetpack/guide/ui-layer?hl=zh-cn">界面层页面</a>。</p><h3 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h3><p>应用的数据层包含<em>业务逻辑</em>。业务逻辑决定应用的价值，它包含决定应用如何创建、存储和更改数据的规则。</p><p>数据层由多个代码库组成，其中每个代码库可包含零到多个数据源。您应该为应用处理的每种不同类型的数据创建一个代码库类。例如，您可以为与电影相关的数据创建 <code>MoviesRepository</code> 类，或者为与付款相关的数据创建 <code>PaymentsRepository</code> 类。</p><p><img src="/./img/mad-arch-overview-data.png" alt="在典型架构中，数据层的代码库会向应用的其余部分提供数据，而这些代码库则依赖于数据源。"></p><p><strong>图 3.</strong> 数据层在应用架构中的作用。</p><p>代码库类负责以下任务：</p><ul><li>向应用的其余部分提供数据。</li><li>对数据进行集中更改。</li><li>解决多个数据源之间的冲突。</li><li>从应用的其余部分中提取数据源。</li><li>包含业务逻辑。</li></ul><p>每个数据源类应仅负责处理一个数据源，该数据源可以是文件、网络来源或本地数据库。数据源类是应用与数据操作系统之间的桥梁。</p><p>如需详细了解此层，请参阅<a href="https://developer.android.google.cn/jetpack/guide/data-layer?hl=zh-cn">数据层页面</a>。</p><h3 id="网域层"><a href="#网域层" class="headerlink" title="网域层"></a>网域层</h3><p>网域层是位于界面与数据层之间的可选层。</p><p>网域层负责封装复杂的业务逻辑，或者由多个 ViewModel 重复使用的简单业务逻辑。此层是可选的，因为并非所有应用都有这类需求。请仅在需要时使用该层，例如处理复杂逻辑或支持可重用性。</p><p><img src="/./img/mad-arch-overview-domain.png" alt="如果添加了此层，则该可选网域层会向界面层提供依赖项，而它自身依赖于数据层。"></p><p>**图 4.**网域层在应用架构中的作用。</p><p>该层中的类通常称为<em>用例</em>或<em>交互方</em>。每个用例都应仅负责单个功能。例如，如果多个 ViewModel 依赖时区在屏幕上显示适当的消息，则您的应用可能具有 <code>GetTimeZoneUseCase</code> 类。</p><p>如需详细了解此层，请参阅<a href="https://developer.android.google.cn/jetpack/guide/domain-layer?hl=zh-cn">网域层页面</a>。</p><h2 id="管理组件之间的依赖关系"><a href="#管理组件之间的依赖关系" class="headerlink" title="管理组件之间的依赖关系"></a>管理组件之间的依赖关系</h2><p>应用中的类要依赖其他类才能正常工作。您可以使用以下任一设计模式来收集特定类的依赖项：</p><ul><li><a href="https://developer.android.google.cn/training/dependency-injection?hl=zh-cn">依赖注入 (DI)</a>：依赖注入使类能够定义其依赖项而不构造它们。在运行时，另一个类负责提供这些依赖项。</li><li><a href="https://en.wikipedia.org/wiki/Service_locator_pattern">服务定位器</a>：服务定位器模式提供了一个注册表，类可以从中获取其依赖项而不构造它们。</li></ul><p>您可以借助这些模式来扩展代码，因为它们可提供清晰的依赖项管理模式（无需复制代码，也不会增添复杂性）。 此外，您还可以借助这些模式在测试和生产实现之间快速切换。</p><p><strong>我们建议在 Android 应用中采用依赖项注入模式并使用 <a href="https://developer.android.google.cn/training/dependency-injection/hilt-android?hl=zh-cn">Hilt 库</a>。</strong>Hilt 通过遍历依赖项树自动构造对象，为依赖项提供编译时保证，并为 Android 框架类创建依赖项容器。</p><h2 id="常见的最佳做法"><a href="#常见的最佳做法" class="headerlink" title="常见的最佳做法"></a>常见的最佳做法</h2><p>编程是一个创造性的领域，构建 Android 应用也不例外。 无论是在多个 Activity 或 Fragment 之间传递数据，检索远程数据并将其保留在本地以在离线模式下使用，还是复杂应用遇到的任何其他常见情况，解决问题的方法都会有很多种。</p><p>虽然以下建议不是强制性的，但在大多数情况下，遵循这些建议会使您的代码库更强大、可测试性更高且更易维护：</p><p><strong>不要将数据存储在应用组件中。</strong></p><p>请避免将应用的入口点（如 Activity、Service 和广播接收器）指定为数据源。相反，您应只将其与其他组件协调，以检索与该入口点相关的数据子集。每个应用组件存在的时间都很短暂，具体取决于用户与其设备的交互情况以及系统当前的整体运行状况。</p><p><strong>减少对 Android 类的依赖</strong>。</p><p>您的应用组件应该是唯一依赖于 Android 框架 SDK API （例如 <a href="https://developer.android.google.cn/reference/android/content/Context?hl=zh-cn"><code>Context</code></a> 或 <a href="https://developer.android.google.cn/guide/topics/ui/notifiers/toasts?hl=zh-cn"><code>Toast</code></a>）的类。将应用中的其他类与这些类分离开来有助于改善可测试性，并减少应用中的<a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)">耦合</a>。</p><p><strong>在应用的各个模块之间设定明确定义的职责界限。</strong></p><p>例如，请勿在代码库中将从网络加载数据的代码散布到多个类或软件包中。同样，也不要将不相关的职责（如数据缓存和数据绑定）定义到同一个类中。遵循<a href="https://developer.android.google.cn/jetpack/guide?hl=zh-cn#recommended-app-arch">推荐的应用架构</a>可以帮助您解决此问题。</p><p><strong>尽量少公开每个模块中的代码。</strong></p><p>例如，请勿试图创建从模块提供内部实现细节的快捷方式。短期内，您可能会省点时间，但随着代码库的不断发展，您可能会反复陷入技术上的麻烦。</p><p><strong>专注于应用的独特核心，以使其从其他应用中脱颖而出。</strong></p><p>不要一次又一次地编写相同的样板代码，这是在做无用功。 相反，您应将时间和精力集中放在能让应用与众不同的方面上，并让 Jetpack 库以及建议的其他库处理重复的样板。</p><p><strong>考虑如何使应用的每个部分可独立测试。</strong></p><p>例如，如果使用明确定义的 API 从网络获取数据，将会更容易测试在本地数据库中保留该数据的模块。如果您将这两个模块的逻辑混放在一处，或将网络代码分散在整个代码库中，那么即便能够进行有效测试，难度也会大很多。</p><p><strong>保留尽可能多的相关数据和最新数据。</strong></p><p>这样，即使用户的设备处于离线模式，他们也可以使用您应用的功能。请记住，并非所有用户都能享受到稳定的高速连接 - 即使有时可以使用，在比较拥挤的地方网络信号也可能不佳。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下 Google 示例展示了良好的应用架构。您不妨浏览一下它们，了解如何实际运用本指南：</p><ul><li><a href="https://github.com/google/iosched">iosched</a>（Google I&#x2F;O 应用）</li><li><a href="https://github.com/android/sunflower">Sunflower</a></li><li><a href="https://github.com/android/trackr">Trackr</a></li><li><a href="https://github.com/android/compose-samples/tree/main/JetNews">Jetnews</a>（使用 Jetpack Compose 实现）</li><li><a href="https://github.com/android/architecture-samples">架构示例</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin协程</title>
    <link href="/Kotlin/Kotlin%E5%8D%8F%E7%A8%8B/"/>
    <url>/Kotlin/Kotlin%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Kotlin协程"><a href="#Kotlin协程" class="headerlink" title="Kotlin协程"></a>Kotlin协程</h1><p>[TOC]</p><p>本篇以Android中的Kotlin协程为例</p><p><a href="https://developer.android.google.cn/kotlin/coroutines?hl=zh-cn">Android 上的 Kotlin 协程  | Android 开发者  | Android Developers (google.cn)</a></p><h2 id="协程基本介绍"><a href="#协程基本介绍" class="headerlink" title="协程基本介绍"></a>协程基本介绍</h2><p>协程是一项 Kotlin 功能，可将长时间运行的任务（例如数据库或网络访问）的异步回调转换为顺序代码。</p><p>为了避免用户在使用您的应用时感觉到任何卡顿，主线程必须<a href="https://medium.com/androiddevelopers/exceed-the-android-speed-limit-b73a0692abc1">每隔 16 毫秒或更短时间</a>更新一次屏幕，也就是每秒约 60 帧，这个过程中会执行<code>onDraw()</code>方法来渲染UI。</p><p>下面的代码向网络请求数据。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDataNeeded</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> result = networkRequest()    <span class="hljs-comment">// Successful network request</span>    databaseSave(result)    <span class="hljs-comment">// Result saved</span>&#125;</code></pre></div><p>但是会阻塞主线程。</p><p><img src="/./img/image-20221216112959847.png" alt="image-20221216112959847"></p><p>我们可以使用回调函数实现相同的功能，这样不会阻塞。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDataNeeded</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// Async callbacks</span>    networkRequest &#123; result -&gt;       <span class="hljs-comment">// Successful network request</span>       databaseSave(result) &#123; rows -&gt;         <span class="hljs-comment">// Result saved</span>       &#125;    &#125;&#125;</code></pre></div><p>网络库将在另一个线程上请求网络，当数据准备好时，传递数据或回调到主线程。</p><p><img src="/./img/image-20221216112031955.png" alt="image-20221216112031955"></p><p>系统使用协程将基于回调的代码转换为顺序代码，我们的网络库仍然使用另一个线程来运行网络。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDataNeeded</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// The same code with coroutines</span>    <span class="hljs-keyword">val</span> result = networkRequest()    <span class="hljs-comment">// Successful network request</span>    databaseSave(result)    <span class="hljs-comment">// Result saved</span>&#125;</code></pre></div><p>挂起函数内的代码和普通函数的执行方式不同，它执行每一行代码，直到到达一个调用，这时他会复制当前的状态然后挂起，等待网络请求完成，再恢复保存的状态。</p><p><img src="/./img/image-20221216114040628.png" alt="image-20221216114040628"></p><p>关键字 <code>suspend</code> 是 Kotlin 将函数（即函数类型）标记为可供协程使用的方式。当协程调用标记为 <code>suspend</code> 的函数时，它不会像常规函数调用一样在函数返回之前进行阻塞，而是<strong>挂起</strong>执行，直到结果就绪为止，然后从上次停止的位置<strong>恢复</strong>并使用返回的结果。当它挂起并等待结果时，<strong>它会取消阻塞正在运行它的线程</strong>，以便其他函数或协程可以运行。</p><p>协程的优点：</p><ul><li>不用写复杂的回调函数（Replace  callbacks）</li><li>线程安全（Main safety）</li></ul><p>在 Android 上，避免阻塞主线程是非常必要的。主线程是一个处理所有界面更新的线程，也是调用所有点击处理程序和其他界面回调的线程。因此，主线程必须顺畅运行才能确保出色的用户体验。</p><p>为了避免用户在使用您的应用时感觉到任何卡顿，主线程必须<a href="https://medium.com/androiddevelopers/exceed-the-android-speed-limit-b73a0692abc1">每隔 16 毫秒或更短时间</a>更新一次屏幕，也就是每秒约 60 帧。许多常见任务所需的时间都比这个时间长，例如解析大型 JSON 数据集、将数据写入数据库或从网络提取数据。因此，从主线程调用此类代码可能会导致应用暂停、卡顿甚至冻结。如果您阻塞主线程太久，应用甚至可能会崩溃并显示一个<strong>应用无响应</strong>对话框。</p><h2 id="向项目添加协程"><a href="#向项目添加协程" class="headerlink" title="向项目添加协程"></a>向项目添加协程</h2><p>要在 Kotlin 中使用协程，您必须在项目的 <code>build.gradle (Module: app)</code> 文件中添加 <code>coroutines-core</code> 库。</p><p>Android 上的协程作为核心库和 Android 专用扩展函数提供：</p><ul><li><strong>kotlinx-coroutines-core</strong> - 用于在 Kotlin 中使用协程的主接口</li><li><strong>kotlinx-coroutines-android</strong> - 在协程中支持 Android 主线程</li></ul><p>此初始应用已在 <code>build.gradle.</code> 中包含依赖项。创建新的应用项目时，您需要打开 <code>build.gradle (Module: app)</code> 并将协程依赖项添加到项目中。</p><div class="code-wrapper"><pre><code class="hljs groovy">dependencies &#123;  ...  implementation <span class="hljs-string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:x.x.x&quot;</span>  implementation <span class="hljs-string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:x.x.x&quot;</span>&#125;</code></pre></div><p>您可以在 <a href="https://github.com/Kotlin/kotlinx.coroutines/releases">Kotlin 协程版本页面</a>上找到协程库的最新版版本号，以替代“xxx”。</p><h2 id="回调模式"><a href="#回调模式" class="headerlink" title="回调模式"></a>回调模式</h2><p>在不阻塞主线程的情况下执行长时间运行的任务的一种模式是回调。通过使用回调，您可以在后台线程上启动长时间运行的任务。任务完成后，系统会调用回调函数，以在主线程上告知您结果。</p><p>我们来看一个回调模式的示例。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// Slow request with callbacks</span><span class="hljs-meta">@UiThread</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeNetworkRequest</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// The slow network request runs on another thread</span>    slowFetch &#123; result -&gt;        <span class="hljs-comment">// When the result is ready, this callback will get the result</span>        show(result)    &#125;    <span class="hljs-comment">// makeNetworkRequest() exits after calling slowFetch without waiting for the result</span>&#125;</code></pre></div><p>由于此代码带有 <a href="https://developer.android.google.cn/reference/android/support/annotation/UiThread?hl=zh-cn"><code>@UiThread</code></a> 注解，因此它必须足够快地运行以在主线程上执行。也就是说，它需要非常快地返回，以便下一次屏幕更新不会出现延迟。不过，由于 <code>slowFetch</code> 需要几秒钟甚至几分钟才能完成，因此主线程不能等待结果。<code>show(result)</code> 回调允许 <code>slowFetch</code> 在后台线程上运行，并在准备就绪后返回结果。</p><h2 id="使用协程移除回调"><a href="#使用协程移除回调" class="headerlink" title="使用协程移除回调"></a>使用协程移除回调</h2><p>回调是一种很好的模式，但也存在缺点。过多使用回调的代码可能会变得难以读取和推演。此外，回调也不允许使用某些语言功能，例如异常。</p><p>Kotlin 协程使您能够将基于回调的代码转换为顺序代码。顺序编写的代码通常更易于阅读，甚至可以使用异常等语言功能。</p><p>最后，两者所做的事情完全相同：等待长时间运行的任务获得结果，然后继续执行。不过，两者的代码看起来却截然不同。</p><p>关键字 <code>suspend</code> 是 Kotlin 将函数（即函数类型）标记为可供协程使用的方式。当协程调用标记为 <code>suspend</code> 的函数时，它不会像常规函数调用一样在函数返回之前进行阻塞，而是<strong>挂起</strong>执行，直到结果就绪为止，然后从上次停止的位置<strong>恢复</strong>并使用返回的结果。当它挂起并等待结果时，<strong>它会取消阻塞正在运行它的线程</strong>，以便其他函数或协程可以运行。</p><p>例如，在下面的代码中，<code>makeNetworkRequest()</code> 和 <code>slowFetch()</code> 都是 <code>suspend</code> 函数。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// Slow request with coroutines</span><span class="hljs-meta">@UiThread</span><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeNetworkRequest</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// slowFetch is another suspend function so instead of</span>    <span class="hljs-comment">// blocking the main thread  makeNetworkRequest will `suspend` until the result is</span>    <span class="hljs-comment">// ready</span>    <span class="hljs-keyword">val</span> result = slowFetch()    <span class="hljs-comment">// continue to execute after the result is ready</span>    show(result)&#125;<span class="hljs-comment">// slowFetch is main-safe using coroutines</span><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">slowFetch</span><span class="hljs-params">()</span></span>: SlowResult &#123; ... &#125;</code></pre></div><p>与回调版本一样，<code>makeNetworkRequest</code> 必须立即从主线程返回，因为它被标记为 <code>@UiThread</code>。这意味着，它通常无法调用 <code>slowFetch</code> 等阻塞方法。这里体现了 <code>suspend</code> 关键字的神奇之处。</p><div class="note note-success">            <p><strong>重要提示</strong>：<code>suspend</code> 关键字不指定运行代码的线程。挂起函数可以在后台线程或主线程上运行。</p>          </div><p>与基于回调的代码相比，协程代码可以利用更少的代码实现取消阻塞当前线程的相同效果。由于它具有顺序样式，因此可以轻松地链接多个长时间运行的任务，而无需创建多个回调。例如，如果代码从两个网络端点提取结果并将结果保存到数据库，则此代码可以编写为协程中的函数，而无需回调。类似以下代码：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// Request data from network and save it to database with coroutines</span><span class="hljs-comment">// Because of the @WorkerThread, this function cannot be called on the</span><span class="hljs-comment">// main thread without causing an error.</span><span class="hljs-meta">@WorkerThread</span><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeNetworkRequest</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// slowFetch and anotherFetch are suspend functions</span>    <span class="hljs-keyword">val</span> slow = slowFetch()    <span class="hljs-keyword">val</span> another = anotherFetch()    <span class="hljs-comment">// save is a regular function and will block this thread</span>    database.save(slow, another)&#125;<span class="hljs-comment">// slowFetch is main-safe using coroutines</span><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">slowFetch</span><span class="hljs-params">()</span></span>: SlowResult &#123; ... &#125;<span class="hljs-comment">// anotherFetch is main-safe using coroutines</span><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">anotherFetch</span><span class="hljs-params">()</span></span>: AnotherResult &#123; ... &#125;</code></pre></div><h2 id="了解-CoroutineScope"><a href="#了解-CoroutineScope" class="headerlink" title="了解 CoroutineScope"></a>了解 CoroutineScope</h2><p>在 Kotlin 中，所有协程都在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/"><code>CoroutineScope</code></a> 中运行。作用域在其整个作业期间会控制协程的生命周期。如果取消某个作用域的作业，则该作用域内启动的所有协程也将取消。在 Android 上，在一些情况下，例如当用户离开 <code>Activity</code> 或 <code>Fragment</code> 时，您可以使用作用域取消所有正在运行的协程。作用域还允许您指定默认调度程序。调度程序可以控制哪个线程运行协程。</p><p>对于界面启动的协程，通常在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html"><code>Dispatchers.Main</code></a>（Android 上的主线程）上启动这类协程是正确的。在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html"><code>Dispatchers.Main</code></a> 上启动的协程在挂起期间不会阻塞主线程。由于 <code>ViewModel</code> 协程几乎总是在主线程上更新界面，因此在主线程上启动协程可避免额外的线程切换。在主线程上启动的协程可在启动后随时切换调度程序。例如，它可以使用另一个调度程序从主线程外解析大型 JSON 结果。</p><div class="note note-secondary">            <p><strong>协程提供主线程安全</strong><br>由于协程可以随时轻松地切换线程并将结果传递回原始线程，因此最好在主线程上启动与界面相关的协程。</p><p>使用协程时，<a href="https://developer.android.google.cn/jetpack/androidx/releases/room?hl=zh-cn"><code>Room</code></a> 和 <a href="https://github.com/square/retrofit"><code>Retrofit</code></a> 等库原生提供<strong>主线程安全</strong>，因此您无需管理线程来进行网络或数据库调用。这往往能大幅简化代码。</p><p>但是，即便使用协程，<strong>阻塞代码</strong>（例如对列表进行排序或从文件读取数据）仍然需要显式代码来创建<strong>主线程安全</strong>。如果您使用的网络或数据库（还）不支持协程，情况也是如此。</p>          </div><p>Kotlin 协程默认提供三个调度程序：<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html"><code>Main</code></a>、<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html"><code>IO</code></a> 和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html"><code>Default</code></a>。IO 调度程序针对 IO 工作进行了优化，例如从网络或磁盘读取内容，而 Default 调度程序则针对 CPU 密集型任务进行了优化。</p>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协程</tag>
      
      <tag>Coroutine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Compose中使用Navigation</title>
    <link href="/Android/AndroidCompose%E4%B8%AD%E4%BD%BF%E7%94%A8Navigation/"/>
    <url>/Android/AndroidCompose%E4%B8%AD%E4%BD%BF%E7%94%A8Navigation/</url>
    
    <content type="html"><![CDATA[<h1 id="Jetpack-Compose-Navigation"><a href="#Jetpack-Compose-Navigation" class="headerlink" title="Jetpack Compose Navigation"></a>Jetpack Compose Navigation</h1><p><a href="https://developer.android.google.cn/jetpack/compose/navigation?hl=zh-cn">使用 Compose 进行导航  | Jetpack Compose  | Android Developers (google.cn)</a></p><h2 id="迁移到-Compose-Navigation"><a href="#迁移到-Compose-Navigation" class="headerlink" title="迁移到 Compose Navigation"></a>迁移到 Compose Navigation</h2><p>迁移到 Jetpack Compose 基本涉及以下几个步骤：</p><ol><li>添加最新的 <a href="https://mvnrepository.com/artifact/androidx.navigation/navigation-compose">Compose Navigation 依赖项</a></li><li>设置 <a href="https://developer.android.com/jetpack/compose/navigation#getting-started"><code>NavController</code></a></li><li>添加 <a href="https://developer.android.com/jetpack/compose/navigation#create-navhost"><code>NavHost</code></a> 并创建导航图</li><li>准备路线以在不同的应用目的地之间导航</li><li>将当前导航机制替换为 Compose Navigation</li></ol><p>使用 Compose 中的 Navigation 时，导航图中的每个可组合目的地都与一个<a href="https://developer.android.com/jetpack/compose/navigation#create-navhost"><strong>路线</strong></a>相关联。路线用字符串表示，用于定义指向可组合项的路径，并指引您的 <code>navController</code> 到达正确的位置。您可以将其视为指向特定目的地的隐式深层链接。<strong>每个目的地都必须有一条唯一的路线</strong>。</p><p>Navigation 的 3 个主要部分是 <code>NavController</code>、<code>NavGraph</code> 和 <code>NavHost</code>。<code>NavController</code> 始终与一个 <code>NavHost</code> 可组合项相关联。<code>NavHost</code> 充当容器，负责显示导航图的当前目的地。当您在可组合项之间进行导航时，<code>NavHost</code> 的内容会自动进行<a href="https://developer.android.com/jetpack/compose/mental-model#recomposition">重组</a>。此外，它还会将 <code>NavController</code> 与导航图 (<a href="https://developer.android.com/reference/androidx/navigation/NavGraph"><code>NavGraph</code></a>) 相关联，后者用于标出能够在其间进行导航的可组合目的地。它实际上是一系列可提取的目的地。</p><p>我们将介绍同一 <code>navigateSingleTopTo</code> 扩展函数中可供您使用的一些其他选项：</p><ul><li><code>launchSingleTop = true</code> - 如上所述，这可确保返回堆栈顶部最多只有给定目的地的一个副本</li><li>在 Rally 应用中，这意味着，多次重按同一标签页不会启动同一目的地的多个副本</li><li><code>popUpTo(startDestination) &#123; saveState = true &#125;</code> - 弹出到导航图的起始目的地，以免在您选择标签页时在返回堆栈上构建大型目的地堆栈</li><li>在 Rally 中，这意味着，在任何目的地按下返回箭头都会将整个返回堆栈弹出到“Overview”屏幕</li><li><code>restoreState = true</code> - 确定此导航操作是否应恢复 <code>PopUpToBuilder.saveState</code> 或 <code>popUpToSaveState</code> 属性之前保存的任何状态。请注意，如果之前未使用要导航到的目的地 ID 保存任何状态，<strong>此项不会产生任何影响</strong></li><li>在 Rally 中，这意味着，重按同一标签页会保留屏幕上之前的数据和用户状态，而无需重新加载</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jetpack</tag>
      
      <tag>Compose</tag>
      
      <tag>Navigation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Compose布局详解</title>
    <link href="/Android/AndroidCompose%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3/"/>
    <url>/Android/AndroidCompose%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="深入了解-Jetpack-Compose-布局"><a href="#深入了解-Jetpack-Compose-布局" class="headerlink" title="深入了解 Jetpack Compose 布局"></a>深入了解 Jetpack Compose 布局</h1><p>[TOC]</p><p>Jetpack Compose 提供一个全新的布局模型，用于构建精美、高效的界面。我们深入介绍了这个布局模型，说明了它的底层工作逻辑，它所具备的功能，捆绑的布局和修饰符是如何构建的，以及可以如何轻松创建自定义布局和修饰符。本次研讨会将有助于了解 Compose 的布局模型，您可以使用这个模型来构建应用所需的布局，并且编写更优质的代码。</p><p>内容来自<a href="https://youtu.be/zMKMwh9gZuI">深入了解 Jetpack Compose 布局 - YouTube</a></p><h2 id="Compose布局系统的目标"><a href="#Compose布局系统的目标" class="headerlink" title="Compose布局系统的目标"></a>Compose布局系统的目标</h2><ul><li>简化布局的创建，尤其是自定义布局</li><li>提供强大的布局系统</li><li>实现卓越的性能</li></ul><p><img src="/./img/image-20221209183304625.png" alt="image-20221209183304625"></p><p><strong>如何实现以上目标？</strong></p><h2 id="Jetpack-Compose-如何将状态转为界面"><a href="#Jetpack-Compose-如何将状态转为界面" class="headerlink" title="Jetpack Compose 如何将状态转为界面"></a>Jetpack Compose 如何将状态转为界面</h2><p>这个流程包含三个阶段</p><ul><li>组合</li><li>布局</li><li>绘制</li></ul><p><img src="/./img/image-20221209183505668.png" alt="image-20221209183505668"></p><h3 id="组合阶段（Composition）"><a href="#组合阶段（Composition）" class="headerlink" title="组合阶段（Composition）"></a>组合阶段（Composition）</h3><p>组合阶段会执行可组合函数，这些函数会创建界面并组建界面树。</p><p>例如，执行这个SearchResult可组合函数，就会生成这样一个界面树。</p><p><img src="/./img/image-20221209184149125.png" alt="image-20221209184149125"></p><p>可组合项包含逻辑和控制流，在不同的状态下产生不同的界面树。</p><h3 id="布局阶段（Layout）"><a href="#布局阶段（Layout）" class="headerlink" title="布局阶段（Layout）"></a>布局阶段（Layout）</h3><p>布局阶段会遍历整个界面树，测量每个界面元素并将它们放置在屏幕上的二维空间。也就是说，每个节点会确定其宽度和高度以及x和y坐标。</p><h3 id="绘制阶段（Drawing）"><a href="#绘制阶段（Drawing）" class="headerlink" title="绘制阶段（Drawing）"></a>绘制阶段（Drawing）</h3><p>绘制阶段会重新遍历界面树并呈现全部元素。</p><h2 id="布局阶段的深入介绍"><a href="#布局阶段的深入介绍" class="headerlink" title="布局阶段的深入介绍"></a>布局阶段的深入介绍</h2><p>布局阶段包含两个环节：</p><ul><li>测量（Measure）</li><li>放置（Place）</li></ul><p><img src="/./img/image-20221209185018210.png" alt="image-20221209185018210"></p><p>大致相当于View中的<code>onMeasure</code>和<code>onLayout</code></p><p>不过在Compose中，这两个环节是相互交织的，因此我们暂且将它们视作一个布局环节。</p><p>界面树中每个节点的布局流程包含三个步骤：</p><ul><li>先测量全部子项</li><li>决定自身尺寸</li><li>放置子项</li></ul><p><img src="/./img/image-20221209185722752.png" alt="image-20221209185722752"></p><p>具体过程如下：</p><p><img src="/./img/image-20221209185904184.png" alt="image-20221209185904184"></p><p>这样以来，跟布局在确定了所有子项的尺寸和位置后，就可以确定自己的尺寸和位置（放置指令），然后就可以进入放置环节，系统重新遍历界面树，并执行所有放置指令。</p><p>上述过程如何实现？</p><p>实际上，每个高级别可组合项都是通过低级别可组合项构造而成的。</p><p><img src="/./img/image-20221209190725298.png" alt="image-20221209190725298"></p><p>每一个在屏幕上放置元素的可组合项都包含了一个或多个Layout可组合项，这个Layout可组合项是Compose界面的基础构建块。</p><p>Layout可组合项发出LayoutNode，在Compose中，界面树或组合是LayoutNode的树。</p><p><img src="/./img/image-20221209190949564.png" alt="image-20221209190949564"></p><p>下面是<code>Layout</code>的源码</p><p>参数：</p><ul><li>content - 可组合放置的子项。</li><li>modifier - 应用于布局的修饰符。</li><li>measurePolicy - 定义布局的测量和定位的策略。</li></ul><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;ComposableLambdaParameterPosition&quot;</span>)</span><span class="hljs-meta">@UiComposable</span><span class="hljs-meta">@Composable</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Layout</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    content: @<span class="hljs-type">Composable</span> @<span class="hljs-type">UiComposable</span> () -&gt; <span class="hljs-type">Unit</span>, <span class="hljs-comment">// The children composable to be laid out</span></span></span><span class="hljs-params"><span class="hljs-function">    modifier: <span class="hljs-type">Modifier</span> = Modifier,    <span class="hljs-comment">// Modifiers to be applied to the layout</span></span></span><span class="hljs-params"><span class="hljs-function">    measurePolicy: <span class="hljs-type">MeasurePolicy</span>   <span class="hljs-comment">// The policy defining the measurement and positioning of the layout</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;    <span class="hljs-keyword">val</span> density = LocalDensity.current    <span class="hljs-keyword">val</span> layoutDirection = LocalLayoutDirection.current    <span class="hljs-keyword">val</span> viewConfiguration = LocalViewConfiguration.current    ReusableComposeNode&lt;ComposeUiNode, Applier&lt;Any&gt;&gt;(        factory = ComposeUiNode.Constructor,        update = &#123;            <span class="hljs-keyword">set</span>(measurePolicy, ComposeUiNode.SetMeasurePolicy)            <span class="hljs-keyword">set</span>(density, ComposeUiNode.SetDensity)            <span class="hljs-keyword">set</span>(layoutDirection, ComposeUiNode.SetLayoutDirection)            <span class="hljs-keyword">set</span>(viewConfiguration, ComposeUiNode.SetViewConfiguration)        &#125;,        skippableUpdate = materializerOf(modifier),        content = content    )&#125;</code></pre></div><p>自定义Layout</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MyCustomLayout</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    modifier: <span class="hljs-type">Modifier</span> = Modifier,</span></span><span class="hljs-params"><span class="hljs-function">    content: @<span class="hljs-type">Composable</span> () -&gt; <span class="hljs-type">Unit</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;    Layout(        modifier = modifier,        content = content    ) &#123;measurables:List&lt;Measurable&gt;,        constraints:Constraints -&gt;        <span class="hljs-comment">// TODO measure and place items</span>    &#125;&#125;</code></pre></div><p>在本例的MyCustomLayout可组合项中，我们调用Layout函数，并以尾随lambda的形式提供measurePolicy用于实现所需的测量函数，这个函数接受<code>Constraints</code>对象，定义布局的大小。</p><p><code>Constraints</code>是一个简单的类，用于对布局可以采用的宽度和高度上下限进行建模。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Constraints</span> &#123;    <span class="hljs-keyword">val</span> minWidth: <span class="hljs-built_in">Int</span>    <span class="hljs-keyword">val</span> maxWidth: <span class="hljs-built_in">Int</span>    <span class="hljs-keyword">val</span> minHeight: <span class="hljs-built_in">Int</span>    <span class="hljs-keyword">val</span> maxHeight: <span class="hljs-built_in">Int</span>&#125;</code></pre></div><p>例如，<code>Constrains</code>可以表达布局可以采用任意尺寸</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> bigAsYouLike = <span class="hljs-keyword">class</span> <span class="hljs-title class_">Constraints</span>(    minWidth = <span class="hljs-number">0</span>,    maxWidth = Constraints.Infinity,    minHeight = <span class="hljs-number">0</span>,    maxHeight = Constraints.Infinity,)</code></pre></div><p>也可以表达布局必须采用确切的尺寸</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> bigAsYouLike = <span class="hljs-keyword">class</span> <span class="hljs-title class_">Constraints</span>(    minWidth = <span class="hljs-number">50</span>,    maxWidth = <span class="hljs-number">50</span>,    minHeight = <span class="hljs-number">50</span>,    maxHeight = <span class="hljs-number">50</span>,)</code></pre></div><p>测量函数还会接收可测量项的列表，此列表表示传入的子项元素，Measurable类型公开用于测量项目的函数。</p><p>每个元素的布局流程具体实现：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MyCustomLayout</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    modifier: <span class="hljs-type">Modifier</span> = Modifier,</span></span><span class="hljs-params"><span class="hljs-function">    content: @<span class="hljs-type">Composable</span> () -&gt; <span class="hljs-type">Unit</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;    Layout(        modifier = modifier,        content = content    ) &#123;measurables:List&lt;Measurable&gt;,        constraints:Constraints -&gt;        <span class="hljs-comment">// 测量各个子项，产生可放置列表</span>        <span class="hljs-keyword">val</span> palceables = measurables.map &#123; measurable -&gt;            <span class="hljs-comment">// 执行measurable的measure方法，此方法接受尺寸约束条件</span>            measurable.measure(constraints)        &#125;        <span class="hljs-comment">// 可放置项是经过测量的子项，都有一个尺寸</span>        <span class="hljs-comment">// 使用可放置项来计算布局大小</span>        <span class="hljs-keyword">val</span> width = <span class="hljs-comment">// 从palceables计算得到</span>        <span class="hljs-keyword">val</span> height = <span class="hljs-comment">// 从palceables计算得到</span>        <span class="hljs-comment">// 报告尺寸</span>        layout(width, height)&#123;            <span class="hljs-comment">// layout方法需要一个放置位置块来放置每个项目</span>            placeables.forEach&#123; palceable -&gt;                placeable.place( <span class="hljs-comment">// 还有palceRelative方法，针对从右向左的语言区域镜像水平坐标</span>                    x = ...                    y = ...                )            &#125;        &#125;    &#125;&#125;</code></pre></div><p>place方法仅能用于measure方法返回的放置项，这样的API设计可以防止放置没有测量过的元素。在View中，onMeasure和onLayout的调用顺序没有强制性要求，容易产生bug。</p><p>示例：实现自定义Colum</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MyColum</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    modifier: <span class="hljs-type">Modifier</span> = Modifier,</span></span><span class="hljs-params"><span class="hljs-function">    content: @<span class="hljs-type">Composable</span> () -&gt; <span class="hljs-type">Unit</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;    Layout(        modifier = modifier,        content = content    ) &#123; measurables: List&lt;Measurable&gt;,        constraints: Constraints -&gt;        <span class="hljs-comment">// 测量</span>        <span class="hljs-keyword">val</span> palceables = measurables.map &#123; measurable -&gt;            measurable.measure(constraints)        &#125;        <span class="hljs-comment">// 计算</span>        <span class="hljs-keyword">val</span> height = palceables.sumOf &#123; it.height &#125;        <span class="hljs-keyword">val</span> width = palceables.maxOf &#123; it.width &#125;        <span class="hljs-comment">// 放置</span>        layout(width, height) &#123;            <span class="hljs-keyword">var</span> y = <span class="hljs-number">0</span>            palceables.forEach &#123; placeable -&gt;                placeable.placeRelative(x = <span class="hljs-number">0</span>, y = y)                y += placeable.height            &#125;        &#125;    &#125;&#125;</code></pre></div><p>示例：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">VerticalGrid</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    modifier: <span class="hljs-type">Modifier</span> = Modifier,</span></span><span class="hljs-params"><span class="hljs-function">    columns:<span class="hljs-type">Int</span> = <span class="hljs-number">2</span>,</span></span><span class="hljs-params"><span class="hljs-function">    content: @<span class="hljs-type">Composable</span> () -&gt; <span class="hljs-type">Unit</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span>&#123;    Layout(        modifier = modifier,        content = content    ) &#123; measurables,constraints-&gt;        <span class="hljs-comment">// 列宽等于布局的最大宽度除以列数</span>        <span class="hljs-keyword">val</span> itemWidth = constraints.maxWidth / columns        <span class="hljs-comment">// 构造新的constraints对象</span>        <span class="hljs-keyword">val</span> itemConstraints = constraints.copy(            minWidth = itemWidth,            maxWidth = itemWidth        )        <span class="hljs-comment">// 使用约束条件测量每个项目</span>        <span class="hljs-keyword">val</span> palceables = measurables.map &#123; measurable -&gt;            measurable.measure(itemConstraints)        &#125;        <span class="hljs-comment">// 将项目放入网格</span>        ...    &#125;&#125;</code></pre></div><p>这种为子项内容创建新约束条件的理念，就是实现自定义测量逻辑的方式，能够创建不同约束条件来测量子项，这是这个模型的关键。</p><p><img src="/./img/image-20221213213747607.png" alt="image-20221213213747607"></p><p>最后父项7传递一系列可选的尺寸供子项选择，一旦子项选择了自己的尺寸，父项就必须接受并进行处理。</p><p>优点是可以通过单次测量遍历整个界面树，并且禁止多个测量循环（测试多次会报错），这样可以提高性能，例如用动画效果呈现布局。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// try out different constraints</span><span class="hljs-keyword">val</span> constraints1 = ...<span class="hljs-keyword">val</span> constraints2 = ...<span class="hljs-keyword">val</span> placeable1 = measurable.measure(constraints1)<span class="hljs-keyword">val</span> placeable2 = measurable.measure(constraints2)</code></pre></div><p>什么时候用自定义布局</p><ul><li>无法用标准布局实现</li><li>需要精确元素的控制测量和放置</li><li>实现布局动画</li><li>需要更高的性能</li></ul><h2 id="Modifier修饰符"><a href="#Modifier修饰符" class="headerlink" title="Modifier修饰符"></a>Modifier修饰符</h2><p>Layout函数接受修饰符链作为参数，修饰符修饰自己所关联到的元素，并且在布局自行进行测量和放置之前参与测量和放置。 </p><p>如何实现？</p><p>有很多影响不同行为的各类修饰符，例如drawing修饰符，pointerInput修饰符和focus修饰符，和我们密切相关的是LayoutModifier。 它提供了measure方法，此方法几乎与Layout组合项完全一样，但是它只作用于单个可测量项，而不是可测量项列表，因为修饰符就是应用于单个项目的 。 </p><p>这个示例中，修饰符可像布局一样修改约束条件或实现自定义放置逻辑。这意味着，你并不总是需要编写自定义布局，如果只需要作用于单个项目，就可以改为使用修饰符。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LayoutModifier</span> : <span class="hljs-type">Modifier.Element</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> MeasureScope.<span class="hljs-title">measure</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">measurable: <span class="hljs-type">Measurable</span>,</span></span><span class="hljs-params"><span class="hljs-function">constraints: <span class="hljs-type">Constraints</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span>: MeasureResult    ...&#125;</code></pre></div><p>例如，我们看看PaddingModifier如何工作。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Modifier.<span class="hljs-title">padding</span><span class="hljs-params">(all: <span class="hljs-type">Dp</span>)</span></span> = <span class="hljs-keyword">this</span>.then(PaddingModifier(        start = all,        top = a1l,        end = all,        bottom = all        )    )<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaddingModifier</span>(    <span class="hljs-keyword">val</span> start: Dp = <span class="hljs-number">0.</span>dp,     <span class="hljs-keyword">val</span> top: Dp = <span class="hljs-number">0.</span>dp,    <span class="hljs-keyword">val</span> end: Dp = <span class="hljs-number">0.</span>dp,    <span class="hljs-keyword">val</span> bottom: Dp = <span class="hljs-number">0.</span>dp) : LayoutModifier &#123;...&#125;</code></pre></div><h2 id="高级布局功能"><a href="#高级布局功能" class="headerlink" title="高级布局功能"></a>高级布局功能</h2><h3 id="固有测量属性（Intrinsic-Measurement）"><a href="#固有测量属性（Intrinsic-Measurement）" class="headerlink" title="固有测量属性（Intrinsic Measurement）"></a>固有测量属性（Intrinsic Measurement）</h3><p>Compose不总是使用单传递布局系统。例如，下拉列表需要使用固有最大宽度来确定具体尺寸。</p><div class="code-wrapper"><pre><code class="hljs kotlin">Column(Modifier.width(IntrinsicSize.Max)) &#123;    Text(Modifier.fillMaxWidth())    Text(Modifier.fillMaxWidth())     Text(Modifier.fillMaxWidth())     Text(Modifier.fillMaxWidth())     Text(Modifier.fillMaxWidth())&#125;</code></pre></div><p>下拉列表的宽度 &#x3D; 每个文本不换行的情况下的最大宽度</p><p>文本的最小固有宽度是每行一个单词的宽度，多了会换行。</p><h3 id="ParentData修饰符"><a href="#ParentData修饰符" class="headerlink" title="ParentData修饰符"></a>ParentData修饰符</h3><p>某个布局行为需要从子项获取信息，就需要使用ParentData。</p><p>Box中的align就是ParentData修饰符，它向父项传递信息，供父项确定子项布局，如果不在Box中，就无法使用。</p><p>基线对齐</p><p><img src="/./img/image-20221214113056005.png" alt="image-20221214113056005"></p><p>对齐会穿透至子项</p><p><img src="/./img/image-20221214113124913.png" alt="image-20221214113124913"></p><h3 id="BoxWithConstraints"><a href="#BoxWithConstraints" class="headerlink" title="BoxWithConstraints"></a>BoxWithConstraints</h3><p>这是一个类似Box的可组合项，但是它会将对其内容的组合操作一直延迟到布局环节，那时就有布局信息可用了。</p><p> BoxWithConstraints中的内容在公开约束条件的接收器作用域中运行，这些约束条件是在布局环节以像素或DPI值确定的，因此，里面的内容可以使用这些约束条件来选择要组合的内容。</p><p>例如，根据最大宽度选择不同的呈现内容。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MyApp</span><span class="hljs-params">(...)</span></span> &#123; BoxWithConstraints() &#123; <span class="hljs-comment">// this: BoxWithConstraintsScope </span><span class="hljs-keyword">when</span> &#123;maxWidth &lt; <span class="hljs-number">400.</span>dp -&gt; CompactLayout()maxWidth &lt; <span class="hljs-number">800.</span>dp -&gt; MediumLayout()<span class="hljs-keyword">else</span> -&gt; LargeLayout()&#125;&#125;&#125;</code></pre></div><p>但是BoxWithConstraints会在布局阶段启动子组合，这会影响性能。除非信息的类型会随着大小一起改变，请尽量避免使用BoxWithConstraints。<img src="/./img/image-20221214114817861.png" alt="image-20221214114817861"></p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul><li>只有在改变显示内容时才需要重组，而改变显示位置或显示方法时则不需要。</li><li>除非信息的类型会随着大小一起改变，请尽量避免使用BoxWithConstraints。</li><li>有时无需测量自己的所有子项来确定布局大小</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jetpack</tag>
      
      <tag>Compose</tag>
      
      <tag>layout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Compose迁移</title>
    <link href="/Android/AndroidCompose%E8%BF%81%E7%A7%BB/"/>
    <url>/Android/AndroidCompose%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="迁移到Compose"><a href="#迁移到Compose" class="headerlink" title="迁移到Compose"></a>迁移到Compose</h1><p>如何迁移到 Compose 取决于您和您的团队。要将 Jetpack Compose 集成到现有 Android 应用中，有多种不同的方法。常用的两种迁移策略为：</p><ul><li>完全使用 Compose 开发一个新界面</li><li>选取一个现有界面，然后逐步迁移其中的各个组件。</li></ul><h2 id="新界面中的-Compose"><a href="#新界面中的-Compose" class="headerlink" title="新界面中的 Compose"></a>新界面中的 Compose</h2><p>在重构应用代码以适应新技术时，一种常用的方法是在为应用构建的新功能中采用该技术。在这种情况下，适合使用新的界面。如果您需要为应用构建新界面，请考虑使用 Compose，而应用的其余部分可以保留在 View 系统中。</p><p>在这种情况下，您需要在这些已迁移功能的边缘实现 Compose 互操作性。</p><h2 id="搭配使用-Compose-和-View"><a href="#搭配使用-Compose-和-View" class="headerlink" title="搭配使用 Compose 和 View"></a>搭配使用 Compose 和 View</h2><p>对于特定界面，您可以将部分界面迁移到 Compose，让其他部分保留在 View 系统中。例如，您可以迁移 RecyclerView，同时将界面的其余部分保留在 View 系统中。</p><p>或者，使用 Compose 作为外部布局，并使用 Compose 中可能没有的一些现有 View，比如 MapView 或 AdView。</p><h2 id="完成迁移"><a href="#完成迁移" class="headerlink" title="完成迁移"></a>完成迁移</h2><p>将全部 fragment 或界面迁移到 Compose，一次迁移一个。这种方式最为简单，但比较粗放。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jetpack</tag>
      
      <tag>Compose</tag>
      
      <tag>view</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Compose主题</title>
    <link href="/Android/AndroidCompose%E4%B8%BB%E9%A2%98/"/>
    <url>/Android/AndroidCompose%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Compose主题"><a href="#Compose主题" class="headerlink" title="Compose主题"></a>Compose主题</h1><p><a href="https://developer.android.com/jetpack/compose/themes/material#material3">Compose 中的 Material Design 2  | Jetpack Compose  | Android Developers</a></p><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary">androidx.compose.material3  | Android Developers</a></p><h2 id="创建主题资源"><a href="#创建主题资源" class="headerlink" title="创建主题资源"></a>创建主题资源</h2><ol><li><p>进入<a href="https://m3.material.io/theme-builder#/custom">Material Design</a></p></li><li><p>选择品牌颜色，即<code>Primary Color</code>，也是种子颜色</p></li><li><p>点击右上角Export按钮，选择<code>Jetpack Compose(Theme.kt)</code>，下载主题文件并放入项目包下</p></li><li><p>配置主题，引入颜色，字体，形状等预定义元素</p><p>示例：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">CokoToolsTheme</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    darkTheme: <span class="hljs-type">Boolean</span> = isSystemInDarkTheme()</span></span>, <span class="hljs-comment">// 深色主题</span>    dynamicColor: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">true</span>, <span class="hljs-comment">// 动态取色（Android12+）</span>    content: <span class="hljs-meta">@Composable</span> () -&gt; <span class="hljs-built_in">Unit</span> <span class="hljs-comment">// 这里就是主题作用域</span>) &#123;    <span class="hljs-keyword">val</span> cokeToolsColorScheme = <span class="hljs-keyword">when</span> &#123;        dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; &#123;            <span class="hljs-keyword">val</span> context = LocalContext.current            <span class="hljs-keyword">if</span> (darkTheme) dynamicDarkColorScheme(context) <span class="hljs-keyword">else</span> dynamicLightColorScheme(context)        &#125;        darkTheme -&gt; DarkColors        <span class="hljs-keyword">else</span> -&gt; LightColors    &#125;    MaterialTheme(        colorScheme = cokeToolsColorScheme,        shapes = cokoToolsShapes,        typography = cokoToolsTypography,        content = content    )&#125;</code></pre></div><p>实际上，就是<strong>替换</strong>默认主题<code>MaterialTheme</code>里的元素。</p></li></ol><h2 id="使用主题资源"><a href="#使用主题资源" class="headerlink" title="使用主题资源"></a>使用主题资源</h2><p>首先，将使用自定义主题的内容放在主题作用域中：</p><p>示例：在<code>MainActivity.kt</code>的<code>setContent</code>中放入我们的主题可组合项，并在其作用域内放入<code>HomeScreen</code>可组合项</p><div class="code-wrapper"><pre><code class="hljs kotlin">setContent &#123;    CokoToolsTheme &#123;        HomeScreen()    &#125;&#125;</code></pre></div><p>然后就可以在作用域内使用预定义资源：</p><ul><li><p>使用颜色：</p><div class="code-wrapper"><pre><code class="hljs kotlin">color = MaterialTheme.colorScheme.primary</code></pre></div></li><li><p>使用字体</p><div class="code-wrapper"><pre><code class="hljs kotlin">style = MaterialTheme.typography.titleLarge</code></pre></div></li><li><p>使用形状</p><div class="code-wrapper"><pre><code class="hljs kotlin">shape = MaterialTheme.shapes.large</code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jetpack</tag>
      
      <tag>Compose</tag>
      
      <tag>Theme</tag>
      
      <tag>MaterialDesign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Compose中的状态</title>
    <link href="/Android/AndroidCompose%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81/"/>
    <url>/Android/AndroidCompose%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Compose中的状态"><a href="#Compose中的状态" class="headerlink" title="Compose中的状态"></a>Compose中的状态</h1><p>应用的“状态”是指可以随时间变化的任何值。这是一个非常宽泛的定义，从 <a href="https://developer.android.com/jetpack/androidx/releases/room">Room</a> 数据库到类的变量，全部涵盖在内。</p><p>所有 Android 应用都会向用户显示状态。下面是 Android 应用中的一些状态示例：</p><ul><li>聊天应用中最新收到的消息。</li><li>用户的个人资料照片。</li><li>在项列表中的滚动位置。</li></ul><p><strong>关键提示</strong>：状态决定界面在任何特定时间的显示内容。</p><p>优秀实践是为所有可组合函数提供默认的 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier"><code>Modifier</code></a>，从而提高可重用性。它应作为第一个可选参数显示在参数列表中，位于所有必需参数之后。</p><p>“状态”是指可以随时间变化的任何值，例如，聊天应用最新收到的消息。但是，是什么原因导致状态更新呢？在 Android 应用中，状态会根据事件进行更新。</p><p>事件是从应用外部或内部生成的输入，例如：</p><ul><li>用户与界面互动，例如按下按钮。</li><li>其他因素，例如传感器发送新值或网络响应。</li></ul><p><strong>应用的状态说明了要在界面中显示的内容，而事件则是一种机制，可在状态发生变化时导致界面发生变化。</strong></p><p><strong>关键提示</strong>：通常的描述为“是”某状态，“发生”某事件。</p><p>事件用于通知程序发生了某事。所有 Android 应用都有核心界面更新循环，如下所示：</p><p><img src="/./img/f415ca9336d83142.png" alt="f415ca9336d83142.png"></p><ul><li>事件：由用户或程序的其他部分生成。</li><li>更新状态：事件处理脚本会更改界面所使用的状态。</li><li>显示状态：界面会更新以显示新状态。</li></ul><p>Compose 中的状态管理主要是了解状态和事件之间的交互方式。</p><p>Compose 应用通过调用可组合函数将数据转换为界面。<strong>组合</strong>是指 Compose 在执行可组合项时构建的界面描述。如果发生状态更改，Compose 会使用新状态重新执行受影响的可组合函数，从而创建更新后的界面。这一过程称为<strong>重组</strong>。Compose 还会查看各个可组合项需要哪些数据，以便仅重组数据发生了变化的组件，而避免重组未受影响的组件。</p><p><strong>组合</strong>：Jetpack Compose 在执行可组合项时构建的界面描述。</p><p><strong>初始组合</strong>：通过首次运行可组合项创建组合。</p><p><strong>重组</strong>：在数据发生变化时重新运行可组合项以更新组合。</p><p>为此，<strong>Compose 需要知道要跟踪的状态</strong>，以便在收到更新时安排重组。</p><p><strong>Compose 采用特殊的状态跟踪系统，可以为读取特定状态的任何可组合项安排重组</strong>。这让Compose 能够实现精细控制，并且仅重组需要更改的可组合函数，而不是重组整个界面。这将通过同时跟踪针对状态的“写入”（即状态变化）和针对状态的“读取”来实现。</p><p>使用 Compose 的 <a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/State"><code>State</code></a> 和 <a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState"><code>MutableState</code></a> 类型让 Compose 能够观察到状态。</p><p>Compose 会跟踪每个读取状态 <code>value</code> 属性的可组合项，并在其 <code>value</code> 更改时触发重组。您可以使用 <a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#mutableStateOf(kotlin.Any,androidx.compose.runtime.SnapshotMutationPolicy)"><code>mutableStateOf</code></a> 函数来创建可观察的 <code>MutableState</code>。它接受初始值作为封装在 <code>State</code> 对象中的参数，这样便可使其 <code>value</code> 变为可观察。</p><p>更新 <code>WaterCounter</code> 可组合项，以便 <code>count</code> 以 <code>0</code> 为初始值来使用 <code>mutableStateOf</code> API。当 <code>mutableStateOf</code> 返回 <code>MutableState</code> 类型时，您可以更新其 <code>value</code> 以更新状态，并且 Compose 会在其 <code>value</code> 被读取时触发这些函数的重组。</p><p>如前所述，对 <code>count</code> 所做的任何更改都会安排对自动重组读取 <code>count</code> 的 <code>value</code> 的所有可组合函数进行重组。在此情况下，点击按钮即会触发重组 <code>WaterCounter</code>。</p><p>如果现在运行应用，您会再次发现没有发生任何变化！</p><p>安排重组的过程没有问题。不过，当重组发生时，变量 <code>count</code> 会重新初始化为 0，因此我们需要通过某种方式在重组后保留此值。</p><p>为此，我们可以使用 <a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#remember(kotlin.Function0)"><code>remember</code></a> 可组合内嵌函数。系统会在初始组合期间将由 <strong><code>remember</code></strong> 计算的值存储在组合中，并在重组期间一直保持存储的值。</p><p>您可以将 <strong><code>remember</code></strong> 视为一种在组合中存储单个对象的机制，就像私有 val 属性在对象中执行的操作一样。</p><p><code>remember</code> 和 <code>mutableStateOf</code> 通常在可组合函数中一起使用。</p><p>修改 <code>WaterCounter</code>，将对 <code>mutableStateOf</code> 的调用置于 <code>remember</code> 内嵌可组合函数的内部。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">WaterCounter</span><span class="hljs-params">(modifier: <span class="hljs-type">Modifier</span> = Modifier)</span></span> &#123;    Column(modifier = modifier.padding(<span class="hljs-number">16.</span>dp)) &#123;        <span class="hljs-keyword">val</span> count: MutableState&lt;<span class="hljs-built_in">Int</span>&gt; = remember &#123; mutableStateOf(<span class="hljs-number">0</span>) &#125;        Text(            text = <span class="hljs-string">&quot;You&#x27;ve had <span class="hljs-subst">$&#123;count.value&#125;</span> glasses.&quot;</span>,            modifier = modifier.padding(<span class="hljs-number">16.</span>dp)        )        Button(onClick = &#123; count.value++ &#125;, Modifier.padding(top = <span class="hljs-number">8.</span>dp)) &#123;            Text(<span class="hljs-string">&quot;Add one&quot;</span>)        &#125;    &#125;&#125;</code></pre></div><p>使用 Kotlin 的<a href="https://kotlinlang.org/docs/delegated-properties.html">委托属性</a>来简化 <code>count</code> 的使用。</p><p>您可以使用关键字 <strong>by</strong> 将 <code>count</code> 定义为 var。通过添加委托的 getter 和 setter 导入内容，我们可以间接读取 <code>count</code> 并将其设置为可变，而无需每次都显式引用 <code>MutableState</code> 的 <code>value</code> 属性。</p><p>现在，<code>WaterCounter</code> 如下所示：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">WaterCounter</span><span class="hljs-params">(modifier: <span class="hljs-type">Modifier</span> = Modifier)</span></span> &#123;    Column(modifier = modifier.padding(<span class="hljs-number">16.</span>dp)) &#123;        <span class="hljs-keyword">var</span> count <span class="hljs-keyword">by</span> remember &#123; mutableStateOf(<span class="hljs-number">0</span>) &#125;        Text(            text = <span class="hljs-string">&quot;You&#x27;ve had <span class="hljs-variable">$count</span> glasses.&quot;</span>,            modifier = modifier.padding(<span class="hljs-number">16.</span>dp)        )        Button(onClick = &#123; count++ &#125;, Modifier.padding(top = <span class="hljs-number">8.</span>dp)) &#123;            Text(<span class="hljs-string">&quot;Add one&quot;</span>)        &#125;    &#125;&#125;</code></pre></div><p><a href="https://developer.android.com/jetpack/compose/libraries#streams">Compose 和其他库  | Jetpack Compose  | Android Developers</a></p><p>如果您更改语言、在深色模式与浅色模式之间切换，或者执行任何导致 Android 重新创建运行中 activity 的其他配置更改时，也会发生相同的情况。</p><p>虽然 <code>remember</code> 可帮助您在重组后保持状态，但不会帮助您<strong>在配置更改后保持状态</strong>。为此，您必须使用 <a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/saveable/package-summary#rememberSaveable(kotlin.Array,androidx.compose.runtime.saveable.Saver,kotlin.String,kotlin.Function0)"><code>rememberSaveable</code></a>，而不是 <code>remember</code>。</p><p><code>rememberSaveable</code> 会自动保存可保存在 <a href="https://developer.android.com/reference/android/os/Bundle"><code>Bundle</code></a> 中的任何值。对于其他值，您可以将其传入自定义 Saver 对象。如需详细了解如何<a href="https://developer.android.com/jetpack/compose/state#restore-ui-state">在 Compose 中恢复状态</a>，请参阅相关文档。</p><p>在 <code>WaterCounter</code> 中，将 <code>remember</code> 替换为 <code>rememberSaveable</code>：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> androidx.compose.runtime.saveable.rememberSaveable<span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">WaterCounter</span><span class="hljs-params">(modifier: <span class="hljs-type">Modifier</span> = Modifier)</span></span> &#123;        ...        <span class="hljs-keyword">var</span> count <span class="hljs-keyword">by</span> rememberSaveable &#123; mutableStateOf(<span class="hljs-number">0</span>) &#125;        ...&#125;</code></pre></div><p>现在运行应用并尝试进行一些配置更改。您应该会看到计数器已正确保存。</p><p>在重新创建 activity 或进程后，您可以使用 <strong><code>rememberSaveable</code></strong> 恢复界面状态。除了在重组后保持状态之外，**<code>rememberSaveable</code>** 还会在重新创建 activity 和进程之后保留状态。</p><p>使用 <strong><code>remember</code></strong> 存储对象的可组合项包含内部状态，这会使该可组合项<strong>有状态</strong>。在调用方不需要控制状态，并且不必自行管理状态便可使用状态的情况下，“有状态”会非常有用。但是，<strong>具有内部状态的可组合项往往不易重复使用，也更难测试</strong>。</p><p><strong>不保存任何状态的可组合项称为无状态可组合项</strong>。如需创建<strong>无状态</strong>可组合项，一种简单的方法是使用状态提升。</p><p>Compose 中的状态提升是一种将状态移至可组合项的调用方以使可组合项无状态的模式。Jetpack Compose 中的常规状态提升模式是将状态变量替换为两个参数：</p><ul><li><strong>value: T</strong>：要显示的当前值</li><li><strong>onValueChange: (T) -&gt; Unit</strong>：请求更改值的事件，其中 T 是建议的新值</li></ul><p>其中，此值表示任何可修改的状态。</p><p>状态下降、事件上升的这种模式称为单向数据流 (UDF)，而状态提升就是我们在 Compose 中实现此架构的方式。如需了解相关详情，请参阅 <a href="https://developer.android.com/jetpack/compose/architecture#udf-compose">Compose 架构文档</a>。</p><p>以这种方式提升的状态具有一些重要的属性：</p><ul><li><strong>单一可信来源</strong>：通过移动状态，而不是复制状态，我们可确保只有一个可信来源。这有助于避免 bug。</li><li><strong>可共享</strong>：可与多个可组合项共享提升的状态。</li><li><strong>可拦截</strong>：无状态可组合项的调用方可以在更改状态之前决定忽略或修改事件。</li><li><strong>分离</strong>：无状态可组合函数的状态可以存储在任何位置。例如，存储在 ViewModel 中。</li></ul><h2 id="有状态与无状态"><a href="#有状态与无状态" class="headerlink" title="有状态与无状态"></a>有状态与无状态</h2><p>当所有状态都可以从可组合函数中提取出来时，生成的可组合函数称为无状态函数。</p><p><strong>无状态</strong>可组合项是指不具有任何状态的可组合项，这意味着它不会存储、定义或修改新状态。</p><p><strong>有状态</strong>可组合项是一种具有可以随时间变化的状态的可组合项。</p><p>在实际应用中，让可组合项 100% 完全无状态可能很难实现，具体取决于可组合项的职责。在设计可组合项时，您应该让可组合项拥有尽可能少的状态，并能够在必要时通过在可组合项的 API 中公开状态来提升状态。</p><p><strong>要点</strong>：提升状态时，有三条规则可帮助您弄清楚状态应去向何处：</p><ol><li>状态应至少提升到使用该状态（读取）的所有可组合项的<strong>最低共同父项</strong>。</li><li>状态应至少提升到<strong>它可以发生变化（写入）的最高级别</strong>。</li><li>如果<strong>两种状态发生变化以响应相同的事件</strong>，它们应<strong>提升到同一级别</strong>。</li></ol><p>您可以将状态提升到高于这些规则要求的级别，但如果未将状态提升到足够高的级别，则遵循单向数据流会变得困难或不可能。</p><h2 id="ViewModel-中的状态"><a href="#ViewModel-中的状态" class="headerlink" title="ViewModel 中的状态"></a><a href="https://developer.android.com/codelabs/jetpack-compose-state?continue=https://developer.android.com/courses/pathways/jetpack-compose-for-android-developers-1%23codelab-https://developer.android.com/codelabs/jetpack-compose-state#11">ViewModel 中的状态</a></h2><p>屏幕或界面状态指示应在屏幕上显示的内容（例如任务列表）。<strong>该状态通常会与层次结构中的其他层相关联，原因是其包含应用数据</strong>。</p><p>界面状态描述屏幕上显示的内容，而应用逻辑则描述应用的行为方式以及应如何响应状态变化。逻辑分为两种类型：第一种是界面行为或界面逻辑，第二种是业务逻辑。</p><ul><li>界面逻辑涉及如何在屏幕上显示状态变化（例如导航逻辑或显示信息提示控件）。</li><li>业务逻辑决定如何处理状态更改（例如付款或存储用户偏好设置）。该逻辑通常位于业务层或数据层，但绝不会位于界面层。</li></ul><p><a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a> 提供界面状态以及对位于应用其他层中的业务逻辑的访问。此外，ViewModel 还会在配置更改后继续保留，因此其生命周期比组合更长。ViewModel 可以遵循 Compose 内容（即 activity 或 fragment）的主机的生命周期，也可以遵循导航图的目的地的生命周期（如果您使用的是 <a href="https://developer.android.com/jetpack/compose/navigation">Compose Navigation 库</a>）。</p><p>如需详细了解架构和界面层，请参阅<a href="https://developer.android.com/jetpack/guide/ui-layer#define-ui-state">界面层文档</a>。</p><p><strong>警告</strong>：ViewModel 并不是组合的一部分。因此，您不应保留可组合项中创建的状态（例如，记住的值），因为这可能会导致内存泄漏。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jetpack</tag>
      
      <tag>Compose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Compose基本布局</title>
    <link href="/Android/AndroidCompose%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80/"/>
    <url>/Android/AndroidCompose%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Compose基本布局"><a href="#Compose基本布局" class="headerlink" title="Compose基本布局"></a>Compose基本布局</h1><p><a href="https://developer.android.com/jetpack/compose/layouts/basics#slot-based-layouts">Compose 布局基础知识  | Jetpack Compose  | Android Developers</a></p><p><a href="https://developer.android.google.cn/jetpack/compose/layouts?hl=zh-cn">Compose 中的布局  | Jetpack Compose  | Android Developers (google.cn)</a></p><p>编写可组合项时，您可以使用<strong>修饰符</strong>执行以下操作：</p><ul><li>更改可组合项的尺寸、布局、行为和外观。</li><li>添加信息，例如无障碍标签。</li><li>处理用户输入。</li><li>添加高级互动，例如使元素可点击、可滚动、可拖动或可缩放。</li></ul><p><a href="https://developer.android.com/jetpack/compose/modifiers">Compose 修饰符  | Jetpack Compose  | Android Developers</a></p><p><a href="https://developer.android.com/jetpack/compose/modifiers-list">Compose 修饰符列表  | Jetpack Compose  | Android Developers</a></p><p>一般来说，若要对齐父容器中的可组合项，您应设置该父容器的<strong>对齐方式</strong>。因此，您应告知父项如何对齐其子项，而不是告知子项将其自身放置在父项中。</p><p>对于 <code>Column</code>，您可以决定其子项的水平对齐方式。具体选项包括：</p><ul><li>Start</li><li>CenterHorizontally</li><li>End</li></ul><p>对于 <code>Row</code>，您可以设置垂直对齐。具体选项类似于 <code>Column</code> 的选项：</p><ul><li>Top</li><li>CenterVertically</li><li>Bottom</li></ul><p>对于 <code>Box</code>，您可以同时使用水平对齐和垂直对齐。具体选项包括：</p><ul><li>TopStart</li><li>TopCenter</li><li>TopEnd</li><li>CenterStart</li><li>Center</li><li>CenterEnd</li><li>BottomStart</li><li>BottomCenter</li><li>BottomEnd</li></ul><p>容器的所有子项都将遵循这一相同的对齐模式。您可以通过向单个子项添加 <a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/ColumnScope#(androidx.compose.ui.Modifier).align(androidx.compose.ui.Alignment.Horizontal)"><code>align</code></a> 修饰符来替换其行为。</p><p>在上一步中，您了解了对齐方式，它用于在<strong>交叉轴</strong>上对齐容器的子项。对于 <code>Column</code>，交叉轴是水平轴；对于 <code>Row</code>，交叉轴则是垂直轴。</p><p>不过，我们也可以决定如何在容器的<strong>主轴</strong>（对于 <code>Row</code>，是水平轴；对于 <code>Column</code>，是垂直轴）上放置可组合子项。</p><p>对于 <code>Row</code>，您可以选择以下排列方式：</p><p><img src="/./img/c1e6c40e30136af2.gif" alt="c1e6c40e30136af2.gif"></p><p>对于 <code>Column</code>：</p><p><img src="/./img/df69881d07b064d0.gif" alt="df69881d07b064d0.gif"></p><p>除了这些排列方式之外，您还可以使用 <code>Arrangement.spacedBy()</code> 方法，在每个可组合子项之间添加固定间距。</p><p><strong>基于槽位的布局</strong>会在界面中留出空白区域，让开发者按照自己的意愿来填充。您可以使用它们创建更灵活的布局。</p><p>虽然设计与大多数设备尺寸都非常契合，但如果设备的高度不足（例如在横屏模式下），设计需要能够垂直滚动。这就需要您添加滚动行为。</p><p>如前所述，<code>LazyRow</code> 和 <code>LazyHorizontalGrid</code> 等延迟布局会自动添加滚动行为。但是，您不一定总是需要延迟布局。一般来说，<strong>在列表中有许多元素或需要加载大型数据集时，您需要使用延迟布局</strong>，因此一次发出所有项不仅会降低性能，还会拖慢应用的运行速度。如果列表中的元素数量有限，您也可以选择使用简单的 <code>Column</code> 或 <code>Row</code>，然后<strong>手动添加滚动行为</strong>。为此，您可以使用 <a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier).verticalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean)"><code>verticalScroll</code></a> 或 <a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier).horizontalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean)"><code>horizontalScroll</code></a> 修饰符。这些修饰符需要 <a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/ScrollState"><code>ScrollState</code></a>，后者包含当前的滚动状态，可用于从外部修改滚动状态。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jetpack</tag>
      
      <tag>Compose</tag>
      
      <tag>layout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Compose编程思想</title>
    <link href="/Android/AndroidCompose%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    <url>/Android/AndroidCompose%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="Compose-编程思想"><a href="#Compose-编程思想" class="headerlink" title="Compose 编程思想"></a>Compose 编程思想</h1><p>[TOC]</p><p><a href="https://developer.android.com/jetpack/compose/mental-model">Compose 编程思想  | Jetpack Compose  | Android Developers</a></p><p><a href="https://youtu.be/4zf30a34OOA">https://youtu.be/4zf30a34OOA</a></p><p>Jetpack Compose 是一个适用于 Android 的新式声明性界面工具包。Compose 提供声明性 API，让您可在不以命令方式改变前端视图的情况下呈现应用界面，从而使编写和维护应用界面变得更加容易。此术语需要一些解释说明，它的含义对应用设计非常重要。</p><h2 id="声明性编程范式"><a href="#声明性编程范式" class="headerlink" title="声明性编程范式"></a>声明性编程范式</h2><p>长期以来，Android 视图层次结构一直可以表示为界面 widget 树。由于应用的状态会因用户交互等因素而发生变化，因此界面层次结构需要进行更新以显示当前数据。最常见的界面更新方式是使用 <a href="https://developer.android.com/reference/android/view/View#findViewById(int)"><code>findViewById()</code></a> 等函数遍历树，并通过调用 <code>button.setText(String)</code>、<code>container.addChild(View)</code> 或 <code>img.setImageBitmap(Bitmap)</code> 等方法更改节点。这些方法会改变 widget 的内部状态。</p><p>手动操纵视图会提高出错的可能性。如果一条数据在多个位置呈现，很容易忘记更新显示它的某个视图。此外，当两项更新以出人意料的方式发生冲突时，也很容易造成异常状态。例如，某项更新可能会尝试设置刚刚从界面中移除的节点的值。一般来说，软件维护的复杂性会随着需要更新的视图数量而增长。</p><p>在过去的几年中，整个行业已开始转向声明性界面模型，该模型大大简化了与构建和更新界面关联的工程任务。该技术的工作原理是在概念上从头开始重新生成整个屏幕，然后仅执行必要的更改。此方法可避免手动更新有状态视图层次结构的复杂性。Compose 是一个声明性界面框架。</p><p>重新生成整个屏幕所面临的一个难题是，在时间、计算能力和电池用量方面可能成本高昂。为了减少在这方面耗费的资源，Compose 会智能地选择在任何给定时间需要重新绘制界面的哪些部分。这会对您设计界面组件的方式有一定影响，如<a href="https://developer.android.com/jetpack/compose/mental-model#recomposition">重组</a>中所述。</p><h2 id="简单的可组合函数"><a href="#简单的可组合函数" class="headerlink" title="简单的可组合函数"></a>简单的可组合函数</h2><p>使用 Compose，您可以通过定义一组接受数据而发出界面元素的可组合函数来构建界面。一个简单的示例是 <code>Greeting</code> widget，它接受 <code>String</code> 并发出一个显示问候消息的 <code>Text</code> widget。</p><p><img src="https://developer.android.com/static/images/jetpack/compose/mmodel-simple.png" alt="显示文本“Hello World”的手机的屏幕截图，以及用于生成该界面的简单可组合函数的代码"></p><p><strong>图 1.</strong> 一个简单的可组合函数，可使用所传入的数据在屏幕上呈现文本 widget。</p><p>关于此函数，有几点值得注意：</p><ul><li><p>此函数带有 <code>@Composable</code> 注释。所有可组合函数都必须带有此注释；此注释可告知 Compose 编译器：此函数旨在将数据转换为界面。</p></li><li><p>此函数接受数据。可组合函数可以接受一些参数，这些参数可让应用逻辑描述界面。在本例中，我们的 widget 接受一个 <code>String</code>，因此它可以按名称问候用户。</p></li><li><p>此函数可以在界面中显示文本。为此，它会调用 <code>Text()</code> 可组合函数，该函数实际上会创建文本界面元素。可组合函数通过调用其他可组合函数来发出界面层次结构。</p></li><li><p>此函数不会返回任何内容。发出界面的 Compose 函数不需要返回任何内容，因为它们描述所需的屏幕状态，而不是构造界面 widget。</p></li><li><p>此函数快速、<a href="https://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning">幂等</a>且没有附带效应。</p><ul><li>使用同一参数多次调用此函数时，它的行为方式相同，并且它不使用其他值，如全局变量或对 <code>random()</code> 的调用。</li><li>此函数描述界面而没有任何副作用，如修改属性或全局变量。</li></ul><p>一般来说，出于<a href="https://developer.android.com/jetpack/compose/mental-model#recomposition">重组</a>部分所述的原因，所有可组合函数都应使用这些属性来编写。</p></li></ul><h2 id="声明性范式转变"><a href="#声明性范式转变" class="headerlink" title="声明性范式转变"></a>声明性范式转变</h2><p>在许多面向对象的命令式界面工具包中，您可以通过实例化 widget 树来初始化界面。您通常通过膨胀 XML 布局文件来实现此目的。每个 widget 都维护自己的内部状态，并且提供 getter 和 setter 方法，允许应用逻辑与 widget 进行交互。</p><p>在 Compose 的声明性方法中，widget 相对无状态，并且不提供 setter 或 getter 函数。实际上，widget 不会以对象形式提供。您可以通过调用带有不同参数的同一可组合函数来更新界面。这使得向架构模式（如 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel"><code>ViewModel</code></a>）提供状态变得很容易，如<a href="https://developer.android.com/jetpack/guide">应用架构指南</a>中所述。然后，可组合项负责在每次可观察数据更新时将当前应用状态转换为界面。</p><p><img src="https://developer.android.com/static/images/jetpack/compose/mmodel-flow-data.png" alt="Compose 界面中数据从高级对象向下流向其子级的图示。"></p><p><strong>图 2.</strong> 应用逻辑为顶级可组合函数提供数据。该函数通过调用其他可组合函数来使用这些数据描述界面，将适当的数据传递给这些可组合函数，并沿层次结构向下传递数据。</p><p>当用户与界面交互时，界面会发起 <code>onClick</code> 等事件。这些事件应通知应用逻辑，应用逻辑随后可以改变应用的状态。当状态发生变化时，系统会使用新数据再次调用可组合函数。这会导致重新绘制界面元素，此过程称为“重组”。</p><p><img src="https://developer.android.com/static/images/jetpack/compose/mmodel-flow-events.png" alt="说明界面元素如何通过触发由应用逻辑处理的事件来响应交互的图示。"></p><p><strong>图 3.</strong> 用户与界面元素进行了交互，导致触发一个事件。应用逻辑响应该事件，然后系统根据需要使用新参数自动再次调用可组合函数。</p><h2 id="动态内容"><a href="#动态内容" class="headerlink" title="动态内容"></a>动态内容</h2><p>由于可组合函数是用 Kotlin 而不是 XML 编写的，因此它们可以像其他任何 Kotlin 代码一样动态。例如，假设您想要构建一个界面，用来问候一些用户：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Greeting</span><span class="hljs-params">(names: <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;    <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> names) &#123;        Text(<span class="hljs-string">&quot;Hello <span class="hljs-variable">$name</span>&quot;</span>)    &#125;&#125;</code></pre></div><p>此函数接受名称的列表，并为每个用户生成一句问候语。可组合函数可能非常复杂。您可以使用 <code>if</code> 语句来确定是否要显示特定的界面元素。您可以使用循环。您可以调用辅助函数。您拥有底层语言的全部灵活性。这种强大的功能和灵活性是 Jetpack Compose 的主要优势之一。</p><h2 id="重组"><a href="#重组" class="headerlink" title="重组"></a>重组</h2><p>在命令式界面模型中，如需更改某个 widget，您可以在该 widget 上调用 setter 以更改其内部状态。在 Compose 中，您可以使用新数据再次调用可组合函数。这样做会导致函数进行重组 – 系统会根据需要使用新数据重新绘制函数发出的 widget。Compose 框架可以智能地仅重组已更改的组件。</p><p>例如，假设有以下可组合函数，它用于显示一个按钮：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ClickCounter</span><span class="hljs-params">(clicks: <span class="hljs-type">Int</span>, onClick: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;    Button(onClick = onClick) &#123;        Text(<span class="hljs-string">&quot;I&#x27;ve been clicked <span class="hljs-variable">$clicks</span> times&quot;</span>)    &#125;&#125;</code></pre></div><p>每次点击该按钮时，调用方都会更新 <code>clicks</code> 的值。Compose 会再次调用 lambda 与 <code>Text</code> 函数以显示新值；此过程称为“重组”。不依赖于该值的其他函数不会进行重组。</p><p>如前文所述，重组整个界面树在计算上成本高昂，因为会消耗计算能力并缩短电池续航时间。Compose 使用智能重组来解决此问题。</p><p>重组是指在输入更改时再次调用可组合函数的过程。当函数的输入更改时，会发生这种情况。当 Compose 根据新输入重组时，它仅调用可能已更改的函数或 lambda，而跳过其余函数或 lambda。通过跳过所有未更改参数的函数或 lambda，Compose 可以高效地重组。</p><p>切勿依赖于执行可组合函数所产生的附带效应，因为可能会跳过函数的重组。如果您这样做，用户可能会在您的应用中遇到奇怪且不可预测的行为。附带效应是指对应用的其余部分可见的任何更改。例如，以下操作全部都是危险的附带效应：</p><ul><li>写入共享对象的属性</li><li>更新 <code>ViewModel</code> 中的可观察项</li><li>更新共享偏好设置</li></ul><p>可组合函数可能会像每一帧一样频繁地重新执行，例如在呈现动画时。可组合函数应快速执行，以避免在播放动画期间出现卡顿。如果您需要执行成本高昂的操作（例如从共享偏好设置读取数据），请在后台协程中执行，并将值结果作为参数传递给可组合函数。</p><p>例如，以下代码会创建一个可组合项以更新 <code>SharedPreferences</code> 中的值。该可组合项不应从共享偏好设置本身读取或写入，于是此代码将读取和写入操作移至后台协程中的 <code>ViewModel</code>。应用逻辑会使用回调传递当前值以触发更新。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">SharedPrefsToggle</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    text: <span class="hljs-type">String</span>,</span></span><span class="hljs-params"><span class="hljs-function">    value: <span class="hljs-type">Boolean</span>,</span></span><span class="hljs-params"><span class="hljs-function">    onValueChanged: (<span class="hljs-type">Boolean</span>) -&gt; <span class="hljs-type">Unit</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;    Row &#123;        Text(text)        Checkbox(checked = value, onCheckedChange = onValueChanged)    &#125;&#125;</code></pre></div><p>本文档讨论了您在 Compose 中编程时需要注意的事项：</p><ul><li>可组合函数可以按任何顺序执行。</li><li>可组合函数可以并行执行。</li><li>重组会跳过尽可能多的可组合函数和 lambda。</li><li>重组是乐观的操作，可能会被取消。</li><li>可组合函数可能会像动画的每一帧一样非常频繁地运行。</li></ul><p>下面几部分将介绍如何构建可组合函数以支持重组。在每种情况下，最佳实践都是使可组合函数保持快速、幂等且没有附带效应。</p><h3 id="可组合函数可以按任何顺序执行"><a href="#可组合函数可以按任何顺序执行" class="headerlink" title="可组合函数可以按任何顺序执行"></a>可组合函数可以按任何顺序执行</h3><p>如果您看一下可组合函数的代码，可能会认为这些代码按其出现的顺序运行。但其实未必是这样。如果某个可组合函数包含对其他可组合函数的调用，这些函数可以按任何顺序运行。Compose 可以选择识别出某些界面元素的优先级高于其他界面元素，因而首先绘制这些元素。</p><p>例如，假设您有如下代码，用于在标签页布局中绘制三个屏幕：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ButtonRow</span><span class="hljs-params">()</span></span> &#123;    MyFancyNavigation &#123;        StartScreen()        MiddleScreen()        EndScreen()    &#125;&#125;</code></pre></div><p>对 <code>StartScreen</code>、<code>MiddleScreen</code> 和 <code>EndScreen</code> 的调用可以按任何顺序进行。这意味着，举例来说，您不能让 <code>StartScreen()</code> 设置某个全局变量（附带效应）并让 <code>MiddleScreen()</code> 利用这项更改。相反，其中每个函数都需要保持独立。</p><h3 id="可组合函数可以并行运行"><a href="#可组合函数可以并行运行" class="headerlink" title="可组合函数可以并行运行"></a>可组合函数可以并行运行</h3><p>Compose 可以通过并行运行可组合函数来优化重组。这样一来，Compose 就可以利用多个核心，并以较低的优先级运行可组合函数（不在屏幕上）。</p><p>这种优化意味着，可组合函数可能会在后台线程池中执行。如果某个可组合函数对 <code>ViewModel</code> 调用一个函数，则 Compose 可能会同时从多个线程调用该函数。</p><p>为了确保应用正常运行，所有可组合函数都不应有附带效应，而应通过始终在界面线程上执行的 <code>onClick</code> 等回调触发附带效应。</p><p>调用某个可组合函数时，调用可能发生在与调用方不同的线程上。这意味着，应避免使用修改可组合 lambda 中的变量的代码，既因为此类代码并非线程安全代码，又因为它是可组合 lambda 不允许的附带效应。</p><p>以下示例展示了一个可组合项，它显示一个列表及其项数：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ListComposable</span><span class="hljs-params">(myList: <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;    Row(horizontalArrangement = Arrangement.SpaceBetween) &#123;        Column &#123;            <span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> myList) &#123;                Text(<span class="hljs-string">&quot;Item: <span class="hljs-variable">$item</span>&quot;</span>)            &#125;        &#125;        Text(<span class="hljs-string">&quot;Count: <span class="hljs-subst">$&#123;myList.size&#125;</span>&quot;</span>)    &#125;&#125;</code></pre></div><p>此代码没有附带效应，它会将输入列表转换为界面。此代码非常适合显示小列表。不过，如果函数写入局部变量，则这并非线程安全或正确的代码：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Composable</span><span class="hljs-meta">@Deprecated(<span class="hljs-string">&quot;Example with bug&quot;</span>)</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ListWithBug</span><span class="hljs-params">(myList: <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;    <span class="hljs-keyword">var</span> items = <span class="hljs-number">0</span>    Row(horizontalArrangement = Arrangement.SpaceBetween) &#123;        Column &#123;            <span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> myList) &#123;                Text(<span class="hljs-string">&quot;Item: <span class="hljs-variable">$item</span>&quot;</span>)                items++ <span class="hljs-comment">// Avoid! Side-effect of the column recomposing.</span>            &#125;        &#125;        Text(<span class="hljs-string">&quot;Count: <span class="hljs-variable">$items</span>&quot;</span>)    &#125;&#125;</code></pre></div><p>在本例中，每次重组时，都会修改 <code>items</code>。这可以是动画的每一帧，或是在列表更新时。但不管怎样，界面都会显示错误的项数。因此，Compose 不支持这样的写入操作；通过禁止此类写入操作，我们允许框架更改线程以执行可组合 lambda。</p><h3 id="重组会跳过尽可能多的内容"><a href="#重组会跳过尽可能多的内容" class="headerlink" title="重组会跳过尽可能多的内容"></a>重组会跳过尽可能多的内容</h3><p>如果界面的某些部分无效，Compose 会尽力只重组需要更新的部分。这意味着，它可以跳过某些内容以重新运行单个按钮的可组合项，而不执行界面树中在其上面或下面的任何可组合项。</p><p>每个可组合函数和 lambda 都可以自行重组。以下示例演示了在呈现列表时重组如何跳过某些元素：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Display a list of names the user can click with a header</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Composable</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">NamePicker</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    header: <span class="hljs-type">String</span>,</span></span><span class="hljs-params"><span class="hljs-function">    names: <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;,</span></span><span class="hljs-params"><span class="hljs-function">    onNameClicked: (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;    Column &#123;        <span class="hljs-comment">// this will recompose when [header] changes, but not when [names] changes</span>        Text(header, style = MaterialTheme.typography.h5)        Divider()        <span class="hljs-comment">// LazyColumn is the Compose version of a RecyclerView.</span>        <span class="hljs-comment">// The lambda passed to items() is similar to a RecyclerView.ViewHolder.</span>        LazyColumn &#123;            items(names) &#123; name -&gt;                <span class="hljs-comment">// When an item&#x27;s [name] updates, the adapter for that item</span>                <span class="hljs-comment">// will recompose. This will not recompose when [header] changes</span>                NamePickerItem(name, onNameClicked)            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Display a single name the user can click.</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Composable</span><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">NamePickerItem</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, onClicked: (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;    Text(name, Modifier.clickable(onClick = &#123; onClicked(name) &#125;))&#125;</code></pre></div><p>这些作用域中的每一个都可能是在重组期间执行的唯一一个作用域。当 <code>header</code> 发生更改时，Compose 可能会跳至 <code>Column</code> lambda，而不执行它的任何父项。此外，执行 <code>Column</code> 时，如果 <code>names</code> 未更改，Compose 可能会选择跳过 <code>LazyColumn</code> 的项。</p><p>同样，执行所有可组合函数或 lambda 都应该没有附带效应。当您需要执行附带效应时，应通过回调触发。</p><h3 id="重组是乐观的操作"><a href="#重组是乐观的操作" class="headerlink" title="重组是乐观的操作"></a>重组是乐观的操作</h3><p>只要 Compose 认为某个可组合项的参数可能已更改，就会开始重组。重组是乐观的操作，也就是说，Compose 预计会在参数再次更改之前完成重组。如果某个参数在重组完成之前发生更改，Compose 可能会取消重组，并使用新参数重新开始。</p><p>取消重组后，Compose 会从重组中舍弃界面树。如有任何附带效应依赖于显示的界面，则即使取消了组合操作，也会应用该附带效应。这可能会导致应用状态不一致。</p><p>确保所有可组合函数和 lambda 都幂等且没有附带效应，以处理乐观的重组。</p><h3 id="可组合函数可能会非常频繁地运行"><a href="#可组合函数可能会非常频繁地运行" class="headerlink" title="可组合函数可能会非常频繁地运行"></a>可组合函数可能会非常频繁地运行</h3><p>在某些情况下，可能会针对界面动画的每一帧运行一个可组合函数。如果该函数执行成本高昂的操作（例如从设备存储空间读取数据），可能会导致界面卡顿。</p><p>例如，如果您的 widget 尝试读取设备设置，它可能会在一秒内读取这些设置数百次，这会对应用的性能造成灾难性的影响。</p><p>如果您的可组合函数需要数据，它应为相应的数据定义参数。然后，您可以将成本高昂的工作移至组成操作线程之外的其他线程，并使用 <code>mutableStateOf</code> 或 <code>LiveData</code> 将相应的数据传递给 Compose。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jetpack</tag>
      
      <tag>Compose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDownPlugins的使用</title>
    <link href="/%E7%8E%AF%E5%A2%83/MarkDownPlugins%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/%E7%8E%AF%E5%A2%83/MarkDownPlugins%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MarkDown-Plugins"><a href="#MarkDown-Plugins" class="headerlink" title="MarkDown Plugins"></a>MarkDown Plugins</h1><p>Markdown 插件使用备忘  </p><p>参考：[Markdown All in One 书写Markdown利器(<a href="https://blog.csdn.net/weixin_33895604/article/details/88702076">https://blog.csdn.net/weixin_33895604/article/details/88702076</a>)</p><p><strong>目录：</strong></p><ul><li><a href="#markdown-plugins">MarkDown Plugins</a><ul><li><a href="#markdown-all-in-on-%E6%8F%92%E4%BB%B6">Markdown All in On 插件</a><ul><li><a href="#%E5%BF%AB%E6%8D%B7%E9%94%AE">快捷键</a></li><li><a href="#task-list">Task List</a></li><li><a href="#%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95">生成目录</a></li></ul></li><li><a href="#markdown-preview-enhanced-%E6%8F%92%E4%BB%B6">Markdown Preview Enhanced 插件</a></li></ul></li></ul><h3 id="Markdown-All-in-On-插件"><a href="#Markdown-All-in-On-插件" class="headerlink" title="Markdown All in On 插件"></a>Markdown All in On 插件</h3><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-built_in">Key</span>    <span class="hljs-variable">Command</span><span class="hljs-variable">Ctrl</span> <span class="hljs-operator">+</span> <span class="hljs-variable">B</span>    粗体<span class="hljs-variable">Ctrl</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">I</span>    斜体<span class="hljs-variable">Alt</span> <span class="hljs-operator">+</span> <span class="hljs-variable">S</span>    删除线<span class="hljs-variable">Ctrl</span> <span class="hljs-operator">+</span> <span class="hljs-variable">Shift</span> <span class="hljs-operator">+</span> <span class="hljs-punctuation">]</span>    标题<span class="hljs-punctuation">(</span><span class="hljs-variable">uplevel</span><span class="hljs-punctuation">)</span><span class="hljs-variable">Ctrl</span> <span class="hljs-operator">+</span> <span class="hljs-variable">Shift</span> <span class="hljs-operator">+</span> <span class="hljs-punctuation">[</span>    标题<span class="hljs-punctuation">(</span><span class="hljs-variable">downlevel</span><span class="hljs-punctuation">)</span><span class="hljs-variable">Ctrl</span> <span class="hljs-operator">+</span> <span class="hljs-variable">M</span>    <span class="hljs-built_in">Toggle</span> <span class="hljs-variable">math</span> <span class="hljs-variable">environment</span><span class="hljs-operator">/</span>进入数学环境<span class="hljs-variable">Alt</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">C</span>    <span class="hljs-built_in">Check</span><span class="hljs-operator">/</span><span class="hljs-variable">Uncheck</span> <span class="hljs-variable">task</span> <span class="hljs-variable">list</span> <span class="hljs-variable">item</span></code></pre></div><p><strong>实例：</strong>  </p><p><strong>粗体</strong><br><em>斜体</em><br><del>删除线</del><br>$x+y&#x3D;z$</p><h4 id="Task-List"><a href="#Task-List" class="headerlink" title="Task List"></a>Task List</h4><ul><li><input checked="" disabled="" type="checkbox"> Python Study</li><li><input disabled="" type="checkbox"> Andorid Studey</li><li><input disabled="" type="checkbox"> Java Study</li></ul><h4 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h4><p>Crtl + Shift + P 可以查看更多功能</p><h3 id="Markdown-Preview-Enhanced-插件"><a href="#Markdown-Preview-Enhanced-插件" class="headerlink" title="Markdown Preview Enhanced 插件"></a>Markdown Preview Enhanced 插件</h3><p>预览增强插件，在插件设置里可以更改配色</p>]]></content>
    
    
    <categories>
      
      <category>Environment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>VsCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android对话框</title>
    <link href="/Android/Android%E5%AF%B9%E8%AF%9D%E6%A1%86/"/>
    <url>/Android/Android%E5%AF%B9%E8%AF%9D%E6%A1%86/</url>
    
    <content type="html"><![CDATA[<h1 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h1><ul><li><a href="#%E5%AF%B9%E8%AF%9D%E6%A1%86">对话框</a><ul><li><a href="#%E6%8F%90%E9%86%92%E5%AF%B9%E8%AF%9D%E6%A1%86alertdialog">提醒对话框AlertDialog</a></li><li><a href="#%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%AF%9D%E6%A1%86datepickerdialog">日期对话框DatePickerDialog</a></li><li><a href="#%E6%97%B6%E9%97%B4%E5%AF%B9%E8%AF%9D%E6%A1%86timepickerdialog">时间对话框TimePickerDialog</a></li></ul></li></ul><h2 id="提醒对话框AlertDialog"><a href="#提醒对话框AlertDialog" class="headerlink" title="提醒对话框AlertDialog"></a>提醒对话框AlertDialog</h2><p>AlertDialog名为提醒对话框，它是Android中最常用的对话框，可以完成常见的交互操作，例如提示、确认、选择等功能。由于<br>AlertDialog没有公开的构造方法，因此必须借助建造器<code>AlertDialog.Builder</code>才能完成参数设置，<code>AlertDialog.Builder</code>的常用方法说明如下。</p><ul><li>setIcon：设置对话框的标题图标。</li><li>setTitle：设置对话框的标题文本。</li><li>setMessage：设置对话框的内容文本。</li><li>setPositiveButton：设置肯定按钮的信息，包括按钮文本和点击监听器。</li><li>setNegativeButton：设置否定按钮的信息，包括按钮文本和点击监听器。</li><li>setNeutralButton：设置中性按钮的信息，包括按钮文本和点击监听器，该方法比较少用。</li></ul><p>通过<code>AlertDialog.Builder</code>设置完对话框参数，还需调用建造器的create方法才能生成对话框实例。最后调用对话框实例的show方法，在页面上弹出提醒对话框。</p><p>使用MD3风格的对话框</p><div class="code-wrapper"><pre><code class="hljs kotlin">MaterialAlertDialogBuilder(context)        .setTitle(resources.getString(R.string.title))        .setMessage(resources.getString(R.string.supporting_text))        .setNeutralButton(resources.getString(R.string.cancel)) &#123; dialog, which -&gt;            <span class="hljs-comment">// Respond to neutral button press</span>        &#125;        .setNegativeButton(resources.getString(R.string.decline)) &#123; dialog, which -&gt;            <span class="hljs-comment">// Respond to negative button press</span>        &#125;        .setPositiveButton(resources.getString(R.string.accept)) &#123; dialog, which -&gt;            <span class="hljs-comment">// Respond to positive button press</span>        &#125;        .show()</code></pre></div><p><a href="https://github.com/material-components/material-components-android/blob/master/docs/components/Dialog.md">material-components-android&#x2F;Dialog.md at master · material-components&#x2F;material-components-android (github.com)</a></p><h2 id="日期对话框DatePickerDialog"><a href="#日期对话框DatePickerDialog" class="headerlink" title="日期对话框DatePickerDialog"></a>日期对话框DatePickerDialog</h2><p>虽然EditText提供了<code>inputType=&quot;date&quot;</code>的日期输入，但是很少有人会手工输入完整日期，况且EditText还不支持”年 ** 月 ** 日”这样的中文日期，所以系统提供了专门的日期选择器DatePicker，供用户选择具体的年月日。不过，DatePicker并非弹窗模式而是在当前页面占据一块区域，并且不会自动关闭。按习惯来说，日期控件应该弹出对话框，选择完日期就要自动关闭对话框。因此，很少直接在界面上显示DatePicker，而是利用已经封装好的日期选择对话框DatePickerDialog。</p><p>DatePickerDialog相当于在AlertDialog上装载了DatePicker，编码时只需调用构造方法设置当前的年、月、日，然后调用show方法即可弹出日期对话框。日期选择事件则由监听器OnDateSetListener负责响应，在该监听器的onDateSet方法中，开发者获取用户选择的具体日期，再做后续处理。特别注意onDateSet的月份参数，它的起始值不是1而是0。也就是说，一月份对应的参数值为0，十二月份对应的参数值为11，中间月份的数值以此类推。</p><p>示例：</p><p>日期选择器DatePicker</p><p>新建控件</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">DatePicker</span></span><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/dp_date&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:calendarViewShown</span>=<span class="hljs-string">&quot;false&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:datePickerMode</span>=<span class="hljs-string">&quot;spinner&quot;</span> /&gt;</span></code></pre></div><p><code>android:datePickerMode</code>属性可以选择模式。</p><p>新建按钮点击事件为：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;您选择的日期是%d年%d月%d日&quot;</span>, dpDate.getYear(), dpDate.getMonth() + <span class="hljs-number">1</span>, dpDate.getDayOfMonth());tvDate.setText(desc);</code></pre></div><p>日期对话框DatePickerDialog</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();<span class="hljs-type">DatePickerDialog</span> <span class="hljs-variable">dialog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatePickerDialog</span>(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">this</span>, calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH));dialog.show();</code></pre></div><h2 id="时间对话框TimePickerDialog"><a href="#时间对话框TimePickerDialog" class="headerlink" title="时间对话框TimePickerDialog"></a>时间对话框TimePickerDialog</h2><p>时间选择器TimePicker可以让用户选择具体的小时和分钟。</p><p>TimePickerDialog 的用法类似 DatePickerDialog。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dialog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android_SeekBar</title>
    <link href="/Android/Android_SeekBar/"/>
    <url>/Android/Android_SeekBar/</url>
    
    <content type="html"><![CDATA[<h1 id="SeekBar"><a href="#SeekBar" class="headerlink" title="SeekBar"></a>SeekBar</h1><p>[TOC]</p><p><strong>参考：</strong></p><ul><li><a href="https://developer.android.google.cn/reference/kotlin/android/widget/SeekBar?hl=en">SeekBar  | Android Developers (google.cn)</a></li><li><a href="https://verytoolz.com/blog/cf7594a53a/#:~:text=SeekBar">Kotlin 中的 SeekBar | 码农参考 (verytoolz.com)</a></li></ul><h2 id="Seekbar介绍"><a href="#Seekbar介绍" class="headerlink" title="Seekbar介绍"></a>Seekbar介绍</h2><p>Android seekBar 是progressBar 的修改版本，具有可拖动的拇指，用户可以在其中来回拖动拇指以设置当前进度值。我们可以在我们的安卓设备中使用控制栏，比如亮度控制、音量控制等。</p><p>它是重要的用户界面元素之一，它提供了在定义的范围内选择整数值的功能，例如 1 到 100。</p><p>通过在 SeekBar 中拖动拇指，我们可以来回滑动，在使用 <code>android:min</code> 和 <code>android:max</code> 属性定义的最小和最大整数值之间选择一个值。</p><p>使用<code>android:progress</code>定义初始值。</p><p>在控件列表中有两种SeekBar可供选择，一种是连续的，一种是离散的。</p><p><img src="/./img/image-20221129173639697.png" alt="image-20221129173639697"></p><h2 id="使用SeekBar"><a href="#使用SeekBar" class="headerlink" title="使用SeekBar"></a>使用SeekBar</h2><p>以两个SeekBar数据同步为例。</p><ol><li><p>创建项目，打开<code>activity_main.xml</code>的Design界面，</p></li><li><p>在Widgets列表中有两种SeekBar可供选择，一种是连续的，一种是离散的。根据需要选择不同的类型。这里我们都选上并约束布局。</p><p><img src="/./img/image-20221129173639697.png" alt="image-20221129173639697"></p><ul><li><p>SeekBar连续</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">SeekBar</span></span><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/seekBar2&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;300dp&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;40dp&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:max</span>=<span class="hljs-string">&quot;100&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:progress</span>=<span class="hljs-string">&quot;40&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintHorizontal_bias</span>=<span class="hljs-string">&quot;0.5&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintVertical_bias</span>=<span class="hljs-string">&quot;0.8&quot;</span> /&gt;</span></code></pre></div></li><li><p>SeekBar离散</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">SeekBar</span></span><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/seekBar&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/Widget.AppCompat.SeekBar.Discrete&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;300dp&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;40dp&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:max</span>=<span class="hljs-string">&quot;10&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:progress</span>=<span class="hljs-string">&quot;4&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintVertical_bias</span>=<span class="hljs-string">&quot;0.9&quot;</span> /&gt;</span></code></pre></div></li></ul></li><li><p>在对应的Activity或者Fragment中绑定控件</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> seekBar: SeekBar    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> seekBar2: SeekBar    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        seekBar = findViewById(R.id.seekBar)        seekBar2 = findViewById(R.id.seekBar2)    &#125;&#125;</code></pre></div></li><li><p>让两个控件的进度一致，在<code>onCreate</code>加入以下代码</p><div class="note note-warning">            <p>注意默认的TODO要删掉</p>          </div><div class="code-wrapper"><pre><code class="hljs kotlin">seekBar.progress = seekBar2.progress / <span class="hljs-number">10</span>seekBar.setOnSeekBarChangeListener(<span class="hljs-keyword">object</span> : OnSeekBarChangeListener &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onProgressChanged</span><span class="hljs-params">(seekBar: <span class="hljs-type">SeekBar</span>?, progress: <span class="hljs-type">Int</span>, fromUser: <span class="hljs-type">Boolean</span>)</span></span> &#123;        seekBar2.progress = progress * <span class="hljs-number">10</span> <span class="hljs-comment">// 进度改变时触发</span>    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStartTrackingTouch</span><span class="hljs-params">(seekBar: <span class="hljs-type">SeekBar</span>?)</span></span> &#123;        <span class="hljs-comment">// 开始拖动时触发</span>    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStopTrackingTouch</span><span class="hljs-params">(seekBar: <span class="hljs-type">SeekBar</span>?)</span></span> &#123;        <span class="hljs-comment">// 结束拖动时触发</span>    &#125;&#125;)seekBar2.setOnSeekBarChangeListener(<span class="hljs-keyword">object</span> : OnSeekBarChangeListener &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onProgressChanged</span><span class="hljs-params">(seekBar1: <span class="hljs-type">SeekBar</span>?, progress: <span class="hljs-type">Int</span>, fromUser: <span class="hljs-type">Boolean</span>)</span></span> &#123;        seekBar.progress = progress / <span class="hljs-number">10</span>    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStartTrackingTouch</span><span class="hljs-params">(seekBar: <span class="hljs-type">SeekBar</span>?)</span></span> &#123;    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStopTrackingTouch</span><span class="hljs-params">(seekBar: <span class="hljs-type">SeekBar</span>?)</span></span> &#123;    &#125;&#125;)</code></pre></div></li><li><p><code>build</code>并运行，发现实现了两个SeekBar数据同步的效果。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>view</tag>
      
      <tag>控件</tag>
      
      <tag>kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android文本输入</title>
    <link href="/Android/Android%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5/"/>
    <url>/Android/Android%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="文本输入"><a href="#文本输入" class="headerlink" title="文本输入"></a>文本输入</h1><ul><li><a href="#%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5">文本输入</a><ul><li><a href="#%E7%BC%96%E8%BE%91%E6%A1%86edittext">编辑框EditText</a></li><li><a href="#%E7%84%A6%E7%82%B9%E5%8F%98%E6%9B%B4%E7%9B%91%E5%90%AC%E5%99%A8">焦点变更监听器</a></li><li><a href="#%E6%96%87%E6%9C%AC%E5%8F%98%E5%8C%96%E7%9B%91%E5%90%AC%E5%99%A8">文本变化监听器</a></li><li><a href="#textinputedittext">TextInputEditText</a></li></ul></li></ul><h2 id="编辑框EditText"><a href="#编辑框EditText" class="headerlink" title="编辑框EditText"></a>编辑框EditText</h2><p>编辑框EditText用于接收软键盘输入的文字，例如用户名、密码、评价内容等，它由文本视图派生而来，除了TextView已有的各种属性和方法，EditText还支持下列XML属性。</p><ul><li>inputType:指定输入的文本类型。输入类型的取值说明见表，若同时使用多种文本类型，则可使用竖线”|”把多种文本类型拼接起来。</li><li>maxLength:指定文本允许输入的最大长度。</li><li>hint:指定提示文本的内容。</li><li>textColorHint:指定提示文本的颜色。</li></ul><table><thead><tr><th>输入类型</th><th>说明</th></tr></thead><tbody><tr><td>text</td><td>文本</td></tr><tr><td>textPassword</td><td>文本密码。显示时用圆点”·”代替</td></tr><tr><td>number</td><td>整型数</td></tr><tr><td>numberSigned</td><td>带符号的数字。允许在开头带负号”- “</td></tr><tr><td>numberDecimal</td><td>带小数点的数字</td></tr><tr><td>numberPassword</td><td>数字密码。显示时用圆点”·”代替</td></tr><tr><td>datetime</td><td>时间日期格式。除了数字外，还允许输入横线、斜杆、空格、冒号</td></tr><tr><td>date</td><td>日期格式。除了数字外，还允许输入横线”-“和斜杆”&#x2F;“</td></tr><tr><td>time</td><td>时间格式。除了数字外，还允许输入冒号”:”</td></tr></tbody></table><h2 id="焦点变更监听器"><a href="#焦点变更监听器" class="headerlink" title="焦点变更监听器"></a>焦点变更监听器</h2><p>编辑框点击两次后才会触发点击事件，因为第一次点击只触发焦点变更事件，第二次点击才触发点击事件。</p><p>若要判断是否切换编辑框输入，应当监听焦点变更事件，而非监听点击事件。</p><p>调用编辑框对象的setOnFocusChangeListener方法，即可在光标切换之时（获得光标和失去光标）触发焦点变更事件。</p><p>应用：用于限制文本长度</p><h2 id="文本变化监听器"><a href="#文本变化监听器" class="headerlink" title="文本变化监听器"></a>文本变化监听器</h2><p>调用编辑框对象的addTextChangedListener方法即可注册文本监听器。</p><p>文本监听器的接口名称为TextWatcher，该接口提供了3个监控方法，具体说明如下。</p><ul><li>beforeTextChanged：在文本改变之前触发。</li><li>onTextChanged：在文本改变过程中触发。 </li><li>afterTextChanged：在文本改变之后触发。</li></ul><p>应用：监听文本位数自动关闭软键盘</p><h2 id="TextInputEditText"><a href="#TextInputEditText" class="headerlink" title="TextInputEditText"></a>TextInputEditText</h2><p>TextInputEditText是遵循Material Design设计的文本输入框。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.textfield.TextInputLayout</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:endIconDrawable</span>=<span class="hljs-string">&quot;@drawable/ic_baseline_clear_24&quot;</span> <span class="hljs-attr">这里可以修改end图标的样式</span></span><span class="hljs-tag">    <span class="hljs-attr">app:endIconMode</span>=<span class="hljs-string">&quot;clear_text&quot;</span> <span class="hljs-attr">这里可以修改end图标的模式</span></span><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;@+id/guideline2&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.textfield.TextInputEditText</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;56dp&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:hint</span>=<span class="hljs-string">&quot;Text&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com.google.android.material.textfield.TextInputLayout</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>view</tag>
      
      <tag>控件</tag>
      
      <tag>textview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android选择按钮</title>
    <link href="/Android/Android%E9%80%89%E6%8B%A9%E6%8C%89%E9%92%AE/"/>
    <url>/Android/Android%E9%80%89%E6%8B%A9%E6%8C%89%E9%92%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="选择按钮"><a href="#选择按钮" class="headerlink" title="选择按钮"></a>选择按钮</h1><ul><li><a href="#%E9%80%89%E6%8B%A9%E6%8C%89%E9%92%AE">选择按钮</a><ul><li><a href="#%E5%A4%8D%E9%80%89%E6%A1%86checkbox">复选框CheckBox</a></li><li><a href="#%E5%BC%80%E5%85%B3%E6%8C%89%E9%92%AEswitch">开关按钮Switch</a></li><li><a href="#%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AEradiobutton">单选按钮RadioButton</a></li></ul></li></ul><p>在学习复选框之前，先了解一下CompoundButton。在Android体系中，CompoundButton类是抽象的复合按钮，因为是抽象类，所以它不能直接使用。实际开发中用的是CompoundButton的几个派生类，主要有复选框CheckBox、单选按钮RadioButton以及开关按钮Switch，这些派生类均可使用CompoundButton的属性和方法。加之CompoundButton本身继承了Button类，故以上几种按钮同时具备Button的属性和方法，它们之间的继承关系如图所示。</p><p><img src="/./img/CompoundButton.png" alt="CompoundButton"></p><p>compoundButton 在XML文件中主要使用下面两个属性：</p><ul><li>checked：指定按钮的勾选状态，true表示勾选,false则表示未勾选。默认为未勾选。</li><li>button：指定左侧勾选图标的图形资源，如果不指定就使用系统的默认图标。</li></ul><p>CompoundButton 在Java代码中主要使用下列4种方法：</p><ul><li>setChecked：设置按钮的勾选状态。</li><li>setButtonDrawable：设置左侧勾选图标的图形资源。</li><li>setonCheckedChangeListener：设置勾选状态变化的监听器。</li><li>ischecked：判断按钮是否勾选。</li></ul><h2 id="复选框CheckBox"><a href="#复选框CheckBox" class="headerlink" title="复选框CheckBox"></a>复选框CheckBox</h2><p><strong>对图标进行定制</strong></p><p>自定义drawable文件<code>checkbox_selector.xml</code></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">selector</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:state_checked</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@drawable/check_choose&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:state_checked</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@drawable/check_unchoose&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">selector</span>&gt;</span></code></pre></div><p>Activity对应的xml文件</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">CheckBox</span></span><span class="hljs-tag">  <span class="hljs-attr">android:button</span>=<span class="hljs-string">&quot;@drawable/checkbox_selector&quot;</span></span><span class="hljs-tag">/&gt;</span></code></pre></div><p><strong>更改初始选中状态</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">CheckBox</span></span><span class="hljs-tag">  <span class="hljs-attr">android:button</span>=<span class="hljs-string">&quot;@drawable/checkbox_selector&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">android:checked</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">/&gt;</span></code></pre></div><p><strong>事件监听</strong></p><p>onCreate方法里：</p><div class="code-wrapper"><pre><code class="hljs java">setOnCheckedChangeListener(<span class="hljs-built_in">this</span>);</code></pre></div><p>Activity要 implements <code>CompoundButton.onCheckedChanged</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCheckedChanged</span><span class="hljs-params">(CompoundButton buttonView, <span class="hljs-type">boolean</span> isChecked)</span>&#123;  <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;您%s了这个checkBox&quot;</span>, isChecked ? <span class="hljs-string">&quot;勾选&quot;</span>:<span class="hljs-string">&quot;取消勾选&quot;</span>);  buttonView.setText (desc);&#125;</code></pre></div><h2 id="开关按钮Switch"><a href="#开关按钮Switch" class="headerlink" title="开关按钮Switch"></a>开关按钮Switch</h2><p>Switch是开关按钮，它在选中与取消选中时可展现的界面元素比复选框丰富。Switch 控件新添加的XML属性说明如下：</p><ul><li>textOn：设置右侧开启时的文本。</li><li>textOff：设置左侧关闭时的文本。</li><li>track：设置开关轨道的背景。</li><li>thumb：设置开关标识的图标。</li></ul><p>自定义切换按钮示例：</p><p>（1）在<code>drawable</code>文件夹中定义<code>switch_selector.xml</code></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">selector</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@drawable/switch_on&quot;</span> <span class="hljs-attr">android:state_checked</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@drawable/switch_off&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">selector</span>&gt;</span></code></pre></div><p>（2）在所属Activity中加入</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;start&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:padding</span>=<span class="hljs-string">&quot;5dp&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Switch自定义开关&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">CheckBox</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/ck_status&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;50dp&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;45dp&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;end&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@drawable/switch_selector&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:button</span>=<span class="hljs-string">&quot;@null&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></code></pre></div><p>效果：<br><img src="/img/switch.jpg" alt="switch"></p><h2 id="单选按钮RadioButton"><a href="#单选按钮RadioButton" class="headerlink" title="单选按钮RadioButton"></a>单选按钮RadioButton</h2><p>在Android中，单选按钮使用RadioButton表示，RadioButton又是Button的子类，所以单选按钮可以直接使用Button支持的各种属性。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RadioButton</span> </span><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;显示文本&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/ID号&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:checked</span>=<span class="hljs-string">&quot;true|false&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RadioButton</span>&gt;</span></code></pre></div><p>通常情况下，RadioButton组件要与RadioGroup组件一起使用，组成一个单选按钮组。在XML布局文件中，添加RadioGroup组件的基本格式如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RadioGroup</span></span><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/ID号&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;warp_content&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;warp_content&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--添加多个RadioButton组件--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RadioGroup</span>&gt;</span></code></pre></div><p>RadioGroup实质上是个布局，同一组RadioButton都要放在同一个RadioGroup节点下。除了RadioButton，也允许放置其他控件。</p><p>判断选中了哪个单选按钮，通常不是监听某个单选按钮，而是监听单选组的选中事件。</p><p>下面是RadioGroup常用的3个方法：</p><ul><li>check：选中指定资源编号的单选按钮。</li><li>getCheckedRadioButtonld：获取选中状态单选按钮的资源编号。</li><li>setOnCheckedChangeListener：设置单选按钮勾选变化的监听器。</li></ul><p><a href="https://blog.csdn.net/acmman/article/details/44776547">参考链接</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>view</tag>
      
      <tag>控件</tag>
      
      <tag>button</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android活动（Activity）</title>
    <link href="/Android/Android%E6%B4%BB%E5%8A%A8%EF%BC%88Activity%EF%BC%89/"/>
    <url>/Android/Android%E6%B4%BB%E5%8A%A8%EF%BC%88Activity%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="活动-Activity"><a href="#活动-Activity" class="headerlink" title="活动(Activity)"></a>活动(Activity)</h1><!-- toc --><h2 id="启停活动页面"><a href="#启停活动页面" class="headerlink" title="启停活动页面"></a>启停活动页面</h2><h3 id="Activity的启动和结束"><a href="#Activity的启动和结束" class="headerlink" title="Activity的启动和结束"></a>Activity的启动和结束</h3><ul><li>从当前页面跳到新页面，跳转代码如下：<br><code>startActivity(new Intent(源页面.this,目标页面.class));</code></li><li>从当前页面回到上一个页面，相当于关闭当前页面，返回代码如下：<br><code>finish();//结束当前的活动页面</code></li></ul><h3 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h3><p><img src="/./img/activity_life_cycle.png" alt="activity_life_cycle"></p><p>onCreate：创建活动。把页面布局加载进内存，进入了初始状态。<br>onStart：开始活动。把活动页面显示在屏幕上，进入了就绪状态。<br>onResume：恢复活动。活动页面进入活跃状态，能够与用户正常交互，例如允许响应用户的点击动作、允许用户输入文字等等。<br>onPause：暂停活动。页面进入暂停状态，无法与用户正常交互。<br>onStop：停止活动。页面将不在屏幕上显示。<br>onDestroy：销毁活动。回收活动占用的系统资源，把页面从内存中清除。onRestart：重启活动。重新加载内存中的页面数据。<br>onNewlntent：重用已有的活动实例。</p><p>如果一个Activity已经启动过，并且存在当前应用的Activity任务栈中，启动模式为singieTask，singlelnstance或singleTop(此时已在任务栈顶端)，那么在此启动或回到这个Activity的时候，不会创建新的实例，也就是不会执行onCreate方法，而是执行onNewlntent方法。</p><p><strong>各状态的切换过程：</strong></p><p><img src="/./img/activity_state.png" alt="activity_state"></p><h3 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h3><p>打开AndroidManifest.xml，给activity节点添加属性<code>android:launchMode</code>，属性值填入<code>standard</code>表示采取标准模式，当然不添加属性的话默认就是标准模式。具体的activity节点配置内容示例如下:</p><h4 id="默认启动模式-standard"><a href="#默认启动模式-standard" class="headerlink" title="默认启动模式 standard"></a>默认启动模式 standard</h4><p>该模式可以被设定，不在manifest 设定时候，Activity 的默认模式就是standard。在该模式下，启动的 Activity 会依照启动顺序被依次压入Task栈中：</p><p><img src="/img/standard_mode.png" alt="standard_mode"></p><h4 id="栈顶复用模式-singleTop"><a href="#栈顶复用模式-singleTop" class="headerlink" title="栈顶复用模式 singleTop"></a>栈顶复用模式 singleTop</h4><p>在该模式下，如果栈顶Activity为我们要新建的Activity(目标Activity)，那么就不会重复创建新的Activity。</p><p><img src="/img/single_top_mode.png" alt="single_top_mode"></p><p><strong>应用场景</strong></p><p>适合开启渠道多、多应用开启调用的Activity，通过这种设置可以避免已经创建过的Activity被重复创建，多数通过动态设置使用。</p><h4 id="栈内复用模式-singleTask"><a href="#栈内复用模式-singleTask" class="headerlink" title="栈内复用模式 singleTask"></a>栈内复用模式 singleTask</h4><p>与singleTop模式相似，只不过singleTop模式是只是针对栈顶的元素，而singleTask模式下，如果task栈内存在目标Activity实例，则将task内的对应Activity 实例之上的所有Activity弹出栈，并将对应Activity置于栈顶，获得焦点。</p><p><img src="/img/single_task_mode.png" alt="single_task_mode"></p><p><strong>应用场景</strong></p><p><strong>程序主界面</strong>：我们肯定不希望主界面被创建多次，而且在主界面退出的时候退出整个App是最好的效果。</p><p><strong>耗费系统资源的Activity</strong>：对于那些及其耗费系统资源的Activity，我们可以考虑将其设为singleTask模式，减少资源耗费。</p><h4 id="全局唯一模式-singlelnstance"><a href="#全局唯一模式-singlelnstance" class="headerlink" title="全局唯一模式 singlelnstance"></a>全局唯一模式 singlelnstance</h4><p>在该模式下，我们会为目标Activity创建一个新的Task栈，将目标Activity放入新的Task，并让目标Activity获得焦点。新的Task有且只有这一个Activity 实例。如果已经创建过目标Activity实例，则不会创建新的Task，而是将以前创建过的Activity唤醒。</p><p><img src="/./img/single_instance_mode.png" alt="single_instance_mode"></p><h4 id="动态设置启动模式"><a href="#动态设置启动模式" class="headerlink" title="动态设置启动模式"></a>动态设置启动模式</h4><p>可以为intend设置不同启动标志</p><p><code>intent.setF1ags(Intent.FLAG_ACTIVITY_CLEAR_TOP);</code></p><h5 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h5><p>该标志用于开辟新任务的活动栈</p><h5 id="FLAG-ACTIVITY-SINGLE-TOP"><a href="#FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="FLAG_ACTIVITY_SINGLE_TOP"></a>FLAG_ACTIVITY_SINGLE_TOP</h5><p>当栈顶为待跳转的活动实例之时，则重用栈顶的实例</p><h5 id="FLAG-ACTIVITY-CLEAR-TASK"><a href="#FLAG-ACTIVITY-CLEAR-TASK" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TASK"></a>FLAG_ACTIVITY_CLEAR_TASK</h5><p>该标志会清空当前活动栈里的所有实例</p><h5 id="FLAG-ACTIVITY-CLEAR-TOP"><a href="#FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TOP"></a>FLAG_ACTIVITY_CLEAR_TOP</h5><p>当设置此Flag时，目标 Activity 会检查Task 中是否存在此实例，如果没有则添加压入栈。如果有，就将位于Task中的对应Activity其上的所有Activity弹出栈，此时有以下两种情况：</p><ul><li>如果同时设置Flag_ACTIVITY_SINGLE_TOP，则直接使用栈内的对应Activity。<br><code>intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP);</code></li><li>没有设置，则将栈内的对应Activity 销毁重新创建。</li></ul><h5 id="FLAG-ACTIVITY-NO-HISTORY"><a href="#FLAG-ACTIVITY-NO-HISTORY" class="headerlink" title="FLAG_ACTIVITY_NO_HISTORY"></a>FLAG_ACTIVITY_NO_HISTORY</h5><p>栈中不保存新启动的活动实例</p><p><strong>应用场景示例：</strong></p><p>对于不允许重复返回的情况，可以设置启动标志<code>FLAG_ACTIVITY_CLEAR_TOP</code>，即使活动栈里面存在待跳转的活动实例，也会重新创建该活动的实例，并清除原实例上方的所有实例，保证栈中最多只有该活动的唯一实例，从而避免了无谓的重复返回。</p><p>对于回不去的登录页面情况，可以设置启动标志<code>FLAG_ACTMTY_CLEAR_TASK</code>，该标志会清空当前活动栈里的所有实例。不过全部清空之后，意味着当前栈没法用了，必须另外找个活动栈才行，也就是同时设置启动标志<code>FLAG_ACTIVTY_ NEW_TASK</code>，该标志用于开辟新任务的活动栈。</p><p><code>intent.setF1ags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);</code></p><h2 id="在活动之间传递消息"><a href="#在活动之间传递消息" class="headerlink" title="在活动之间传递消息"></a>在活动之间传递消息</h2><p>Intent是各个组件之间信息沟通的桥梁，它用于Android各组件之间的通信，主要完成下列工作：</p><ul><li>标明本次通信请求从哪里来、到哪里去、要怎么走。</li><li>发起方携带本次通信需要的数据内容，接收方从收到的意图中解析数据。</li><li>发起方若想判断接收方的处理结果，意图就要负责让接收方传回应答的数据内容。</li></ul><h3 id="Intent的组成部分"><a href="#Intent的组成部分" class="headerlink" title="Intent的组成部分"></a>Intent的组成部分</h3><table><thead><tr><th>元素名称</th><th>设置方法</th><th>说明与用途</th></tr></thead><tbody><tr><td>Component</td><td>setComponent</td><td>组件，它指定意图的来源与目标</td></tr><tr><td>Action</td><td>setAction</td><td>动作，它指定意图的动作行为</td></tr><tr><td>Data</td><td>setData</td><td>即Uri，它指定动作要操纵的数据路径</td></tr><tr><td>Category</td><td>addCategory</td><td>类别，它指定意图的操作类别</td></tr><tr><td>Type</td><td>setType</td><td>数据类型，它指定消息的数据类型</td></tr><tr><td>Extras</td><td>putExtras</td><td>扩展信息，它指定装载的包裹信息</td></tr><tr><td>Flags</td><td>setFlags</td><td>标志位，它指定活动的启动标志</td></tr></tbody></table><h3 id="显式lntent和隐式Intent"><a href="#显式lntent和隐式Intent" class="headerlink" title="显式lntent和隐式Intent"></a>显式lntent和隐式Intent</h3><p><strong>显式lntent，直接指定来源活动与目标活动，属于精确匹配</strong></p><p>在构建一个意图对象时，需要指定两个参数，第一个参数表示跳转的来源页面，即”来源<code>Activity.this</code>“；第二个参数表示待跳转的页面，即”目标<code>Activity.class</code>“。具体的意图构建方式有如下3种：</p><p>(1) 在Intent的构造函数中指定，示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个目标确定的意图</span><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>,ActNextActivity.class);</code></pre></div><p>(2) 调用意图对象的<code>setClass</code>方法指定，示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个新意图</span><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<span class="hljs-comment">// 设置意图要跳转的目标活动</span>intent.setclass(<span class="hljs-built_in">this</span>,ActNextActivity.class);</code></pre></div><p>(3) 调用意图对象的<code>setComponent</code>方法指定，示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个新意图</span><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<span class="hljs-comment">// 创建包含目标活动在内的组件名称对象</span><span class="hljs-type">ComponentName</span> <span class="hljs-variable">component</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">componentName</span>(<span class="hljs-built_in">this</span>,ActNextActivity.c1ass);<span class="hljs-comment">// 设置意图携带的组件信息</span>intent.setcomponent(component);</code></pre></div><p>这种方式可用于启动其他应用（包括系统应用）的Activity</p><p>只需知道包名和类名即可</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ComponentName</span> <span class="hljs-variable">component</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComponentName</span>(pkg:<span class="hljs-string">&quot;&quot;</span>,cls:<span class="hljs-string">&quot;&quot;</span>);</code></pre></div><p><strong>隐式Intent，没有明确指定要跳转的目标活动，只给出一个动作字符串让系统自动匹配，属于模糊匹配</strong></p><p>通常App不希望向外部暴露活动名称，只给出一个事先定义好的标记串，这样大家约定俗成、按图索骥就好，隐式lntent便起到了标记过滤作用。这个动作名称标记串，可以是自己定义的动作，也可以是已有的系统动作。常见系统动作的取值说明见表。</p><table><thead><tr><th>lntent类的系统动作常量名</th><th>系统动作的常量值</th><th>说明</th></tr></thead><tbody><tr><td>ACTION_MAIN</td><td>android.intent.action.MAIN</td><td>App启动时的入口</td></tr><tr><td>ACTION_VIEW</td><td>android.intent.action.VIEW</td><td>向用户显示数据</td></tr><tr><td>ACTION_SEND</td><td>android.intent.action.SEND</td><td>分享内容</td></tr><tr><td>ACTION_CALL</td><td>android.intent.action.CALL</td><td>直接拨号</td></tr><tr><td>ACITON_DIAL</td><td>android.intent.action.DIAL</td><td>准备拨号</td></tr><tr><td>ACTION_SENDTO</td><td>android.intent.action.SENDTO</td><td>发送短信</td></tr><tr><td>ACTION_ANSWER</td><td>android.intent.action.ANSWER</td><td>接听电话</td></tr></tbody></table><p><strong>示例：拨打指定电话</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();intent.setAction(Intent.ACTION_DIAL);<span class="hljs-type">Uri</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span>  Uri.parse(<span class="hljs-string">&quot;tel:&quot;</span>+phoneNo);intent.setData(uri);startActivity(intent);</code></pre></div><p><strong>示例：发送短信到指定号码</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();intent.setAction(Intent.ACTION_SENDTO);<span class="hljs-type">Uri</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span>  Uri.parse(<span class="hljs-string">&quot;smsto:&quot;</span>+phoneNo);intent.setData(uri);startActivity(intent);</code></pre></div><p><strong>示例：自定义隐式  intent</strong></p><p>在目标Activity的清单文件中加入<code>&lt;intent-filter&gt;</code></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.YUR&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span></code></pre></div><p>进行跳转</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();intent.setAction(<span class="hljs-string">&quot;android.intent.action.YUR&quot;</span>);intent.addCategory(Intent.CATEGORY_DEFAULT);startActivity(intent);</code></pre></div><h3 id="向下一个Activity发送数据"><a href="#向下一个Activity发送数据" class="headerlink" title="向下一个Activity发送数据"></a>向下一个Activity发送数据</h3><p>Intent使用Bundle对象存放待传递的数据信息。<br>Bundle对象操作各类型数据的读写方法说明见下表。</p><table><thead><tr><th>数据类型</th><th>读方法</th><th>写方法</th></tr></thead><tbody><tr><td>整型数</td><td>getlnt</td><td>putlnt</td></tr><tr><td>浮点数</td><td>getFloat</td><td>putFloat</td></tr><tr><td>双精度数</td><td>getDouble</td><td>putDouble</td></tr><tr><td>布尔值</td><td>getBoolean</td><td>putBoolean</td></tr><tr><td>字符串</td><td>getString</td><td>putString</td></tr><tr><td>字符串数组</td><td>getStringArray</td><td>putStringArray</td></tr><tr><td>字符串列表</td><td>getStringArrayList</td><td>putStringArrayList</td></tr><tr><td>可序列化结构</td><td>getSerializable</td><td>putSerializable</td></tr></tbody></table><h3 id="向上一个Activity返回数据"><a href="#向上一个Activity返回数据" class="headerlink" title="向上一个Activity返回数据"></a>向上一个Activity返回数据</h3><p>请求类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActRequestActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">mRequest</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你睡了吗？&quot;</span>;    <span class="hljs-keyword">private</span> ActivityResultLauncher&lt;Intent&gt; register;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_act_request);        <span class="hljs-type">TextView</span> <span class="hljs-variable">tvRequest</span> <span class="hljs-operator">=</span> findViewById(R.id.tv_request);        tvRequest.setText(<span class="hljs-string">&quot;待发送的消息：&quot;</span> + mRequest);        findViewById(R.id.btn_request).setOnClickListener(<span class="hljs-built_in">this</span>);        <span class="hljs-type">TextView</span> <span class="hljs-variable">tvResponse</span> <span class="hljs-operator">=</span> findViewById(R.id.tv_response);        register = registerForActivityResult(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityResultContracts</span>.StartActivityForResult(), result -&gt; &#123;            <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> result.getData();                <span class="hljs-keyword">if</span> (intent != <span class="hljs-literal">null</span> &amp;&amp; result.getResultCode() == Activity.RESULT_OK) &#123;                    <span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> intent.getExtras();                    <span class="hljs-type">String</span> <span class="hljs-variable">response_time</span> <span class="hljs-operator">=</span> bundle.getString(<span class="hljs-string">&quot;response_time&quot;</span>);                    <span class="hljs-type">String</span> <span class="hljs-variable">response_content</span> <span class="hljs-operator">=</span> bundle.getString(<span class="hljs-string">&quot;response_content&quot;</span>);                    <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;收到返回消息：\n返回时间为%s\n返回内容为%s&quot;</span>, response_time, response_content);                    tvResponse.setText(desc);                &#125;            &#125;        &#125;);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, ActResponseActivity.class);        <span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();        bundle.putString(<span class="hljs-string">&quot;request_time&quot;</span>, DateUtil.getCurrentTime());        bundle.putString(<span class="hljs-string">&quot;request_content&quot;</span>, mRequest);        intent.putExtras(bundle);        register.launch(intent);    &#125;&#125;</code></pre></div><p>回应类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActResponseActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">mResponse</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;我没睡&quot;</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_act_response);        <span class="hljs-type">TextView</span> <span class="hljs-variable">tvRequest</span> <span class="hljs-operator">=</span> findViewById(R.id.tv_request);        <span class="hljs-comment">// 获取上个Activity传的的数据</span>        <span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> getIntent().getExtras();        <span class="hljs-type">String</span> <span class="hljs-variable">request_time</span> <span class="hljs-operator">=</span> bundle.getString(<span class="hljs-string">&quot;request_time&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">request_content</span> <span class="hljs-operator">=</span> bundle.getString(<span class="hljs-string">&quot;request_content&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;收到请求消息：\n请求时间为%s\n请求内容为%s&quot;</span>, request_time, request_content);        tvRequest.setText(desc);        findViewById(R.id.btn_response).setOnClickListener(<span class="hljs-built_in">this</span>);        <span class="hljs-type">TextView</span> <span class="hljs-variable">tvResponse</span> <span class="hljs-operator">=</span> findViewById(R.id.tv_response);        tvResponse.setText(<span class="hljs-string">&quot;待返回的消息：&quot;</span> + mResponse);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();        <span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();        bundle.putString(<span class="hljs-string">&quot;response_time&quot;</span>, DateUtil.getCurrentTime());        bundle.putString(<span class="hljs-string">&quot;response_content&quot;</span>, mResponse);        intent.putExtras(bundle);        <span class="hljs-comment">// 携带意图返回上一个页面。RESULT OK表示处理成功</span>        setResult(Activity.RESULT_OK, intent);        finish();    &#125;&#125;</code></pre></div><h2 id="为活动补充附加信息"><a href="#为活动补充附加信息" class="headerlink" title="为活动补充附加信息"></a>为活动补充附加信息</h2><h3 id="利用资源文件配置字符串"><a href="#利用资源文件配置字符串" class="headerlink" title="利用资源文件配置字符串"></a>利用资源文件配置字符串</h3><p>示例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> getString(R.string.weather_str);tv_resource.setText(value);</code></pre></div><p>优点： 无需编译，使用灵活。</p><h3 id="利用元数据传递配置信息"><a href="#利用元数据传递配置信息" class="headerlink" title="利用元数据传递配置信息"></a>利用元数据传递配置信息</h3><h4 id="什么是元数据"><a href="#什么是元数据" class="headerlink" title="什么是元数据"></a>什么是元数据</h4><p>放在清单文件里的数据</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MetaDataActivity&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;MetaDate&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:value</span>=<span class="hljs-string">&quot;Hello Meta&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span></code></pre></div><h4 id="元数据应用场景"><a href="#元数据应用场景" class="headerlink" title="元数据应用场景"></a>元数据应用场景</h4><p>调用第三方SDK是，使用token进行身份验证</p><h4 id="获取元数据信息"><a href="#获取元数据信息" class="headerlink" title="获取元数据信息"></a>获取元数据信息</h4><p>在Java代码中，获取元数据信息的步骤分为下列三步：</p><ul><li>调用<code>getPackageManager</code>方法获得当前应用的包管理器；</li><li>调用包管理器的<code>getActivitylnfo</code>方法获得当前活动的信息对象；</li><li>活动信息对象的<code>metaData</code>是<code>Bundle</code>包裹类型，调用包裹对象的<code>getString</code>即可获得指定名称的参数值；</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">TextView</span> <span class="hljs-variable">tvMeta</span> <span class="hljs-operator">=</span> findViewById(R.id.tv_meta);<span class="hljs-comment">// 获取应用包管理器</span><span class="hljs-type">PackageManager</span> <span class="hljs-variable">pm</span> <span class="hljs-operator">=</span> getPackageManager();<span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 从应用包管理器中获取当前的活动信息</span>    <span class="hljs-type">ActivityInfo</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> pm.getActivityInfo(getComponentName(), PackageManager.GET_META_DATA);    <span class="hljs-comment">// 获取活动附加的元数据信息</span>    <span class="hljs-type">Bundle</span> <span class="hljs-variable">metaData</span> <span class="hljs-operator">=</span> info.metaData;    <span class="hljs-type">String</span> <span class="hljs-variable">metaDate</span> <span class="hljs-operator">=</span> metaData.getString(<span class="hljs-string">&quot;MetaDate&quot;</span>);    tvMeta.setText(metaDate);&#125; <span class="hljs-keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;    e.printStackTrace();&#125;</code></pre></div><h3 id="给应用页面注册快捷方式"><a href="#给应用页面注册快捷方式" class="headerlink" title="给应用页面注册快捷方式"></a>给应用页面注册快捷方式</h3><p>元数据不仅能传递简单的字符串参数，还能传送更复杂的资源数据，比如实现应用的快捷方式菜单。</p><p><strong>示例：</strong><br>清单文件：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.ButtonClickActivity&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.app.shortcuts&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/shortcuts&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span></code></pre></div><p>在res目录下新建xml文件夹，里面新建<code>shortcuts.xml</code>，注意所有字符串要在<code>value/string.xml</code>文件里注册，</p><p><code>shortcuts.xml</code>代码示例：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">shortcuts</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">shortcut</span></span><span class="hljs-tag">        <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:shortcutId</span>=<span class="hljs-string">&quot;first&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:shortcutLongLabel</span>=<span class="hljs-string">&quot;@string/long_1&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:shortcutShortLabel</span>=<span class="hljs-string">&quot;@string/short_1&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">intent</span></span><span class="hljs-tag">            <span class="hljs-attr">android:action</span>=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:targetClass</span>=<span class="hljs-string">&quot;com.yorick.chapter03.ViewGravityActivity&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:targetPackage</span>=<span class="hljs-string">&quot;com.yorick.chapter03&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">categories</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.shortcut.conversation&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">shortcut</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">shortcut</span></span><span class="hljs-tag">        <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:shortcutId</span>=<span class="hljs-string">&quot;second&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:shortcutLongLabel</span>=<span class="hljs-string">&quot;@string/long_2&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:shortcutShortLabel</span>=<span class="hljs-string">&quot;@string/short_2&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">intent</span></span><span class="hljs-tag">            <span class="hljs-attr">android:action</span>=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:targetClass</span>=<span class="hljs-string">&quot;com.yorick.chapter03.GridLayoutActivity&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:targetPackage</span>=<span class="hljs-string">&quot;com.yorick.chapter03&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">categories</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.shortcut.conversation&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">shortcut</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">shortcut</span></span><span class="hljs-tag">        <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:shortcutId</span>=<span class="hljs-string">&quot;third&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:shortcutLongLabel</span>=<span class="hljs-string">&quot;@string/long_3&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:shortcutShortLabel</span>=<span class="hljs-string">&quot;@string/short_3&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">intent</span></span><span class="hljs-tag">            <span class="hljs-attr">android:action</span>=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:targetClass</span>=<span class="hljs-string">&quot;com.yorick.chapter03.RelativeLayoutActivity&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:targetPackage</span>=<span class="hljs-string">&quot;com.yorick.chapter03&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">categories</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.shortcut.conversation&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">shortcut</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">shortcuts</span>&gt;</span></code></pre></div><p><code>string.xml</code>代码示例：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;app_name&quot;</span>&gt;</span>chapter03<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span>Hello,World!<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;short_1&quot;</span>&gt;</span>first<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;long_1&quot;</span>&gt;</span>重力视图<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;short_2&quot;</span>&gt;</span>short<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;long_2&quot;</span>&gt;</span>网格视图<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;short_3&quot;</span>&gt;</span>third<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;long_3&quot;</span>&gt;</span>相对视图<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>activity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android图像视图（ImageView）</title>
    <link href="/Android/Android%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%EF%BC%88ImageView%EF%BC%89/"/>
    <url>/Android/Android%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%EF%BC%88ImageView%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="图像视图-ImageView"><a href="#图像视图-ImageView" class="headerlink" title="图像视图(ImageView)"></a>图像视图(ImageView)</h1><ul><li><a href="#%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BEimageview">图像视图(ImageView)</a><ul><li><a href="#%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%9A%84%E7%BC%A9%E6%94%BE%E7%B1%BB%E5%9E%8B">图像视图的缩放类型</a></li></ul></li><li><a href="#%E5%9B%BE%E5%83%8F%E6%8C%89%E9%92%AElmagebutton">图像按钮(lmageButton)</a><ul><li><a href="#imagebutton%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88">ImageButton的使用场合</a></li></ul></li><li><a href="#%E5%90%8C%E6%97%B6%E5%B1%95%E7%A4%BA%E6%96%87%E6%9C%AC%E4%B8%8E%E5%9B%BE%E5%83%8F">同时展示文本与图像</a></li></ul><p>图像视图展示的图片通常位于<code>res/drawable***</code>目录，设置图像视图的显示图片有两种方式：</p><ul><li>在XML文件中，通过属性<code>android:src</code>设置图片资源，属性值格式形如<code>@drawable/apple</code>。（apple为不含扩展名的图片名称）</li><li>在Java代码中，调用<code>setlmageResource</code>方法设置图片资源，方法参数格式形如<code>R.drawable.apple</code>。</li></ul><h2 id="图像视图的缩放类型"><a href="#图像视图的缩放类型" class="headerlink" title="图像视图的缩放类型"></a>图像视图的缩放类型</h2><p>lmageView本身默认图片居中显示（<code>fitCenter</code>），若要改变图片的显示方式，可通过<code>scaleType</code>属性设定，该属性的取值说明如下：</p><table><thead><tr><th>XML中的缩放类型</th><th>ScaleType类中的缩放类型</th><th>说明</th></tr></thead><tbody><tr><td>fitXY</td><td>FIT_XY</td><td>拉伸图片使其正好填满视图（图片可能被拉伸变形)</td></tr><tr><td>fitStart</td><td>FIT_START</td><td>保持宽高比例，拉伸图片使其位于视图上方或左侧</td></tr><tr><td>fitCenter</td><td>FIT_CENTER</td><td>保持宽高比例，拉伸图片使其位于视图中间</td></tr><tr><td>fitEnd</td><td>FIT_END</td><td>保持宽高比例，拉伸图片使其位于视图下方或右侧</td></tr><tr><td>center</td><td>CENTER</td><td>保持图片原尺寸，并使其位于视图中间</td></tr><tr><td>centerCrop</td><td>CENTER_CROP</td><td>拉伸图片使其充满视图，并位于视图中间</td></tr><tr><td>centerlnside</td><td>CENTER_INSIDE</td><td>保持宽高比例，缩小图片使之位于视图中间(只缩小不放大)</td></tr></tbody></table><p>java代码中设置图片缩放属性：<br><code>iv_scale.setScaleType(ImageView.ScaleType.CENTER);</code></p><p>很多情况下，可以注意到<code>centernside</code>和<code>center</code>的显示效果居然一模一样，这缘于它们的缩放规则设定。表面上<code>fitCenter</code>、<code>centerinside</code>、<code>center</code>三个类型都是居中显示，且均不越过图像视图的边界。它们之间的区别在于：<code>fitCenter</code>既允许缩小图片、也允许放大图片，<code>centerInside</code>只允许缩小图片、不允许放大图标，而center自始至终保持原始尺寸(既不允许缩小图片、也不允许放大图片)。因此，当图片尺寸大于视图宽高，<code>centerInside</code>与<code>fitCenter</code>都会缩小图片，此时它俩的显示效果相同；当图片尺寸小于视图宽高，<code>centernside</code>与<code>center</code>都保持图片大小不变，此时它俩的显示效果相同。</p><h1 id="图像按钮-lmageButton"><a href="#图像按钮-lmageButton" class="headerlink" title="图像按钮(lmageButton)"></a>图像按钮(lmageButton)</h1><p><code>lmageButton</code>是显示图片的图像按钮，但它继承自<code>lmageView</code>，而非继承<code>Button</code>。<br><code>lmageButton</code>和<code>Button</code>之间的区别有：</p><ul><li><code>Button</code>既可显示文本也可显示图片，<code>lmageButton</code>只能显示图片不能显示文本。</li><li><code>lmageButton</code>上的图像可按比例缩放，而<code>Button</code>通过背景设置的图像会拉伸变形。</li><li><code>Button</code>只能靠背景显示一张图片，而<code>lmageButton</code>可分别在前景和背景显示图片，从而实现两张图片叠加的效果。</li></ul><h2 id="ImageButton的使用场合"><a href="#ImageButton的使用场合" class="headerlink" title="ImageButton的使用场合"></a>ImageButton的使用场合</h2><p>在某些场合，有的字符无法由输入法打出来，或者某些文字以特殊字体展示，就适合先切图再放到<code>ImageButton</code>。例如：开平方符号$\sqrt{n}$，等等。</p><p><code>lmageButton</code>与<code>lmageView</code>之间的区别有：</p><ul><li><code>lmageButton</code>有默认的按钮背景，<code>ImageView</code>默认无背景。</li><li><code>lmageButton</code>默认的缩放类型为<code>center</code>，而<code>ImageView</code>默认的缩放类型为<code>fitCenter</code>。</li></ul><h1 id="同时展示文本与图像"><a href="#同时展示文本与图像" class="headerlink" title="同时展示文本与图像"></a>同时展示文本与图像</h1><p>同时展示文本与图像的可能途径包括：</p><p>(1）利用<code>LinearLayout</code>对<code>ImageView</code>和<code>TextView</code>组合布局。<br>(2）通过按钮控件<code>Button</code>的<code>drawable***</code>属性设置文本周围的图标。</p><p><code>drawableTop</code>:指定文字上方的图片。<br><code>drawableBottom</code>:指定文字下方的图片。<br><code>drawableLeft</code>:指定文字左边的图片。<br><code>drawableRight</code>:指定文字右边的图片。<br><code>drawablePadding</code>:指定图片与文字的间距。</p><p><a href="https://www.bilibili.com/video/BV19U4y1R7zV?p=33&t=170.1">修改背景不起作用</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>view</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android按钮（Button）</title>
    <link href="/Android/Android%E6%8C%89%E9%92%AE%EF%BC%88Button%EF%BC%89/"/>
    <url>/Android/Android%E6%8C%89%E9%92%AE%EF%BC%88Button%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="按钮-Button"><a href="#按钮-Button" class="headerlink" title="按钮(Button)"></a>按钮(Button)</h1><ul><li><a href="#%E6%8C%89%E9%92%AEbutton">按钮(Button)</a><ul><li><a href="#%E6%8E%A7%E4%BB%B6%E5%B1%9E%E6%80%A7">控件属性</a></li><li><a href="#%E7%82%B9%E5%87%BB%E5%92%8C%E9%95%BF%E6%8C%89%E4%BA%8B%E4%BB%B6">点击和长按事件</a></li><li><a href="#%E7%A6%81%E7%94%A8%E5%92%8C%E6%81%A2%E5%A4%8D%E6%8C%89%E9%92%AE">禁用和恢复按钮</a></li></ul></li></ul><h2 id="控件属性"><a href="#控件属性" class="headerlink" title="控件属性"></a>控件属性</h2><p>按钮控件<code>Button</code>由<code>TextView</code>派生而来，它们之间的区别有：</p><ul><li><code>Button</code>拥有默认的按钮背景，而<code>TextView</code>默认无背景;</li><li><code>Button</code>的内部文本默认居中对齐，而<code>TextView</code>的内部文本默认靠左对齐；</li><li><code>Button</code>会默认将英文字母转为大写，而<code>TextView</code>保持原始的英文大小写。</li></ul><p>与<code>TextView</code>相比，<code>Button</code>增加了两个新属性：</p><ul><li><code>textAllCaps</code>属性，它指定了是否将英文字母转为大写，为<code>true</code>是表示自动转为大写，为<code>false</code>表示不做大写转换；</li><li><code>onClick</code>属性，它用来接管用户的点击动作，指定了点击按钮时要触发哪个方法。</li></ul><h2 id="点击和长按事件"><a href="#点击和长按事件" class="headerlink" title="点击和长按事件"></a>点击和长按事件</h2><p>监听器，意思是专门监听控件的动作行为。只有控件发生了指定的动作，监听器才会触发开关去执行对应的代码逻辑。</p><p>按钮控件有两种常用的监听器：</p><ul><li>点击监听器，通过<code>setOnClickListener</code>方法设置。按钮被按住少于500毫秒时，会触发点击事件。</li><li>长按监听器，通过<code>setOnLongClickListener</code>方法设置。按钮被按住超过500毫秒时，会触发长按事件。</li></ul><p>点击事件有多种实现方式：</p><ul><li><p>使用匿名内部类的方式适用于按钮少的情况，使用静态内部类可以防止内存泄漏。</p><div class="code-wrapper"><pre><code class="hljs java">btnLongClick.setOnLongClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnLongClickListener() &#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onLongClick</span><span class="hljs-params">(View v)</span> &#123;      <span class="hljs-comment">// 这里放点击实现的代码</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;       <span class="hljs-comment">// 返回true表示事件已经被消耗掉，不往上层冒泡；否则向上层冒泡</span>  &#125;  &#125;);</code></pre></div><p>改用<code>lambda</code>表达式：</p><div class="code-wrapper"><pre><code class="hljs java">btnLongClick.setOnLongClickListener(v -&gt; &#123;  <span class="hljs-comment">//这里放点击实现的代码</span>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   &#125;);</code></pre></div><p>没有事件甚至可以省略大括号：</p><div class="code-wrapper"><pre><code class="hljs java">btnLongClick.setOnLongClickListener(v -&gt; <span class="hljs-literal">false</span>);</code></pre></div></li><li><p>单独点击事件也适用于按钮少的情况，使用静态内部类可以防止内存泄漏。</p></li><li><p>公共点击事件适用于按钮多的时候，直接使当前<code>Activity</code>实现<code>View.OnClickListener</code>接口的<code>onClick</code>方法。</p></li></ul><p>代码示例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ButtonClickActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener &#123;    <span class="hljs-keyword">private</span> TextView tvResult;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_button_click);        tvResult = findViewById(R.id.tv_result);        <span class="hljs-type">Button</span> <span class="hljs-variable">btnClickSingle</span> <span class="hljs-operator">=</span> findViewById(R.id.btn_click_single);        btnClickSingle.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyOnClickListener</span>(tvResult));        <span class="hljs-type">Button</span> <span class="hljs-variable">btnClickPublic</span> <span class="hljs-operator">=</span> findViewById(R.id.btn_click_public);        <span class="hljs-type">Button</span> <span class="hljs-variable">btnClickPublic2</span> <span class="hljs-operator">=</span> findViewById(R.id.btn_click_public_2);        btnClickPublic.setOnClickListener(<span class="hljs-built_in">this</span>);        btnClickPublic2.setOnClickListener(<span class="hljs-built_in">this</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s 您点击了按钮 %s&quot;</span>, DateUtil.getCurrentTime(), ((Button) v).getText());        <span class="hljs-keyword">switch</span> (v.getId()) &#123;            <span class="hljs-keyword">case</span> R.id.btn_click_public:                tvResult.setText(desc);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> R.id.btn_click_public_2:                tvResult.setText(desc);                <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-comment">// 写成静态内部类，减少内存泄露</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyOnClickListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TextView tvResult;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyOnClickListener</span><span class="hljs-params">(TextView tvResult)</span> &#123;            <span class="hljs-built_in">this</span>.tvResult = tvResult;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;            <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s 您点击了按钮 %s&quot;</span>, DateUtil.getCurrentTime(), ((Button) v).getText());            tvResult.setText(desc);        &#125;    &#125;&#125;</code></pre></div><p>当然，除此之外<code>button</code>还有很多事件监听器。如<code>setOnTouchListener</code>可以实现双击事件。</p><p><a href="https://blog.csdn.net/zuo_er_lyf/article/details/80068006">参考</a></p><h2 id="禁用和恢复按钮"><a href="#禁用和恢复按钮" class="headerlink" title="禁用和恢复按钮"></a>禁用和恢复按钮</h2><p>在实际业务中，按钮通常拥有两种状态，即不可用状态与可用状态，它们在外观和功能上的区别如下：</p><ul><li>不可用按钮：按钮不允许点击，即使点击也没反应，同时按钮文字为灰色；</li><li>可用按钮：按钮允许点击，点击按钮会触发点击事件，同时按钮文字为正常的黑色；</li></ul><p>是否允许点击由<code>enabled</code>属性控制，属性值为<code>true</code>时表示允许点击，为<code>false</code>时表示不允许点击。</p><p>在Java代码中用<code>setEnabled()</code>方法控制，属性值为<code>true</code>时表示允许点击，为<code>false</code>时表示不允许点击。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>view</tag>
      
      <tag>控件</tag>
      
      <tag>button</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android滚动视图（ScrollView）</title>
    <link href="/Android/Android%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE%EF%BC%88ScrollView%EF%BC%89/"/>
    <url>/Android/Android%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE%EF%BC%88ScrollView%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="滚动视图-ScrollView"><a href="#滚动视图-ScrollView" class="headerlink" title="滚动视图(ScrollView)"></a>滚动视图(ScrollView)</h1><p><strong>滚动视图有两种</strong></p><ul><li><code>ScrollView</code>，它是垂直方向的滚动视图；垂直方向滚动时，<code>layout_width</code>属性值设置为<code>match_parent</code>，<code>layout_height</code>属性值设置为<code>wrap_content</code>。</li><li><code>HorizontalScrollView</code>，它是水平方向的滚动视图；水平方向滚动时，<code>layout_width</code>属性值设置为<code>wrap_content</code>，<code>layout_height</code>属性值设置为<code>match_parent</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>layout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android网格布局（GridLayout）</title>
    <link href="/Android/Android%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%EF%BC%88GridLayout%EF%BC%89/"/>
    <url>/Android/Android%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%EF%BC%88GridLayout%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>网格布局支持多行多列的表格排列。</p><p>网格布局默认从左往右、从上到下排列，它新增了两个属性：</p><ul><li><code>columnCount</code>属性，它指定了网格的列数，即每行能放多少个视图；</li><li><code>rowCount</code>属性，它指定了网格的行数，即每列能放多少个视图；</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>layout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android相对布局（RelativeLayout）</title>
    <link href="/Android/Android%E7%9B%B8%E5%AF%B9%E5%B8%83%E5%B1%80%EF%BC%88RelativeLayout%EF%BC%89/"/>
    <url>/Android/Android%E7%9B%B8%E5%AF%B9%E5%B8%83%E5%B1%80%EF%BC%88RelativeLayout%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="相对布局-RelativeLayout"><a href="#相对布局-RelativeLayout" class="headerlink" title="相对布局(RelativeLayout)"></a>相对布局(RelativeLayout)</h1><p>相对布局的下级视图位置由其他视图决定。用于确定下级视图位置的参照物分两种：</p><ul><li>与该视图自身平级的视图；</li><li>该视图的上级视图(也就是它归属的<code>RelativeLayout</code>)</li></ul><p>如果不设定下级视图的参照物，那么下级视图默认显示在<code>RelativeLayout</code>内部的左上角。</p><h2 id="相对位置取值"><a href="#相对位置取值" class="headerlink" title="相对位置取值"></a>相对位置取值</h2><table><thead><tr><th>相对位置的属性取值</th><th>相对位置说明</th></tr></thead><tbody><tr><td>layout_toLeftOf</td><td>当前视图在指定视图的左边</td></tr><tr><td>layout_toRightOf</td><td>当前视图在指定视图的右边</td></tr><tr><td>layout_above</td><td>当前视图在指定视图的上方</td></tr><tr><td>layout_below</td><td>当前视图在指定视图的下方</td></tr><tr><td>layout_alignLeft</td><td>当前视图与指定视图的左侧对齐</td></tr><tr><td>layout_alignRight</td><td>当前视图与指定视图的右侧对齐</td></tr><tr><td>layout_alignTop</td><td>当前视图与指定视图的顶部对齐</td></tr><tr><td>layout_alignBottom</td><td>当前视图与指定视图的底部对齐</td></tr><tr><td>layout_centerlnParent</td><td>当前视图在上级视图中间</td></tr><tr><td>layout_centerHorizontal</td><td>当前视图在上级视图的水平方向居中</td></tr><tr><td>layout_centerVertical</td><td>当前视图在上级视图的垂直方向居中</td></tr><tr><td>layout_alignParentLeft</td><td>当前视图与上级视图的左侧对齐</td></tr><tr><td>layout_alignParentRight</td><td>当前视图与上级视图的右侧对齐</td></tr><tr><td>layout_alignParentTop</td><td>当前视图与上级视图的顶部对齐</td></tr><tr><td>layout_alignParentBottom</td><td>当前视图与上级视图的底部对齐</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>layout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android线性布局（LinearLayout）</title>
    <link href="/Android/Android%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80%EF%BC%88LinearLayout%EF%BC%89/"/>
    <url>/Android/Android%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80%EF%BC%88LinearLayout%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="线性布局-LinearLayout"><a href="#线性布局-LinearLayout" class="headerlink" title="线性布局(LinearLayout)"></a>线性布局(LinearLayout)</h1><h2 id="线性布局的排列方式"><a href="#线性布局的排列方式" class="headerlink" title="线性布局的排列方式"></a>线性布局的排列方式</h2><p>线性布局内部的各视图有两种排列方式:</p><ul><li><code>orientation</code>属性值为<code>horizontal</code>时，内部视图在水平方向从左往右排列。</li><li><code>orientation</code>属性值为<code>vertical</code>时，内部视图在垂直方向从上往下排列。</li><li>如果不指定<code>orientation</code>属性，则<code>LinearLayout</code>默认水平方向排列。</li></ul><h2 id="线性布局的权重"><a href="#线性布局的权重" class="headerlink" title="线性布局的权重"></a>线性布局的权重</h2><p>线性布局的权重概念，指的是线性布局的下级视图各自拥有多大比例的宽高。</p><p>权重属性名叫<code>layout_weight</code>，但该属性不在<code>LinearLayout</code>节点设置，而在线性布局的直接下级视图设置，表示该下级视图占据的宽高比例。</p><ul><li><code>layout_width</code>填<code>0dp</code>时，<code>layout_weight</code>表示水平方向的宽度比例。</li><li><code>layout_height</code>填<code>0dp</code>时，<code>layout_weight</code>表示垂直方向的高度比例。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>layout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android视图（View）</title>
    <link href="/Android/Android%E8%A7%86%E5%9B%BE%EF%BC%88View%EF%BC%89/"/>
    <url>/Android/Android%E8%A7%86%E5%9B%BE%EF%BC%88View%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="视图（View）"><a href="#视图（View）" class="headerlink" title="视图（View）"></a>视图（View）</h1><ul><li><a href="#%E8%A7%86%E5%9B%BEview">视图（View）</a><ul><li><a href="#%E8%AE%BE%E7%BD%AE%E8%A7%86%E5%9B%BE%E7%9A%84%E5%AE%BD%E9%AB%98">设置视图的宽高</a><ul><li><a href="#%E5%9C%A8xml%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%AE%BE%E7%BD%AE%E8%A7%86%E5%9B%BE%E5%AE%BD%E9%AB%98">在xml代码中设置视图宽高</a></li><li><a href="#%E5%9C%A8java%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%AE%BE%E7%BD%AE%E8%A7%86%E5%9B%BE%E5%AE%BD%E9%AB%98">在java代码中设置视图宽高</a></li><li><a href="#dp-%E8%BD%AC-px-%E5%B7%A5%E5%85%B7%E7%B1%BB">dp 转 px 工具类</a></li></ul></li><li><a href="#%E8%AE%BE%E7%BD%AE%E8%A7%86%E5%9B%BE%E7%9A%84%E9%97%B4%E8%B7%9D">设置视图的间距</a></li><li><a href="#%E8%AE%BE%E7%BD%AE%E8%A7%86%E5%9B%BE%E7%9A%84%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F">设置视图的对齐方式</a></li></ul></li></ul><h2 id="设置视图的宽高"><a href="#设置视图的宽高" class="headerlink" title="设置视图的宽高"></a>设置视图的宽高</h2><p>设置视图的宽高有两种途径：</p><h3 id="在xml代码中设置视图宽高"><a href="#在xml代码中设置视图宽高" class="headerlink" title="在xml代码中设置视图宽高"></a>在xml代码中设置视图宽高</h3><p>视图宽度通过属性<code>android:layout_width</code>表达，视图高度通过属性<code>android:layout_height</code>表达，宽高的取值主要有下列三种：</p><ul><li>match_parent：表示与上级视图保持一致。</li><li>wrap_content：表示与内容自适应。</li><li>以dp为单位的具体尺寸。</li></ul><h3 id="在java代码中设置视图宽高"><a href="#在java代码中设置视图宽高" class="headerlink" title="在java代码中设置视图宽高"></a>在java代码中设置视图宽高</h3><p>首先确保XML中的宽高属性值为<code>wrap_content</code>，接着打开该页面对应的Java代码，依序执行以下三个步骤：</p><ul><li>调用控件对象的<code>getLayoutParams</code>方法，获取该控件的布局参数。</li><li>布局参数的<code>width</code>属性表示宽度，<code>height</code>属性表示高度，修改这两个属性值。</li><li>调用控件对象的<code>setLayoutParams</code>方法，填入修改后的布局参数使之生效。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 获取布局参数（含宽度和高度)</span>ViewGroup.<span class="hljs-type">LayoutParams</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> tv.getLayoutParams();<span class="hljs-comment">// 修改布局参数中的宽度数值，注意默认px单位，所以要一个工具类将 dp 转换为 px</span>params.width = Utils.dip2px(<span class="hljs-built_in">this</span>, <span class="hljs-number">300</span>);<span class="hljs-comment">// 设置布局参数（</span>tv.setLayoutParams(params);</code></pre></div><h3 id="dp-转-px-工具类"><a href="#dp-转-px-工具类" class="headerlink" title="dp 转 px 工具类"></a>dp 转 px 工具类</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Utils</span> &#123;    <span class="hljs-comment">// 根据手机的分辨率从 dp 的单位转成为 px（像素）</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dip2px</span><span class="hljs-params">(Context context, <span class="hljs-type">float</span> dpValue)</span> &#123;        <span class="hljs-comment">// 获取当前手机的像素密度(1个dp对应几个px)</span>        <span class="hljs-type">float</span> <span class="hljs-variable">scale</span> <span class="hljs-operator">=</span> context.getResources().getDisplayMetrics().density;        <span class="hljs-comment">// 四舍五入取整</span>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (dpValue * scale + <span class="hljs-number">0.5f</span>);    &#125;&#125;</code></pre></div><p>context（上下文） 的妙用！</p><h2 id="设置视图的间距"><a href="#设置视图的间距" class="headerlink" title="设置视图的间距"></a>设置视图的间距</h2><p>设置视图的间距有两种途径：</p><ul><li><p>采用<code>layout_margin</code>属性，它指定了当前视图与周围平级视图之间的距离（外边距）。包括<code>layout_margin</code>、<code>layout_marginLeft</code>、<code>layout_marginTop</code>、<code>layout_marginRight</code>、<code>layout_marginBottom</code></p></li><li><p>采用<code>padding</code>属性，它指定了当前视图与内部下级视图之间的距离（内边距）。包括<code>padding</code>、<code>paddingLeft</code>、<code>paddingTop</code>、<code>paddingRight</code>、<code>paddingBottom</code></p></li></ul><p><code>margin</code>和<code>padding</code>属性适用于所有视图，附视图家族的依赖继承关系：</p><p><img src="/./img/view_relationship.png" alt="视图家族的依赖继承关系"></p><h2 id="设置视图的对齐方式"><a href="#设置视图的对齐方式" class="headerlink" title="设置视图的对齐方式"></a>设置视图的对齐方式</h2><p>设置视图的对齐方式有两种途径：</p><ul><li>采用<code>layout_gravity</code>属性，它指定了当前视图相对于上级视图的对齐方式。</li><li>采用<code>gravity</code>属性，它指定了下级视图相对于当前视图的对齐方式。<br><code>layout_gravity</code>与<code>gravity</code>的取值包括: <code>left</code>、<code>top</code>、<code>right</code>、<code>bottom</code>，还可以用竖线连接各取值，例如<code>left|top</code>表示即靠左又靠上，也就是朝左上角对齐。</li></ul><p><a href="https://www.jianshu.com/p/d597d96d5167">Android 中 marginLeft 和 marginStart 的区别</a></p><p><a href="https://developer.android.com/about/versions/android-4.2.html#RTL">goole官方解释</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>view</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android文本控件（TextView）</title>
    <link href="/Android/Android%E6%96%87%E6%9C%AC%E6%8E%A7%E4%BB%B6%EF%BC%88TextView%EF%BC%89/"/>
    <url>/Android/Android%E6%96%87%E6%9C%AC%E6%8E%A7%E4%BB%B6%EF%BC%88TextView%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="文本控件（TextView）"><a href="#文本控件（TextView）" class="headerlink" title="文本控件（TextView）"></a>文本控件（TextView）</h1><ul><li><a href="#%E6%96%87%E6%9C%AC%E6%8E%A7%E4%BB%B6textview">文本控件（TextView）</a><ul><li><a href="#%E5%AD%97%E4%BD%93%E5%8D%95%E4%BD%8D">字体单位</a></li><li><a href="#%E8%AE%BE%E7%BD%AE%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2">设置字体颜色</a></li><li><a href="#%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2">设置背景颜色</a></li></ul></li></ul><h2 id="字体单位"><a href="#字体单位" class="headerlink" title="字体单位"></a>字体单位</h2><p>原来文本大小存在不同的字号单位，XML文件要求在字号数字后面写明单位类型，常见的字号单位主要有px、dp、sp 3种，分别介绍如下。</p><ol><li>px<br>px是手机屏幕的最小显示单位，它与设备的显示屏有关。一般来说，同样尺寸的屏幕(比如6英寸手机)，如果看起来越清晰，则表示像素密度越高，以px计量的分辨率也越大。</li><li>dp<br>dp有时也写作dip，指的是与设备无关的显示单位，它只与屏幕的尺寸有关。一般来说，同样尺寸的屏幕以dp计量的分辨率是相同的，比如同样是6英寸手机，无论它由哪个厂家生产，其分辨率换算成dp单位都是一个大小。</li><li>sp<br>sp的原理跟dp差不多，但它专门用来设置字体大小。手机在系统设置里可以调整字体的大小(小、标准、大、超大)。设置普通字体时，同数值dp和sp的文字看起来一样大;如果设置为大字体，用dp设置的文字没有变化，用sp设置的文字就变大了。字体大小采用不同单位的话，显示的文字大小各不相同。例如，30pX、30dp、30sp这3个字号，在不同手机上的显示大小有所差异。有的手机像素密度较低，一个dp相当于两个px，此时30px等同于15dp;有的手机像素密度较高，一个dp相当于3个px，此时30px等同于10dp。假设某个App的内部文本使用字号30pX，则该App安装到前一部手机的字体大小为15dp，安装到后一部手机的字体大小为10dp，显然后一部手机显示的文本会更小。</li></ol><h2 id="设置字体颜色"><a href="#设置字体颜色" class="headerlink" title="设置字体颜色"></a>设置字体颜色</h2><ul><li><p>在XML文件中则通过属性<code>android:textColor</code>指定文本颜色，色值由透明度alpha和RGB三原色（红色red、绿色green、蓝色blue）联合定义。例如：<code>android:textColor=&quot;#00ff00&quot;</code>，注意，此时默认透明度为ff，即完全不透明。</p></li><li><p>在java文件中通过<code>setTextColor()</code>方法指定文本颜色，例如：<code>setTextColor(0x00ff00)</code>，注意，此时默认透明度为00，即完全透明。</p></li><li><p>色值有八位十六进制数与六位十六进制数两种表达方式，例如八位编码FFEEDDCC中，FF表示透明度，EE表示红色的浓度，DD表示绿色的浓度，CC表示蓝色的浓度。</p></li><li><p>透明度为FF表示完全不透明，为00表示完全透明。RGB三色的数值越大,表示颜色越浓，也就越亮；数值越小，表示颜色越淡，也就越暗。</p></li></ul><h2 id="设置背景颜色"><a href="#设置背景颜色" class="headerlink" title="设置背景颜色"></a>设置背景颜色</h2><p>XML文件中：</p><p><code>android:background=&quot;@color/green&quot;</code></p><p>java文件中：</p><p><code>setBackgroundResource(R.color.green);</code></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>view</tag>
      
      <tag>控件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android预备知识</title>
    <link href="/Android/Android%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <url>/Android/Android%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-预备知识"><a href="#Android-预备知识" class="headerlink" title="Android 预备知识"></a>Android 预备知识</h1><ul><li><a href="#android-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86">Android 预备知识</a><ul><li><a href="#app%E8%BF%90%E8%A1%8C%E6%97%A5%E5%BF%97">App运行日志</a></li><li><a href="#app-%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">APP 工程文件目录结构</a></li><li><a href="#gradle">Gradle</a></li><li><a href="#%E5%8D%95%E4%BD%8D">单位</a><ul><li><a href="#dpi">Dpi</a></li><li><a href="#density">Density</a></li><li><a href="#dip">Dip</a></li><li><a href="#%E5%AE%9E%E9%AA%8C%E4%B8%80">实验一</a></li><li><a href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C">实验二</a></li></ul></li><li><a href="#%E5%BF%AB%E6%8D%B7%E9%94%AE">快捷键</a></li><li><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4">格式化时间</a></li></ul></li></ul><h2 id="App运行日志"><a href="#App运行日志" class="headerlink" title="App运行日志"></a>App运行日志</h2><p>Android 采用Log工具打印日志，它将各类日志划分为五个等级：</p><ul><li><span class="label label-primary">Log.e</span>：表示错误信息，比如可能导致程序崩溃的异常。</li><li><span class="label label-warning">Log.w</span>：表示警告信息。</li><li><span class="label label-primary">Log.i</span>：表示一般消息。</li><li><code>Log.d</code>：表示调试信息，可把程序运行时的变量值打印出来，方便跟踪调试。</li><li><code>Log.v</code>：表示冗余信息。</li></ul><p><img src="/./img/log.png" alt="log"></p><h2 id="APP-工程文件目录结构"><a href="#APP-工程文件目录结构" class="headerlink" title="APP 工程文件目录结构"></a>APP 工程文件目录结构</h2><p>App工程分为两个层次，第一个层次是项目，另一个层次是模块。模块依附于项目，每个项目至少有一个模块，也能拥有多个模块。一般所言的“编译运行App”，指的是运行某个模块，而非运行某个项目，因为模块才对应实际的App。</p><p><img src="/./img/project_structure.png" alt="project_structure"></p><p>从图中看到，该项目下面有两个分类：一个是 app(代表app模块)；另一个是 Gradle Scripts。其中，app 下面又有3个子目录，其功能说明如下：<br>(1) manifests 子目录，下面只有一个XML文件，即AndroidManifest.xml，它是 App 的运行配置文件。<br>(2) java子目录，下面有3个com.example.myapp包，其中第一个包存放当前模块的Java源代码，后面两个包存放测试用的Java代码。<br>(3) res子目录，存放当前模块的资源文件。res下面又有4个子目录：</p><ul><li>drawable目录存放图形描述文件与图片文件。</li><li>layout目录存放App页面的布局文件。</li><li>mipmap目录存放App的启动图标。</li><li>values目录存放一些常量定义文件，例如字符串常量strings.xml、像素常量dimens.xml、颜色常量colors.xml、样式风格定义styles.xml等。</li></ul><p>Gradle scripts 下面主要是工程的编译配置文件，主要有：<br>(1) <code>build.gradle</code>，该文件分为项目级与模块级两种，用于描述App工程的编译规则。<br>(2) <code>proguard-rules.pro</code>，该文件用于描述Java代码的混淆规则。<br>(3) <code>gradle.properties</code>，该文件用于配置编译工程的命令行参数，一般无须改动。<br>(4) <code>settings.gradle</code>，该文件配置了需要编译哪些模块。初始内容为<code>include &#39;:app&#39;</code>，表示只编译 app 模块。<br>(5)<code>local.properties</code>，项目的本地配置文件，它在工程编译时自动生成，用于描述开发者电脑的环境配置，包括SDK的本地路径、NDK的本地路径等。</p><h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><p>Gradle 是一个项目自动化构建工具，帮我们做了依赖、打包、部署、发布、各种渠道的差异管理等工作。</p><h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>px (Pixel像素)</td><td>也称为图像元素，是作为图像构成的基本单元，单个像素的大小并不固定，跟随屏幕大小和像素数量的关系变化，一个像素点为1px。</td></tr><tr><td>Resolution(分辨率)</td><td>是指屏幕的垂直和水平方向的像素数量，如果分辨率是1920 1080，那就是垂直方向有1920个像素，水平方向有1080个像素。</td></tr><tr><td>Dpi(像素密度)</td><td>是指屏幕上每英寸（1英寸&#x3D;2.54厘米)距离中有多少个像素点。</td></tr><tr><td>Density(密度)</td><td>是指屏幕上每平方英寸(2.54^2平方厘米)中含有的像素点数量。</td></tr><tr><td>Dip&#x2F;dp(设备独立像素)</td><td>也可以叫做dp，长度单位，同一个单位在不同的设备上有不同的显示效果，具体效果根据设备的密度有关，详细的公式请看下面。</td></tr></tbody></table><p>  计算规则  </p><p>我们以一个4.95英寸 1920 1080 的nexus5手机设备为例：</p><h3 id="Dpi"><a href="#Dpi" class="headerlink" title="Dpi"></a>Dpi</h3><ol><li>计算直角边像素数量：$1920^2+1080^2&#x3D;2202^2$ (勾股定理) 。</li><li>计算DPI：$2202&#x2F;4.95&#x3D; 445$ 。</li><li>得到这个设备的DPI为 445 (每英寸的距离中有445个像素)。</li></ol><h3 id="Density"><a href="#Density" class="headerlink" title="Density"></a>Density</h3><p>上面得到每英寸中有445像素，那么density为每平方英寸中的像素数量，应该为: $445^2&#x3D;198025$ 。</p><h3 id="Dip"><a href="#Dip" class="headerlink" title="Dip"></a>Dip</h3><p>所有显示到屏幕上的图像都是以p×为单位，Dip是我们开发中使用的长度单位，最后他也需要转换成pX，计算这个设备上 1dip等于多少px：<br><code>px = dip x dpi /160</code><br>根据换算关系:320 x 480分辨率，3.6寸的手机: dpi为160，1dp&#x3D;1px</p><h3 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h3><p>相同分辨率，不同大小的手机AB：</p><table><thead><tr><th>代号</th><th>分辨率</th><th>尺寸</th><th>dpi</th><th>dp</th></tr></thead><tbody><tr><td>手机A</td><td>320x480</td><td>3.6寸</td><td>160</td><td>1dp&#x3D;1px</td></tr><tr><td>手机B</td><td>320x480</td><td>7.2寸</td><td>80</td><td>1dp&#x3D;0.5px</td></tr><tr><td>假如AB都设置一个宽度为100dp的TextView：</td><td></td><td></td><td></td><td></td></tr><tr><td>代号</td><td>TextView宽度</td><td>手机宽度</td><td>比例关系</td><td></td></tr><tr><td>—–</td><td>————</td><td>——–</td><td>——–</td><td></td></tr><tr><td>手机A</td><td>100px</td><td>320px</td><td>10&#x2F;32</td><td></td></tr><tr><td>手机B</td><td>50px</td><td>320px</td><td>5&#x2F;32</td><td></td></tr></tbody></table><p>得出结论:</p><p>  对于相同分辨率的手机，屏幕越大，同DP的组件占用屏幕比例越小。  </p><p>如图所示：</p><p><img src="/./img/dp_1.png" alt="dp_1"></p><h3 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h3><p>相同大小，不同分辨率的手机AB：</p><table><thead><tr><th>代号</th><th>分辨率</th><th>尺寸</th><th>dpi</th><th>dp</th></tr></thead><tbody><tr><td>手机A</td><td>320x480</td><td>3.6寸</td><td>160</td><td>1dp&#x3D;1px</td></tr><tr><td>手机B</td><td>640x960</td><td>3.6寸</td><td>320</td><td>1dp&#x3D;2px</td></tr></tbody></table><p>假如AB都设置一个宽度为100dp的TextView：</p><table><thead><tr><th>代号</th><th>TextView宽度</th><th>手机宽度</th><th>比例关系</th></tr></thead><tbody><tr><td>手机A</td><td>100px</td><td>320px</td><td>10&#x2F;32</td></tr><tr><td>手机B</td><td>200px</td><td>640px</td><td>10&#x2F;32</td></tr></tbody></table><p>得出结论:</p><p>  对于相同尺寸的手机，即使分辨率不同，同DP的组件占用屏幕比例也相同。  </p><p>如图所示：</p><p><img src="/./img/dp_2.png" alt="dp_2"></p><p>综上：</p><p>  dp的UI效果只在相同尺寸的屏幕上相同，如果屏幕尺寸差异过大，则需要重做dp适配。  </p><p>这也是平板需要单独做适配的原因，可见dp不是比例。</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>快捷键可以提高代码编写效率</p><ul><li><code>Ctrl</code>+<code>Alt</code>+<code>L</code>：格式化代码</li><li><code>Ctrl</code>+<code>Alt</code>+<code>O</code>：清除多余的引用</li><li><code>选中变量名</code>+<code>Ctrl</code>+<code>Alt</code>+<code>O</code>+<code>Enter/Tab</code>：将局部变量转为全局变量</li></ul><p>使用Compose构建布局时：</p><ul><li><code>comp</code>快速生成可组合函数</li><li><code>prev</code>快速生成可组合函数的预览</li></ul><h2 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h2><table border=0 cellspacing=3 cellpadding=0 summary="Examples of date and time patterns interpreted in the U.S. locale">   <tr style="background-color: rgb(204, 204, 255);">       <th align=left>Date and Time Pattern       <th align=left>Result   <tr>       <td><code>"yyyy.MM.dd G 'at' HH:mm:ss z"</code>       <td><code>2001.07.04 AD at 12:08:56 PDT</code>   <tr style="background-color: rgb(238, 238, 255);">       <td><code>"EEE, MMM d, ''yy"</code>       <td><code>Wed, Jul 4, '01</code>   <tr>       <td><code>"h:mm a"</code>       <td><code>12:08 PM</code>   <tr style="background-color: rgb(238, 238, 255);">       <td><code>"hh 'o''clock' a, zzzz"</code>       <td><code>12 o'clock PM, Pacific Daylight Time</code>   <tr>       <td><code>"K:mm a, z"</code>       <td><code>0:08 PM, PDT</code>   <tr style="background-color: rgb(238, 238, 255);">       <td><code>"yyyyy.MMMM.dd GGG hh:mm aaa"</code>       <td><code>02001.July.04 AD 12:08 PM</code>   <tr>       <td><code>"EEE, d MMM yyyy HH:mm:ss Z"</code>       <td><code>Wed, 4 Jul 2001 12:08:56 -0700</code>   <tr style="background-color: rgb(238, 238, 255);">       <td><code>"yyMMddHHmmssZ"</code>       <td><code>010704120856-0700</code>   <tr>       <td><code>"yyyy-MM-dd'T'HH:mm:ss.SSSZ"</code>       <td><code>2001-07-04T12:08:56.235-0700</code>   <tr style="background-color: rgb(238, 238, 255);">       <td><code>"yyyy-MM-dd'T'HH:mm:ss.SSSXXX"</code>       <td><code>2001-07-04T12:08:56.235-07:00</code>   <tr>       <td><code>"YYYY-'W'ww-u"</code>       <td><code>2001-W27-3</code></table>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022Kotlin中文开发者大会</title>
    <link href="/Kotlin/Kotlin2022%E4%B8%AD%E6%96%87%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A/"/>
    <url>/Kotlin/Kotlin2022%E4%B8%AD%E6%96%87%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="2022Kotlin中文开发者大会"><a href="#2022Kotlin中文开发者大会" class="headerlink" title="2022Kotlin中文开发者大会"></a>2022Kotlin中文开发者大会</h1><p>Compose</p><p>跨平台开发框架</p><p><img src="/./img/image-20221126144537814.png" alt="image-20221126144537814"></p><p>Compose RunTime</p><p>基于位置的存储</p><p>树形的逻辑结构</p><p>Applier</p><p>两棵树</p><ul><li>Solt Table 虚拟树</li><li>Node Tree 渲染树</li></ul><p><img src="/./img/image-20221126144131517.png" alt="image-20221126144131517"></p><p><a href="https://github.com/JetBrains/compose-jb/tree/master/examples/todoapp">compose-jb&#x2F;examples&#x2F;todoapp at master · JetBrains&#x2F;compose-jb (github.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lifecycles</title>
    <link href="/Android/AndroidLifecycles/"/>
    <url>/Android/AndroidLifecycles/</url>
    
    <content type="html"><![CDATA[<h1 id="LifeCycles"><a href="#LifeCycles" class="headerlink" title="LifeCycles"></a>LifeCycles</h1><p><a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle">使用生命周期感知型组件处理生命周期  | Android 开发者  | Android Developers (google.cn)</a></p><p><img src="/./img/image-20221118171304454.png" alt="image-20221118171304454"></p><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><ol><li><p>创建项目<code>LifeCycles</code></p></li><li><p>创建布局文件</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Chronometer</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/meter&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;34sp&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></code></pre></div></li><li><p><code>MainActivity</code>中</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> chronometer: Chronometer    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        chronometer = findViewById(R.id.meter)<span class="hljs-comment">//        chronometer.base = System.currentTimeMillis() // UNIX 时间 1970 1 1 0时（格林尼治）至今的毫秒数</span>        chronometer.base = SystemClock.elapsedRealtime() <span class="hljs-comment">// 手机上次开机至今的毫秒数，这里就是默认值，不写也行</span>        chronometer.start()    &#125;&#125;</code></pre></div><p>运行App，打开后计时器开始计时，放在后台依然继续计时。</p></li><li><p>继承<code>onPause</code>方法，添加<code>chronometer.stop()</code></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">super</span>.onPause()    chronometer.stop()&#125;</code></pre></div><p>发现切到后台后计时器停止，再次返回前台依然停止。</p></li><li><p>继承<code>onResume</code>方法，添加<code>chronometer.start()</code>，同时删除<code>onCreate</code>方法中的<code>chronometer.start()</code></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">super</span>.onResume()    chronometer.start()&#125;</code></pre></div><p>发现打开后计时器开始计时，切回后台重新打开依然继续计时。</p><p>实际上<code>chronometer.start()</code>和<code>chronometer.stop()</code>方法仅仅改变的是视图中计时器的启动与停止，并不回真正控制其计时。</p></li><li><p>添加变量elapsedTime，并修改<code>onPause</code>方法和<code>onResume</code>方法</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> elapsedTime: <span class="hljs-built_in">Long</span> = <span class="hljs-number">0</span> <span class="hljs-comment">// 保存切回后台前的计时器时间</span><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">super</span>.onPause()    elapsedTime = SystemClock.elapsedRealtime() - chronometer.base    chronometer.stop() <span class="hljs-comment">// 可写可不写</span>&#125;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">super</span>.onResume()    chronometer.base = SystemClock.elapsedRealtime() - elapsedTime <span class="hljs-comment">// 将计时器的开始计时点设为当前时间减去保存的切回后台前的计时器时间</span>    chronometer.start()&#125;</code></pre></div><p>如果有很多像<code>elapsedTime</code>这样需要在生命周期方法里管理的对象，这样写其实就存在很多问题。</p><ul><li>代码繁杂臃肿，界面控制器Activity和Fragment应该尽可能保持精简。</li><li>代码可复用性差</li></ul></li><li><p>自定义View，新建<code>MyChronometer</code>类，继承<code>Chronometer</code>类，实现<code>DefaultLifecycleObserver</code>接口</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyChronometer</span>(    context: Context,    attributeSet: AttributeSet) : Chronometer(context, attributeSet), DefaultLifecycleObserver &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> elapsedTime: <span class="hljs-built_in">Long</span> = <span class="hljs-number">0</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onPause</span><span class="hljs-params">(owner: <span class="hljs-type">LifecycleOwner</span>)</span></span> &#123;        elapsedTime = SystemClock.elapsedRealtime() - base        stop()    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">(owner: <span class="hljs-type">LifecycleOwner</span>)</span></span> &#123;        base = SystemClock.elapsedRealtime() - elapsedTime        start()    &#125;&#125;</code></pre></div></li><li><p><code>MainActivity</code>精简为</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> chronometer: MyChronometer    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        chronometer = findViewById(R.id.meter)        lifecycle.addObserver(chronometer) <span class="hljs-comment">// 注册生命周期观察者</span>    &#125;&#125;</code></pre></div><p>修改<code>Chronometer</code>控件的标签为<code>com.yorick.lifecycles.MyChronometer</code></p><p>运行，实现了上面一样的效果，但是<code>MainActivity</code>非常精简，没有多余的代码。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jetpack</tag>
      
      <tag>Lifecycles</tag>
      
      <tag>Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Navigation</title>
    <link href="/Android/AndroidNavigation/"/>
    <url>/Android/AndroidNavigation/</url>
    
    <content type="html"><![CDATA[<h1 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h1><p>[TOC]</p><p><a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started?hl=zh-cn">Navigation 组件使用入门  | Android 开发者  | Android Developers (google.cn)</a></p><p><a href="https://developer.android.google.cn/guide/navigation/navigation-ui?hl=zh-cn#kotlin">使用 NavigationUI 更新界面组件  | Android 开发者  | Android Developers (google.cn)</a></p><p><a href="https://blog.csdn.net/qq_33235287/article/details/104512251">Navigation的用法-CSDN博客</a></p><h2 id="Navigation介绍"><a href="#Navigation介绍" class="headerlink" title="Navigation介绍"></a>Navigation介绍</h2><p><img src="/./img/image-20221114184612702.png" alt="image-20221114184612702"></p><p>导航是指支持用户导航、进入和退出应用中不同内容片段的交互。Android Jetpack 的导航组件可帮助您实现导航，无论是简单的按钮点击，还是应用栏和抽屉式导航栏等更为复杂的模式，该组件均可应对。导航组件还通过遵循<a href="https://developer.android.google.cn/guide/navigation/navigation-principles?hl=zh-cn">一套既定原则</a>来确保一致且可预测的用户体验。</p><p>导航组件由以下三个关键部分组成：</p><ul><li>导航图：在一个集中位置包含所有导航相关信息的 XML 资源。这包括应用内所有单个内容区域（称为<em>目标</em>）以及用户可以通过应用获取的可能路径。</li><li><code>NavHost</code>：显示导航图中目标的空白容器。导航组件包含一个默认 <code>NavHost</code> 实现 (<a href="https://developer.android.google.cn/reference/androidx/navigation/fragment/NavHostFragment?hl=zh-cn"><code>NavHostFragment</code></a>)，可显示 Fragment 目标。</li><li><code>NavController</code>：在 <code>NavHost</code> 中管理应用导航的对象。当用户在整个应用中移动时，<code>NavController</code> 会安排 <code>NavHost</code> 中目标内容的交换。</li></ul><p>在应用中导航时，您告诉 <code>NavController</code>，您想沿导航图中的特定路径导航至特定目标，或直接导航至特定目标。<code>NavController</code> 便会在 <code>NavHost</code> 中显示相应目标。</p><p>导航组件提供各种其他优势，包括以下内容：</p><ul><li>处理 Fragment 事务。</li><li>默认情况下，正确处理往返操作。</li><li>为动画和转换提供标准化资源。</li><li>实现和处理深层链接。</li><li>包括导航界面模式（例如抽屉式导航栏和底部导航），用户只需完成极少的额外工作。</li><li><a href="https://developer.android.google.cn/guide/navigation/navigation-pass-data?hl=zh-cn#Safe-args">Safe Args</a> - 可在目标之间导航和传递数据时提供类型安全的 Gradle 插件。</li><li><code>ViewModel</code> 支持 - 您可以将 <code>ViewModel</code> 的范围限定为导航图，以在图表的目标之间共享与界面相关的数据。</li></ul><p>此外，您还可以使用 Android Studio 的 <a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started?hl=zh-cn">Navigation Editor</a> 来查看和编辑导航图。</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>如需在您的项目中添加 Navigation 支持，请向应用的 <code>build.gradle</code> 文件添加以下依赖项：</p><div class="code-wrapper"><pre><code class="hljs groovy">dependencies &#123;  <span class="hljs-keyword">def</span> nav_version = <span class="hljs-string">&quot;2.5.3&quot;</span>  <span class="hljs-comment">// Java language implementation</span>  implementation <span class="hljs-string">&quot;androidx.navigation:navigation-fragment:$nav_version&quot;</span>  implementation <span class="hljs-string">&quot;androidx.navigation:navigation-ui:$nav_version&quot;</span>  <span class="hljs-comment">// Kotlin</span>  implementation <span class="hljs-string">&quot;androidx.navigation:navigation-fragment-ktx:$nav_version&quot;</span>  implementation <span class="hljs-string">&quot;androidx.navigation:navigation-ui-ktx:$nav_version&quot;</span>  <span class="hljs-comment">// Feature module Support</span>  implementation <span class="hljs-string">&quot;androidx.navigation:navigation-dynamic-features-fragment:$nav_version&quot;</span>  <span class="hljs-comment">// Testing Navigation</span>  androidTestImplementation <span class="hljs-string">&quot;androidx.navigation:navigation-testing:$nav_version&quot;</span>  <span class="hljs-comment">// Jetpack Compose Integration</span>  implementation <span class="hljs-string">&quot;androidx.navigation:navigation-compose:$nav_version&quot;</span>&#125;</code></pre></div><h2 id="创建导航图"><a href="#创建导航图" class="headerlink" title="创建导航图"></a>创建导航图</h2><p>导航发生在应用中的各个目的地（即您的应用中用户可以导航到的任意位置）之间。这些目的地是通过操作连接的。</p><p>导航图是一种资源文件，其中包含您的所有目的地和操作。该图表会显示应用的所有导航路径。</p><p>图 1 直观显示了一个示例应用的导航图，该应用包含 6 个目的地（通过 5 个操作连接）。每个目的地均由一个预览缩略图表示，连接操作由箭头表示，该箭头表示用户可以如何从一个目的地导航到另一个目的地。</p><p><img src="https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-graph_2x-callouts.png?hl=zh-cn" alt="img"><strong>图 1.</strong> 一个导航图，显示了由 5 个操作连接的 6 个不同目的地的预览。</p><ol><li>“目的地”是指应用中的不同内容区域。</li><li>“操作”是指目的地之间的逻辑连接，表示用户可以采取的路径。</li></ol><p>如需向项目添加导航图，请执行以下操作：</p><ol><li>在“Project”窗口中，右键点击 <code>res</code> 目录，然后依次选择 <strong>New &gt; Android Resource File</strong>。此时系统会显示 <strong>New Resource File</strong> 对话框。</li><li>在 <strong>File name</strong> 字段中输入名称，例如“nav_graph”。</li><li>从 <strong>Resource type</strong> 下拉列表中选择 <strong>Navigation</strong>，然后点击 <strong>OK</strong>。</li></ol><p>当您添加首个导航图时，Android Studio 会在 <code>res</code> 目录内创建一个 <code>navigation</code> 资源目录。该目录包含您的导航图资源文件（例如 <code>nav_graph.xml</code>）。</p><p><strong>注意</strong>：向您的项目添加导航图时，如果您尚未将导航依赖项添加到应用的 <code>build.gradle</code> 文件中，Android Studio 会显示一条提示，并为您提供添加依赖项的选项。但请注意，Android Studio 3.4 添加了非 KTX 1.0.0 版本的依赖项，因此，如果您使用的是 Kotlin 或打算使用 2.0.0 或更高版本，请务必替换这些值。</p><h2 id="Navigation-Editor"><a href="#Navigation-Editor" class="headerlink" title="Navigation Editor"></a>Navigation Editor</h2><p>添加图表后，Android Studio 会在 Navigation Editor 中打开该图表。在 Navigation Editor 中，您可以直观地修改导航图，或直接修改底层 XML。</p><p><img src="https://developer.android.google.cn/static/images/guide/navigation/nav-editor-2x.png?hl=zh-cn" alt="img"><strong>图 2.</strong> Navigation Editor</p><ol><li><strong>Destinations panel</strong>：列出了导航宿主和目前位于 <strong>Graph Editor</strong> 中的所有目的地。</li><li><strong>Graph Editor</strong>：包含导航图的视觉表示形式。您可以在 <strong>Design</strong> 视图和 <strong>Text</strong> 视图中的底层 XML 表示形式之间切换。</li><li><strong>Attributes</strong>：显示导航图中当前所选项的属性。</li></ol><p>点击 <strong>Text</strong> 标签页可查看相应的 XML，它应类似于以下代码段：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">navigation</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/nav_graph&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">navigation</span>&gt;</span></code></pre></div><p><code>&lt;navigation&gt;</code> 元素是导航图的根元素。当您向图表添加目的地和连接操作时，可以看到相应的 <code>&lt;destination&gt;</code> 和 <code>&lt;action&gt;</code> 元素在此处显示为子元素。如果您有<a href="https://developer.android.google.cn/guide/navigation/navigation-nested-graphs?hl=zh-cn">嵌套图表</a>，它们将显示为子 <code>&lt;navigation&gt;</code> 元素。</p><h2 id="向-Activity-添加-NavHost"><a href="#向-Activity-添加-NavHost" class="headerlink" title="向 Activity 添加 NavHost"></a>向 Activity 添加 NavHost</h2><p>导航宿主是 Navigation 组件的核心部分之一。导航宿主是一个空容器，用户在您的应用中导航时，目的地会在该容器中交换进出。</p><p>导航宿主必须派生于 <a href="https://developer.android.google.cn/reference/androidx/navigation/NavHost?hl=zh-cn"><code>NavHost</code></a>。Navigation 组件的默认 <code>NavHost</code> 实现 (<a href="https://developer.android.google.cn/reference/androidx/navigation/fragment/NavHostFragment?hl=zh-cn"><code>NavHostFragment</code></a>) 负责处理 Fragment 目的地的交换。</p><p><strong>注意</strong>：Navigation 组件旨在用于具有一个主 activity 和多个 fragment 目的地的应用。主 activity 与导航图相关联，且包含一个负责根据需要交换目的地的 <code>NavHostFragment</code>。在具有多个 activity 目的地的应用中，每个 activity 均拥有其自己的导航图。</p><h3 id="通过-XML-添加-NavHostFragment"><a href="#通过-XML-添加-NavHostFragment" class="headerlink" title="通过 XML 添加 NavHostFragment"></a>通过 XML 添加 NavHostFragment</h3><p>以下 XML 示例显示了作为应用主 Activity 一部分的 <code>NavHostFragment</code>：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">androidx.appcompat.widget.Toolbar</span></span><span class="hljs-tag">        <span class="hljs-attr">...</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">androidx.fragment.app.FragmentContainerView</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/nav_host_fragment&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;androidx.navigation.fragment.NavHostFragment&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag"></span><span class="hljs-tag">        <span class="hljs-attr">app:defaultNavHost</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:navGraph</span>=<span class="hljs-string">&quot;@navigation/nav_graph&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.bottomnavigation.BottomNavigationView</span></span><span class="hljs-tag">        <span class="hljs-attr">...</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></code></pre></div><p>请注意以下几点：</p><ul><li><code>android:name</code> 属性包含 <code>NavHost</code> 实现的类名称。</li><li><code>app:navGraph</code> 属性将 <code>NavHostFragment</code> 与导航图相关联。导航图会在此 <code>NavHostFragment</code> 中指定用户可以导航到的所有目的地。</li><li><code>app:defaultNavHost=&quot;true&quot;</code> 属性确保您的 <code>NavHostFragment</code> 会拦截系统返回按钮。请注意，只能有一个默认 <code>NavHost</code>。如果同一布局（例如，双窗格布局）中有多个托管容器，请务必仅指定一个默认 <code>NavHost</code>。</li></ul><p>您也可以使用<a href="https://developer.android.google.cn/studio/write/layout-editor?hl=zh-cn">布局编辑器</a>向 activity 添加 <code>NavHostFragment</code>，具体操作步骤如下：</p><ol><li>在项目文件列表中，双击 Activity 的布局 XML 文件，以在 Layout Editor 中将其打开。</li><li>在 <strong>Palette</strong> 窗格内，选择 <strong>Containers</strong> 类别，或者搜索“NavHostFragment”。</li><li>将 <code>NavHostFragment</code> 视图拖动到您的 Activity 上。</li><li>接下来，在随即显示的 <strong>Navigation Graphs</strong> 对话框中，选择需要与此 <code>NavHostFragment</code> 相关联的相应导航图，然后点击 <strong>OK</strong>。</li></ol><h2 id="向导航图添加目的地"><a href="#向导航图添加目的地" class="headerlink" title="向导航图添加目的地"></a>向导航图添加目的地</h2><p>您可以从现有的 Fragment 或 Activity 创建目的地。您还可以使用 Navigation Editor 创建新目的地，或创建占位符以便稍后替换为 fragment 或 activity。</p><p>在本示例中，我们来创建一个新目的地。如需使用 Navigation Editor 添加新目的地，请执行以下操作：</p><ol><li>在 Navigation Editor 中，点击 <strong>New Destination</strong> 图标 <img src="https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-new-destination-icon.png?hl=zh-cn" alt="img">，然后点击 <strong>Create new destination</strong>。</li><li>在随即显示的 <strong>New Android Component</strong> 对话框中，创建您的 Fragment。如需详细了解 Fragment，请参阅 <a href="https://developer.android.google.cn/guide/components/fragments?hl=zh-cn">Fragment 文档</a>。</li></ol><p>当您返回到 Navigation Editor 中时，会发现 Android Studio 已将此目的地添加到图中。</p><p>图 1 显示了目的地和<a href="https://developer.android.google.cn/guide/navigation/navigation-create-destinations?hl=zh-cn#placeholders">占位符目的地</a>的示例。</p><p><img src="https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-destination-and-placeholder_2x.png?hl=zh-cn" alt="img"><strong>图 3.</strong> 目的地和占位符</p><p>如需了解向导航图添加目的地的其他方式，请参阅<a href="https://developer.android.google.cn/guide/navigation/navigation-create-destinations?hl=zh-cn">创建目的地</a>。</p><h2 id="目的地详解"><a href="#目的地详解" class="headerlink" title="目的地详解"></a>目的地详解</h2><p>点击一个目的地以将其选中，并注意 <strong>Attributes</strong> 面板中显示的以下属性：</p><ul><li><strong>Type</strong> 字段指示在您的源代码中，该目的地是作为 fragment、activity 还是其他自定义类实现的。</li><li><strong>Label</strong> 字段包含该目的地的用户可读名称。例如，如果您使用 [<code>setupWithNavController()</code>](<a href="https://developer.android.google.cn/reference/androidx/navigation/ui/NavigationUI?hl=zh-cn#setupWithNavController">https://developer.android.google.cn/reference/androidx/navigation/ui/NavigationUI?hl=zh-cn#setupWithNavController</a>(androidx.appcompat.widget.Toolbar, androidx.navigation.NavController)) 将 <a href="https://developer.android.google.cn/reference/androidx/navigation/NavGraph?hl=zh-cn"><code>NavGraph</code></a> 连接到 <code>Toolbar</code>，就可能在界面上看到此字段。因此，我们建议您对此值使用资源字符串。</li><li><strong>ID</strong> 字段包含该目的地的 ID，它用于在代码中引用该目的地。</li><li><strong>Class</strong> 下拉列表显示与该目的地相关联的类的名称。您可以点击此下拉列表，将相关联的类更改为其他目的地类型。</li></ul><p>点击 <strong>Text</strong> 标签页可查看导航图的 XML 视图。XML 中同样包含该目的地的 <code>id</code>、<code>name</code>、<code>label</code> 和 <code>layout</code> 属性，如下所示：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">navigation</span> <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:startDestination</span>=<span class="hljs-string">&quot;@id/blankFragment&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/blankFragment&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.cashdog.cashdog.BlankFragment&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;@string/label_blank&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">tools:layout</span>=<span class="hljs-string">&quot;@layout/fragment_blank&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">navigation</span>&gt;</span></code></pre></div><h2 id="将某个屏幕指定为起始目的地"><a href="#将某个屏幕指定为起始目的地" class="headerlink" title="将某个屏幕指定为起始目的地"></a>将某个屏幕指定为起始目的地</h2><p><a href="https://developer.android.google.cn/guide/navigation/navigation-principles?hl=zh-cn">起始目的地</a>是用户打开您的应用时看到的第一个屏幕，也是用户退出您的应用时看到的最后一个屏幕。Navigation Editor 使用房子图标 <img src="https://developer.android.google.cn/static/studio/images/buttons/navigation-house.png?hl=zh-cn" alt="img"> 表示起始目的地。</p><p>所有目的地就绪后，您便可以选择起始目的地，具体操作步骤如下：</p><ol><li>在 <strong>Design</strong> 标签页中，点击相应目的地，使其突出显示。</li><li>点击 <strong>Assign start destination</strong> 按钮 <img src="https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-start-destination-icon.png?hl=zh-cn" alt="img">。或者，您可以右键点击该目的地，然后点击 <strong>Set as Start Destination</strong>。</li></ol><h2 id="连接目的地"><a href="#连接目的地" class="headerlink" title="连接目的地"></a>连接目的地</h2><p>操作是指目的地之间的逻辑连接。操作在导航图中以箭头表示。操作通常会将一个目的地连接到另一个目的地，不过您也可以创建<a href="https://developer.android.google.cn/guide/navigation/navigation-global-action?hl=zh-cn">全局操作</a>，此类操作可让您从应用中的任意位置转到特定目的地。</p><p>借助操作，您可以表示用户在您的应用中导航时可以采取的不同路径。请注意，如需实际导航到各个目的地，您仍然需要编写代码以执行导航操作。如需了解详情，请参阅本主题后面的<a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started?hl=zh-cn#navigate">导航到目的地</a>部分。</p><p>您可以使用 Navigation Editor 将两个目的地连接起来，具体操作步骤如下：</p><ol><li><p>在 <strong>Design</strong> 标签页中，将鼠标悬停在目的地的右侧，该目的地为您希望用户从中导航出来的目的地。该目的地右侧上方会显示一个圆圈，如图 4 所示。</p><p><img src="https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-actioncircle_2x.png?hl=zh-cn" alt="img"><br><strong>图 4.</strong> 一个包含操作连接圆圈的目的地</p></li><li><p>点击您希望用户导航到的目的地，并将光标拖动到该目的地的上方，然后松开。这两个目的地之间生成的线条表示操作，如图 5 所示。</p><p><img src="https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-connected_2x.png?hl=zh-cn" alt="img"><strong>图 5.</strong> 通过操作连接目的地</p></li><li><p>点击箭头以突出显示该操作。此时 <strong>Attributes</strong> 面板中会显示以下属性：</p><ul><li><strong>Type</strong> 字段包含“Action”。</li><li><strong>ID</strong> 字段包含该操作的 ID。</li><li><strong>Destination</strong> 字段包含目的地 Fragment 或 Activity 的 ID。</li></ul></li><li><p>点击 <strong>Text</strong> 标签，以切换到 XML 视图。现在，一个 action 元素已添加到源目的地中。该操作有一个 ID 和一个目的地属性（其中包含下一个目的地的 ID），如以下示例所示：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">navigation</span> <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">app:startDestination</span>=<span class="hljs-string">&quot;@id/blankFragment&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/blankFragment&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.cashdog.cashdog.BlankFragment&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;@string/label_blank&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">tools:layout</span>=<span class="hljs-string">&quot;@layout/fragment_blank&quot;</span> &gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span></span><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/action_blankFragment_to_blankFragment2&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:destination</span>=<span class="hljs-string">&quot;@id/blankFragment2&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">fragment</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/blankFragment2&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.cashdog.cashdog.BlankFragment2&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;@string/label_blank_2&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">tools:layout</span>=<span class="hljs-string">&quot;@layout/fragment_blank_fragment2&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">navigation</span>&gt;</span></code></pre></div></li></ol><p>在导航图中，操作由 <code>&lt;action&gt;</code> 元素表示。操作至少应包含自己的 ID 和用户应转到的目的地的 ID。</p><h2 id="导航到目的地"><a href="#导航到目的地" class="headerlink" title="导航到目的地"></a>导航到目的地</h2><p>导航到目的地是使用 <a href="https://developer.android.google.cn/reference/androidx/navigation/NavController?hl=zh-cn"><code>NavController</code></a> 完成的，它是一个在 <code>NavHost</code> 中管理应用导航的对象。每个 <code>NavHost</code> 均有自己的相应 <code>NavController</code>。您可以使用以下方法之一检索 <code>NavController</code>：</p><p><strong>Kotlin</strong>：</p><ul><li><a href="https://developer.android.google.cn/reference/kotlin/androidx/navigation/fragment/package-summary?hl=zh-cn#(androidx.fragment.app.Fragment).findNavController()"><code>Fragment.findNavController()</code></a></li><li><a href="https://developer.android.google.cn/reference/kotlin/androidx/navigation/package-summary?hl=zh-cn#(android.view.View).findNavController()"><code>View.findNavController()</code></a></li><li><a href="https://developer.android.google.cn/reference/kotlin/androidx/navigation/package-summary?hl=zh-cn#(android.app.Activity).findNavController(kotlin.Int)"><code>Activity.findNavController(viewId: Int)</code></a></li></ul><p><strong>Java</strong>：</p><ul><li><a href="https://developer.android.google.cn/reference/androidx/navigation/fragment/NavHostFragment?hl=zh-cn#findNavController(android.support.v4.app.Fragment)"><code>NavHostFragment.findNavController(Fragment)</code></a></li><li>[<code>Navigation.findNavController(Activity, @IdRes int viewId)</code>](<a href="https://developer.android.google.cn/reference/androidx/navigation/Navigation?hl=zh-cn#findNavController">https://developer.android.google.cn/reference/androidx/navigation/Navigation?hl=zh-cn#findNavController</a>(android.app.Activity, int))</li><li><a href="https://developer.android.google.cn/reference/androidx/navigation/Navigation?hl=zh-cn#findNavController(android.view.View)"><code>Navigation.findNavController(View)</code></a></li></ul><p>使用 <code>FragmentContainerView</code> 创建 <code>NavHostFragment</code>，或通过 <code>FragmentTransaction</code> 手动将 <code>NavHostFragment</code> 添加到您的 Activity 时，尝试通过 <code>Navigation.findNavController(Activity, @IdRes int)</code> 检索 Activity 的 <code>onCreate()</code> 中的 <code>NavController</code> 将失败。您应改为直接从 <code>NavHostFragment</code> 检索 <code>NavController</code>。</p><p><a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started?hl=zh-cn#kotlin">Kotlin</a><a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started?hl=zh-cn#java">Java</a></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> navHostFragment =        supportFragmentManager.findFragmentById(R.id.nav_host_fragment) <span class="hljs-keyword">as</span> NavHostFragment<span class="hljs-keyword">val</span> navController = navHostFragment.navController</code></pre></div><h3 id="使用-Safe-Args-确保类型安全"><a href="#使用-Safe-Args-确保类型安全" class="headerlink" title="使用 Safe Args 确保类型安全"></a>使用 Safe Args 确保类型安全</h3><p>如需在目的地之间导航，建议使用 Safe Args Gradle 插件。该插件可以生成简单的对象和构建器类，这些类支持在目的地之间进行类型安全的导航和参数传递。</p><p><strong>注意</strong>：如需了解其他导航方式，请参阅<a href="https://developer.android.google.cn/guide/navigation/navigation-navigate?hl=zh-cn">导航到目的地</a>。</p><p>如需将 <a href="https://developer.android.google.cn/topic/libraries/architecture/navigation/navigation-pass-data?hl=zh-cn#Safe-args">Safe Args</a> 添加到您的项目，请在顶层 <code>build.gradle</code> 文件中包含以下 <code>classpath</code>：</p><p><a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started?hl=zh-cn#groovy">Groovy</a><a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started?hl=zh-cn#kotlin">Kotlin</a></p><div class="code-wrapper"><pre><code class="hljs groovy">buildscript &#123;    repositories &#123;        google()    &#125;    dependencies &#123;        <span class="hljs-keyword">def</span> nav_version = <span class="hljs-string">&quot;2.5.3&quot;</span>        classpath <span class="hljs-string">&quot;androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version&quot;</span>    &#125;&#125;</code></pre></div><p>您还必须应用以下两个可用插件之一。</p><p>如需生成适用于 Java 模块或 Java 和 Kotlin 混合模块的 Java 语言代码，请将以下行添加到<strong>应用或模块</strong>的 <code>build.gradle</code> 文件中：</p><p><a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started?hl=zh-cn#groovy">Groovy</a><a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started?hl=zh-cn#kotlin">Kotlin</a></p><div class="code-wrapper"><pre><code class="hljs groovy">plugins &#123;  id <span class="hljs-string">&#x27;androidx.navigation.safeargs&#x27;</span>&#125;</code></pre></div><p>此外，如需生成仅适用于 Kotlin 模块的 Kotlin 语言代码，请添加以下行：</p><p><a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started?hl=zh-cn#groovy">Groovy</a><a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started?hl=zh-cn#kotlin">Kotlin</a></p><div class="code-wrapper"><pre><code class="hljs groovy">plugins &#123;  id <span class="hljs-string">&#x27;androidx.navigation.safeargs.kotlin&#x27;</span>&#125;</code></pre></div><p>根据<a href="https://developer.android.google.cn/jetpack/androidx/migrate?hl=zh-cn#migrate">迁移到 AndroidX</a>) 文档，您的 <a href="https://developer.android.google.cn/studio/build?hl=zh-cn#properties-files"><code>gradle.properties</code> 文件</a>中必须具有 <code>android.useAndroidX=true</code>。</p><p>启用 Safe Args 后，该插件会生成代码，其中包含您定义的每个操作的类和方法。对于每个操作，Safe Args 还会为每个源目的地（生成相应操作的目的地）生成一个类。生成的类的名称由源目的地类的名称和“Directions”一词组成。例如，如果目的地的名称为 <code>SpecifyAmountFragment</code>，生成的类的名称为 <code>SpecifyAmountFragmentDirections</code>。生成的类为源目的地中定义的每个操作提供了一个静态方法。该方法会将任何定义的操作参数作为参数，并返回可传递到 <code>navigate()</code> 的 <code>NavDirections</code> 对象。</p><p>例如，假设我们的导航图包含一个操作，该操作将源目的地 <code>SpecifyAmountFragment</code> 和接收目的地 <code>ConfirmationFragment</code> 连接起来。</p><p>Safe Args 会生成一个 <code>SpecifyAmountFragmentDirections</code> 类，其中只包含一个 <code>actionSpecifyAmountFragmentToConfirmationFragment()</code> 方法（该方法会返回 <code>NavDirections</code> 对象）。然后，您可以将返回的 <code>NavDirections</code> 对象直接传递到 <code>navigate()</code>，如以下示例所示：</p><p><a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started?hl=zh-cn#kotlin">Kotlin</a><a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started?hl=zh-cn#java">Java</a></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> &#123;    <span class="hljs-keyword">val</span> action =        SpecifyAmountFragmentDirections            .actionSpecifyAmountFragmentToConfirmationFragment()    view.findNavController().navigate(action)&#125;</code></pre></div><p>如需详细了解如何使用 Safe Args 在目的地之间传递数据，请参阅<a href="https://developer.android.google.cn/guide/navigation/navigation-pass-data?hl=zh-cn#Safe-args">使用 Safe Args 传递类型安全的数据</a>。</p><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h3 id="创建Navigation"><a href="#创建Navigation" class="headerlink" title="创建Navigation"></a>创建Navigation</h3><ol><li><p><strong>新建Fragment</strong>，并创建对应的布局文件</p><p><img src="/./img/image-20221112181122669.png" alt="image-20221112181122669"></p><p>默认的布局是<code>FrameLayout</code>，我们可以改为或者嵌套<code>ConstraintLayout</code></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.HomeFragment&quot;</span> /&gt;</span></code></pre></div></li><li><p><strong>创建Navigation资源文件</strong></p><p><img src="/./img/image-20221112181644495.png" alt="image-20221112181644495"></p><p>配置如下</p><p><img src="/./img/image-20221112181906028.png" alt="image-20221112181906028"></p><p>这里AndroidStudio有个小Bug，可能会一直加载布局文件，别慌，我们关掉所有的xml文件，重新打开<code>my_nav.xml</code>文件，不出意外会提示缺少依赖：</p><p><img src="/./img/image-20221112182300752.png" alt="image-20221112182300752"></p><p>点击<code>OK</code>会自动补全依赖。</p><p>打开<code>build.gradle</code>发现自动导入的依赖如下：</p><div class="code-wrapper"><pre><code class="hljs groovy">implementation <span class="hljs-string">&#x27;androidx.navigation:navigation-fragment-ktx:2.5.3&#x27;</span>implementation <span class="hljs-string">&#x27;androidx.navigation:navigation-ui-ktx:2.5.3&#x27;</span></code></pre></div></li><li><p><strong>设计跳转逻辑</strong></p><p>进入Navigation Editor，添加目的地</p><p><img src="/./img/image-20221112183751474.png" alt="image-20221112183751474"></p><p>根据跳转逻辑连接目的地，带房子图标的是<strong>主页</strong>，就是NavHost显示的首个界面</p><p><img src="/./img/image-20221112184034079.png" alt="image-20221112184034079"></p></li><li><p><strong>向 Activity 添加 NavHost</strong></p><p>找到<code>fragmentContainerView</code>拖到布局中（一定是布局的导航栏中），并添加约束</p><p><img src="/./img/image-20221112190307587.png" alt="image-20221112190307587"></p><p>选择刚刚创建好的Navigation布局文件</p><p><img src="/./img/image-20221112184740090.png" alt="image-20221112184740090"></p></li><li><p><strong>为控件绑定跳转事件</strong></p><p>实现<code>onViewCreated()</code>方法</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;    <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState)    view.findViewById&lt;Button&gt;(R.id.button)        .setOnClickListener &#123; v -&gt;            <span class="hljs-keyword">val</span> controller = Navigation.findNavController(v)            controller.navigate(R.id.action_homeFragment_to_detailFragment)        &#125;&#125;</code></pre></div><p>或者</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;    <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState)    view.findViewById&lt;Button&gt;(R.id.button)            .setOnClickListener(Navigation.createNavigateOnClickListener(R.id.action_homeFragment_to_detailFragment))&#125;</code></pre></div></li></ol><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><ul><li><p><strong>第一种：可视化</strong></p><p>在Navigation Edit中添加参数，在Attributes栏的Argument中，也是以键值对的形式添加。</p><p><img src="/./img/image-20221113165722681.png" alt="image-20221113165722681"></p><p>添加后fragment标签内增加</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">argument</span></span><span class="hljs-tag">   <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;name&quot;</span></span><span class="hljs-tag"> <span class="hljs-attr">app:argType</span>=<span class="hljs-string">&quot;string&quot;</span></span><span class="hljs-tag">   <span class="hljs-attr">android:defaultValue</span>=<span class="hljs-string">&quot;Jack&quot;</span> /&gt;</span></code></pre></div><p>在fragment中通过键值获取参数</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> string = arguments?.getString(<span class="hljs-string">&quot;name&quot;</span>)</code></pre></div></li></ul><p>   可以点击action对改值进行重写，会覆盖掉原来的值。</p><p>   注意跳转时目的地不同，携带的参数也不同</p>   <div class="code-wrapper"><pre><code class="hljs kotlin">controller.navigate(R.id.action_homeFragment_to_detailFragment) <span class="hljs-comment">// Tom</span>controller.navigate(R.id.detailFragment) <span class="hljs-comment">// Jack</span></code></pre></div><ul><li><p><strong>第二种：通过Bundle传递参数</strong></p><div class="code-wrapper"><pre><code class="hljs kotlin">bundle.putString(<span class="hljs-string">&quot;my_name&quot;</span>, text)<span class="hljs-keyword">val</span> controller = Navigation.findNavController(v)controller.navigate(R.id.action_homeFragment_to_detailFragment, bundle) <span class="hljs-comment">// Tom</span></code></pre></div><p>接收参数，和上面一样</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> string1 = arguments?.getString(<span class="hljs-string">&quot;my_name&quot;</span>)</code></pre></div></li></ul><h3 id="添加动画"><a href="#添加动画" class="headerlink" title="添加动画"></a>添加动画</h3><ol><li><p>创建anim资源文件，类似导航资源文件的创建</p></li><li><p>创建动画效果，</p><p>示例：从中间向右平移<code>slide_to_right</code></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">translate</span></span><span class="hljs-tag">        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">动画时间</span></span><span class="hljs-tag">        <span class="hljs-attr">android:fromXDelta</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">x轴起点</span></span><span class="hljs-tag">        <span class="hljs-attr">android:toXDelta</span>=<span class="hljs-string">&quot;100%&quot;</span>&gt;</span>x轴终点    <span class="hljs-tag">&lt;/<span class="hljs-name">translate</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></code></pre></div><p>示例：从左向中间平移<code>slide_from_left</code></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">translate</span></span><span class="hljs-tag">        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;300&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:fromXDelta</span>=<span class="hljs-string">&quot;-100%&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:toXDelta</span>=<span class="hljs-string">&quot;0%&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">translate</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></code></pre></div><p>示例：简单缩放和旋转，从中间放大</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scale</span></span><span class="hljs-tag">        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;1000&quot;</span>  <span class="hljs-attr">动画时间</span></span><span class="hljs-tag">        <span class="hljs-attr">android:fromXScale</span>=<span class="hljs-string">&quot;0.0&quot;</span> <span class="hljs-attr">原比例</span></span><span class="hljs-tag">        <span class="hljs-attr">android:fromYScale</span>=<span class="hljs-string">&quot;0.0&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:pivotX</span>=<span class="hljs-string">&quot;50%&quot;</span>  <span class="hljs-attr">x轴原点</span></span><span class="hljs-tag">        <span class="hljs-attr">android:pivotY</span>=<span class="hljs-string">&quot;50%&quot;</span>  <span class="hljs-attr">y轴原点</span></span><span class="hljs-tag">        <span class="hljs-attr">android:toXScale</span>=<span class="hljs-string">&quot;1.0&quot;</span>  <span class="hljs-attr">放大后比例</span></span><span class="hljs-tag">        <span class="hljs-attr">android:toYScale</span>=<span class="hljs-string">&quot;1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rotate</span></span><span class="hljs-tag">        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;1000&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:fromDegrees</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">原角度</span> </span><span class="hljs-tag">        <span class="hljs-attr">android:pivotX</span>=<span class="hljs-string">&quot;50%&quot;</span> </span><span class="hljs-tag">        <span class="hljs-attr">android:pivotY</span>=<span class="hljs-string">&quot;50%&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:toDegrees</span>=<span class="hljs-string">&quot;360&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></code></pre></div></li><li><p>在Navigation Editor中为Action添加动画即可。</p></li></ol><h2 id="使用ViewModel管理导航之间的数据"><a href="#使用ViewModel管理导航之间的数据" class="headerlink" title="使用ViewModel管理导航之间的数据"></a>使用ViewModel管理导航之间的数据</h2><p><img src="/./img/image-20221114184723610.png" alt="image-20221114184723610"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jetpack</tag>
      
      <tag>Navigation</tag>
      
      <tag>Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataBinding</title>
    <link href="/Android/AndroidDataBinding/"/>
    <url>/Android/AndroidDataBinding/</url>
    
    <content type="html"><![CDATA[<h1 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h1><p><img src="/./img/image-20221105181749287.png" alt="image-20221105181749287"></p><p>DataBinding是Google提供给我们的数据绑定的支持库，实现在页面组件中直接绑定应用程序的数据源。</p><h2 id="使用DataBinding"><a href="#使用DataBinding" class="headerlink" title="使用DataBinding"></a>使用DataBinding</h2><p>示例App要实现的功能是，点击按钮Button，TextView的数字<code>+1</code></p><ol><li><p>项目中引入dataBinding</p><div class="code-wrapper"><pre><code class="hljs groovy"><span class="hljs-comment">// 在build.gradle文件添加</span>android&#123;   ...   dataBinding&#123;      enabled <span class="hljs-literal">true</span>   &#125;   ...&#125;</code></pre></div></li><li><p>新建activity和对应的layout布局文件。包括一个Button和一个Text View。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/textView&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Hello World&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;34sp&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintVertical_bias</span>=<span class="hljs-string">&quot;0.422&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/button&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintVertical_bias</span>=<span class="hljs-string">&quot;0.71&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></code></pre></div></li><li><p>布局文件格式转换（普通layout➡️databing对应的layout）<br>光标在布局文件的根布局➡️按<code>Alt</code> +<code> Enter</code>➡️点击 <code>Convert to data binding layout</code></p><p>得到转换后的layout布局文件，内容如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/textView&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Hello World&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;34sp&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintVertical_bias</span>=<span class="hljs-string">&quot;0.422&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/button&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintVertical_bias</span>=<span class="hljs-string">&quot;0.71&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span></code></pre></div><p>观察到外层嵌套了layout标签，里面增加了data标签。</p></li><li><p>创建MyViewModel类</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> : <span class="hljs-type">ViewModel</span>() &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _number = MutableLiveData&lt;<span class="hljs-built_in">Int</span>&gt;()    <span class="hljs-keyword">val</span> number: LiveData&lt;<span class="hljs-built_in">Int</span>&gt;        <span class="hljs-keyword">get</span>() = _number    <span class="hljs-keyword">init</span> &#123;        _number.value = <span class="hljs-number">0</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;        _number.value = _number.value?.plus(<span class="hljs-number">1</span>)    &#125;&#125;</code></pre></div></li><li><p>这里有两种方式实现<code>+1</code>功能</p><ul><li><p><strong>方式一：</strong></p><p><code>DataBinding</code>会基于<code>layout</code>创建一个<code>Binding class</code>，这个类包含了布局属性(定义的变量)到相关视图的所有绑定，并且会为布局中的数据元素生成<code>setter</code>，生成的类的名称是基于<code>layout</code>的名称(驼峰命名，加上<code>Binding</code>后缀)。比如布局名是<code>activity_main.xml</code>，生成的类就是<code>ActivityMainBinding</code>。你能通过这个类去<code>inflate</code>布局和数据模型，也可以通过<code>DataBindingUtil</code>类。</p><ul><li><p>在<code>MainActivity</code>使用<code>DataBindingUtils</code>加载布局，这里使用了懒加载，即随用随加载。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> binding: ActivityMainBinding <span class="hljs-keyword">by</span> lazy &#123;    DataBindingUtil.setContentView(        <span class="hljs-keyword">this</span>,        R.layout.activity_main    )&#125;</code></pre></div></li><li><p><code>inflate</code>加载布局（此方法也能用于<code>RecyclerView</code>, <code>ViewPager</code>）</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> myViewModel <span class="hljs-keyword">by</span> lazy &#123; ViewModelProvider(<span class="hljs-keyword">this</span>)[MyViewModel::<span class="hljs-keyword">class</span>.java] &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> binding <span class="hljs-keyword">by</span> lazy &#123; ActivityMainBinding.inflate(layoutInflater) &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)        setContentView(binding.root)        ...    &#125;&#125;</code></pre></div></li></ul><p>上述两种方法大家二选一，一般在<code>Activity</code>中我们都用第一种。</p><p>如果在fragment中绑定布局</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MasterFragment</span> : <span class="hljs-type">Fragment</span>() &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">        inflater: <span class="hljs-type">LayoutInflater</span>, container: <span class="hljs-type">ViewGroup</span>?,</span></span><span class="hljs-params"><span class="hljs-function">        savedInstanceState: <span class="hljs-type">Bundle</span>?</span></span><span class="hljs-params"><span class="hljs-function">    )</span></span>: View &#123;        <span class="hljs-keyword">val</span> viewModel = ViewModelProvider(requireActivity())[MyViewModel::<span class="hljs-keyword">class</span>.java]        <span class="hljs-keyword">val</span> binding = DataBindingUtil.inflate&lt;FragmentMasterBinding&gt;(            inflater,            R.layout.fragment_master,            container,            <span class="hljs-literal">false</span>        )        binding.<span class="hljs-keyword">data</span> = viewModel        binding.lifecycleOwner = requireActivity()        <span class="hljs-keyword">return</span> binding.root&#125;</code></pre></div><p>然后在<code>MainActivity</code>的<code>onCreate</code>方法添加Observe和按钮点击事件</p><div class="code-wrapper"><pre><code class="hljs kotlin">  myViewModel.number.observe(<span class="hljs-keyword">this</span>) &#123;  binding.textView.text = it.toString()  &#125;  binding.button.setOnClickListener &#123;  myViewModel.add()  &#125;  - **方式二：**  反向绑定，把数据数据绑定和按钮点击事件放在布局文件中  在layout的<span class="hljs-keyword">data</span>中添加：  ```xml  &lt;<span class="hljs-keyword">data</span>&gt;      &lt;variable      name=<span class="hljs-string">&quot;data&quot;</span>      type=<span class="hljs-string">&quot;com.yorick.databinding.MyViewModel&quot;</span> /&gt;  &lt;/<span class="hljs-keyword">data</span>&gt;</code></pre></div><p>修改TextView的text属性：</p><div class="code-wrapper"><pre><code class="hljs xml">android:text=&quot;@&#123;data.number.toString()&#125;&quot;</code></pre></div><p>Button增加onClick属性：</p><div class="code-wrapper"><pre><code class="hljs xml">android:onClick=&quot;@&#123;()-&gt;data.add()&#125;&quot;</code></pre></div><p>Activity仅保留以下代码：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> myViewModel <span class="hljs-keyword">by</span> lazy &#123; ViewModelProvider(<span class="hljs-keyword">this</span>)[MyViewModel::<span class="hljs-keyword">class</span>.java] &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> binding: ActivityMainBinding <span class="hljs-keyword">by</span> lazy &#123;        DataBindingUtil.setContentView(            <span class="hljs-keyword">this</span>,            R.layout.activity_main        )    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)        binding.<span class="hljs-keyword">data</span> = myViewModel        binding.lifecycleOwner = <span class="hljs-keyword">this</span>    &#125;&#125;</code></pre></div></li></ul></li></ol><p>参考：</p><ul><li><a href="https://blog.csdn.net/hncdcsm1/article/details/109505160">(在Android中使用DataBinding(Kotlin)_CSDN</a></li><li><a href="https://blog.51cto.com/baorant24/5768873">Jetpeck DataBinding实践——轻松上手DataBinding_51CTO</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jetpack</tag>
      
      <tag>Architecture</tag>
      
      <tag>DataBinding</tag>
      
      <tag>ViewModel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LiveData</title>
    <link href="/Android/AndroidLiveData/"/>
    <url>/Android/AndroidLiveData/</url>
    
    <content type="html"><![CDATA[<h1 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h1><p><a href="https://developer.android.google.cn/reference/kotlin/androidx/lifecycle/LiveData">LiveData  | Android Developers (google.cn)</a></p><p>[TOC]</p><h2 id="LiveData的定义"><a href="#LiveData的定义" class="headerlink" title="LiveData的定义"></a>LiveData的定义</h2><p><a href="https://developer.android.google.cn/reference/androidx/lifecycle/LiveData"><code>LiveData</code></a> 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有<a href="https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020">生命周期</a>感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。</p><p>从上述定义可以知道：</p><ul><li>LiveData 是一个<code>可观察</code>的<code>数据存储类</code>；</li><li>LiveData 具有<code>生命周期感知</code>能力；</li><li>LivaData <code>仅更新</code>处于<code>活跃生命周期状态（ STARTED 或 RESUMED 状态）</code>的应用组件观察者。</li></ul><h2 id="LiveData的优势"><a href="#LiveData的优势" class="headerlink" title="LiveData的优势"></a>LiveData的优势</h2><ul><li>确保界面符合数据状态；</li><li>不会发生内存泄漏；</li><li>不会因 Activity 的停止而导致崩溃</li><li>不需要手动处理生命周期</li><li>数据始终保持最新状态</li><li>共享资源</li><li>适当的配置修改</li></ul><h2 id="LiveData的使用"><a href="#LiveData的使用" class="headerlink" title="LiveData的使用"></a>LiveData的使用</h2><h3 id="LiveData-基本使用"><a href="#LiveData-基本使用" class="headerlink" title="LiveData 基本使用"></a>LiveData 基本使用</h3><p>类型为 LiveData 的对象没有公开的方法给更新其 value，要想更新 LiveData 对象的 value，需要使用 类型为 MutableLiveData 的LiveData 对象，其提供了 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/MutableLiveData#setValue(T)"><code>setValue(T)</code></a> 和 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/MutableLiveData#postValue(T)"><code>postValue(T)</code></a> 方法，其中如果想在多线程中更新数据只能使用 <code>postValue(T)</code> 方法。</p><p>使用步骤主要分三步：</p><ol><li>创建 LiveData 对象实例（常在 ViewModel 中）；</li><li>创建 Observer 对象（常在 Activity 或者 Fragment 中）；</li><li>使用 observer() 方法将 Observer 对象附加到 LiveData 对象（通常在 Activity 或者 Fragment 中）。</li></ol><p>示例：</p><ol><li><p>创建 LiveData 对象实例（常在 ViewModel 中），由于将可变的 LiveData 暴露给外部是不安全的，因此常见的作法是将其转换为不可变的 LiveData 类型对外部进行提供；</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewModelWithLiveData</span> : <span class="hljs-type">ViewModel</span>() &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _likedNumber = MutableLiveData&lt;<span class="hljs-built_in">Int</span>&gt;()    <span class="hljs-keyword">val</span> likedNumber: LiveData&lt;<span class="hljs-built_in">Int</span>&gt;        <span class="hljs-keyword">get</span>() = _likedNumber    <span class="hljs-keyword">init</span> &#123;        _likedNumber.value = <span class="hljs-number">0</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addLikedNumber</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>)</span></span> &#123;        _likedNumber.value = _likedNumber.value?.plus(n)    &#125;&#125;</code></pre></div><p>将用来用来界面展示的可更新的数据 LiveData 对象创建在 ViewModel 中，而不是创建在对应的 Activity 或 <a href="https://so.csdn.net/so/search?q=Fragment&spm=1001.2101.3001.7020">Fragment</a> 中是为了避免是的对应的 Activity 或 Fragment 太过庞大不易后续维护，同时将其实例和 Activity 或 Fragment 分开可以使得 LiveData 对象在配置更改后继续存在。</p></li><li><p>通常在 Activity  或者 Fragment 中的<code>onCreate()</code>方法中进行 Observer 对象的创建并将其附加到 LiveData 对象，这样做是为了系统不会从 Activity 或 Fragment 的 <code>onResume()</code> 方法进行冗余调用（从生命周期图中可以看出 onCreate() 的执行的次数一般是少于 onResume() 的）。</p><p>同时其作用为当 Activity 或 Fragment 在变为活跃状态后就具有可以立即显示的数据，当应用组件处于 STARTED 状态，就会从正在观察的 LiveData 对象接收最新的数据。观察示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModelWithLiveData <span class="hljs-keyword">by</span> lazy &#123;        ViewModelProvider(<span class="hljs-keyword">this</span>).<span class="hljs-keyword">get</span>(ViewModelWithLiveData::<span class="hljs-keyword">class</span>.java)    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> textView: TextView    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> imageButtonLike: ImageButton    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> imageButtonDislike: ImageButton    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        textView = findViewById(R.id.textView)        imageButtonLike = findViewById(R.id.imageButton)        imageButtonDislike = findViewById(R.id.imageButton2)        viewModelWithLiveData.likedNumber.observe(<span class="hljs-keyword">this</span>) &#123;            textView.text = it.toString()        &#125;        imageButtonLike.setOnClickListener &#123;            viewModelWithLiveData.addLikedNumber(<span class="hljs-number">1</span>)        &#125;        imageButtonDislike.setOnClickListener &#123;            viewModelWithLiveData.addLikedNumber(-<span class="hljs-number">1</span>)        &#125;    &#125;&#125;</code></pre></div></li></ol><h3 id="转换-LiveData"><a href="#转换-LiveData" class="headerlink" title="转换 LiveData"></a>转换 LiveData</h3><p>对于转换 LiveData 来说，可以使用 Transformations 提供的 map() 与 switchMap() 方法。</p><ul><li><p>map() 方法主要应用在给你提供的信息内容较多，但是我们只需要其内容的一部分这种情况。例如有一个 User 类，其属性有姓名，年龄，性别等，但是我们只需要姓名，就可以使用 map()。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> userLiveData: LiveData&lt;User&gt; = UserLiveData()<span class="hljs-keyword">val</span> userName: LiveData&lt;String&gt; = Transformations.map(userLiveData) &#123;    user -&gt; <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;user.name&#125;</span>&quot;</span>&#125;</code></pre></div></li><li><p>switchMap() 方法则更多的适用于 ViewModel 中的某个 LiveData 对象是调用其他的方法获取到的，此时可以使用 switchMap() 方法将其转换为一个可观察的 LiveData 对象。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUser</span><span class="hljs-params">(id: <span class="hljs-type">String</span>)</span></span>: LiveData&lt;User&gt; &#123;  ...&#125;<span class="hljs-keyword">val</span> userId: LiveData&lt;String&gt; = ...<span class="hljs-keyword">val</span> user = Transformations.switchMap(userId) &#123; id -&gt; getUser(id) &#125;</code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jetpack</tag>
      
      <tag>Architecture</tag>
      
      <tag>LiveData</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ViewModel</title>
    <link href="/Android/AndroidViewModel/"/>
    <url>/Android/AndroidViewModel/</url>
    
    <content type="html"><![CDATA[<h1 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h1><p>[TOC]</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://developer.android.google.cn/reference/kotlin/androidx/lifecycle/ViewModel">ViewModel  | Android Developers (google.cn)</a></p><p>ViewModel is a class that is responsible for preparing and managing the data for an <code>Activity</code> or a <code>Fragment</code>. It also handles the communication of the Activity &#x2F; Fragment with the rest of the application (e.g. calling the business logic classes).</p><p><img src="/./img/mvc.png" alt="image-20221102170743112"></p><p>ViewModel将数据从UI层抽象出来</p><p><img src="/./img/image-20221102190253813.png" alt="image-20221102190253813"></p><p>由ViewModel管理的数据独立于Activity的生命周期之外。</p><p>ViewModel与LiveData配合实现对数据的监听。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol><li><p>创建MyViewModel类，并声明需要存放的数据，由于将可变的 LiveData 暴露给外部是不安全的，因此常见的作法是将其转换为不可变的 LiveData 类型对外部进行提供；</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> : <span class="hljs-type">ViewModel</span>() &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _number = MutableLiveData&lt;<span class="hljs-built_in">Int</span>&gt;()    <span class="hljs-keyword">val</span> number: LiveData&lt;<span class="hljs-built_in">Int</span>&gt;        <span class="hljs-keyword">get</span>() = _number    <span class="hljs-keyword">init</span> &#123;        _number.value = <span class="hljs-number">0</span>    &#125;&#125;</code></pre></div></li><li><p>在Activity实例化MyViewModel有两种方法</p><ul><li><p>在Activity中声明MyViewModel类，延迟加载</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> myViewModel: MyViewModel</code></pre></div><p>在onCreate方法中实例化</p><div class="code-wrapper"><pre><code class="hljs kotlin">myViewModel = ViewModelProvider(<span class="hljs-keyword">this</span>)[MyViewModel::<span class="hljs-keyword">class</span>.java]</code></pre></div></li><li><p>懒加载，随用随加载</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> myViewModel <span class="hljs-keyword">by</span> lazy &#123; ViewModelProvider(<span class="hljs-keyword">this</span>)[MyViewModel::<span class="hljs-keyword">class</span>.java] &#125;</code></pre></div></li></ul></li><li><p>若在Fragment中使用</p><div class="code-wrapper"><pre><code class="hljs kotlin">myViewModel = ViewModelProvider(requireActivity())[MyViewModel::<span class="hljs-keyword">class</span>.java]</code></pre></div></li><li><p>使用MyViewModel中的成员变量</p><div class="code-wrapper"><pre><code class="hljs kotlin">textView.text = myViewModel.number.toString()</code></pre></div></li></ol><h2 id="ViewModelSavedState"><a href="#ViewModelSavedState" class="headerlink" title="ViewModelSavedState"></a>ViewModelSavedState</h2><p><img src="/./img/image-20221109170013398.png" alt="image-20221109170013398"></p><p>虽然<code>viewModel</code>要比<code>onSaveInstanceState</code>简单，但是<code>viewModel</code>只能在屏幕旋转和语言切换后（即配置变更时）的页面重建维持数据，当页面意外销毁时数据无法恢复（viewModel也会重建），而这点<code>onSaveInstanceState</code>可以做到。关于意外销毁，我们暂且理解成非配置变更引起的销毁重建，比如内存不足等场景。</p><p><a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel-savedstate?hl=zh-cn#kotlin">ViewModel 的已保存状态模块  | Android 开发者  | Android Developers (google.cn)</a></p><h3 id="使用SavedInstanceState保存数据"><a href="#使用SavedInstanceState保存数据" class="headerlink" title="使用SavedInstanceState保存数据"></a>使用SavedInstanceState保存数据</h3><ol><li><p>在Activity重写<code>onSaveInstanceState()</code>方法，以键值对的形式保存数据</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> key: String = <span class="hljs-string">&quot;title&quot;</span><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(outState: <span class="hljs-type">Bundle</span>)</span></span> &#123;    <span class="hljs-keyword">super</span>.onSaveInstanceState(outState)    outState.putString(key, textView.text.toString())&#125;</code></pre></div></li><li><p>在<code>onCreate()</code>方法中获取数据</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)    setContentView(R.layout.activity_main)    textView = findViewById(R.id.textView)    button1 = findViewById(R.id.button)    textView.text = savedInstanceState?.getString(key) ?: textView.text    ...&#125;</code></pre></div></li></ol><h3 id="使用ViewModelSavedState保存数据"><a href="#使用ViewModelSavedState保存数据" class="headerlink" title="使用ViewModelSavedState保存数据"></a>使用ViewModelSavedState保存数据</h3><p>解决当进程被系统回收后，如何保存数据。</p><ol><li><p>在module的<code>build.gradle</code>引入依赖</p><div class="code-wrapper"><pre><code class="hljs groovy">dependencies &#123;    ...    implementation <span class="hljs-string">&#x27;androidx.lifecycle:lifecycle-extensions:2.2.0&#x27;</span>    ...&#125;</code></pre></div></li><li><p>创建ViewModel</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.yorick.viewmodelsavedstate<span class="hljs-keyword">import</span> androidx.lifecycle.MutableLiveData<span class="hljs-keyword">import</span> androidx.lifecycle.SavedStateHandle<span class="hljs-keyword">import</span> androidx.lifecycle.ViewModel<span class="hljs-keyword">class</span> <span class="hljs-title class_">SavedStateViewModel</span>(    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> handle: SavedStateHandle) : ViewModel() &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> number = MutableLiveData&lt;<span class="hljs-built_in">Int</span>&gt;()    <span class="hljs-keyword">init</span> &#123;        number.value = <span class="hljs-number">0</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;        getNumber().value = getNumber().value?.plus(<span class="hljs-number">1</span>)    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getNumber</span><span class="hljs-params">()</span></span>: MutableLiveData&lt;<span class="hljs-built_in">Int</span>&gt; &#123;        <span class="hljs-keyword">if</span> (!handle.contains(MainActivity.KEY_NUMBER)) &#123;            handle.<span class="hljs-keyword">set</span>(MainActivity.KEY_NUMBER, <span class="hljs-number">0</span>)        &#125;        <span class="hljs-keyword">return</span> handle.getLiveData(MainActivity.KEY_NUMBER)    &#125;&#125;</code></pre></div></li><li><p>创建布局，包括一个<code>TextView</code>和一个<code>Button</code></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">variable</span></span><span class="hljs-tag">            <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.yorick.viewmodelsavedstate.SavedStateViewModel&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/textView&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123;data.number.toString()&#125;&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;34sp&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintVertical_bias</span>=<span class="hljs-string">&quot;0.352&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:onClick</span>=<span class="hljs-string">&quot;@&#123;()-&gt;data.add()&#125;&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Button&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintVertical_bias</span>=<span class="hljs-string">&quot;0.653&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span></code></pre></div></li><li><p>创建Activity</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.yorick.viewmodelsavedstate<span class="hljs-keyword">import</span> androidx.appcompat.app.AppCompatActivity<span class="hljs-keyword">import</span> android.os.Bundle<span class="hljs-keyword">import</span> androidx.databinding.DataBindingUtil<span class="hljs-keyword">import</span> androidx.lifecycle.SavedStateViewModelFactory<span class="hljs-keyword">import</span> androidx.lifecycle.ViewModelProvider<span class="hljs-keyword">import</span> com.yorick.viewmodelsavedstate.databinding.ActivityMainBinding<span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> savedStateViewModel <span class="hljs-keyword">by</span> lazy &#123;        ViewModelProvider(            <span class="hljs-keyword">this</span>,            SavedStateViewModelFactory(application, <span class="hljs-keyword">this</span>)        )[SavedStateViewModel::<span class="hljs-keyword">class</span>.java]    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> binding: ActivityMainBinding <span class="hljs-keyword">by</span> lazy &#123;        DataBindingUtil.setContentView(<span class="hljs-keyword">this</span>, R.layout.activity_main)    &#125;    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> KEY_NUMBER = <span class="hljs-string">&quot;KEY_NUMBER&quot;</span>    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        binding.<span class="hljs-keyword">data</span> = savedStateViewModel        binding.lifecycleOwner = <span class="hljs-keyword">this</span>    &#125;&#125;</code></pre></div></li></ol><h3 id="使用ViewModel-SharedPreference存储数据"><a href="#使用ViewModel-SharedPreference存储数据" class="headerlink" title="使用ViewModel&amp;SharedPreference存储数据"></a>使用ViewModel&amp;SharedPreference存储数据</h3><p><a href="../../14_SharedPreferences.md">使用ViewModel和SharedPreference以键值对的形式存储数据</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jetpack</tag>
      
      <tag>Architecture</tag>
      
      <tag>ViewModel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin互操作性与可空性</title>
    <link href="/Kotlin/Kotlin%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7%E4%B8%8E%E5%8F%AF%E7%A9%BA%E6%80%A7/"/>
    <url>/Kotlin/Kotlin%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7%E4%B8%8E%E5%8F%AF%E7%A9%BA%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="互操作性与可空性"><a href="#互操作性与可空性" class="headerlink" title="互操作性与可空性"></a>互操作性与可空性</h2><ul><li><a href="#%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7%E4%B8%8E%E5%8F%AF%E7%A9%BA%E6%80%A7">互操作性与可空性</a><ul><li><a href="#%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7%E4%B8%8E%E5%8F%AF%E7%A9%BA%E6%80%A7-1">互操作性与可空性</a></li><li><a href="#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a></li><li><a href="#%E5%B1%9E%E6%80%A7%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%BA%92%E6%93%8D%E4%BD%9C">属性、异常与互操作</a><ul><li><a href="#%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE">属性访问</a></li><li><a href="#java%E8%B0%83%E7%94%A8kotlin">Java调用Kotlin</a><ul><li><a href="#filejvmnamename">@file:JvmName(“name”)</a></li><li><a href="#jvmfield">@JvmField</a></li><li><a href="#jvmoverloads">@JvmOverloads</a></li><li><a href="#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%92%8Cjvmstatic">伴生对象和@JvmStatic</a></li></ul></li><li><a href="#throws">@Throws</a></li></ul></li><li><a href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C">函数类型操作</a></li></ul></li></ul><h3 id="互操作性与可空性-1"><a href="#互操作性与可空性-1" class="headerlink" title="互操作性与可空性"></a>互操作性与可空性</h3><p>Java世界里所有对象都可能是null，当一个Kotlin函数返回String类型值，你不能想当然地认为它的返回值就能符合Kotlin关于空值的规定。</p><p>新建Jhava类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.jetbrains.annotations.NotNull;<span class="hljs-keyword">import</span> org.jetbrains.annotations.Nullable;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Jhava</span> &#123;    <span class="hljs-meta">@NotNull</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">utterGreeting</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HELLO&quot;</span>;    &#125;    <span class="hljs-meta">@Nullable</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">determineFriendshipLevel</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre></div><h3 id="类型映射"><a href="#类型映射" class="headerlink" title="类型映射"></a>类型映射</h3><p>代码运行时，所有的映射类型都会重新映射回对应的Java类型。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">val</span> hitPoint = adversary.hitPointsprintln(hitPoint.dec()) <span class="hljs-comment">// 999</span>println(hitPoint.javaClass) <span class="hljs-comment">// int</span></code></pre></div><h3 id="属性、异常与互操作"><a href="#属性、异常与互操作" class="headerlink" title="属性、异常与互操作"></a>属性、异常与互操作</h3><h4 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHitPoints</span><span class="hljs-params">()</span> &#123;    System.out.println(<span class="hljs-string">&quot;-------getHitPoints-------&quot;</span>);    <span class="hljs-keyword">return</span> hitPoints;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHitPoints</span><span class="hljs-params">(<span class="hljs-type">int</span> hitPoints)</span> &#123;    System.out.println(<span class="hljs-string">&quot;-------setHitPoints-------&quot;</span>);    <span class="hljs-built_in">this</span>.hitPoints = hitPoints;&#125;</code></pre></div><p>不需要调用相关getter，setter方法，你可以使用<code>对象名.字段名</code>来获取或者设置一个Java类的字段值。实际上还是暗中调用了getter，setter方法。</p><div class="code-wrapper"><pre><code class="hljs kt">adversary.hitPoints = <span class="hljs-number">888</span>println(adversary.hitPoints)<span class="hljs-comment">// -------setHitPoints-------</span><span class="hljs-comment">// -------getHitPoints-------</span><span class="hljs-comment">// 888</span></code></pre></div><h4 id="Java调用Kotlin"><a href="#Java调用Kotlin" class="headerlink" title="Java调用Kotlin"></a>Java调用Kotlin</h4><h5 id="file-JvmName-“name”"><a href="#file-JvmName-“name”" class="headerlink" title="@file:JvmName(“name”)"></a>@file:JvmName(“name”)</h5><p>Kotlin在类Hreo中定义方法</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeProclamation</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Greetings,beast!&quot;</span></code></pre></div><p>Java在主方法中调用</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    System.out.println(HeroKt.makeProclamation());&#125;</code></pre></div><p>修改编译后Kotlin文件的名字，在文件首行加上</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-meta">@file:JvmName</span>(<span class="hljs-string">&quot;Hero&quot;</span>)</code></pre></div><p>Java在调用就可以使用新名字</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    System.out.println(Hero.makeProclamation());&#125;</code></pre></div><h5 id="JvmField"><a href="#JvmField" class="headerlink" title="@JvmField"></a>@JvmField</h5><p>正常使用Java获取或者修改Kotlin类的属性时，Kotlin会提供自动生成的getter，setter方法。</p><p>Kotlin类</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpellsBook</span> &#123;    <span class="hljs-keyword">val</span> spells = listOf(<span class="hljs-string">&quot;Magic Wu Wu&quot;</span>, <span class="hljs-string">&quot;Lay on Hans&quot;</span>)&#125;</code></pre></div><p>Java在主方法中使用</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-type">SpellsBook</span> <span class="hljs-variable">spellsBook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpellsBook</span>();spellsBook.getSpells();</code></pre></div><p>为Kotlin类的属性添加<code>@JvmField</code>注解，你就可以使用<code>对象名.字段名</code>来获取或者设置一个Java字段值</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpellsBook</span> &#123;    <span class="hljs-meta">@JvmField</span>    <span class="hljs-keyword">val</span> spells = listOf(<span class="hljs-string">&quot;Magic Wu Wu&quot;</span>, <span class="hljs-string">&quot;Lay on Hans&quot;</span>)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">SpellsBook</span> <span class="hljs-variable">spellsBook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpellsBook</span>();List&lt;String&gt; list =  spellsBook.spells;<span class="hljs-keyword">for</span> (String s : list) &#123;    System.out.println(s);&#125;<span class="hljs-comment">// Magic Wu Wu</span><span class="hljs-comment">// Lay on Hans</span></code></pre></div><h5 id="JvmOverloads"><a href="#JvmOverloads" class="headerlink" title="@JvmOverloads"></a>@JvmOverloads</h5><p><code>@JvmOverloads</code>注解协助产生Kotlin函数的重载版本。设计一个可能会暴露给Java用户使用的API时，记得使用<code>@JvmOverloads</code>注解，这样，无论你是Kotlin开发者还是Java开发者，都会对这个API的可靠性感到满意。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handoverFood</span><span class="hljs-params">(leftHand: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;berries&quot;</span>, rightHand: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;beef&quot;</span>)</span></span> &#123;    println(<span class="hljs-string">&quot;Emmmm... you hand over some delicious <span class="hljs-variable">$leftHand</span> and <span class="hljs-variable">$rightHand</span>&quot;</span>)&#125;</code></pre></div><p>在kt中调用没有参数个数问题，但是在Java中如果只填入一个参数，另一个想使用默认值，就会报错，为了解决这个问题，使用<code>@JvmOverloads</code>注解。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-meta">@JvmOverloads</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handoverFood</span><span class="hljs-params">(leftHand: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;berries&quot;</span>, rightHand: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;beef&quot;</span>)</span></span> &#123;    println(<span class="hljs-string">&quot;Emmmm... you hand over some delicious <span class="hljs-variable">$leftHand</span> and <span class="hljs-variable">$rightHand</span>&quot;</span>)&#125;</code></pre></div><p>在Java中调用不报错了</p><div class="code-wrapper"><pre><code class="hljs java">Hero.handoverFood(<span class="hljs-string">&quot;apple&quot;</span>);</code></pre></div><h5 id="伴生对象和-JvmStatic"><a href="#伴生对象和-JvmStatic" class="headerlink" title="伴生对象和@JvmStatic"></a>伴生对象和@JvmStatic</h5><p><code>@JvmField</code>注解还能用来以静态方式提供伴生对象里定义的值。<br><code>@JvmStatic</code>注解的作用类似于<code>@JvmField</code>，允许你直接调用伴生对象里的函数。</p><p>Kotlin类定义伴生对象</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpellsBook</span> &#123;    <span class="hljs-meta">@JvmField</span>    <span class="hljs-keyword">val</span> spells = listOf(<span class="hljs-string">&quot;Magic Wu Wu&quot;</span>, <span class="hljs-string">&quot;Lay on Hans&quot;</span>)    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;        <span class="hljs-meta">@JvmField</span>        <span class="hljs-keyword">val</span> MAX_SPELLS_COUNT = <span class="hljs-number">10</span>        <span class="hljs-meta">@JvmStatic</span>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getSpellsBookGreeting</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;I am the greatest Magician&quot;</span>)    &#125;&#125;</code></pre></div><p>在Java中调用</p><div class="code-wrapper"><pre><code class="hljs java">System.out.println(SpellsBook.MAX_SPELLS_COUNT); <span class="hljs-comment">// 10</span>SpellsBook.getSpellsBookGreeting(); <span class="hljs-comment">// I am the greatest Magician</span></code></pre></div><h4 id="Throws"><a href="#Throws" class="headerlink" title="@Throws"></a>@Throws</h4><p>抛出一个需要检查的指定异常，Java和Kotlin有关异常检查的差异让<code>@Throws</code>注解给解决掉了，在编写供Java开发者调用的Kotlin API时，要考虑使用<code>@Throws</code>注解，这样，用户就知道怎么正确处理任何异常了。</p><p>在Java抛出的异常Kotlin不会强制提示在编译时处理，反之亦然。</p><h2 id="（1）在Java类中抛出异常Kotlin中调用会抛出异常的类并没有报错，但是如果运行还是会报错"><a href="#（1）在Java类中抛出异常Kotlin中调用会抛出异常的类并没有报错，但是如果运行还是会报错" class="headerlink" title="（1）在Java类中抛出异常Kotlin中调用会抛出异常的类并没有报错，但是如果运行还是会报错"></a>（1）在Java类中抛出异常<br><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extendHandInFriendship</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>();&#125;</code></pre></div><br>Kotlin中调用会抛出异常的类并没有报错，但是如果运行还是会报错<br><div class="code-wrapper"><pre><code class="hljs kt">adversary.extendHandInFriendship() <span class="hljs-comment">// 没有报错</span></code></pre></div></h2><p>（2）在Kotlin中抛出异常</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">acceptApology</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">throw</span> IOException()&#125;</code></pre></div><p>Java中并没有强制编译时处理</p><div class="code-wrapper"><pre><code class="hljs java">Hero.acceptApology();</code></pre></div><p>尝试用try catch处理，却报错</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">try</span> &#123;    Hero.acceptApology();&#125;<span class="hljs-keyword">catch</span> (IOException e)&#123; <span class="hljs-comment">// 报错</span>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Caught!&quot;</span>);&#125;</code></pre></div><p>反编译成Java发现，原来Kotlin在编译时把IOException强制转换成了Throwable类型</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acceptApology</span><span class="hljs-params">()</span> &#123;      <span class="hljs-keyword">throw</span> (Throwable)(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>());   &#125;</code></pre></div><p>在try catch将IOException改为Throwable发现报错消失</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">try</span> &#123;    Hero.acceptApology();&#125;<span class="hljs-keyword">catch</span> (Throwable e)&#123; <span class="hljs-comment">// 报错消失</span>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Caught!&quot;</span>);&#125;</code></pre></div><hr><p>但是如果我们要正常处理IOException，而且强制编译时处理，就要给kt里抛出错误的方法加上<code>@Throws</code>注释。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-meta">@Throws(IOException::class)</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">acceptApology</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">throw</span> IOException()&#125;</code></pre></div><p>此时java里try-catch不报错</p><h3 id="函数类型操作"><a href="#函数类型操作" class="headerlink" title="函数类型操作"></a>函数类型操作</h3><p>函数类型和匿名函数能提供高效的语法用于组件间的交互，是Kotlin编程语言里比较新颖的特性。他们简洁的语法因-&gt;操作符而实现，但Java8之前的JDK版本并并不支持lambda表达式。在Java里，Kotlin函数类型使用FunctionN这样的名字的接口来表示的，FunctionN中的N代表值参数目。这样的Function接口由23个，从Function0到Function22，每一个FunctionN都包含一个invoke函数，专用于调用函数类型函数，所以，在何时候需要调一个函数类型，都用它调用invoke。</p><p>在kt类中添加一个translator的函数类型</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-comment">// 添加一个translator的函数类型，接收一个字符串</span><span class="hljs-comment">// 将其改为小写字母，再大写第一个字符，最后打印结果。</span><span class="hljs-keyword">val</span> translator = &#123; utterance: String -&gt;    println(utterance.lowercase().capitalize())&#125;</code></pre></div><p>在Java主方法中调用</p><div class="code-wrapper"><pre><code class="hljs java">Function1&lt;String, Unit&gt; translator = Hero.getTranslator();translator.invoke(<span class="hljs-string">&quot;HELLO&quot;</span>); <span class="hljs-comment">// Hello</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin函数式编程</title>
    <link href="/Kotlin/Kotlin%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/Kotlin/Kotlin%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul><li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">什么是函数式编程</a></li><li><a href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%88%AB">函数类别</a></li><li><a href="#%E5%8F%98%E6%8D%A2transform">变换transform</a><ul><li><a href="#map">map</a></li><li><a href="#flatmap">flatMap</a></li></ul></li><li><a href="#%E8%BF%87%E6%BB%A4filter">过滤filter</a><ul><li><a href="#filter">filter</a></li><li><a href="#%E6%89%BE%E7%B4%A0%E6%95%B0">找素数</a></li></ul></li><li><a href="#%E5%90%88%E5%B9%B6combine">合并combine</a><ul><li><a href="#zip">zip</a></li><li><a href="#fold">fold</a></li></ul></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">为什么要使用函数式编程</a></li><li><a href="#%E5%BA%8F%E5%88%97">序列</a><ul><li><a href="#generatesequence">generateSequence</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%BA%8F%E5%88%97%E6%9F%A5%E6%89%BE%E7%B4%A0%E6%95%B0">使用序列查找素数</a></li></ul></li></ul></li></ul><h3 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h3><p>我们一直在学习面向对象编程范式，另一个较知名的编程范式是诞生于20世纪50年，基于抽象数学的入演算发展而来的函数式编程，尽管函数式编程语言更常用在学术而非商业软件领域，但它的一些原则适用于任何编程语言。函数式编程范式主要依赖于高阶函数（以函数为参数或返回函数）返回的数据，这些高阶函数专用于处理各种集合，可方便地联合多个同类函数构建链式操作以创建复杂的计算行为。Kotlin支持多种编程范式，所以你可以混用面向对象编程和函数式编程范式来解决手头的问题。</p><h3 id="函数类别"><a href="#函数类别" class="headerlink" title="函数类别"></a>函数类别</h3><p>一个函数式应用通常由三大类函数构成:变换transform、过滤filter、合并combine。每类函数都针对集合数据类型设计，目标是产生一个最终结果。函数式编程用到的函数生来都是可组合的，也就是说，你可以组合多个简单函数来构建复杂的计算行为。</p><h3 id="变换transform"><a href="#变换transform" class="headerlink" title="变换transform"></a>变换transform</h3><p>变换是函数式编程的第一大类函数，变换函数会遍历集合内容，用一个以值参形式传入的变换器函数，变换每一个元素，然后返回包含已修改元素的集合给链上的其他函数。</p><p>最常用的两个变换函数是map和flatMap。</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map返回的集合中的元素个数和输入集合必须一样，不过，返回的新集合里的元素可以是不同类型的。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> animals = listOf(<span class="hljs-string">&quot;zebra&quot;</span>, <span class="hljs-string">&quot;giraffe&quot;</span>, <span class="hljs-string">&quot;elephant&quot;</span>, <span class="hljs-string">&quot;rat&quot;</span>)    <span class="hljs-keyword">val</span> babies = animals        .map &#123; animals -&gt; <span class="hljs-string">&quot;A little <span class="hljs-variable">$animals</span>&quot;</span> &#125;        .map &#123; baby -&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$baby</span>,with the cutest little tail ever!&quot;</span> &#125;    println(animals) <span class="hljs-comment">// [zebra, giraffe, elephant, rat]</span>    println(babies) <span class="hljs-comment">// [A little zebra,with the cutest little tail ever!, A little giraffe,with the cutest little tail ever!, A little elephant,with the cutest little tail ever!, A little rat,with the cutest little tail ever!]</span>        <span class="hljs-keyword">val</span> animalsLength = animals.map &#123; it.length &#125;    println(animalsLength) <span class="hljs-comment">// [5, 7, 8, 3]</span>&#125;</code></pre></div><p>可以看到，原始集合没有被修改，map变换函数和你定义的变换器函数做完事情后，返回的是一个新集合，这样，变量就不用变来变去了。</p><p><strong>事实上，函数式编程范式支持的设计理念就是不可变数据的副本在链上的函数间传递。</strong></p><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><p>flatMap函数操作一个集合的集合，将其中多个集合中的元素合并后返回一个包含所有元素的单一集合。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> res = listOf(        listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>),        listOf(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)    ).flatMap &#123; it &#125;    println(res)&#125;</code></pre></div><h3 id="过滤filter"><a href="#过滤filter" class="headerlink" title="过滤filter"></a>过滤filter</h3><p>过滤是函数式编程的第二大类函数，过滤函数接受一个predicate函数，用它按给定条件检查接收者集合里的元素并给出true或false的判定。如果predicate函数返回true，受检元素就会添加到过滤函数返回的新集合里。如果predicate函数返回false，那么受检元素就被移出新集合。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> res = listOf(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Jimmy&quot;</span>, <span class="hljs-string">&quot;Rose&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>)        .filter &#123; it.contains(<span class="hljs-string">&quot;J&quot;</span>) &#125;    println(res) <span class="hljs-comment">// [Jack, Jimmy]</span>&#125;</code></pre></div><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter过滤函数接受一个predicate函数，在flatMap遍历它的输入集合中的所有元素时，filter函数会让predicate函数按过滤条件，将符合条件的元素都放入它返回的新集合里。最后，flatMap会把变换器函数返回的子集合合并在一个新集合里。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> items = listOf(        listOf(<span class="hljs-string">&quot;red apple&quot;</span>, <span class="hljs-string">&quot;green apple&quot;</span>, <span class="hljs-string">&quot;blue apple&quot;</span>),        listOf(<span class="hljs-string">&quot;red fish&quot;</span>, <span class="hljs-string">&quot;blue fish&quot;</span>),        listOf(<span class="hljs-string">&quot;yellow banana&quot;</span>, <span class="hljs-string">&quot;teal banana&quot;</span>)    )    <span class="hljs-keyword">val</span> redItems = items.flatMap &#123; it.filter &#123; it.contains(<span class="hljs-string">&quot;red&quot;</span>) &#125; &#125;    println(redItems) <span class="hljs-comment">// [red apple, red fish]</span>&#125;</code></pre></div><h4 id="找素数"><a href="#找素数" class="headerlink" title="找素数"></a>找素数</h4><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> numbers = listOf(<span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">22</span>, <span class="hljs-number">18</span>, <span class="hljs-number">11</span>)    <span class="hljs-comment">// 找素数</span>    <span class="hljs-keyword">val</span> primes = numbers.filter &#123; number -&gt;        (<span class="hljs-number">2</span> until number).map &#123; number % it &#125;            .none &#123; it == <span class="hljs-number">0</span> &#125;    &#125;    println(primes) <span class="hljs-comment">// [7, 3, 11]</span>&#125;</code></pre></div><h3 id="合并combine"><a href="#合并combine" class="headerlink" title="合并combine"></a>合并combine</h3><p>合并是函数式编程的第三大类函数，合并函数能将不同的集合合并成一个新集合，这和接收者是包含集合的集合的flatMap函数不同。</p><h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><p>zip合并函数来合并两个集合,返回一个包含键值对的新集合。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> names = listOf(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Jimmy&quot;</span>, <span class="hljs-string">&quot;Rose&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>)    <span class="hljs-keyword">val</span> ages = listOf(<span class="hljs-number">15</span>, <span class="hljs-number">21</span>, <span class="hljs-number">18</span>, <span class="hljs-number">22</span>)    <span class="hljs-keyword">val</span> students = names.zip(ages)    println(students) <span class="hljs-comment">// [(Jack, 15), (Jimmy, 21), (Rose, 18), (Tom, 22)]</span>&#125;</code></pre></div><h4 id="fold"><a href="#fold" class="headerlink" title="fold"></a>fold</h4><p>另一个可以用来合并值的合并类函数是fold，这个合并函数接受一个初始累加器值，随后会根据匿名函数的结果更新。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> foldedValue = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).fold(<span class="hljs-number">0</span>) &#123; acc, number -&gt;        println(<span class="hljs-string">&quot;accVal: <span class="hljs-variable">$acc</span>&quot;</span>)        acc + number * <span class="hljs-number">3</span>    &#125;    println(<span class="hljs-string">&quot;Final value:<span class="hljs-variable">$foldedValue</span>&quot;</span>)&#125;<span class="hljs-comment">// accVal: 0</span><span class="hljs-comment">// accVal: 3</span><span class="hljs-comment">// accVal: 9</span><span class="hljs-comment">// accVal: 18</span><span class="hljs-comment">// Final value:30</span></code></pre></div><h3 id="为什么要使用函数式编程"><a href="#为什么要使用函数式编程" class="headerlink" title="为什么要使用函数式编程"></a>为什么要使用函数式编程</h3><p>乍看之下，实现同样的任务，Java版本和函数式版本的代码量差不多，但仔细分析一下，就能看出函数式版本的诸多优势。</p><ul><li>累加变量(employeeShirtSizes)都是隐式定义的。</li><li>函数运算结果会自动赋值给累加变量，降低了代码出错的机会。</li><li>执行新任务的函数很容易添加到函数调用链上，因为他们都兼容lterable类型。</li></ul><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><p>List、Set、Map集合类型，这几个集合类型统称为及早集合(eager collection)这些集合的任何一个实例在创建后，它要包含的元素都会被加入并允许你访问。对应及早集合，Kotlin还有另外一类集合：惰性集合（lazy collection）类似于类的惰性初始化，惰性集合类型的性能表现优异，尤其是用于包含大量元素的集合时，因为集合元素是按需产生的。</p><p>Kotlin有个内置惰性集合类型叫序列(Sequence)，序列不会索引排序它的内容，也不记录元素数目，事实上，在使用一个序列时，序列里的值可能有无限多，因为某个数据源能产生无限多个元素。</p><h4 id="generateSequence"><a href="#generateSequence" class="headerlink" title="generateSequence"></a>generateSequence</h4><p>针对某个序列，你可能会定义一个只要序列有新值产生就被调用一下的函数，这样的函数叫迭代器函数，要定义一个序列和它的迭代器，你可以使用Kotlin的序列构造函数generateSequence，generateSequence函数接受一个初始种子值作为序列的起步值，在用generateSequence定义的序列上调用一个函数时，generateSequence函数会调用你指定的迭代器函数，决定下一个要产生的值。</p><h4 id="使用序列查找素数"><a href="#使用序列查找素数" class="headerlink" title="使用序列查找素数"></a>使用序列查找素数</h4><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">isPrime</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;    (<span class="hljs-number">2</span> until <span class="hljs-keyword">this</span>).map &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> % it == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 假定0-5000内，可以找到1000个素数，普通集合写法</span>    <span class="hljs-keyword">val</span> toList = (<span class="hljs-number">1.</span><span class="hljs-number">.5000</span>).toList().filter &#123; it.isPrime() &#125;.take(<span class="hljs-number">1000</span>)    println(toList.size) <span class="hljs-comment">// 670</span>    <span class="hljs-comment">// 使用序列</span>    <span class="hljs-keyword">val</span> oneThousandPrimes = generateSequence(<span class="hljs-number">2</span>) &#123; value -&gt;        value + <span class="hljs-number">1</span>    &#125;.filter &#123; it.isPrime() &#125;.take(<span class="hljs-number">1000</span>)    println(oneThousandPrimes.toList().size) <span class="hljs-comment">// 1000</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin拓展函数和拓展属性</title>
    <link href="/Kotlin/Kotlin%E6%8B%93%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E6%8B%93%E5%B1%95%E5%B1%9E%E6%80%A7/"/>
    <url>/Kotlin/Kotlin%E6%8B%93%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E6%8B%93%E5%B1%95%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="拓展函数"><a href="#拓展函数" class="headerlink" title="拓展函数"></a>拓展函数</h2><ul><li><a href="#%E6%8B%93%E5%B1%95%E5%87%BD%E6%95%B0">拓展函数</a><ul><li><a href="#%E5%AE%9A%E4%B9%89%E6%8B%93%E5%B1%95%E5%87%BD%E6%95%B0">定义拓展函数</a></li><li><a href="#%E5%9C%A8%E8%B6%85%E7%B1%BB%E4%B8%8A%E5%AE%9A%E4%B9%89%E6%8B%93%E5%B1%95%E5%87%BD%E6%95%B0">在超类上定义拓展函数</a></li><li><a href="#%E6%B3%9B%E5%9E%8B%E6%8B%93%E5%B1%95%E5%87%BD%E6%95%B0">泛型拓展函数</a></li></ul></li><li><a href="#%E6%8B%93%E5%B1%95%E5%B1%9E%E6%80%A7">拓展属性</a><ul><li><a href="#%E5%AE%9A%E4%B9%89%E6%8B%93%E5%B1%95%E5%B1%9E%E6%80%A7">定义拓展属性</a></li></ul></li><li><a href="#%E5%85%B6%E4%BB%96%E6%8B%93%E5%B1%95%E7%89%B9%E6%80%A7">其他拓展特性</a><ul><li><a href="#%E5%8F%AF%E7%A9%BA%E7%B1%BB%E6%8B%93%E5%B1%95">可空类拓展</a></li><li><a href="#infix%E5%85%B3%E9%94%AE%E5%AD%97">infix关键字</a></li><li><a href="#kotlin%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95">Kotlin标准库中的扩展</a></li></ul></li><li><a href="#dsl">DSL</a><ul><li><a href="#apply%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3">apply函数详解</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFdsl">什么是DSL</a></li></ul></li></ul><h3 id="定义拓展函数"><a href="#定义拓展函数" class="headerlink" title="定义拓展函数"></a>定义拓展函数</h3><p>扩展可以在不直接修改类定义的情况下增加类功能，扩展可以用于自定义类，也可以用于比如List、String，以及Kotlin标准库里的其他类。和继承相似，扩展也能共享类行为，在你无法接触某个类定义，或者某个类没有使用open修饰符，导致你无法继承它时，扩展就是增加类功能的最好选择。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">addExt</span><span class="hljs-params">(amount: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>)</span></span> = <span class="hljs-keyword">this</span> + <span class="hljs-string">&quot;!&quot;</span>.repeat(amount)<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    println(<span class="hljs-string">&quot;Hi,Yorick&quot;</span>.addExt(<span class="hljs-number">6</span>))&#125;</code></pre></div><h3 id="在超类上定义拓展函数"><a href="#在超类上定义拓展函数" class="headerlink" title="在超类上定义拓展函数"></a>在超类上定义拓展函数</h3><p>在超类上定义拓展函数，Any的所有子类都能使用该函数了</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Any.<span class="hljs-title">easyPrint</span><span class="hljs-params">()</span></span> = println(<span class="hljs-keyword">this</span>)<span class="hljs-comment">// 作用范围为全局</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-string">&quot;test&quot;</span>.easyPrint() <span class="hljs-comment">// test</span>    <span class="hljs-number">15.</span>easyPrint() <span class="hljs-comment">// 15</span>&#125;</code></pre></div><p>但是如果想要支持链式调用，返回值就必须为String，这样的话其他类型就无法使用easyPrint。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 给字符串添加拓展函数</span><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">addExt</span><span class="hljs-params">(amount: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>)</span></span> = <span class="hljs-keyword">this</span> + <span class="hljs-string">&quot;!&quot;</span>.repeat(amount)<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">easyPrint</span><span class="hljs-params">()</span></span>:String &#123;    println(<span class="hljs-keyword">this</span>)    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//    15.easyPrint() // 此行报错</span>    <span class="hljs-string">&quot;aaa&quot;</span>.easyPrint().addExt(<span class="hljs-number">2</span>).easyPrint()&#125;<span class="hljs-comment">// aaa</span><span class="hljs-comment">// aaa!!</span></code></pre></div><p>要解决上面的问题，就要用到泛型拓展函数</p><h3 id="泛型拓展函数"><a href="#泛型拓展函数" class="headerlink" title="泛型拓展函数"></a>泛型拓展函数</h3><p>新的泛型扩展函数不仅可以支持任何类型的接收者，还保留了接收者的类型信息，使用泛型类型后，扩展函数能够支持更多类型的接收者，适用范围更广了。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-comment">// 给字符串添加拓展函数</span><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">addExt</span><span class="hljs-params">(amount: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>)</span></span> = <span class="hljs-keyword">this</span> + <span class="hljs-string">&quot;!&quot;</span>.repeat(amount)<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">easyPrint</span><span class="hljs-params">()</span></span>: T &#123;    println(<span class="hljs-keyword">this</span>)    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-number">15.</span>easyPrint() <span class="hljs-comment">// 正常使用</span>    <span class="hljs-string">&quot;aaa&quot;</span>.easyPrint().addExt(<span class="hljs-number">2</span>).easyPrint()&#125;<span class="hljs-comment">// 15</span><span class="hljs-comment">// aaa</span><span class="hljs-comment">// aaa!!</span></code></pre></div><p>泛型扩展函数在Kotlin标准库里随处可见，例如let函数，let函数被定义成了泛型扩展函数，所以能支持任何类型，它接收一个lambda表达式，这个lambda表达式接收者T作为值参，返回的R-lambda表达式返回的任何新类型。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">let</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;    <span class="hljs-keyword">return</span> block(<span class="hljs-keyword">this</span>)&#125;</code></pre></div><h2 id="拓展属性"><a href="#拓展属性" class="headerlink" title="拓展属性"></a>拓展属性</h2><h3 id="定义拓展属性"><a href="#定义拓展属性" class="headerlink" title="定义拓展属性"></a>定义拓展属性</h3><p>除了给类添加功能扩展函数外，你还可以给类定义扩展属性，给String类添加一个扩展，这个扩展属性可以统计字符串里有多少个元音字母。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">easyPrint</span><span class="hljs-params">()</span></span>: T &#123;    println(<span class="hljs-keyword">this</span>)    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>&#125;<span class="hljs-comment">// 统计元音字母</span><span class="hljs-keyword">val</span> String.numVowels    <span class="hljs-keyword">get</span>() = count &#123; <span class="hljs-string">&quot;aeiou&quot;</span>.contains(it) &#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-string">&quot;The people&#x27;s Republic of China&quot;</span>.numVowels.easyPrint() <span class="hljs-comment">// 10 </span>&#125;</code></pre></div><h2 id="其他拓展特性"><a href="#其他拓展特性" class="headerlink" title="其他拓展特性"></a>其他拓展特性</h2><h3 id="可空类拓展"><a href="#可空类拓展" class="headerlink" title="可空类拓展"></a>可空类拓展</h3><p>你也可以定义扩展函数用于可空类型，在可空类型上定义扩展函数，你就可以且直接在扩展函数体内解决可能出现的空值问题。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String?.<span class="hljs-title">printWithDefault</span><span class="hljs-params">(default: <span class="hljs-type">String</span>)</span></span> = print(<span class="hljs-keyword">this</span> ?: default)<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> nullableString: String? = <span class="hljs-literal">null</span>    nullableString.printWithDefault(<span class="hljs-string">&quot;abc&quot;</span>) <span class="hljs-comment">// abc</span>&#125;</code></pre></div><h3 id="infix关键字"><a href="#infix关键字" class="headerlink" title="infix关键字"></a>infix关键字</h3><p>infix关键字适用于有<strong>单个参数</strong>的扩展和类函数，可以让你以更简洁的语法调用函数，如果一个函数定义使用了infix关键字，那么调用它时，接收者和函数之间的<strong>点操作</strong>以及<strong>参数的一对括号</strong>都可以不要。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> String?.<span class="hljs-title">printWithDefault</span><span class="hljs-params">(default: <span class="hljs-type">String</span>)</span></span> = print(<span class="hljs-keyword">this</span> ?: default)<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> nullableString: String? = <span class="hljs-literal">null</span>    <span class="hljs-comment">// 下面这行</span>    nullableString printWithDefault <span class="hljs-string">&quot;abc&quot;</span>&#125;</code></pre></div><p>常见与mapOf</p><div class="code-wrapper"><pre><code class="hljs kotlin">mapOf(<span class="hljs-string">&quot;Jack&quot;</span> to <span class="hljs-number">18</span>) <span class="hljs-comment">// 等价于 </span><span class="hljs-string">&quot;Jack&quot;</span>.to(<span class="hljs-number">18</span>)</code></pre></div><p>新建包extension，定义方法：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> extension<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Iterable<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">randomTake</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">this</span>.shuffled().first()</code></pre></div><p>使用：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 引入方法</span><span class="hljs-keyword">import</span> extension.randomTake<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-string">&quot;Morty&quot;</span>, <span class="hljs-string">&quot;Sandy&quot;</span>)    <span class="hljs-keyword">val</span> <span class="hljs-keyword">set</span> = setOf(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-string">&quot;Morty&quot;</span>, <span class="hljs-string">&quot;Sandy&quot;</span>)    println(list.randomTake()) <span class="hljs-comment">// 示例输出 Yorick</span>    println(<span class="hljs-keyword">set</span>.randomTake()) <span class="hljs-comment">// 示例输出 Morty</span>&#125;</code></pre></div><p>也可以给引入的方法取别名</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> extension.randomTake <span class="hljs-keyword">as</span> rt<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-string">&quot;Morty&quot;</span>, <span class="hljs-string">&quot;Sandy&quot;</span>)    <span class="hljs-keyword">val</span> <span class="hljs-keyword">set</span> = setOf(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-string">&quot;Morty&quot;</span>, <span class="hljs-string">&quot;Sandy&quot;</span>)    println(list.rt())    println(<span class="hljs-keyword">set</span>.rt())&#125;</code></pre></div><h3 id="Kotlin标准库中的扩展"><a href="#Kotlin标准库中的扩展" class="headerlink" title="Kotlin标准库中的扩展"></a>Kotlin标准库中的扩展</h3><p>Kotlin标准库提供的很多功能都是通过扩展函数和扩展属性来实现的，包含类扩展的标准库文件通常都是以类名加s后缀来命名的，例如<code>Sequences.kt</code>，<code>Ranges.kt</code>，<code>Maps.kt</code>。</p><h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><h3 id="apply函数详解"><a href="#apply函数详解" class="headerlink" title="apply函数详解"></a>apply函数详解</h3><p>apply函数时如何做到支持接收者对象的隐式调用的？</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">apply</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: T &#123;    block()    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>&#125;</code></pre></div><p><strong>为什么传入泛型的拓展函数？</strong> <code>T.() -&gt; Unit</code></p><p>因为拓展函数里自带了this的隐式调用，比如addExt()函数</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> java.io.File<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">addExt</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;*&quot;</span>.repeat(<span class="hljs-keyword">this</span>.count())<span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">apply</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: T &#123;    block()    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> file = File(<span class="hljs-string">&quot;xxx&quot;</span>).apply &#123;        setReadable(<span class="hljs-literal">true</span>)    &#125;&#125;</code></pre></div><p><strong>为什么是泛型的拓展函数？</strong></p><p>如果不用泛型怎么写？</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> File.<span class="hljs-title">apply</span><span class="hljs-params">(block: <span class="hljs-type">File</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: File &#123;    block()    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> file = File(<span class="hljs-string">&quot;xxx&quot;</span>).apply &#123;        setReadable(<span class="hljs-literal">true</span>)    &#125;&#125;</code></pre></div><p>但是这样apply就只能用于File类型。</p><p><strong>分解调用，加深理解</strong></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> File.<span class="hljs-title">apply</span><span class="hljs-params">(block: <span class="hljs-type">File</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: File &#123;    block()    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> file = File(<span class="hljs-string">&quot;xxx&quot;</span>).apply &#123;        setReadable(<span class="hljs-literal">true</span>)    &#125;    <span class="hljs-comment">// 将上面代码分解一下</span>    <span class="hljs-comment">// 定义拓展函数</span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> File.<span class="hljs-title">ext</span><span class="hljs-params">()</span></span> = setReadable(<span class="hljs-literal">true</span>)    <span class="hljs-comment">// 给block复制</span>    <span class="hljs-keyword">val</span> block = File::ext    <span class="hljs-comment">// 传入apply函数</span>    file =  File(<span class="hljs-string">&quot;xx&quot;</span>).apply &#123; block &#125;&#125;</code></pre></div><h3 id="什么是DSL"><a href="#什么是DSL" class="headerlink" title="什么是DSL"></a>什么是DSL</h3><p>使用这样的编程范式，就可以写出业界知名的<code>领域特定语言</code>(DSL)，一种API编程范式，暴露接收者的函数和特性，以便于使用你定义的lambda表达式来读取和配置它们。</p>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin泛型</title>
    <link href="/Kotlin/Kotlin%E6%B3%9B%E5%9E%8B/"/>
    <url>/Kotlin/Kotlin%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li><a href="#%E6%B3%9B%E5%9E%8B">泛型</a><ul><li><a href="#%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB">定义泛型类</a></li><li><a href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0">泛型函数</a></li><li><a href="#%E5%A4%9A%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0">多泛型参数</a></li><li><a href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F">泛型类型约束</a></li><li><a href="#%E9%85%8D%E5%90%88vararg%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%8F%82">配合vararg关键字实现多参</a></li><li><a href="#out%E5%8D%8F%E5%8F%98">out（协变）</a></li><li><a href="#in%E9%80%86%E5%8F%98">in（逆变）</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8inout">为什么使用in&amp;out</a></li><li><a href="#reified">reified</a></li></ul></li></ul><h3 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h3><p>泛型类的构造函数可以接受任何类型。</p><p>MagicBox类指定的泛型参数由放在一对<code>&lt;&gt;</code>里的字母T表示，T是个代表item类型的占位符。MagicBox类接受任何类型的item作为主构造函数值<code>(item: T)</code>，并将item值赋给同样是T类型的subject私有属性。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicBox</span>&lt;<span class="hljs-type">T</span>&gt;(item: T) &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> subject: T = item&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Boy</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-keyword">val</span> weight: <span class="hljs-built_in">Int</span>)<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> box1: MagicBox&lt;Boy&gt; = MagicBox(Boy(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-number">21</span>))    <span class="hljs-keyword">val</span> box2: MagicBox&lt;Dog&gt; = MagicBox(Dog(<span class="hljs-number">20</span>))&#125;</code></pre></div><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><ul><li><p>泛型参数也可以用于函数。</p></li><li><p>定义一个函数用于获取元素，当且仅当MagicBox可用时，才能获取元素。</p></li></ul><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicBox</span>&lt;<span class="hljs-type">T</span>&gt;(item: T) &#123;    <span class="hljs-keyword">var</span> available = <span class="hljs-literal">false</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> subject: T = item    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetch</span><span class="hljs-params">()</span></span>: T? &#123;        <span class="hljs-comment">// 判断接收者是否满足lambda的表达式，满足返回接收者，不满足则返回null。</span>        <span class="hljs-keyword">return</span> subject.takeIf &#123; available &#125;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Boy</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-keyword">val</span> weight: <span class="hljs-built_in">Int</span>)<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> box1: MagicBox&lt;Boy&gt; = MagicBox(Boy(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-number">21</span>))    <span class="hljs-keyword">val</span> box2: MagicBox&lt;Dog&gt; = MagicBox(Dog(<span class="hljs-number">20</span>))    box1.available = <span class="hljs-literal">true</span>    box1.fetch()?.run &#123;        println(<span class="hljs-string">&quot;you find <span class="hljs-variable">$name</span>&quot;</span>)    &#125;&#125;</code></pre></div><h3 id="多泛型参数"><a href="#多泛型参数" class="headerlink" title="多泛型参数"></a>多泛型参数</h3><p>泛型函数或泛型类也可以有多个泛型参数</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicBox</span>&lt;<span class="hljs-type">T</span>&gt;(item: T) &#123;    <span class="hljs-keyword">var</span> available = <span class="hljs-literal">false</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> subject: T = item    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetch</span><span class="hljs-params">()</span></span>: T? &#123;        <span class="hljs-comment">// 判断接收者是否满足lambda的表达式，满足返回接收者，不满足则返回null。</span>        <span class="hljs-keyword">return</span> subject.takeIf &#123; available &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">fetch</span><span class="hljs-params">(subjectModFunc: (<span class="hljs-type">T</span>) -&gt; (<span class="hljs-type">R</span>))</span></span>: R? &#123;        <span class="hljs-keyword">return</span> subjectModFunc(subject).takeIf &#123; available &#125;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Boy</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)<span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-keyword">val</span> weight: <span class="hljs-built_in">Int</span>)<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> box1: MagicBox&lt;Boy&gt; = MagicBox(Boy(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-number">15</span>))    <span class="hljs-keyword">val</span> box2: MagicBox&lt;Dog&gt; = MagicBox(Dog(<span class="hljs-number">20</span>))    box1.available = <span class="hljs-literal">true</span>    box1.fetch()?.run &#123;        println(<span class="hljs-string">&quot;you find <span class="hljs-variable">$name</span>&quot;</span>)    &#125;    <span class="hljs-keyword">val</span> man = box1.fetch &#123;        Man(it.name, it.age.plus(<span class="hljs-number">10</span>))    &#125;&#125;</code></pre></div><h3 id="泛型类型约束"><a href="#泛型类型约束" class="headerlink" title="泛型类型约束"></a>泛型类型约束</h3><p>如果要确保MagicBox里面只能装指定类型的物品，如Human类型<br>怎么办？</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这里用Human约束泛型类型</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicBox</span>&lt;<span class="hljs-type">T : Human</span>&gt;(item: T) &#123;    <span class="hljs-keyword">var</span> available = <span class="hljs-literal">false</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> subject: T = item    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetch</span><span class="hljs-params">()</span></span>: T? &#123;        <span class="hljs-keyword">return</span> subject.takeIf &#123; available &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">fetch</span><span class="hljs-params">(subjectModFunc: (<span class="hljs-type">T</span>) -&gt; (<span class="hljs-type">R</span>))</span></span>: R? &#123;        <span class="hljs-keyword">return</span> subjectModFunc(subject).takeIf &#123; available &#125;    &#125;&#125;<span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>(<span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)<span class="hljs-keyword">class</span> <span class="hljs-title class_">Boy</span>(<span class="hljs-keyword">val</span> name: String, age: <span class="hljs-built_in">Int</span>) : Human(age)<span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span>(<span class="hljs-keyword">val</span> name: String, age: <span class="hljs-built_in">Int</span>) : Human(age)<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-keyword">val</span> weight: <span class="hljs-built_in">Int</span>)<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> box1: MagicBox&lt;Boy&gt; = MagicBox(Boy(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-number">15</span>))<span class="hljs-comment">//    val box2: MagicBox&lt;Dog&gt; = MagicBox(Dog(20))</span>    box1.available = <span class="hljs-literal">true</span>    box1.fetch()?.run &#123;        println(<span class="hljs-string">&quot;you find <span class="hljs-variable">$name</span>&quot;</span>)    &#125;    <span class="hljs-keyword">val</span> man = box1.fetch &#123;        Man(it.name, it.age.plus(<span class="hljs-number">10</span>))    &#125;&#125;</code></pre></div><h3 id="配合vararg关键字实现多参"><a href="#配合vararg关键字实现多参" class="headerlink" title="配合vararg关键字实现多参"></a>配合vararg关键字实现多参</h3><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicBox</span>&lt;<span class="hljs-type">T : Human</span>&gt;(<span class="hljs-keyword">vararg</span> item: T) &#123;    <span class="hljs-keyword">var</span> available = <span class="hljs-literal">false</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> subject: Array&lt;<span class="hljs-keyword">out</span> T&gt; = item    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetch</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>)</span></span>: T? &#123;        <span class="hljs-comment">// 判断接收者是否满足lambda的表达式，满足返回接收者，不满足则返回null。</span>        <span class="hljs-keyword">return</span> subject[index].takeIf &#123; available &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">fetch</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>, subjectModFunc: (<span class="hljs-type">T</span>) -&gt; (<span class="hljs-type">R</span>))</span></span>: R? &#123;        <span class="hljs-keyword">return</span> subjectModFunc(subject[index]).takeIf &#123; available &#125;    &#125;&#125;<span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>(<span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)<span class="hljs-keyword">class</span> <span class="hljs-title class_">Boy</span>(<span class="hljs-keyword">val</span> name: String, age: <span class="hljs-built_in">Int</span>) : Human(age)<span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span>(<span class="hljs-keyword">val</span> name: String, age: <span class="hljs-built_in">Int</span>) : Human(age)<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> box1 = MagicBox(        Boy(<span class="hljs-string">&quot;Jimmy&quot;</span>, <span class="hljs-number">16</span>),        Boy(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">13</span>),        Boy(<span class="hljs-string">&quot;Morty&quot;</span>, <span class="hljs-number">14</span>)    )    box1.available = <span class="hljs-literal">true</span>    box1.fetch(<span class="hljs-number">1</span>)?.run &#123;        println(<span class="hljs-string">&quot;you find <span class="hljs-variable">$name</span>&quot;</span>) <span class="hljs-comment">// Jack</span>    &#125;    box1.fetch(<span class="hljs-number">2</span>) &#123;        Man(it.name, it.age.plus(<span class="hljs-number">10</span>))    &#125;&#125;</code></pre></div><p>想要使用<code>box1[1]</code>获取实例，那么就要进行运算符重载</p><p>在MagicBox类中添加</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>)</span></span>: T? = subject[index]?.takeIf &#123; available &#125;</code></pre></div><p>调用</p><div class="code-wrapper"><pre><code class="hljs kotlin">println(box1[<span class="hljs-number">1</span>]?.name) <span class="hljs-comment">// Jack</span></code></pre></div><h3 id="out（协变）"><a href="#out（协变）" class="headerlink" title="out（协变）"></a>out（协变）</h3><p>out（协变），如果泛型类只将泛型类型作为函数的返回（输出），那么使用out，可以称之为生产类&#x2F;接口，因为它主要是用来生产(produce)指定的泛型对象。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Production</span>&lt;<span class="hljs-type">out T</span>&gt; &#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">product</span><span class="hljs-params">()</span></span>: T&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-type">in T</span>&gt; &#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consumer</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductionConsumer</span>&lt;<span class="hljs-type">T</span>&gt; &#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">product</span><span class="hljs-params">()</span></span>: T    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consumer</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>&#125;<span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Food</span><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastFood</span> : <span class="hljs-type">Food</span>()<span class="hljs-keyword">class</span> <span class="hljs-title class_">Burger</span> : <span class="hljs-type">FastFood</span>()<span class="hljs-keyword">class</span> <span class="hljs-title class_">FoodStore</span> : <span class="hljs-type">Production</span>&lt;<span class="hljs-type">Food</span>&gt; &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">product</span><span class="hljs-params">()</span></span>: Food &#123;        println(<span class="hljs-string">&quot;Produce Food&quot;</span>)        <span class="hljs-keyword">return</span> Food()    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">FastFoodStore</span> : <span class="hljs-type">Production</span>&lt;<span class="hljs-type">FastFood</span>&gt; &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">product</span><span class="hljs-params">()</span></span>: FastFood &#123;        println(<span class="hljs-string">&quot;Produce FastFood&quot;</span>)        <span class="hljs-keyword">return</span> FastFood()    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">BurgerStore</span> : <span class="hljs-type">Production</span>&lt;<span class="hljs-type">Burger</span>&gt; &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">product</span><span class="hljs-params">()</span></span>: Burger &#123;        println(<span class="hljs-string">&quot;Produce Burger&quot;</span>)        <span class="hljs-keyword">return</span> Burger()    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 子类泛型对象可以赋值给父类泛型对象</span>    <span class="hljs-keyword">val</span> production1: Production&lt;Food&gt; = FoodStore()    <span class="hljs-keyword">val</span> production2: Production&lt;Food&gt; = FastFoodStore()    <span class="hljs-keyword">val</span> production3: Production&lt;Food&gt; = BurgerStore()&#125;</code></pre></div><h3 id="in（逆变）"><a href="#in（逆变）" class="headerlink" title="in（逆变）"></a>in（逆变）</h3><p>in（逆变），如果泛型类只将泛型类型作为函数的入参（输入），那么使用<br>in，可以称之为消费者类&#x2F;接口，因为它主要是用来消费(consume)指定的泛型对象。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Production</span>&lt;<span class="hljs-type">out T</span>&gt; &#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">product</span><span class="hljs-params">()</span></span>: T&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-type">in T</span>&gt; &#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consumer</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductionConsumer</span>&lt;<span class="hljs-type">T</span>&gt; &#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">product</span><span class="hljs-params">()</span></span>: T    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consumer</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>&#125;<span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Food</span><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastFood</span> : <span class="hljs-type">Food</span>()<span class="hljs-keyword">class</span> <span class="hljs-title class_">Burger</span> : <span class="hljs-type">FastFood</span>()<span class="hljs-keyword">class</span> <span class="hljs-title class_">EveryBody</span> : <span class="hljs-type">Consumer</span>&lt;<span class="hljs-type">Food</span>&gt; &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consumer</span><span class="hljs-params">(item: <span class="hljs-type">Food</span>)</span></span> &#123;        println(<span class="hljs-string">&quot;Eat Food&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernPeople</span> : <span class="hljs-type">Consumer</span>&lt;<span class="hljs-type">FastFood</span>&gt; &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consumer</span><span class="hljs-params">(item: <span class="hljs-type">FastFood</span>)</span></span> &#123;        println(<span class="hljs-string">&quot;Eat FastFood&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">American</span> : <span class="hljs-type">Consumer</span>&lt;<span class="hljs-type">Burger</span>&gt; &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consumer</span><span class="hljs-params">(item: <span class="hljs-type">Burger</span>)</span></span> &#123;        println(<span class="hljs-string">&quot;Eat Burger&quot;</span>)    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 父类泛型对象可以赋值给子类泛型对象</span>    <span class="hljs-keyword">val</span> consumer1: Consumer&lt;Burger&gt; = EveryBody()    <span class="hljs-keyword">val</span> consumer2: Consumer&lt;Burger&gt; = ModernPeople()    <span class="hljs-keyword">val</span> consumer3: Consumer&lt;Burger&gt; = American()&#125;</code></pre></div><h3 id="为什么使用in-out"><a href="#为什么使用in-out" class="headerlink" title="为什么使用in&amp;out"></a>为什么使用in&amp;out</h3><p>父类泛型对象可以赋值给子类泛型对象，用in。<br>子类泛型对象可以赋值给父类泛型对象，用out。</p><p><img src="/./img/in_out.png" alt="in&amp;out"></p><h3 id="reified"><a href="#reified" class="headerlink" title="reified"></a>reified</h3><p>有时候，你可能想知道某个泛型参数具体是什么类型，reified关键字能帮你检查泛型参数类型。Kotlin不允许对泛型参数T做类型检查，因为泛型参数类型会被类型擦除，也就是说，T的类型信息在运行时是不可知的。</p><p>人话：配合内联使用，加了reified关键字，就可以使用is判断类型了。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicBox</span>&lt;<span class="hljs-type">T : Human</span>&gt;(<span class="hljs-keyword">vararg</span> item: T) &#123;    <span class="hljs-comment">// 随机产生一个对象，如果不是指定类型的对象，就通过backup函数生成一个指定类型的对象</span>    <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">randomOrBackup</span><span class="hljs-params">(backup: () -&gt; <span class="hljs-type">T</span>)</span></span>: T &#123;        <span class="hljs-keyword">val</span> items = listOf(            Boy(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">20</span>),            Man(<span class="hljs-string">&quot;Jimmy&quot;</span>, <span class="hljs-number">35</span>)        )        <span class="hljs-keyword">val</span> random = items.shuffled().first()        <span class="hljs-comment">// 这里进行类型判断</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (random <span class="hljs-keyword">is</span> T) &#123;            random        &#125; <span class="hljs-keyword">else</span> &#123;            backup()        &#125;    &#125;&#125;<span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>(<span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)<span class="hljs-keyword">class</span> <span class="hljs-title class_">Boy</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String, age: <span class="hljs-built_in">Int</span>) : Human(age)&#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Boy(name=&#x27;<span class="hljs-variable">$name</span>&#x27;,age=&#x27;<span class="hljs-variable">$age</span>&#x27;)&quot;</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String, age: <span class="hljs-built_in">Int</span>) : Human(age)&#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Boy(name=&#x27;<span class="hljs-variable">$name</span>&#x27;,age=&#x27;<span class="hljs-variable">$age</span>&#x27;)&quot;</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-keyword">val</span> weight: <span class="hljs-built_in">Int</span>)<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> box: MagicBox&lt;Boy&gt; = MagicBox()    <span class="hljs-keyword">val</span> subject = box.randomOrBackup &#123;        Boy(<span class="hljs-string">&quot;Jimmy&quot;</span>, <span class="hljs-number">21</span>)    &#125;    println(subject)&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>泛型</tag>
      
      <tag>Generic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin接口与抽象类</title>
    <link href="/Kotlin/Kotlin%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <url>/Kotlin/Kotlin%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li><a href="#%E6%8E%A5%E5%8F%A3">接口</a><ul><li><a href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89">接口定义</a></li><li><a href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0">默认实现</a></li></ul></li><li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></li></ul><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>Kotlin规定所有的接口属性和函数实现都要使用override关键字，接口中定义的函数并不需要open关键字修饰，他们默认就是open的。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Movable</span> &#123;    <span class="hljs-keyword">var</span> maxSpeed: <span class="hljs-built_in">Int</span>    <span class="hljs-keyword">var</span> wheels: <span class="hljs-built_in">Int</span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">move</span><span class="hljs-params">(movable: <span class="hljs-type">Movable</span>)</span></span>: String&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>(_name: String, <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> wheels: <span class="hljs-built_in">Int</span> = <span class="hljs-number">4</span>) : Movable&#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> maxSpeed: <span class="hljs-built_in">Int</span>        <span class="hljs-keyword">get</span>() = TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)        <span class="hljs-keyword">set</span>(value) &#123;&#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">move</span><span class="hljs-params">(movable: <span class="hljs-type">Movable</span>)</span></span>: String &#123;        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)    &#125;&#125;</code></pre></div><h3 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h3><p>可以在接口里提供默认属性的getter方法和函数实现。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Movable</span> &#123;    <span class="hljs-keyword">var</span> maxSpeed: <span class="hljs-built_in">Int</span>        <span class="hljs-keyword">get</span>() = (<span class="hljs-number">1.</span><span class="hljs-number">.500</span>).shuffled().last()        <span class="hljs-keyword">set</span>(value) &#123;&#125;    <span class="hljs-keyword">var</span> wheels: <span class="hljs-built_in">Int</span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">move</span><span class="hljs-params">(movable: <span class="hljs-type">Movable</span>)</span></span>: String&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>(_name: String, <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> wheels: <span class="hljs-built_in">Int</span> = <span class="hljs-number">4</span>) : Movable &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> maxSpeed: <span class="hljs-built_in">Int</span>        <span class="hljs-comment">// 使用默认方法</span>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">super</span>.maxSpeed        <span class="hljs-keyword">set</span>(value) &#123;&#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">move</span><span class="hljs-params">(movable: <span class="hljs-type">Movable</span>)</span></span>: String &#123;        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)    &#125;&#125;</code></pre></div><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>要定义一个抽象类，你需要在定义之前加上abstract关键字，除了具体的函数实现，抽象类也可以包含抽象函数—只有定义，没有函数实现。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Gun</span>(<span class="hljs-keyword">val</span> range: <span class="hljs-built_in">Int</span>) &#123;    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;        println(<span class="hljs-string">&quot;doSomething&quot;</span>)    &#125;    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">pullTrigger</span><span class="hljs-params">()</span></span>: String&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">M416</span>(<span class="hljs-keyword">val</span> price: <span class="hljs-built_in">Int</span>) : Gun(range = <span class="hljs-number">600</span>) &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">pullTrigger</span><span class="hljs-params">()</span></span>: String &#123;        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin面向对象_继承与对象</title>
    <link href="/Kotlin/Kotlin%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <url>/Kotlin/Kotlin%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><ul><li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a><ul><li><a href="#%E7%BB%A7%E6%89%BF">继承</a><ul><li><a href="#open%E5%85%B3%E9%94%AE%E5%AD%97">open关键字</a></li><li><a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%BD%AC%E6%8D%A2">类型检测与转换</a></li><li><a href="#%E6%99%BA%E8%83%BD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">智能类型转换</a></li><li><a href="#any%E8%B6%85%E7%B1%BB">Any超类</a></li></ul></li><li><a href="#%E5%AF%B9%E8%B1%A1">对象</a><ul><li><a href="#object%E5%85%B3%E9%94%AE%E5%AD%97">Object关键字</a></li><li><a href="#%E5%AF%B9%E8%B1%A1%E5%A3%B0%E6%98%8E">对象声明</a></li><li><a href="#%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F">对象表达式</a></li><li><a href="#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1">伴生对象</a></li><li><a href="#%E5%B5%8C%E5%A5%97%E7%B1%BB">嵌套类</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB">数据类</a></li><li><a href="#copy%E5%85%B3%E9%94%AE%E5%AD%97">copy关键字</a></li><li><a href="#%E7%BB%93%E6%9E%84%E5%A3%B0%E6%98%8E">结构声明</a></li><li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">运算符重载</a></li><li><a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB">枚举类</a></li><li><a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0">枚举类定义函数</a></li><li><a href="#%E4%BB%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">代数数据类型</a></li><li><a href="#%E5%AF%86%E5%B0%81%E7%B1%BB">密封类</a></li></ul></li></ul></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="open关键字"><a href="#open关键字" class="headerlink" title="open关键字"></a>open关键字</h3><p>类默认都是封闭的，要让某个类开放继承，必须使用open关键字修饰它。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span>(<span class="hljs-keyword">val</span> name: String) &#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Product: <span class="hljs-variable">$name</span>&quot;</span>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Nothing&quot;</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">LuxuryProduct</span> : <span class="hljs-type">Product</span>(<span class="hljs-string">&quot;Luxury&quot;</span>) &#123;    <span class="hljs-comment">// 重写方法</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;LuxuryProduct loading...&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> p:Product = LuxuryProduct()    println(p.load()) <span class="hljs-comment">// LuxuryProduct loading...</span>&#125;</code></pre></div><h3 id="类型检测与转换"><a href="#类型检测与转换" class="headerlink" title="类型检测与转换"></a>类型检测与转换</h3><p>使用<code>is</code>进行类型检测<br>使用<code>as</code>进行类型转换</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">import</span> java.io.File<span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span>(<span class="hljs-keyword">val</span> name: String) &#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Product: <span class="hljs-variable">$name</span>&quot;</span>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Nothing&quot;</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">LuxuryProduct</span> : <span class="hljs-type">Product</span>(<span class="hljs-string">&quot;Luxury&quot;</span>) &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;LuxuryProduct loading...&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">special</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;LuxuryProduct special function&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> p: Product = LuxuryProduct()    println(p.load())    <span class="hljs-comment">// 类型检测</span>    println(p <span class="hljs-keyword">is</span> Product) <span class="hljs-comment">// true</span>    println(p <span class="hljs-keyword">is</span> LuxuryProduct) <span class="hljs-comment">// true</span>    println(p <span class="hljs-keyword">is</span> File) <span class="hljs-comment">// false</span>    <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">is</span> LuxuryProduct) &#123;        <span class="hljs-comment">// 类型转换</span>        println((p <span class="hljs-keyword">as</span> LuxuryProduct).special()) <span class="hljs-comment">// LuxuryProduct special function</span>    &#125;&#125;</code></pre></div><h3 id="智能类型转换"><a href="#智能类型转换" class="headerlink" title="智能类型转换"></a>智能类型转换</h3><p>Kotlin编译器很聪明，只要能确定any is 父类条件检查属实，它就会将any当做子类类型对待，因此，编译器允许你不经类型转换直接使用。</p><div class="code-wrapper"><pre><code class="hljs kt">println((p <span class="hljs-keyword">as</span> LuxuryProduct).special())p.special() <span class="hljs-comment">// 再次调用无需转换</span></code></pre></div><h3 id="Any超类"><a href="#Any超类" class="headerlink" title="Any超类"></a>Any超类</h3><p>类似Java里的Object，Kotlin所有类的共同超类为Any</p><div class="code-wrapper"><pre><code class="hljs kt">println(p <span class="hljs-keyword">is</span> Any) <span class="hljs-comment">// true</span></code></pre></div><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="Object关键字"><a href="#Object关键字" class="headerlink" title="Object关键字"></a>Object关键字</h3><p>使用object关键字，你可以定义一个只能产生一个实例的类-单例</p><p>使用object关键字有三种方式</p><ul><li>对象声明</li><li>对象表达式</li><li>伴生对象</li></ul><h3 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h3><p>对象声明有利于组织代码和管理状态，尤其是管理整个应用运行生命周期内的某些一致性状态。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">object</span> ApplicationConfig &#123;    <span class="hljs-keyword">init</span> &#123;        println(<span class="hljs-string">&quot;ApplicationConfig is loading...&quot;</span>)    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;        println(<span class="hljs-string">&quot;do something...&quot;</span>)    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 单例模式 类名=对象名</span>    ApplicationConfig.doSomething()    println(ApplicationConfig) <span class="hljs-comment">// ApplicationConfig@52cc8049</span>    println(ApplicationConfig) <span class="hljs-comment">//ApplicationConfig@52cc8049</span>&#125;</code></pre></div><h3 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h3><p>有时候你不一定非要定义一个新的命名类不可，也许你需要某个现有类的一种变体实例，但只需用一次就行了，对于这种用完就丢的类实例，连命名都可以省了。</p><p>这个匿名类依然遵循object关键字的一个规则，即一旦实例化，该匿名类只能有唯一一个实例存在。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;loading something...&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 对象表达式</span>    <span class="hljs-keyword">val</span> p = <span class="hljs-keyword">object</span> : Player() &#123;        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span>: String = <span class="hljs-string">&quot;anonymous class load...&quot;</span>    &#125;    println(p.load())&#125;</code></pre></div><h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>使用companion修饰符，将对象伴生在类上，一个类只能有一个伴生对象。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">import</span> java.io.File<span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigMap</span> &#123;    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> PATH = <span class="hljs-string">&quot;E://demo.txt&quot;</span>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span> = File(PATH).readBytes()    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    ConfigMap.load()&#125;</code></pre></div><h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>如果一个类只对另一个类有用，那么将其嵌入到该类中并使这两个类保持在一起是合乎逻辑的，可以使用嵌套类。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Play</span> &#123;    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Equipment</span>(<span class="hljs-keyword">var</span> name: String) &#123;        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;equipment: <span class="hljs-variable">$name</span>&quot;</span>)    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">battle</span><span class="hljs-params">()</span></span> &#123;        Equipment(<span class="hljs-string">&quot;sharp knife&quot;</span>).show()    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 直接调用</span>    Play.Equipment(<span class="hljs-string">&quot;M416&quot;</span>).show() <span class="hljs-comment">// equipment: M416</span>&#125;</code></pre></div><h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><p>数据类，是专门设计用来存储数据的类</p><ul><li>数据类提供了<code>toString</code>的个性化实现</li><li><code>==</code>符号默认情况下，比较对象就是比较它们的引用值，数据类提供了<code>equals</code>和<code>hashCode</code>的个性化实现</li></ul><p>使用数据类</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>(<span class="hljs-keyword">var</span> x: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">var</span> y: <span class="hljs-built_in">Int</span>) &#123;    <span class="hljs-keyword">val</span> isInBounds = x &gt; <span class="hljs-number">0</span> &amp;&amp; y &gt; <span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    println(Coordinate(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))    println(Coordinate(x = <span class="hljs-number">10</span>, y = <span class="hljs-number">20</span>) == Coordinate(x = <span class="hljs-number">10</span>, y = <span class="hljs-number">20</span>))&#125;<span class="hljs-comment">// Coordinate(x=10, y=20)</span><span class="hljs-comment">// true</span></code></pre></div><p>使用普通类</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>(<span class="hljs-keyword">var</span> x: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">var</span> y: <span class="hljs-built_in">Int</span>) &#123;    <span class="hljs-keyword">val</span> isInBounds = x &gt; <span class="hljs-number">0</span> &amp;&amp; y &gt; <span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    println(Coordinate(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))    println(Coordinate(x = <span class="hljs-number">10</span>, y = <span class="hljs-number">20</span>) == Coordinate(x = <span class="hljs-number">10</span>, y = <span class="hljs-number">20</span>))&#125;<span class="hljs-comment">// Coordinate@52cc8049</span><span class="hljs-comment">// false</span></code></pre></div><p>正是因为上述这些特性，你才倾向于用数据类来表示存储数据的简单对象，对于那些经常需要比较、复制或打印自身内容的类，数据类尤其适合它们。然而，一个类要成为数据类，也要符合一定条件。总结下来，主要有三个方面：</p><ul><li>数据类必须有至少带一个参数的主构造函数</li><li>数据类主构造函数的参数必须是val或var</li><li>数据类不能使用abstract、open、sealed和inner修饰符</li></ul><h3 id="copy关键字"><a href="#copy关键字" class="headerlink" title="copy关键字"></a>copy关键字</h3><p>data还提供了复制对象的方法copy。</p><p>但是，copy时不会执行次构造函数里的语句，所以次构造函数里的赋值不会被copy到新对象。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>) &#123;    <span class="hljs-keyword">var</span> score = <span class="hljs-number">10</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> bobby = <span class="hljs-string">&quot;music&quot;</span>    <span class="hljs-keyword">var</span> subject: String    <span class="hljs-keyword">init</span> &#123;        println(<span class="hljs-string">&quot;initializing subject&quot;</span>)        subject = <span class="hljs-string">&quot;math&quot;</span>    &#125;    <span class="hljs-keyword">constructor</span>(_name: String) : <span class="hljs-keyword">this</span>(_name, <span class="hljs-number">10</span>) &#123;        println(<span class="hljs-string">&quot;constructor&quot;</span>)        score = <span class="hljs-number">20</span>    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student(name=&#x27;<span class="hljs-variable">$name</span>&#x27;, age=<span class="hljs-variable">$age</span>, score=<span class="hljs-variable">$score</span>, bobby=&#x27;<span class="hljs-variable">$bobby</span>&#x27;, subject=&#x27;<span class="hljs-variable">$subject</span>&#x27;)&quot;</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> s = Student(<span class="hljs-string">&quot;John&quot;</span>)    <span class="hljs-keyword">val</span> copy = s.copy(<span class="hljs-string">&quot;Alice&quot;</span>)    println(s)    println(copy)&#125;<span class="hljs-comment">// initializing subject</span><span class="hljs-comment">// constructor</span><span class="hljs-comment">// initializing subject</span><span class="hljs-comment">// Student(name=&#x27;John&#x27;, age=10, score=20, bobby=&#x27;music&#x27;, subject=&#x27;math&#x27;)</span><span class="hljs-comment">// Student(name=&#x27;Alice&#x27;, age=10, score=10, bobby=&#x27;music&#x27;, subject=&#x27;math&#x27;)</span></code></pre></div><h3 id="结构声明"><a href="#结构声明" class="headerlink" title="结构声明"></a>结构声明</h3><p>解构声明的后台实现就是声明component1、component2等若干个组件函数，让每个函数负责管理你想返回的一个属性数据。</p><p>普通类</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PlayerScore</span>(<span class="hljs-keyword">val</span> exp: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> level: <span class="hljs-built_in">Int</span>) &#123;    <span class="hljs-comment">// 需要组件函数</span>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">component1</span><span class="hljs-params">()</span></span> = exp    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">component2</span><span class="hljs-params">()</span></span> = level&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> (x, y) = PlayerScore(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)    println(<span class="hljs-string">&quot;<span class="hljs-variable">$x</span>,<span class="hljs-variable">$y</span>&quot;</span>) <span class="hljs-comment">// 10,20</span></code></pre></div><p>如果你定义一个数据类，它会自动为所有定义在主构造函数的属性添加对应的组件函数。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PlayerScore</span>(<span class="hljs-keyword">val</span> exp: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> level: <span class="hljs-built_in">Int</span>) &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> (x, y) = PlayerScore(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)    println(<span class="hljs-string">&quot;<span class="hljs-variable">$x</span>,<span class="hljs-variable">$y</span>&quot;</span>) <span class="hljs-comment">// 10,20</span>&#125;</code></pre></div><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>如果要将内置运算符应用在自定义类身上，你必须重写运算符函数，告诉编译器该如何操作自定义类。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>(<span class="hljs-keyword">var</span> x: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">var</span> y: <span class="hljs-built_in">Int</span>) &#123;    <span class="hljs-keyword">val</span> isInBounds = x &gt; <span class="hljs-number">0</span> &amp;&amp; y &gt; <span class="hljs-number">0</span>    <span class="hljs-comment">// 重载加法运算符</span>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(other: <span class="hljs-type">Coordinate</span>)</span></span> = Coordinate(x + other.x, y + other.y)&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> p1 = Coordinate(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)    <span class="hljs-keyword">val</span> p2 = Coordinate(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>)    <span class="hljs-keyword">val</span> p3 = p1 + p2    println(p3) <span class="hljs-comment">// Coordinate(x=30, y=30)</span>&#125;</code></pre></div><p>常见操作符</p><table><thead><tr><th>操作符</th><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>+</td><td>plus</td><td>把一个对象添加到另一个对象里</td></tr><tr><td>+&#x3D;</td><td>plusAssign</td><td>把一个对象添加到另一个对象里，然后将结果赋值给第一个对象</td></tr><tr><td>&#x3D;&#x3D;</td><td>equals</td><td>如果两个对象相等，则返回true，否则返回false</td></tr><tr><td>&gt;</td><td>compareTo</td><td>如果左边的对象大于右边的对象，则返回true，否则返回false</td></tr><tr><td>[ ]</td><td>get</td><td>返回集合中指定位置的元素</td></tr><tr><td>..</td><td>rangeTo</td><td>创建一个range对象</td></tr><tr><td>in</td><td>contains</td><td>如果对象包含在集合里，则返回true</td></tr></tbody></table><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>枚举类,用来定义常量集合的一种特殊类。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Direction</span> &#123;    EAST,    WEST,    SOUTH,    NORTH&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    println(Direction.EAST) <span class="hljs-comment">// EAST</span>    println(Direction.EAST <span class="hljs-keyword">is</span> Direction) <span class="hljs-comment">// true</span>&#125;</code></pre></div><h3 id="枚举类定义函数"><a href="#枚举类定义函数" class="headerlink" title="枚举类定义函数"></a>枚举类定义函数</h3><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Direction</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> coordinate: Coordinate) &#123;    <span class="hljs-comment">// 实例</span>    EAST(Coordinate(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)),    WEST(Coordinate(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)),    SOUTH(Coordinate(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)),    NORTH(Coordinate(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateCoordinate</span><span class="hljs-params">(playerCoordinate: <span class="hljs-type">Coordinate</span>)</span></span> =        Coordinate(playerCoordinate.x + coordinate.x, playerCoordinate.y + coordinate.y)&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    println(Direction.EAST.updateCoordinate(Coordinate(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)))&#125;<span class="hljs-comment">// Coordinate(x=11, y=20)</span></code></pre></div><h3 id="代数数据类型"><a href="#代数数据类型" class="headerlink" title="代数数据类型"></a>代数数据类型</h3><p>可以用来表示一组子类型的闭集,枚举类就是一种简单的ADT。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LicenseStatus</span> &#123;    UNQUALIFIED,    LEARNING,    QUALIFIED;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span>(<span class="hljs-keyword">var</span> status: LicenseStatus) &#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkLicense</span><span class="hljs-params">()</span></span>: String &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (status) &#123;            LicenseStatus.UNQUALIFIED -&gt; <span class="hljs-string">&quot;没资格&quot;</span>            LicenseStatus.LEARNING -&gt; <span class="hljs-string">&quot;正在学&quot;</span>            LicenseStatus.QUALIFIED -&gt; <span class="hljs-string">&quot;有资格&quot;</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    println(Driver(LicenseStatus.QUALIFIED).checkLicense())&#125;</code></pre></div><h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p>对于更复杂的ADT，你可以使用Kotlin的密封类(sealed class）来实现更复杂的定义，密封类可以用来定义一个类似于枚举类的ADT，但你可以更灵活地控制某个子类型。</p><p>密封类可以有若干个子类，要继承密封类，这些子类必须和它定义在同一个文件里。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LicenseStatus</span> &#123;    <span class="hljs-comment">// 没有属性，所以用单例模式</span>    <span class="hljs-keyword">object</span> UnQualified : LicenseStatus()    <span class="hljs-keyword">object</span> Learning : LicenseStatus()    <span class="hljs-comment">// 每次id不一样，所以使用类</span>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Qualified</span>(<span class="hljs-keyword">val</span> licenseID: String) : LicenseStatus()&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span>(<span class="hljs-keyword">var</span> status: LicenseStatus) &#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkLicense</span><span class="hljs-params">()</span></span>: String &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (status) &#123;            <span class="hljs-keyword">is</span> LicenseStatus.UnQualified -&gt; <span class="hljs-string">&quot;没资格&quot;</span>            <span class="hljs-keyword">is</span> LicenseStatus.Learning -&gt; <span class="hljs-string">&quot;正在学&quot;</span>            <span class="hljs-keyword">is</span> LicenseStatus.Qualified -&gt; <span class="hljs-string">&quot;有资格，驾驶证编号：<span class="hljs-subst">$&#123;(this.status as LicenseStatus.Qualified).licenseID&#125;</span>&quot;</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> status = LicenseStatus.Qualified(<span class="hljs-string">&quot;2225211&quot;</span>)    <span class="hljs-keyword">val</span> driver = Driver(status)    println(driver.checkLicense())    <span class="hljs-comment">// 有资格，驾驶证编号：2225211</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin面向对象_定义类和初始化</title>
    <link href="/Kotlin/Kotlin%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/Kotlin/Kotlin%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><ul><li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a><ul><li><a href="#%E5%AE%9A%E4%B9%89%E7%B1%BB">定义类</a><ul><li><a href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E4%B8%8Efield%E5%85%B3%E9%94%AE%E5%AD%97">定义类与field关键字</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7">计算属性</a></li><li><a href="#%E9%98%B2%E8%8C%83%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6">防范竞态条件</a></li></ul></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a><ul><li><a href="#%E4%B8%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">主构造函数</a></li><li><a href="#%E5%9C%A8%E4%B8%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8C%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7">在主构造函数里定义属性</a></li><li><a href="#%E6%AC%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">次构造函数</a></li><li><a href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">默认参数</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97">初始化块</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F">初始化顺序</a></li><li><a href="#%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96">延迟初始化</a></li><li><a href="#%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96">惰性初始化</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%99%B7%E9%98%B1">初始化陷阱</a></li></ul></li></ul></li></ul><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><h3 id="定义类与field关键字"><a href="#定义类与field关键字" class="headerlink" title="定义类与field关键字"></a>定义类与field关键字</h3><p>在Kotlin中，定义类的属性后会自动生成默认getter和setter方法（可变属性才有），使用形如<code>p.name</code>的方法获取或者修改对象属性时，本质是调用了自动生成的getter和setter方法，可以从反编译成java的代码中看出。</p><p>同时也会自动生成field关键字，来储存属性数据，只可以在重新getter和setter方法时使用。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-comment">// 定义类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;yorick&quot;</span>        <span class="hljs-keyword">get</span>() = field.capitalize()        <span class="hljs-keyword">set</span>(value) &#123;            field = value.trim()        &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> p = Player()    println(p.name)    p.name = <span class="hljs-string">&quot; Alex &quot;</span>    println(p.name)&#125;<span class="hljs-comment">// 输出</span><span class="hljs-comment">// Yorick</span><span class="hljs-comment">// Alex</span></code></pre></div><p>反编译成java的主方法的Player类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;   <span class="hljs-meta">@NotNull</span>   <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yorick&quot;</span>;   <span class="hljs-meta">@NotNull</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;      <span class="hljs-keyword">return</span> StringsKt.capitalize(<span class="hljs-built_in">this</span>.name);   &#125;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> String value)</span> &#123;      Intrinsics.checkNotNullParameter(value, <span class="hljs-string">&quot;value&quot;</span>);      <span class="hljs-built_in">this</span>.name = StringsKt.trim((CharSequence)value).toString();   &#125;&#125;</code></pre></div><p>反编译成java的主方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">Player</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Player</span>();    <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> p.getName();    System.out.println(var1);    p.setName(<span class="hljs-string">&quot; Alex &quot;</span>);    var1 = p.getName();    System.out.println(var1);&#125;</code></pre></div><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>计算属性是通过一个覆盖的get或set运算符来定义，这时field就不需要了。有点函数的意思。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;    <span class="hljs-keyword">val</span> rolledValue        <span class="hljs-keyword">get</span>() = (<span class="hljs-number">1.</span><span class="hljs-number">.6</span>).shuffled().first()&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> p = Player()    println(p.rolledValue)&#125;<span class="hljs-comment">// 示例输出</span><span class="hljs-comment">// 2</span></code></pre></div><h3 id="防范竞态条件"><a href="#防范竞态条件" class="headerlink" title="防范竞态条件"></a>防范竞态条件</h3><p>如果一个类属性既可空又可变，那么引用它之前你必须保证它非空，一个办法是用also标准函数。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;    <span class="hljs-keyword">var</span> words: String? = <span class="hljs-string">&quot;Hello&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saySomething</span><span class="hljs-params">()</span></span> &#123;        words?.also &#123;            println(<span class="hljs-string">&quot;Hello <span class="hljs-subst">$&#123;it.toUpperCase()&#125;</span>&quot;</span>)        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> p = Player()    p.saySomething()&#125;<span class="hljs-comment">// 输出</span><span class="hljs-comment">// Hello HELLO</span></code></pre></div><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h3><p>我们在Player类的定义头中定义一个主构造函数，使用临时变量为Player的各个属性提供初始值，在Kotlin中，为便于识别，临时变量（包括仅引用一次的参数），通常都会以下划线开头的名字命名。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span>(    _name: String,    _age: <span class="hljs-built_in">Int</span>,    _isNormal: <span class="hljs-built_in">Boolean</span>) &#123;    <span class="hljs-keyword">var</span> name = _name        <span class="hljs-keyword">get</span>() = field.capitalize()        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>(value) &#123;            field = value.trim()        &#125;    <span class="hljs-keyword">var</span> age = _age    <span class="hljs-keyword">var</span> isNormal = _isNormal&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> player = Player(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-literal">true</span>)    println(player.name)&#125;</code></pre></div><h3 id="在主构造函数里定义属性"><a href="#在主构造函数里定义属性" class="headerlink" title="在主构造函数里定义属性"></a>在主构造函数里定义属性</h3><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span>(    _name: String,    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>,    <span class="hljs-keyword">var</span> isNormal: <span class="hljs-built_in">Boolean</span>) &#123;    <span class="hljs-keyword">var</span> name = _name        <span class="hljs-keyword">get</span>() = field.capitalize()        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>(value) &#123;            field = value.trim()        &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> player = Player(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-literal">true</span>)    println(player.name)&#125;</code></pre></div><h3 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h3><p>我们可以定义多个此构造函数来配置不同的参数组合，同时初始化代码逻辑。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span>(    _name: String,    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>,    <span class="hljs-keyword">var</span> isNormal: <span class="hljs-built_in">Boolean</span>) &#123;    <span class="hljs-keyword">var</span> name = _name        <span class="hljs-keyword">get</span>() = field.capitalize()        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>(value) &#123;            field = value.trim()        &#125;    <span class="hljs-comment">// 次构造函数</span>    <span class="hljs-keyword">constructor</span>(_name: String) : <span class="hljs-keyword">this</span>(_name, age = <span class="hljs-number">10</span>, isNormal = <span class="hljs-literal">true</span>) &#123;        <span class="hljs-keyword">this</span>.name = _name.uppercase()    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> p1 = Player(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-literal">true</span>)    println(p1.name)    <span class="hljs-keyword">val</span> p2 = Player(<span class="hljs-string">&quot;hobo&quot;</span>)    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;p2.name&#125;</span> <span class="hljs-subst">$&#123;p2.age&#125;</span> <span class="hljs-subst">$&#123;p2.isNormal&#125;</span>&quot;</span>)&#125;<span class="hljs-comment">// 输出</span><span class="hljs-comment">// Yorick</span><span class="hljs-comment">// HOBO 10 true</span></code></pre></div><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>定义构造函数时，可以给构造函数参数指定默认值，如果用户调用时不提供值参，就使用这个默认值。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span>(    _name: String,    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> = <span class="hljs-number">20</span>,    <span class="hljs-keyword">var</span> isNormal: <span class="hljs-built_in">Boolean</span>) &#123;    <span class="hljs-keyword">var</span> name = _name        <span class="hljs-keyword">get</span>() = field.capitalize()        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>(value) &#123;            field = value.trim()        &#125;    <span class="hljs-keyword">constructor</span>(_name: String) : <span class="hljs-keyword">this</span>(_name, age = <span class="hljs-number">10</span>, isNormal = <span class="hljs-literal">true</span>) &#123;        <span class="hljs-keyword">this</span>.name = _name.uppercase()    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 可以按顺序传参，指定参数名称就行</span>    <span class="hljs-keyword">val</span> player = Player(<span class="hljs-string">&quot;Yorick&quot;</span>, isNormal = <span class="hljs-literal">true</span>)    println(player.age) <span class="hljs-comment">// 20</span>&#125;</code></pre></div><h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><p>初始化块可以设置变量或值，以及执行有效性检查，如检查传给某构造函数的值是否有效，初始化块代码会在构造类实例时执行。在次构造函数执行之前就执行。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span>(    _name: String,    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>,    <span class="hljs-keyword">var</span> isNormal: <span class="hljs-built_in">Boolean</span>) &#123;    <span class="hljs-keyword">var</span> name = _name        <span class="hljs-keyword">get</span>() = field.capitalize()        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>(value) &#123;            field = value.trim()        &#125;    <span class="hljs-keyword">constructor</span>(_name: String) : <span class="hljs-keyword">this</span>(_name, age = <span class="hljs-number">10</span>, isNormal = <span class="hljs-literal">true</span>) &#123;        <span class="hljs-keyword">this</span>.name = _name.uppercase()    &#125;    <span class="hljs-comment">// 在实例化时执行</span>    <span class="hljs-keyword">init</span> &#123;        require(age &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-string">&quot;age must be positive&quot;</span> &#125;        require(name.isNotBlank()) &#123; <span class="hljs-string">&quot;player must have a name&quot;</span> &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> player = Player(<span class="hljs-string">&quot;&quot;</span>, -<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)    <span class="hljs-comment">// 异常 IllegalArgumentException</span>&#125;</code></pre></div><h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><ul><li>主构造函数里声明的属性</li><li>类级别的属性赋值</li><li>init初始化块里的属性赋值和函数调用</li><li>次构造函数里的属性赋值和函数调用</li></ul><p><img src="/./img/init_order.png" alt="init_order"></p><h3 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h3><p>我们知道，一般来说，类的属性在初始化时不能为空，但有的时候我们不得不先让其为空，在使用之前赋值，然后再初始化使用。这时候就用到了延迟初始化。</p><p>使用lateinit关键字相当于做了一个约定：在用它之前负责初始化</p><p>注意：</p><ul><li>lateinit 对应使用var来声明属性</li><li>lateinit 不可以修饰原始数据类型（byte，char，short ,int，long，float，double）</li></ul><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BattlePlayer</span> &#123;    <span class="hljs-comment">// 在使用之前初始化</span>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> equipment:String    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ready</span><span class="hljs-params">()</span></span>&#123;        equipment = <span class="hljs-string">&quot;RPG&quot;</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">battle</span><span class="hljs-params">()</span></span>&#123;        println(equipment)    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> player = BattlePlayer()    player.ready() <span class="hljs-comment">// 若注释掉此行，则异常 kotlin.UninitializedPropertyAccessException: lateinit property equipment has not been initialized</span>    player.battle()&#125;</code></pre></div><p>为了保证安全，只要无法确认lateinit变量是否完成初始化，可以执行isInitialized检查</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BattlePlayer</span> &#123;    <span class="hljs-comment">// 在使用之前初始化</span>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> equipment: String    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ready</span><span class="hljs-params">()</span></span> &#123;        equipment = <span class="hljs-string">&quot;RPG&quot;</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">battle</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">if</span> (::equipment.isInitialized) println(equipment)    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> player = BattlePlayer()    player.ready()    player.battle()&#125;</code></pre></div><h3 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h3><p>延迟初始化并不是推后初始化的唯一方式，你也可以暂时不初始化某个变量，直到首次使用它，这个叫作惰性初始化。</p><p>与lateinit的区别，惰性初始化是配置好的、自动执行的。而lateinit需要手动赋值。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyPayer</span>(_name: String) &#123;    <span class="hljs-keyword">var</span> name = _name    <span class="hljs-keyword">val</span> config <span class="hljs-keyword">by</span> lazy &#123; loadConfig() &#125;    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadConfig</span><span class="hljs-params">()</span></span>: String &#123;        println(<span class="hljs-string">&quot;loading...&quot;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Config is ready!&quot;</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> player = LazyPayer(<span class="hljs-string">&quot;Jerry&quot;</span>)    Thread.sleep(<span class="hljs-number">3000</span>)    println(player.config) <span class="hljs-comment">// 在执行此行时输出 loading... Config is ready!</span>&#125;</code></pre></div><p>对比正常初始化：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyPayer</span>(_name: String) &#123;    <span class="hljs-keyword">var</span> name = _name    <span class="hljs-keyword">val</span> config = loadConfig()    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadConfig</span><span class="hljs-params">()</span></span>: String &#123;        println(<span class="hljs-string">&quot;loading...&quot;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Config is ready!&quot;</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> player = LazyPayer(<span class="hljs-string">&quot;Jerry&quot;</span>) <span class="hljs-comment">// 输出 loading...</span>    println(player.config) <span class="hljs-comment">// 输出 Config is ready!</span>&#125;</code></pre></div><h3 id="初始化陷阱"><a href="#初始化陷阱" class="headerlink" title="初始化陷阱"></a>初始化陷阱</h3><p>（1）Kotlin的编译顺序</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InitPlayer</span>() &#123;    <span class="hljs-keyword">init</span> &#123;        <span class="hljs-keyword">val</span> bloodBonus = blood.times(<span class="hljs-number">4</span>)    &#125;    <span class="hljs-keyword">val</span> blood = <span class="hljs-number">100</span>&#125;<span class="hljs-comment">// 编译报错：Variable &#x27;blood&#x27; must be initialized</span></code></pre></div><p>编译报错：Variable ‘blood’ must be initialized</p><p>原因：Kotlin是自上而下编译代码，所以应该先声明类属性</p><p>修改后正常运行</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InitPlayer</span>() &#123;    <span class="hljs-keyword">val</span> blood = <span class="hljs-number">100</span>    <span class="hljs-keyword">init</span> &#123;        <span class="hljs-keyword">val</span> bloodBonus = blood.times(<span class="hljs-number">4</span>)    &#125;&#125;</code></pre></div><p>（2）</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InitPlayer</span>() &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">firstLetter</span><span class="hljs-params">()</span></span> = name[<span class="hljs-number">0</span>]    <span class="hljs-keyword">init</span> &#123;        println(firstLetter())        name = <span class="hljs-string">&quot;iKun&quot;</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    InitPlayer()&#125;<span class="hljs-comment">// 运行时异常NullPointerException</span></code></pre></div><p>原因：init块在类属性定义之后运行，类方法在调用时运行，但是类方法试图在类属性赋值前获取属性值，这必然导致空指针。</p><p>修改后正常运行</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InitPlayer</span>() &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">firstLetter</span><span class="hljs-params">()</span></span> = name[<span class="hljs-number">0</span>]    <span class="hljs-keyword">init</span> &#123;        name = <span class="hljs-string">&quot;iKun&quot;</span>        println(firstLetter())    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    InitPlayer()&#125;</code></pre></div><p>（3）</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InitPlayer</span>(_name: String) &#123;    <span class="hljs-keyword">val</span> playerName: String = initPlayerName()    <span class="hljs-keyword">val</span> name: String = _name    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initPlayerName</span><span class="hljs-params">()</span></span>: String = name&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> player = InitPlayer(<span class="hljs-string">&quot;Jimmy&quot;</span>)    println(player.playerName) <span class="hljs-comment">// null</span>&#125;</code></pre></div><p>因为编译器看到所有属性都初始化了，所以代码编译没问题，但运行结果却是null，问题出在哪？</p><p>在用initPlayerName函数初始化playerName时，name属性还未完成初始化。</p><p>修改后正常运行</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InitPlayer</span>(_name: String) &#123;    <span class="hljs-keyword">val</span> name: String = _name    <span class="hljs-keyword">val</span> playerName: String = initPlayerName()    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initPlayerName</span><span class="hljs-params">()</span></span>: String = name&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> player = InitPlayer(<span class="hljs-string">&quot;Jimmy&quot;</span>)    println(player.playerName) <span class="hljs-comment">// null</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin集合与数组</title>
    <link href="/Kotlin/Kotlin%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E7%BB%84/"/>
    <url>/Kotlin/Kotlin%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Kotlin集合与数组"><a href="#Kotlin集合与数组" class="headerlink" title="Kotlin集合与数组"></a>Kotlin集合与数组</h1><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><h3 id="List的创建与元素获取"><a href="#List的创建与元素获取" class="headerlink" title="List的创建与元素获取"></a>List的创建与元素获取</h3><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 创建List</span>    <span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-string">&quot;Sandy&quot;</span>)    <span class="hljs-comment">// 普通获取</span>    println(list[<span class="hljs-number">2</span>])    <span class="hljs-comment">// 使用安全索引函数获取</span>    <span class="hljs-comment">// getOrElse:没有则返回lambda表达式的结果</span>    println(list.getOrElse(<span class="hljs-number">3</span>)&#123;<span class="hljs-string">&quot;Nothing&quot;</span>&#125;)    <span class="hljs-comment">// getOrNull:没有则返回空</span>    println(list.getOrNull(<span class="hljs-number">3</span>))    <span class="hljs-comment">// getOrNull配合合并操作符使用</span>    println(list.getOrNull(<span class="hljs-number">3</span>)?:<span class="hljs-string">&quot;Nothing&quot;</span>)&#125;</code></pre></div><h3 id="可变列表"><a href="#可变列表" class="headerlink" title="可变列表"></a>可变列表</h3><p>在Kotlin中，支持修改内容的列表叫可变列表，要创建可变列表，可以使用mutableListOf函数。List还支持使用toList和toMutableList函数动态实现只读列表和可变列表的相互转换。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 创建可变列表</span>    <span class="hljs-keyword">val</span> mutableList = mutableListOf(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-string">&quot;Sandy&quot;</span>)    mutableList.add(<span class="hljs-string">&quot;Jack&quot;</span>)    mutableList.remove(<span class="hljs-string">&quot;Jerry&quot;</span>)、    <span class="hljs-comment">// 相互转换</span>    listOf(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-string">&quot;Sandy&quot;</span>).toMutableList()    mutableList.toList()&#125;</code></pre></div><h3 id="mutator函数"><a href="#mutator函数" class="headerlink" title="mutator函数"></a>mutator函数</h3><p>能修改可变列表的函数有个统一的名字：mutator函数</p><p>添加元素运算符与删除元素运算符</p><p>基于lambda表达式指定的条件删除元素</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 创建可变列表</span>    <span class="hljs-keyword">val</span> mutableList = mutableListOf(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-string">&quot;Sandy&quot;</span>)    mutableList += <span class="hljs-string">&quot;Morty&quot;</span> <span class="hljs-comment">// 相当于add</span>    mutableList -= <span class="hljs-string">&quot;Sandy&quot;</span> <span class="hljs-comment">// 相当于remove</span>    mutableList.removeIf&#123;it.contains(<span class="hljs-string">&quot;o&quot;</span>)&#125; <span class="hljs-comment">// 满足条件才移除</span>    println(mutableList)&#125;</code></pre></div><h3 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h3><ul><li><p>for in 遍历</p></li><li><p>forEach 遍历</p></li><li><p>forEachIndexed 遍历时要获取索引</p></li></ul><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-string">&quot;Sandy&quot;</span>)    <span class="hljs-keyword">for</span> (s <span class="hljs-keyword">in</span> list) &#123;        println(s)    &#125;    list.forEach &#123;        println(it)    &#125;    list.forEachIndexed &#123; index, item -&gt;        println(<span class="hljs-string">&quot;<span class="hljs-variable">$index</span> : <span class="hljs-variable">$item</span>&quot;</span>)    &#125;&#125;</code></pre></div><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-string">&quot;Sandy&quot;</span>)    <span class="hljs-comment">// 解构赋值</span>    <span class="hljs-keyword">val</span> (origin,dest,proxy) = list    println(<span class="hljs-string">&quot;<span class="hljs-variable">$origin</span> <span class="hljs-variable">$dest</span> <span class="hljs-variable">$proxy</span>&quot;</span>)&#125;</code></pre></div><p>当想跳过某个元素，则用下划线代替。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-keyword">val</span> (origin, _, proxy) = listprintln(<span class="hljs-string">&quot;<span class="hljs-variable">$origin</span> <span class="hljs-variable">$proxy</span>&quot;</span>)<span class="hljs-comment">// 输出</span><span class="hljs-comment">// Yorick Sandy</span></code></pre></div><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><p>通过setOf创建set集合，使用elementAt函数读取集合中的元素。</p><h3 id="Set创建与元素获取"><a href="#Set创建与元素获取" class="headerlink" title="Set创建与元素获取"></a>Set创建与元素获取</h3><p>setOf：创建集合<br>elementAt：获取集合</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 重复元素自动覆盖</span>    <span class="hljs-keyword">val</span> <span class="hljs-keyword">set</span> = setOf(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-string">&quot;Sandy&quot;</span>,<span class="hljs-string">&quot;Yorick&quot;</span>)    println(<span class="hljs-keyword">set</span>.elementAt(<span class="hljs-number">2</span>)) <span class="hljs-comment">// Sandy</span>&#125;</code></pre></div><h3 id="可变集合"><a href="#可变集合" class="headerlink" title="可变集合"></a>可变集合</h3><p>通过mutableSetOf创建可变的set集合</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> mutableSet = mutableSetOf(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-string">&quot;Sandy&quot;</span>, <span class="hljs-string">&quot;Yorick&quot;</span>)    mutableSet += <span class="hljs-string">&quot;Morty&quot;</span>    mutableSet.forEach &#123;        println(it)    &#125;&#125;</code></pre></div><h3 id="集合转换和快捷去重"><a href="#集合转换和快捷去重" class="headerlink" title="集合转换和快捷去重"></a>集合转换和快捷去重</h3><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 通过集合转换函数去重</span>    <span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-string">&quot;Sandy&quot;</span>, <span class="hljs-string">&quot;Yorick&quot;</span>)        .toSet()        .toList()    println(list)    <span class="hljs-comment">// 快捷操作</span>    println(listOf(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-string">&quot;Sandy&quot;</span>, <span class="hljs-string">&quot;Yorick&quot;</span>).distinct())&#125;<span class="hljs-comment">// 都输出</span><span class="hljs-comment">// [Yorick, Jerry, Sandy]</span></code></pre></div><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Kotlin提供各种Array，虽然是引用类型，但可以编译成Java基本数据类型。</p><table><thead><tr><th>数组类型</th><th>创建函数</th></tr></thead><tbody><tr><td>lntArray</td><td>intArrayOf</td></tr><tr><td>DoubleArray</td><td>doubleArrayOf</td></tr><tr><td>LongArray</td><td>longArrayOf</td></tr><tr><td>ShortArray</td><td>shortArrayOf</td></tr><tr><td>ByteArray</td><td>byteArrayOf</td></tr><tr><td>FloatArray</td><td>floatArrayOf</td></tr><tr><td>BooleanArray</td><td>booleanArrayOf</td></tr><tr><td>Array</td><td>arrayOf</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> intArrayOf = intArrayOf(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)    <span class="hljs-comment">// list可以直接转换为array</span>    listOf(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>).toIntArray()    <span class="hljs-comment">// 对象数组</span>    <span class="hljs-keyword">val</span> arrayList = arrayListOf(File(<span class="hljs-string">&quot;xxx&quot;</span>), File(<span class="hljs-string">&quot;yyy&quot;</span>), File(<span class="hljs-string">&quot;zzz&quot;</span>))&#125;</code></pre></div><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Map的创建"><a href="#Map的创建" class="headerlink" title="Map的创建"></a>Map的创建</h3><p>使用mapOf创建Map</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 创建Map</span>    <span class="hljs-keyword">val</span> map = mapOf(<span class="hljs-string">&quot;Yorick&quot;</span> to <span class="hljs-number">21</span>, <span class="hljs-string">&quot;Lily&quot;</span> to <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Jerry&quot;</span> to <span class="hljs-number">17</span>)    <span class="hljs-comment">// 等价方式</span>    mapOf(Pair(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-number">21</span>), Pair(<span class="hljs-string">&quot;Lily&quot;</span>, <span class="hljs-number">20</span>))&#125;</code></pre></div><h3 id="读取Map的值"><a href="#读取Map的值" class="headerlink" title="读取Map的值"></a>读取Map的值</h3><ul><li><code>[]</code>取值运算符，读取键对应的值，如果键不存在就返回null</li><li><code>getValue</code>，读取键对应的值，如果键不存在就抛出异常</li><li><code>getOrElse</code>，读取键对应的值，或者使用匿名函数返回默认值</li><li><code>getOrDefault</code>，读取键对应的值，或者返回默认值</li></ul><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> map = mapOf(<span class="hljs-string">&quot;Yorick&quot;</span> to <span class="hljs-number">21</span>, <span class="hljs-string">&quot;Lily&quot;</span> to <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Jerry&quot;</span> to <span class="hljs-number">17</span>)    println(map[<span class="hljs-string">&quot;Yorick&quot;</span>]) <span class="hljs-comment">// 21</span>    println(map.getValue(<span class="hljs-string">&quot;Yorick&quot;</span>)) <span class="hljs-comment">// 21</span>    println(map.getOrElse(<span class="hljs-string">&quot;Rose&quot;</span>) &#123; <span class="hljs-string">&quot;NOTHING&quot;</span> &#125;) <span class="hljs-comment">// NOTHING</span>    println(map.getOrDefault(<span class="hljs-string">&quot;Rose&quot;</span>,<span class="hljs-number">0</span>)) <span class="hljs-comment">// 0</span>&#125;</code></pre></div><h3 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h3><p>还是用forEach</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> map = mapOf(<span class="hljs-string">&quot;Yorick&quot;</span> to <span class="hljs-number">21</span>, <span class="hljs-string">&quot;Lily&quot;</span> to <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Jerry&quot;</span> to <span class="hljs-number">17</span>)    <span class="hljs-comment">// 遍历Map</span>    map.forEach &#123;        println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;it.key&#125;</span> : <span class="hljs-subst">$&#123;it.value&#125;</span>&quot;</span>)    &#125;    map.forEach &#123; (key: String, value: <span class="hljs-built_in">Int</span>) -&gt;        println(<span class="hljs-string">&quot;<span class="hljs-variable">$key</span> : <span class="hljs-variable">$value</span>&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 都输出</span><span class="hljs-comment">// Yorick : 21</span><span class="hljs-comment">// Lily : 20</span><span class="hljs-comment">// Jerry : 17</span></code></pre></div><h3 id="可变Map"><a href="#可变Map" class="headerlink" title="可变Map"></a>可变Map</h3><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> mutableMap = mutableMapOf(<span class="hljs-string">&quot;Yorick&quot;</span> to <span class="hljs-number">21</span>, <span class="hljs-string">&quot;Lily&quot;</span> to <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Jerry&quot;</span> to <span class="hljs-number">17</span>)    mutableMap += <span class="hljs-string">&quot;Morty&quot;</span> to <span class="hljs-number">16</span>    <span class="hljs-comment">// 使用put增加</span>    mutableMap.put(<span class="hljs-string">&quot;Morty&quot;</span>, <span class="hljs-number">15</span>)    <span class="hljs-comment">// 获取不到则放入</span>    mutableMap.getOrPut(<span class="hljs-string">&quot;kimmy&quot;</span>) &#123; <span class="hljs-number">11</span> &#125;&#125;</code></pre></div><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>使用kotlin实现Stack与LinkedList</p><p><a href="https://cloud.tencent.com/developer/article/1741702">Kotlin中Stack与LinkedList的实现方法示例 - 腾讯云开发者社区-</a></p>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Collection</tag>
      
      <tag>Set</tag>
      
      <tag>List</tag>
      
      <tag>Map</tag>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin标准库函数</title>
    <link href="/Kotlin/Kotlin%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <url>/Kotlin/Kotlin%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="标准库函数"><a href="#标准库函数" class="headerlink" title="标准库函数"></a>标准库函数</h2><ul><li><a href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0">标准库函数</a><ul><li><a href="#apply">apply</a></li><li><a href="#let">let</a></li><li><a href="#run">run</a></li><li><a href="#with">with</a></li><li><a href="#also">also</a></li><li><a href="#takeif">takeIf</a></li><li><a href="#takeunless">takeUnless</a></li></ul></li></ul><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply函数可看作一个配置函数，你可以传入一个接收者，然后调用一系列配置以便它使用，如果提供lambda给apply函数执行，它会返回配置好的接收者。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 配置一个File实例</span>    <span class="hljs-keyword">val</span> file1 = File(<span class="hljs-string">&quot;E://demo.txt&quot;</span>)    file1.setReadable(<span class="hljs-literal">true</span>)    file1.setWritable(<span class="hljs-literal">true</span>)    file1.setExecutable(<span class="hljs-literal">false</span>)    <span class="hljs-comment">// 使用apply</span>    <span class="hljs-keyword">val</span> file2 = File(<span class="hljs-string">&quot;E://demo.txt&quot;</span>).apply &#123;        <span class="hljs-comment">// 这里可以省略this</span>        <span class="hljs-comment">// 所有操作默认接收者为file2</span>        <span class="hljs-comment">// 这也叫隐式调用</span>        setReadable(<span class="hljs-literal">true</span>)        setWritable(<span class="hljs-literal">true</span>)        setExecutable(<span class="hljs-literal">false</span>)    &#125;&#125;</code></pre></div><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>和上面apply差不多，但是会返回lambda函数的最后一行的结果，并赋值给接收者，但是不支持隐式调用。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 求集合第一个元素的平方</span>    <span class="hljs-keyword">val</span> res = listOf(<span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>).first().let &#123;        it * it    &#125;    println(res)    <span class="hljs-comment">// 不用let</span>    <span class="hljs-keyword">val</span> firstElement = listOf(<span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>).first()    <span class="hljs-keyword">val</span> res2 = firstElement * firstElement    println(res2)&#125;</code></pre></div><p>配合安全操作符使用。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    println(formatGreeting(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// What&#x27;s your name?</span>    println(formatGreeting(<span class="hljs-string">&quot;Yorick&quot;</span>)) <span class="hljs-comment">// Hello! Yorick.</span>    println(formatGreeting1(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// What&#x27;s your name?</span>    println(formatGreeting1(<span class="hljs-string">&quot;Yorick&quot;</span>)) <span class="hljs-comment">// Hello! Yorick.</span>&#125;<span class="hljs-comment">// 使用let进行链式调用</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">formatGreeting</span><span class="hljs-params">(guestName: <span class="hljs-type">String</span>?)</span></span>: String &#123;    <span class="hljs-keyword">return</span> guestName?.let &#123;        <span class="hljs-string">&quot;Hello! <span class="hljs-variable">$it</span>.&quot;</span>    &#125; ?: <span class="hljs-string">&quot;What&#x27;s your name?&quot;</span>&#125;<span class="hljs-comment">// 传统方式</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">formatGreeting1</span><span class="hljs-params">(guestName: <span class="hljs-type">String</span>?)</span></span>: String &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (guestName != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-string">&quot;Hello! <span class="hljs-variable">$guestName</span>.&quot;</span>    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-string">&quot;What&#x27;s your name?&quot;</span>    &#125;&#125;</code></pre></div><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>结合了let和apply，可以像let一样返回lambda最后一行结果，同时可以像apply一样隐式调用。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 判断文件是否包含某字符</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> file = File(<span class="hljs-string">&quot;E://demo.txt&quot;</span>)    <span class="hljs-keyword">val</span> res = file.run &#123;        readText().contains(<span class="hljs-string">&quot;demo&quot;</span>)    &#125;    println(res) <span class="hljs-comment">// true</span>&#125;</code></pre></div><p>另外，run也能用来执行函数引用</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">//::表示把一个方法当做一个参数，传递到另一个方法中进行使用，通俗的来讲就是引用一个方法。</span>    <span class="hljs-string">&quot;The People&#x27;s Republic of China&quot;</span>        .run(::isLong)        .run(::showMessage)        .run(::println)&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isLong</span><span class="hljs-params">(str: <span class="hljs-type">String</span>)</span></span> = str.length &gt;= <span class="hljs-number">10</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showMessage</span><span class="hljs-params">(isLong: <span class="hljs-type">Boolean</span>)</span></span>: String &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (isLong) &#123;        <span class="hljs-string">&quot;String is too long!&quot;</span>    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-string">&quot;OK!&quot;</span>    &#125;&#125;<span class="hljs-comment">// 输出</span><span class="hljs-comment">// String is too long!</span></code></pre></div><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with函数是run的变体，他们的功能行为是一样的，但with的调用方式不同，调用with时需要值参作为其第一个参数传入。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 使用run</span>    <span class="hljs-keyword">val</span> res1 = <span class="hljs-string">&quot;The People&#x27;s Republic of China&quot;</span>.run &#123;        length &gt; <span class="hljs-number">10</span>    &#125;    println(res1)    <span class="hljs-comment">// 使用with</span>    <span class="hljs-keyword">val</span> res2 = with(<span class="hljs-string">&quot;The People&#x27;s Republic of China&quot;</span>) &#123;        length &gt; <span class="hljs-number">10</span>    &#125;    println(res2)&#125;<span class="hljs-comment">// 输出</span><span class="hljs-comment">// true</span><span class="hljs-comment">// true</span></code></pre></div><h3 id="also"><a href="#also" class="headerlink" title="also"></a>also</h3><p>和let相似，把接收者传给lambda，但是返回的是原始对象，常用于链式调用。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> fileContents: List&lt;String&gt;    File(<span class="hljs-string">&quot;E://demo.txt&quot;</span>)        .also &#123;            println(it.name)        &#125;.also &#123;            fileContents = it.readLines()        &#125;    println(fileContents)&#125;<span class="hljs-comment">// 输出示例</span><span class="hljs-comment">// demo.txt</span><span class="hljs-comment">// [demo, demo, hhhh, edited by Yorick, 2022年9月8日11点32分]</span></code></pre></div><h3 id="takeIf"><a href="#takeIf" class="headerlink" title="takeIf"></a>takeIf</h3><p>类似if，判断接收者是否满足lambda的表达式，满足返回接收者，不满足则返回null。</p><div class="code-wrapper"><pre><code class="hljs kt"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> res = File(<span class="hljs-string">&quot;E://demo.txt&quot;</span>)        .takeIf &#123; it.exists() &amp;&amp; it.canRead() &#125;        ?.readText()    println(res)&#125;<span class="hljs-comment">// 输出文件内容</span></code></pre></div><h3 id="takeUnless"><a href="#takeUnless" class="headerlink" title="takeUnless"></a>takeUnless</h3><p>takeIf的否定，false才返回对象，true返回null</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> res = File(<span class="hljs-string">&quot;E://demo.txt&quot;</span>)        .takeUnless &#123; it.isHidden &#125;        ?.readText()    println(res)&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin数字类型</title>
    <link href="/Kotlin/Kotlin%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B/"/>
    <url>/Kotlin/Kotlin%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><ul><li><a href="#%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B">数字类型</a><ul><li><a href="#%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B-1">数字类型</a></li><li><a href="#%E5%AE%89%E5%85%A8%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0">安全转换函数</a></li><li><a href="#double%E8%BD%ACint">Double转Int</a></li><li><a href="#double%E7%B1%BB%E5%9E%8B%E6%A0%BC%E5%BC%8F%E5%8C%96">Double类型格式化</a></li></ul></li></ul><h3 id="数字类型-1"><a href="#数字类型-1" class="headerlink" title="数字类型"></a>数字类型</h3><p>和Java一样，Kotlin的数字类型都是有符号的，也就是说正负数都可以表示。</p><table><thead><tr><th>类型</th><th>位</th><th>最大值</th><th>最小值</th></tr></thead><tbody><tr><td>Byte</td><td>8</td><td>127</td><td>-128</td></tr><tr><td>Short</td><td>16</td><td>32767</td><td>-32768</td></tr><tr><td>Int</td><td>32</td><td>2147483647</td><td>-2147483648</td></tr><tr><td>Long</td><td>64</td><td>9223372036854775807</td><td>-9223372036854775808</td></tr><tr><td>Float</td><td>32</td><td>3.4028235E38</td><td>1.4E-45</td></tr><tr><td>Double</td><td>64</td><td>1.7976931348623157E308</td><td>4.9E-324</td></tr></tbody></table><h3 id="安全转换函数"><a href="#安全转换函数" class="headerlink" title="安全转换函数"></a>安全转换函数</h3><p>Kotlin提供了<code>toDoubleOrNull</code>和<code>tolntOrNull</code>这样的安全转换函数，如果数值不能正确转换，与其触发异常不如干脆返回<code>null</code>值。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> number: <span class="hljs-built_in">Int</span> = <span class="hljs-string">&quot;9.99&quot;</span>.toInt()    println(number)&#125;<span class="hljs-comment">// 抛异常</span><span class="hljs-comment">// NumberFormatException</span></code></pre></div><p>使用安全转换函数</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> number: <span class="hljs-built_in">Int</span>? = <span class="hljs-string">&quot;9.99&quot;</span>.toIntOrNull()    println(number)&#125;<span class="hljs-comment">// 输出</span><span class="hljs-comment">// null</span></code></pre></div><h3 id="Double转Int"><a href="#Double转Int" class="headerlink" title="Double转Int"></a>Double转Int</h3><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 直接取小数点前，精度损失</span>    println(<span class="hljs-number">8.9999994522</span>.toInt()) <span class="hljs-comment">// 8</span>    <span class="hljs-comment">// 四舍五入转换</span>    println(<span class="hljs-number">8.9999994522</span>.roundToInt()) <span class="hljs-comment">// 9</span>&#125;</code></pre></div><h3 id="Double类型格式化"><a href="#Double类型格式化" class="headerlink" title="Double类型格式化"></a>Double类型格式化</h3><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> s = <span class="hljs-string">&quot;%.2f&quot;</span>.format(<span class="hljs-number">8.9199994522</span>)    println(s) <span class="hljs-comment">// 8.92</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin字符串</title>
    <link href="/Kotlin/Kotlin%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/Kotlin/Kotlin%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>[TOC]</p><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><h4 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h4><p>substring函数支持IntRange类型（表示一个整数范围的类型）的参数，until创建的范围不包括上限值。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> NAME = <span class="hljs-string">&quot;Jerry Smith&quot;</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> index = NAME.indexOf(<span class="hljs-string">&quot; &quot;</span>)    <span class="hljs-comment">// Java方式</span>    <span class="hljs-keyword">var</span> str = NAME.substring(<span class="hljs-number">0</span>, index)    println(str)    <span class="hljs-comment">// Kotlin方式</span>    str = NAME.substring(<span class="hljs-number">0</span> until index)    println(str)&#125;<span class="hljs-comment">// 输出</span><span class="hljs-comment">// Jerry</span><span class="hljs-comment">// Jerry</span></code></pre></div><h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p>split函数返回的是List集合数据，List集合又支持解构语法特性，它允许你在一个表达式里给多个变量赋值，解构常用来简化变量的赋值。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> NAMES = <span class="hljs-string">&quot;Jerry,Morty,Yorick&quot;</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = NAMES.split(<span class="hljs-string">&quot;,&quot;</span>)    <span class="hljs-comment">// data[0]</span>    <span class="hljs-comment">// 结构语法</span>    <span class="hljs-keyword">val</span> (origin, dest, proxy) = NAMES.split(<span class="hljs-string">&quot;,&quot;</span>)    println(<span class="hljs-string">&quot;<span class="hljs-variable">$origin</span> <span class="hljs-variable">$dest</span> <span class="hljs-variable">$proxy</span>&quot;</span>)&#125;<span class="hljs-comment">// 输出</span><span class="hljs-comment">// Jerry Morty Yorick</span></code></pre></div><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>replace 字符串替换</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> str = <span class="hljs-string">&quot;The People&#x27;s Republic of China&quot;</span>    <span class="hljs-keyword">val</span> reStr = str.replace(Regex(<span class="hljs-string">&quot;[anxious]&quot;</span>)) &#123;        <span class="hljs-keyword">when</span> (it.value) &#123;            <span class="hljs-string">&quot;a&quot;</span> -&gt; <span class="hljs-string">&quot;6&quot;</span>            <span class="hljs-string">&quot;n&quot;</span> -&gt; <span class="hljs-string">&quot;3&quot;</span>            <span class="hljs-string">&quot;x&quot;</span> -&gt; <span class="hljs-string">&quot;2&quot;</span>            <span class="hljs-string">&quot;i&quot;</span> -&gt; <span class="hljs-string">&quot;5&quot;</span>            <span class="hljs-string">&quot;o&quot;</span> -&gt; <span class="hljs-string">&quot;4&quot;</span>            <span class="hljs-string">&quot;u&quot;</span> -&gt; <span class="hljs-string">&quot;0&quot;</span>            <span class="hljs-string">&quot;s&quot;</span> -&gt; <span class="hljs-string">&quot;7&quot;</span>            <span class="hljs-keyword">else</span> -&gt; it.value        &#125;    &#125;    println(str)    println(reStr)&#125;<span class="hljs-comment">// 输出</span><span class="hljs-comment">// The People&#x27;s Republic of China</span><span class="hljs-comment">// The Pe4ple&#x27;7 Rep0bl5c 4f Ch536</span></code></pre></div><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>在Kotlin中，用<code>==</code>检查两个字符串中的字符是否匹配，用<code>===</code>检查两个变量是否指向内存堆上同一对象。而在Java中<code>==</code>做引用比较（是否为同一对象），做内容比较时用<code>equals</code>方法。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> str1 = <span class="hljs-string">&quot;Yorick&quot;</span>    <span class="hljs-keyword">val</span> str2 = <span class="hljs-string">&quot;Yorick&quot;</span>    println(str1==str2)    println(str1===str2)&#125;<span class="hljs-comment">// 输出</span><span class="hljs-comment">// true</span><span class="hljs-comment">// true</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> str1 = <span class="hljs-string">&quot;Yorick&quot;</span>    <span class="hljs-keyword">val</span> str2 = <span class="hljs-string">&quot;yorick&quot;</span>.capitalize()    println(str1 == str2)    println(str1 === str2)&#125;</code></pre></div><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><h3 id="遍历字符"><a href="#遍历字符" class="headerlink" title="遍历字符"></a>遍历字符</h3><p>forEach</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> str1 = <span class="hljs-string">&quot;Yorick&quot;</span>    <span class="hljs-keyword">val</span> str2 = <span class="hljs-string">&quot;yorick&quot;</span>.capitalize()    println(str1 == str2)    println(str1 === str2)    str1.forEach &#123;        print(<span class="hljs-string">&quot;<span class="hljs-variable">$it</span> * &quot;</span>)    &#125;&#125;<span class="hljs-comment">// 输出</span><span class="hljs-comment">// Y * o * r * i * c * k * </span></code></pre></div><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p><a href="https://www.delftstack.com/zh/howto/kotlin/kotlin-string-format/">在 Kotlin 中格式化字符串 | D栈 - Delft Stack</a></p>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin空安全与异常</title>
    <link href="/Kotlin/Kotlinnull%E5%AE%89%E5%85%A8%E4%B8%8E%E5%BC%82%E5%B8%B8/"/>
    <url>/Kotlin/Kotlinnull%E5%AE%89%E5%85%A8%E4%B8%8E%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="null安全与异常"><a href="#null安全与异常" class="headerlink" title="null安全与异常"></a>null安全与异常</h2><ul><li><a href="#null%E5%AE%89%E5%85%A8%E4%B8%8E%E5%BC%82%E5%B8%B8">null安全与异常</a><ul><li><a href="#%E5%8F%AF%E7%A9%BA%E6%80%A7">可空性</a></li><li><a href="#null%E5%AE%89%E5%85%A8">null安全</a><ul><li><a href="#%E5%AE%89%E5%85%A8%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6">安全调用操作符</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%B8%A6let%E7%9A%84%E5%AE%89%E5%85%A8%E8%B0%83%E7%94%A8">使用带let的安全调用</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6">使用!!.操作符</a></li><li><a href="#%E4%BD%BF%E7%94%A8if%E5%88%A4%E6%96%ADnull%E5%80%BC">使用if判断null值</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E7%A9%BA%E5%90%88%E5%B9%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F">使用空合并表达式</a></li></ul></li><li><a href="#%E5%BC%82%E5%B8%B8">异常</a></li><li><a href="#%E5%85%88%E5%86%B3%E6%9D%A1%E4%BB%B6%E5%87%BD%E6%95%B0">先决条件函数</a></li></ul></li></ul><p>Koltin受不了Java里常见的空指针异常，所以做出了改良。Kotlin更多地把运行时可能会出现的null问题，以编译错误的方式，提前在代码编译期强迫我们重视起来。</p><h3 id="可空性"><a href="#可空性" class="headerlink" title="可空性"></a>可空性</h3><p>对于null值问题，Kotlin反其道而行之，除非另有规定，变量不可为null值，这样一来，运行时崩溃从根源上得到解决。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 编译无法通过</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;Hi,Yorick!&quot;</span>    str = <span class="hljs-literal">null</span>&#125;</code></pre></div><p>如果我偏要赋null值呢？</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> str:String? = <span class="hljs-string">&quot;Hi,Yorick!&quot;</span>    str = <span class="hljs-literal">null</span>&#125;</code></pre></div><!-- ### Kotlin的null类型 ### 编译时间与运行时间 --><h3 id="null安全"><a href="#null安全" class="headerlink" title="null安全"></a>null安全</h3><p>Kotlin区分可空类型和非可空类型，所以，你要一个可空类型变量运行，而它又可能不存在，对于这种潜在危险，编译器时刻警惕着。为了应对这种风险，Kotlin不允许你在可空类型值上调用函数，除非你主动接手安全管理。</p><h4 id="安全调用操作符"><a href="#安全调用操作符" class="headerlink" title="安全调用操作符"></a>安全调用操作符</h4><p>直接调用空类型的方法，编译器会报错</p><div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> str:String? = <span class="hljs-string">&quot;Hi,Yorick!&quot;</span>    str = <span class="hljs-literal">null</span>    <span class="hljs-comment">// 下面会报错</span>    println(str.length)&#125;</code></pre></div><p>但是使用安全调用操作符<code>?.</code>，就可有避免，<code>?.</code>的作用为调用者非空才执行。</p><div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> str:String? = <span class="hljs-string">&quot;Hi,Yorick!&quot;</span>    str = <span class="hljs-literal">null</span>    println(str?.length)&#125;</code></pre></div><h4 id="使用带let的安全调用"><a href="#使用带let的安全调用" class="headerlink" title="使用带let的安全调用"></a>使用带let的安全调用</h4><p>安全调用允许在可空类型上调用函数，但是如果还想做点额外的事，比如创建新值，或判断不为null就调用其他函数，怎么办?</p><p>可以使用带let函数的安全调用操作符。你可以在任何类型上调用let函数，它的主要作用是让你在指定的作用域内定义一个或多个变量。</p><div class="code-wrapper"><pre><code class="hljs java">fun <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">var</span> str: String? = <span class="hljs-string">&quot;hi,Yorick!&quot;</span>    str = str?.let &#123;        <span class="hljs-comment">// 非空白的字符串</span>        <span class="hljs-keyword">if</span> (it.isNotBlank()) &#123;            it.capitalize()        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-string">&quot;Hi,Yorick!&quot;</span>        &#125;    &#125;    println(str)&#125;<span class="hljs-comment">// 输出</span><span class="hljs-comment">// Hi,Yorick!</span></code></pre></div><h4 id="使用-操作符"><a href="#使用-操作符" class="headerlink" title="使用!!.操作符"></a>使用!!.操作符</h4><p><code>!!.</code>非空断言操作符，强制执行方法，会抛出空指针异常。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> str: String? = <span class="hljs-string">&quot;hi,Yorick!&quot;</span>    str = <span class="hljs-literal">null</span>    println(str!!.capitalize())&#125;</code></pre></div><h4 id="使用if判断null值"><a href="#使用if判断null值" class="headerlink" title="使用if判断null值"></a>使用if判断null值</h4><p>这里就是传统Java的使用if判断null值，可以比较一下，Kotlin用一个<code>?</code>就解决了。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> str: String? = <span class="hljs-string">&quot;hi,Yorick!&quot;</span>    <span class="hljs-keyword">if</span> (str != <span class="hljs-literal">null</span>) &#123;        str = str.capitalize()    &#125; <span class="hljs-keyword">else</span> &#123;        println(<span class="hljs-string">&quot;为空&quot;</span>)    &#125;    println(str)&#125;</code></pre></div><p>我们可以使用if判断，但是相比之下安全调用操作符用起来更灵活，代码也更简洁，我们可以用安全操作符进行多个函数的链式调用。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> str: String? = <span class="hljs-string">&quot;hi,Yorick.&quot;</span>    str = str?.capitalize().plus(<span class="hljs-string">&quot;Have a nice day!&quot;</span>)    println(str)&#125;<span class="hljs-comment">// 输出</span><span class="hljs-comment">// Hi,Yorick.Have a nice day!</span></code></pre></div><p>如果第一个<code>?.</code>方法的调用者为空，那么后面的方法都不会被调用。</p><h4 id="使用空合并表达式"><a href="#使用空合并表达式" class="headerlink" title="使用空合并表达式"></a>使用空合并表达式</h4><p><code>?:</code>操作符的意思是，如果左边的求值结果为null，就使用右边的结果值。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> str: String? = <span class="hljs-string">&quot;hi,Yorick.&quot;</span>    str = <span class="hljs-literal">null</span>    println(str ?: <span class="hljs-string">&quot;yeah!&quot;</span>)&#125;<span class="hljs-comment">// 输出</span><span class="hljs-comment">// yeah!</span></code></pre></div><p>空合并操作符也可以和let函数一起使用来代替if&#x2F;else语句。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> str: String? = <span class="hljs-string">&quot;hi,Yorick.&quot;</span>    str = str?.let &#123; it.capitalize() &#125; ?: <span class="hljs-string">&quot;yeah!&quot;</span>    println(str)&#125;</code></pre></div><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常处理：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> number: <span class="hljs-built_in">Int</span>? = <span class="hljs-literal">null</span>    <span class="hljs-keyword">try</span> &#123;        number!!.plus(<span class="hljs-number">1</span>)    &#125; <span class="hljs-keyword">catch</span> (e: KotlinNullPointerException) &#123;        println(e)    &#125;&#125;</code></pre></div><p>自定义异常：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> java.lang.IllegalArgumentException<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> number: <span class="hljs-built_in">Int</span>? = <span class="hljs-literal">null</span>    <span class="hljs-keyword">try</span> &#123;        checkOperation(number)        number!!.plus(<span class="hljs-number">1</span>)    &#125; <span class="hljs-keyword">catch</span> (e: KotlinNullPointerException) &#123;        println(e)    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkOperation</span><span class="hljs-params">(number: <span class="hljs-type">Int</span>?)</span></span> &#123;    number ?: <span class="hljs-keyword">throw</span> UnskilledException()&#125;<span class="hljs-comment">// 自定义异常</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnskilledException</span> : <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;操作不当&quot;</span>)</code></pre></div><h3 id="先决条件函数"><a href="#先决条件函数" class="headerlink" title="先决条件函数"></a>先决条件函数</h3><p>Kotlin标准库提供了一些便利函数，使用这些内置函数，你可以抛出带自定义信息的异常，这些便利函数叫做先决条件函数，你可以用它定义先决条件，条件必须满足目标代码才能执行。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在上面代码的基础上修改</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkOperation</span><span class="hljs-params">(number: <span class="hljs-type">Int</span>?)</span></span> &#123;    checkNotNull(number) &#123; <span class="hljs-string">&quot;Something is Null!&quot;</span> &#125;&#125;</code></pre></div><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>checkNotNull</td><td>如果参数为null，则抛出IllegalStateException异常，否则返回非null值</td></tr><tr><td>require</td><td>如果参数为false，则抛出IllegalArgumentException异常</td></tr><tr><td>requireNotNull</td><td>如果参数为null，则抛出IllegalStateException异常，否则返回非null值</td></tr><tr><td>error</td><td>如果参数为null，则抛出IllegalStateException异常并输出错误信息，否则返回非null值</td></tr><tr><td>assert</td><td>如果参数为false，则抛出AssertError异常，并打上断言编译器标记</td></tr></tbody></table><!-- ### 已检查异常和未检查异常 ### 可空性如何保证 -->]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异常</tag>
      
      <tag>Exception</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin匿名函数和函数类型</title>
    <link href="/Kotlin/Kotlin%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B/"/>
    <url>/Kotlin/Kotlin%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="匿名函数和函数类型"><a href="#匿名函数和函数类型" class="headerlink" title="匿名函数和函数类型"></a>匿名函数和函数类型</h2><ul><li><a href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B">匿名函数和函数类型</a><ul><li><a href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">匿名函数</a><ul><li><a href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%9A%90%E5%BC%8F%E8%BF%94%E5%9B%9E">函数类型与隐式返回</a></li><li><a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">函数参数</a></li><li><a href="#it%E5%85%B3%E9%94%AE%E5%AD%97">it关键字</a></li></ul></li><li><a href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD">类型推断</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFlambda">什么是lambda</a></li><li><a href="#%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E6%98%AF%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0">定义参数是函数的函数</a></li><li><a href="#%E5%87%BD%E6%95%B0%E5%85%A7%E8%81%94">函数內联</a></li><li><a href="#%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8">函数引用</a></li><li><a href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B">函数类型作为返回值类型</a></li><li><a href="#lambda%E4%B8%8E%E9%97%AD%E5%8C%85">lambda与闭包</a></li><li><a href="#lambda%E4%B8%8E%E5%86%85%E9%83%A8%E5%8C%BF%E5%90%8D%E7%B1%BB">lambda与内部匿名类</a></li></ul></li></ul><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>定义时不取名字的函数，我们称之为匿名函数，匿名函数通常整体传递给其他函数，或者从其他函数返回。</p><p>匿名函数对Kotlin来说很重要，有了它，我们能够根据需要制定特殊规则，轻松定制标准库里的内置函数。</p><div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> total = <span class="hljs-string">&quot;MISSSSSSSYOU&quot;</span>.count()    <span class="hljs-keyword">val</span> count = <span class="hljs-string">&quot;MISSSSSSSYOU&quot;</span>.count(&#123; letter -&gt;        letter == <span class="hljs-string">&#x27;S&#x27;</span>    &#125;)    println(total)    println(count)&#125;</code></pre></div><h4 id="函数类型与隐式返回"><a href="#函数类型与隐式返回" class="headerlink" title="函数类型与隐式返回"></a>函数类型与隐式返回</h4><p>匿名函数也有类型，可以直接赋值给函数类型变量。</p><p>匿名函数一般不需要return，会隐式或自动返回函数体最后一行语句的结果。</p><div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-comment">// 定义变量，类型为返回值为String的匿名函数</span><span class="hljs-keyword">val</span> blessingFun:()-&gt;String = &#123;    <span class="hljs-keyword">val</span> holiday = <span class="hljs-string">&quot;National Day&quot;</span>    <span class="hljs-comment">// 自动返回函数体最后一行语句的结果</span>    <span class="hljs-string">&quot;Happy <span class="hljs-variable">$holiday</span>&quot;</span>&#125;<span class="hljs-comment">// 也可用先声明，后赋值</span><span class="hljs-keyword">val</span> blessingFun:()-&gt;StringblessingFun = &#123;    <span class="hljs-keyword">val</span> holiday = <span class="hljs-string">&quot;National Day&quot;</span>    <span class="hljs-string">&quot;Happy <span class="hljs-variable">$holiday</span>&quot;</span>&#125;</code></pre></div><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>匿名函数需要带参数时，参数的类型放在匿名函数的参数定义中，参数名(形参)放在函数定义中。</p><div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-comment">//               参数类型   返回值类型  参数名(形参)</span><span class="hljs-keyword">val</span> blessingFun: (String) -&gt; String = &#123; name -&gt;    <span class="hljs-keyword">val</span> holiday = <span class="hljs-string">&quot;New Year&quot;</span>    <span class="hljs-string">&quot;<span class="hljs-variable">$name</span>,Happy <span class="hljs-variable">$holiday</span>!&quot;</span>&#125;println(blessingFun(<span class="hljs-string">&quot;Yorick&quot;</span>))<span class="hljs-comment">// 输出</span><span class="hljs-comment">// Yorick,Happy New Year!</span></code></pre></div><h4 id="it关键字"><a href="#it关键字" class="headerlink" title="it关键字"></a>it关键字</h4><p>定义只有一个参数的匿名函数时，可以用<code>it</code>关键字表示参数名。</p><div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> blessingFun: (String) -&gt; String = &#123;    <span class="hljs-keyword">val</span> holiday = <span class="hljs-string">&quot;New Year&quot;</span>    <span class="hljs-comment">// it关键字表示参数名</span>    <span class="hljs-string">&quot;<span class="hljs-variable">$it</span>,Happy <span class="hljs-variable">$holiday</span>&quot;</span>&#125;println(blessingFun(<span class="hljs-string">&quot;Yorick&quot;</span>))<span class="hljs-comment">// 输出</span><span class="hljs-comment">// Yorick,Happy New Year!</span></code></pre></div><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>定义变量时，如果已把匿名函数作为变量赋值，就不需要显式指明变量类型。</p><div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> blessingFun = &#123;    <span class="hljs-keyword">val</span> holiday = <span class="hljs-string">&quot;National Day&quot;</span>    <span class="hljs-string">&quot;Happy <span class="hljs-variable">$holiday</span>&quot;</span>&#125;println(blessingFun())<span class="hljs-comment">// 输出</span><span class="hljs-comment">// Happy National Day</span></code></pre></div><p>当匿名函数有参数时，也可以省略变量类型，但是在匿名函数內要定义参数类型。</p><ul><li>不省略变量类型<div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> blessingFun:(String,<span class="hljs-built_in">Int</span>)-&gt;String=&#123;name,year-&gt;    <span class="hljs-keyword">val</span> holiday = <span class="hljs-string">&quot;New Year&quot;</span>    <span class="hljs-string">&quot;<span class="hljs-variable">$name</span>,Happy <span class="hljs-variable">$holiday</span> <span class="hljs-variable">$year</span>!&quot;</span>&#125;println(blessingFun(<span class="hljs-string">&quot;Yorick&quot;</span>,<span class="hljs-number">2022</span>))<span class="hljs-comment">// 输出</span><span class="hljs-comment">// Yorick,Happy New Year 2022!</span></code></pre></div></li><li>省略变量类型<div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> blessingFun = &#123; name: String, year: <span class="hljs-built_in">Int</span> -&gt;    <span class="hljs-keyword">val</span> holiday = <span class="hljs-string">&quot;New Year&quot;</span>    <span class="hljs-string">&quot;<span class="hljs-variable">$name</span>,Happy <span class="hljs-variable">$holiday</span> <span class="hljs-variable">$year</span>!&quot;</span>&#125;println(blessingFun(<span class="hljs-string">&quot;Yorick&quot;</span>,<span class="hljs-number">2022</span>))<span class="hljs-comment">// 输出</span><span class="hljs-comment">// Yorick,Happy New Year 2022!</span></code></pre></div></li></ul><h3 id="什么是lambda"><a href="#什么是lambda" class="headerlink" title="什么是lambda"></a>什么是lambda</h3><p>我们将匿名函数称为lambda，将它的定义称为lambda表达式，它返回的数据称为lambda结果。</p><h3 id="定义参数是函数的函数"><a href="#定义参数是函数的函数" class="headerlink" title="定义参数是函数的函数"></a>定义参数是函数的函数</h3><p>函数的参数是另一个函数</p><div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> getRefreshWords = &#123; name: String, sec: <span class="hljs-built_in">Int</span> -&gt;        <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;name&#125;</span>还有<span class="hljs-subst">$&#123;sec&#125;</span>秒刷新！&quot;</span>    &#125;    showOnBoard(<span class="hljs-string">&quot;主宰&quot;</span>, getRefreshWords)&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showOnBoard</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, getRefreshWords: (<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>)</span></span> &#123;    <span class="hljs-keyword">val</span> sec = (<span class="hljs-number">1.</span><span class="hljs-number">.60</span>).shuffled().last()    println(getRefreshWords(name, sec))&#125;<span class="hljs-comment">// 输出示例</span><span class="hljs-comment">// 主宰还有18秒刷新！</span></code></pre></div><p>可怕的是，它还有省略写法！</p><p>如果一个函数的lambda参数排在最后，或者是唯一的参数，那么括住lambda值参的一对圆括号就可以稍等。</p><div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    showOnBoard(<span class="hljs-string">&quot;主宰&quot;</span>) &#123; name: String, sec: <span class="hljs-built_in">Int</span> -&gt;        <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;name&#125;</span>还有<span class="hljs-subst">$&#123;sec&#125;</span>秒刷新！&quot;</span>    &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showOnBoard</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, getRefreshWords: (<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>)</span></span> &#123;    <span class="hljs-keyword">val</span> sec = (<span class="hljs-number">1.</span><span class="hljs-number">.60</span>).shuffled().last()    println(getRefreshWords(name, sec))&#125;<span class="hljs-comment">// 输出示例</span><span class="hljs-comment">// 主宰还有18秒刷新！</span></code></pre></div><h3 id="函数內联"><a href="#函数內联" class="headerlink" title="函数內联"></a>函数內联</h3><p>lambda使用方便灵活，但是灵活是有代价的。<br>在JVM上，你定义的lambda会以对象的实例形式存在，JVM会为所有同lambda打交道的变量分配内存，这就产生了内存开销，这会带来严重的性能问题。幸运的是，kotlin有一种优化机制叫内联，有了内联，JVM就不需要使用lambda对象实例了，因而避免了变量内存分配。哪里需要使用lambda，编译器就会将函数体复制粘贴到哪里。</p><p>没有使用内联的Kotlin代码</p><div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> getRefreshWords = &#123; name: String, sec: <span class="hljs-built_in">Int</span> -&gt;        <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;name&#125;</span>还有<span class="hljs-subst">$&#123;sec&#125;</span>秒刷新！&quot;</span>    &#125;    showOnBoard(<span class="hljs-string">&quot;主宰&quot;</span>, getRefreshWords)&#125;<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showOnBoard</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, getRefreshWords: (<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>)</span></span> &#123;    <span class="hljs-keyword">val</span> sec = (<span class="hljs-number">1.</span><span class="hljs-number">.60</span>).shuffled().last()    println(getRefreshWords(name, sec))&#125;</code></pre></div><p>反编译成Java的部分代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnonymousFunc2Kt</span> &#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;      <span class="hljs-type">Function2</span> <span class="hljs-variable">getRefreshWords</span> <span class="hljs-operator">=</span> (Function2)<span class="hljs-literal">null</span>.INSTANCE;      showOnBoard(<span class="hljs-string">&quot;主宰&quot;</span>, getRefreshWords);   &#125;   <span class="hljs-comment">// $FF: synthetic method</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] var0)</span> &#123;      main();   &#125;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showOnBoard</span><span class="hljs-params">(String name, Function2 getRefreshWords)</span> &#123;      <span class="hljs-type">byte</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;      <span class="hljs-type">int</span> <span class="hljs-variable">sec</span> <span class="hljs-operator">=</span> ((Number)CollectionsKt.last(CollectionsKt.shuffled((Iterable)(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntRange</span>(var3, <span class="hljs-number">60</span>))))).intValue();      <span class="hljs-type">Object</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> getRefreshWords.invoke(name, sec);      System.out.println(var4);   &#125;&#125;</code></pre></div><p>我们发现main函数里只有两行代码，需要调用实例化后的lambda函数才能运行。</p><p>在函数showOnBoard的private后加入inline</p><div class="code-wrapper"><pre><code class="hljs Kotlin">...<span class="hljs-keyword">private</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showOnBoard</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, getRefreshWords: (<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>)</span></span>...</code></pre></div><p>此时反编译后的Java代码的主方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">Function2</span> <span class="hljs-variable">getRefreshWords</span> <span class="hljs-operator">=</span> (Function2)<span class="hljs-literal">null</span>.INSTANCE;    <span class="hljs-type">String</span> <span class="hljs-variable">name$iv</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;主宰&quot;</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">$i$f$showOnBoard</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-type">byte</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">sec$iv</span> <span class="hljs-operator">=</span> ((Number)CollectionsKt.last(CollectionsKt.shuffled((Iterable)(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntRange</span>(var3, <span class="hljs-number">60</span>))))).intValue();    <span class="hljs-type">Object</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> getRefreshWords.invoke(name$iv, sec$iv);    System.out.println(var5);&#125;</code></pre></div><p>我们发现主方法多了很多，这是因为他复制了lambda函数体里的代码，直接运行，不再去实例化lambda函数。</p><p>但是，使用lambda递归函数无法内联，因为会导致复制粘贴无限循环，编译会发出警告。</p><p>例如，这里的递归函数就不能使用内联。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, show)&#125;<span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><span class="hljs-keyword">val</span> show: (<span class="hljs-built_in">Int</span>) -&gt; (String) = &#123;    println(it)    it.toString()&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>, num2: <span class="hljs-type">Int</span>, show: (<span class="hljs-type">Int</span>) -&gt; (<span class="hljs-type">String</span>))</span></span> &#123;    sum = num1 + num2    <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">100</span>) &#123;        show(sum)        <span class="hljs-comment">// 递归</span>        add(num2, sum, show)    &#125;&#125;</code></pre></div><h3 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h3><p>要把函数作为参数传给其他函数使用，除了传lambda表达式，kotlin还提供了其他方法，传递函数引用，函数引用可以把一个具名函数转换成一个值参，可以使用lambda表达式的地方，都可以使用函数引用。</p><div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// ::表示把一个方法当做一个参数，传递到另一个方法中进行使用，通俗的来讲就是引用一个方法。</span>    showOnBoard(<span class="hljs-string">&quot;主宰&quot;</span>, ::getRefreshWords)&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getRefreshWords</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, sec: <span class="hljs-type">Int</span>)</span></span>: String &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;name&#125;</span>还有<span class="hljs-subst">$&#123;sec&#125;</span>秒刷新！&quot;</span>&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showOnBoard</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, getRefreshWords: (<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>)</span></span> &#123;    <span class="hljs-keyword">val</span> sec = (<span class="hljs-number">1.</span><span class="hljs-number">.60</span>).shuffled().last()    println(getRefreshWords(name, sec))&#125;</code></pre></div><h3 id="函数类型作为返回值类型"><a href="#函数类型作为返回值类型" class="headerlink" title="函数类型作为返回值类型"></a>函数类型作为返回值类型</h3><div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> getRefreshWords = configRefreshWords()    println(getRefreshWords(<span class="hljs-string">&quot;主宰&quot;</span>))&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">configRefreshWords</span><span class="hljs-params">()</span></span>: (String) -&gt; String &#123;    <span class="hljs-keyword">val</span> sec = (<span class="hljs-number">1.</span><span class="hljs-number">.60</span>).shuffled().last()    <span class="hljs-keyword">return</span> &#123; name: String -&gt;        <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;name&#125;</span>还有<span class="hljs-subst">$&#123;sec&#125;</span>秒刷新！&quot;</span>    &#125;&#125;<span class="hljs-comment">// 输出示例</span><span class="hljs-comment">// 主宰还54有秒刷新！</span></code></pre></div><h3 id="lambda与闭包"><a href="#lambda与闭包" class="headerlink" title="lambda与闭包"></a>lambda与闭包</h3><p>闭包：能够读取其他函数内部变量的函数</p><p>在Kotlin中，匿名函数能修改并引用定义在自己的作用域之外的变量。lambda就是匿名函数，所以Kotlin中的lambda就是闭包。</p><h3 id="lambda与内部匿名类"><a href="#lambda与内部匿名类" class="headerlink" title="lambda与内部匿名类"></a>lambda与内部匿名类</h3><p>我们知道Kotlin可以把函数作为另一个函数的参数，那如何用Java实现呢？</p><p>这就要使用Java里的接口和内部类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaAnonymousClass</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        showOnBoard(<span class="hljs-string">&quot;主宰&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRefreshWords</span>());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RefreshWords</span> &#123;        String <span class="hljs-title function_">getRefreshWords</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> sec)</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showOnBoard</span><span class="hljs-params">(String name, RefreshWords refreshWords)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">sec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">60</span>);        System.out.println(refreshWords.getRefreshWords(name, sec));    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRefreshWords</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RefreshWords</span> &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRefreshWords</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> sec)</span> &#123;            <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;还有&quot;</span> + sec + <span class="hljs-string">&quot;秒刷新！&quot;</span>;        &#125;    &#125;&#125;</code></pre></div><p>或者使用匿名内部类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaAnonymousClass</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        showOnBoard(<span class="hljs-string">&quot;主宰&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefreshWords</span>() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRefreshWords</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> sec)</span> &#123;                <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;还有&quot;</span> + sec + <span class="hljs-string">&quot;秒刷新！&quot;</span>;            &#125;        &#125;);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RefreshWords</span> &#123;        String <span class="hljs-title function_">getRefreshWords</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> sec)</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showOnBoard</span><span class="hljs-params">(String name, RefreshWords refreshWords)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">sec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">60</span>);        System.out.println(refreshWords.getRefreshWords(name, sec));    &#125;&#125;</code></pre></div><p>Java8 以后支持lambda表达式，那么main方法可以写成：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    showOnBoard(<span class="hljs-string">&quot;主宰&quot;</span>, (name, sec) -&gt; name + <span class="hljs-string">&quot;还有&quot;</span> + sec + <span class="hljs-string">&quot;秒刷新！&quot;</span>);&#125;</code></pre></div><p>可以看出，还是kotlin的简洁，函数类型可以让开发者少写模式代码，写出更灵活的代码。</p>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin函数</title>
    <link href="/Kotlin/Kotlin%E5%87%BD%E6%95%B0/"/>
    <url>/Kotlin/Kotlin%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Kotlin函数"><a href="#Kotlin函数" class="headerlink" title="Kotlin函数"></a>Kotlin函数</h2><ul><li><a href="#kotlin%E5%87%BD%E6%95%B0">Kotlin函数</a><ul><li><a href="#%E5%87%BD%E6%95%B0%E5%A4%B4">函数头</a></li><li><a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">函数参数</a></li><li><a href="#unit%E5%87%BD%E6%95%B0">Unit函数</a></li><li><a href="#nothing%E7%B1%BB%E5%9E%8B">Nothing类型</a></li><li><a href="#%E5%8F%8D%E5%BC%95%E5%8F%B7%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D">反引号中的函数名</a></li></ul></li></ul><h3 id="函数头"><a href="#函数头" class="headerlink" title="函数头"></a>函数头</h3><div class="code-wrapper"><pre><code class="hljs Kotlin">     <span class="hljs-keyword">private</span>       <span class="hljs-function"><span class="hljs-keyword">fun</span>        <span class="hljs-title">doSomething</span><span class="hljs-params">(age:<span class="hljs-type">Int</span>, flag:<span class="hljs-type">Boolean</span>)</span></span> : String<span class="hljs-comment">// 可见行修饰符  函数声明关键字   函数名            函数参数          返回类型</span></code></pre></div><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>（1）默认值参</p><p>如果不打算传入值参，可以预先给参数指定默认值</p><div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fix</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span>)</span></span> &#123;    println(name + age)&#125;<span class="hljs-comment">// 主函数</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    fix(<span class="hljs-string">&quot;Yorick&quot;</span>)&#125;</code></pre></div><p>（2）具名函数参数</p><p>如果使用命名值参，就可以不用管值参的顺序</p><div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    fix(age = <span class="hljs-number">9</span>, name = <span class="hljs-string">&quot;Jerry&quot;</span>)&#125;</code></pre></div><h3 id="Unit函数"><a href="#Unit函数" class="headerlink" title="Unit函数"></a>Unit函数</h3><p>不是所有函数都有返回值，Kotlin中没有返回值的函数叫Unit函数，也就是说他们的返回类型是Unit。在Kotlin之前，函数不返回任何东西用void描述，意思是”没有返回类型，不会带来什么，忽略它”，也就是说如果函数不返回任何东西，就忽略类型。但是，void这种解决方案无法解释现代语言的一个重要特征，泛型。</p><div class="code-wrapper"><pre><code class="hljs Kotlin">println(fix(<span class="hljs-string">&quot;Yorick&quot;</span>))<span class="hljs-comment">// 输出</span><span class="hljs-comment">// Yorick6</span><span class="hljs-comment">// kotlin.Unit</span></code></pre></div><h3 id="Nothing类型"><a href="#Nothing类型" class="headerlink" title="Nothing类型"></a>Nothing类型</h3><p>TODO函数的任务就是抛出异常，就是永远别指望它运行成功，返回Nothing类型</p><div class="code-wrapper"><pre><code class="hljs Kotlin">TODO(<span class="hljs-string">&quot;nothing&quot;</span>)<span class="hljs-comment">// 下面语句不会被执行</span>println(<span class="hljs-string">&quot;after nothing&quot;</span>)</code></pre></div><p>TODO函数本身就是返回一个异常</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">TODO</span><span class="hljs-params">(reason: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Nothing</span> = <span class="hljs-keyword">throw</span> NotImplementedError(<span class="hljs-string">&quot;An operation is not implemented: <span class="hljs-variable">$reason</span>&quot;</span>)</code></pre></div><h3 id="反引号中的函数名"><a href="#反引号中的函数名" class="headerlink" title="反引号中的函数名"></a>反引号中的函数名</h3><p>（1）可以给函数起奇怪的名字（小心被打死qaq）</p><div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-comment">// 定义</span><span class="hljs-function"><span class="hljs-keyword">fun</span> `****Yorick <span class="hljs-keyword">is</span> the best****`<span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span>&#123;    println(name+<span class="hljs-string">&quot;666&quot;</span>)&#125;<span class="hljs-comment">// 调用</span>`****Yorick <span class="hljs-keyword">is</span> the best****`(<span class="hljs-string">&quot;Yorick&quot;</span>)<span class="hljs-comment">// 输出</span><span class="hljs-comment">// Yorick666</span></code></pre></div><p>（2）由于Java和Kotlin可以相互调用，但是两者关键字不同，众所周知，关键字不能作为变量名或者标识符，所以有时候要加反引号。</p><ul><li>新建MyJava类定义is静态方法<div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyJava</span> &#123;    <span class="hljs-keyword">public</span> static void <span class="hljs-keyword">is</span>()&#123;        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;IS&quot;</span>);    &#125;&#125;</code></pre></div></li><li>在Kotlin中调用is方法<div class="code-wrapper"><pre><code class="hljs Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    MyJava.`<span class="hljs-keyword">is</span>`();&#125;<span class="hljs-comment">// 输出</span>IS</code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin条件语句</title>
    <link href="/Kotlin/Kotlin%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/"/>
    <url>/Kotlin/Kotlin%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><ul><li><a href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">条件语句</a><ul><li><a href="#ifelse-if%E8%A1%A8%E8%BE%BE%E5%BC%8F">if&#x2F;else if表达式</a></li><li><a href="#range%E8%A1%A8%E8%BE%BE%E5%BC%8F">range表达式</a></li><li><a href="#when%E8%A1%A8%E8%BE%BE%E5%BC%8F">when表达式</a></li><li><a href="#string%E6%A8%A1%E6%9D%BF">string模板</a></li></ul></li></ul><h3 id="if-else-if表达式"><a href="#if-else-if表达式" class="headerlink" title="if&#x2F;else if表达式"></a>if&#x2F;else if表达式</h3><p>同Java</p><h3 id="range表达式"><a href="#range表达式" class="headerlink" title="range表达式"></a>range表达式</h3><p>in A..B，in关键字用来检查某个值是否在指定范围之内。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> age = <span class="hljs-number">4</span><span class="hljs-keyword">if</span> (age <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>)&#123;    println(<span class="hljs-string">&quot;婴幼儿&quot;</span>)&#125;<span class="hljs-keyword">else</span>&#123;    println(<span class="hljs-string">&quot;少儿&quot;</span>)&#125;</code></pre></div><p>否定：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (age !<span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>)&#123;    println(<span class="hljs-string">&quot;少儿&quot;</span>)&#125;</code></pre></div><h3 id="when表达式"><a href="#when表达式" class="headerlink" title="when表达式"></a>when表达式</h3><p>允许你编写条件式，在某个条件满足时，执行对应的代码。</p><p>只要代码包含else if分支，都建议改用when表达式。</p><p>类似switch case，但是更简洁。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> school = <span class="hljs-string">&quot;小学&quot;</span><span class="hljs-keyword">val</span> level = <span class="hljs-keyword">when</span>(school)&#123;    <span class="hljs-string">&quot;学前班&quot;</span> -&gt; <span class="hljs-string">&quot;幼儿&quot;</span>    <span class="hljs-string">&quot;小学&quot;</span> -&gt; <span class="hljs-string">&quot;少儿&quot;</span>    <span class="hljs-string">&quot;中学&quot;</span> -&gt; <span class="hljs-string">&quot;青少年&quot;</span>    <span class="hljs-keyword">else</span> -&gt; &#123;        println(<span class="hljs-string">&quot;未知&quot;</span>)    &#125;&#125;println(level)</code></pre></div><h3 id="string模板"><a href="#string模板" class="headerlink" title="string模板"></a>string模板</h3><p>模板支持在字符串的引号内放入变量值。</p><p>还支持字符串里计算表达式的值并插入结果，添加在<code>$&#123;&#125;</code>中的任何表达式，都会作为字符串的一部分求值。</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> origin = <span class="hljs-string">&quot;Jack&quot;</span>    <span class="hljs-keyword">val</span> dest = <span class="hljs-string">&quot;Rose&quot;</span>    println(<span class="hljs-string">&quot;<span class="hljs-variable">$origin</span> love <span class="hljs-variable">$dest</span>&quot;</span>)    <span class="hljs-keyword">val</span> flag = <span class="hljs-literal">true</span>    println(<span class="hljs-string">&quot;Answer is: <span class="hljs-subst">$&#123;if (flag) <span class="hljs-string">&quot;我愿意&quot;</span> else <span class="hljs-string">&quot;对不起&quot;</span>&#125;</span>&quot;</span>)&#125;</code></pre></div><p>输出：</p><div class="code-wrapper"><pre><code class="hljs kotlin">Jack love RoseAnswer <span class="hljs-keyword">is</span>: 我愿意</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin变量、常量与数据类型</title>
    <link href="/Kotlin/Kotlin%E5%8F%98%E9%87%8F%E3%80%81%E5%B8%B8%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/Kotlin/Kotlin%E5%8F%98%E9%87%8F%E3%80%81%E5%B8%B8%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="变量、常量与数据类型"><a href="#变量、常量与数据类型" class="headerlink" title="变量、常量与数据类型"></a>变量、常量与数据类型</h2><ul><li><a href="#%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">变量、常量与数据类型</a><ul><li><a href="#%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F">声明变量</a></li><li><a href="#%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">内置数据类型</a></li><li><a href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD">类型推断</a></li><li><a href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%B8%B8%E9%87%8F">编译时常量</a></li><li><a href="#kotlin%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">Kotlin的引用类型与基本数据类型</a></li></ul></li></ul><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><div class="code-wrapper"><pre><code class="hljs kotlin">       <span class="hljs-keyword">var</span>        max   :    <span class="hljs-built_in">Int</span>      =     <span class="hljs-number">5</span>;<span class="hljs-comment">// 变量定义关键字 变量名  : 类型定义 赋值运算符 赋值;</span></code></pre></div><p>声明可变变量关键字：<code>var</code><br>声明只读变量关键字：<code>val</code></p><h3 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h3><table><thead><tr><th>类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>String</td><td>字符串</td><td>“Hello World”</td></tr><tr><td>Char</td><td>单字符</td><td>‘A’</td></tr><tr><td>Boolean</td><td>true false</td><td>true false</td></tr><tr><td>Int</td><td>整数</td><td>5</td></tr><tr><td>Double</td><td>小数</td><td>3.14</td></tr><tr><td>List</td><td>元素集合</td><td>1,8,10 “Jack”,”rose”,”Jack”</td></tr><tr><td>Set</td><td>无重复元素的集合</td><td>“Jack”,”Jason”,”Jacky”</td></tr><tr><td>Map</td><td>键值对集合</td><td>“small” to 5, “medium” to 8, “large” to 9</td></tr></tbody></table><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>允许省略类型定义，如：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Yorick&quot;</span>;</code></pre></div><h3 id="编译时常量"><a href="#编译时常量" class="headerlink" title="编译时常量"></a>编译时常量</h3><p>只读变量并非绝对只读。</p><p>编译时常量只能在函数之外定义，因为编译时常量必须在编译时赋值，而函数都是在运行时才调用，函数内的变量也是在运行时赋值，编译时常量要在这些变量赋值前就已存在。</p><p>编译时常量只能是常见的基本数据类型：String、Int、Double、Float、Long、Short、Byte、Char、Boolean。</p><h3 id="Kotlin的引用类型与基本数据类型"><a href="#Kotlin的引用类型与基本数据类型" class="headerlink" title="Kotlin的引用类型与基本数据类型"></a>Kotlin的引用类型与基本数据类型</h3><p>Java有两种数据类型：引用类型与基本数据类型。</p><p>Kotlin只提供引用类型这一种数据类型，出于更高性能的需要，Kotlin编译器会在Java字节码中改用基本数据类型。</p>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>骑士周游问题</title>
    <link href="/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E9%97%AE%E9%A2%98/"/>
    <url>/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="骑士周游问题"><a href="#骑士周游问题" class="headerlink" title="骑士周游问题"></a>骑士周游问题</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>（1）骑士周游问题也被称为马踏棋盘算法</p><p>（2）将马随机放在国际象棋的8×8棋盘Board[0～7][0～7]的某个方格中，马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部64个方格。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>骑士周游问题(马踏棋盘问题)实际上是图的深度优先搜索(DFS)的应用。</p><p>（1）创建棋盘chessBoard，是一个二维数组。</p><p>（2）将当前位置设置为已经访问，然后根据当前位置，计算马儿还能走哪些位置，并放入到一个集合中(ArrayList),最多有8个位置，每走一步，就令step+1。</p><p>（3）遍历ArrayList中存放的所有位置，看看哪个可以走通,如果走通，就继续，走不通，就回溯。</p><p>（4）判断马儿是否完成了任务，使用step和应该走的步数比较，如果没有达到数量，则表示没有完成任务，将整个棋盘置0。</p><p>注意：马儿不同的走法，会得到不同的结果，也会影响效率。这里就可以使用贪心算法进行优化，对ArrayList中存放的所有位置按照下一个可以走通结点集合的个数进行非递减排序。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.*;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KnightTravel</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> X; <span class="hljs-comment">// 棋盘列数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> Y; <span class="hljs-comment">// 棋盘行数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] visited;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> finished;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        X = <span class="hljs-number">8</span>;        Y = <span class="hljs-number">8</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-type">int</span>[][] chessBoard = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[X][Y];        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[X * Y];        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        knightTravel(chessBoard, row - <span class="hljs-number">1</span>, col - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);        <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        System.out.println(endTime - startTime + <span class="hljs-string">&quot;ms&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] rows : chessBoard) &#123;            System.out.println(Arrays.toString(rows));        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chessBoard 棋盘</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> row        当前行</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> col        当前列</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> step       当前步数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">knightTravel</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] chessBoard, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> step)</span> &#123;        chessBoard[row][col] = step;        visited[row * X + col] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 从左到右，从上至下、</span>        ArrayList&lt;Point&gt; points = next(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(col, row));        sort(points);        <span class="hljs-keyword">while</span> (!points.isEmpty()) &#123;            <span class="hljs-type">Point</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> points.remove(<span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span> (!visited[p.y * X + p.x]) &#123;                knightTravel(chessBoard, p.y, p.x, step + <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-keyword">if</span> (step &lt; X * Y &amp;&amp; !finished) &#123;            chessBoard[row][col] = <span class="hljs-number">0</span>;            visited[row * X + col] = <span class="hljs-literal">false</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            finished = <span class="hljs-literal">true</span>;        &#125;    &#125;    <span class="hljs-comment">// 功能:根据当前位置(Point对象)，计算马儿还能走哪些位置(Point)，并放入到一个集合中(ArrayList)，最多有8个位置</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Point&gt; <span class="hljs-title function_">next</span><span class="hljs-params">(Point curPoint)</span> &#123;        ArrayList&lt;Point&gt; points = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-type">Point</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>();        <span class="hljs-comment">// 5</span>        <span class="hljs-keyword">if</span> ((p1.x = curPoint.x - <span class="hljs-number">2</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; (p1.y = curPoint.y - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>) &#123;            points.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(p1));        &#125;        <span class="hljs-comment">// 6</span>        <span class="hljs-keyword">if</span> ((p1.x = curPoint.x - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; (p1.y = curPoint.y - <span class="hljs-number">2</span>) &gt;= <span class="hljs-number">0</span>) &#123;            points.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(p1));        &#125;        <span class="hljs-comment">// 7</span>        <span class="hljs-keyword">if</span> ((p1.x = curPoint.x + <span class="hljs-number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y - <span class="hljs-number">2</span>) &gt;= <span class="hljs-number">0</span>) &#123;            points.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(p1));        &#125;        <span class="hljs-comment">// 0</span>        <span class="hljs-keyword">if</span> ((p1.x = curPoint.x + <span class="hljs-number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>) &#123;            points.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(p1));        &#125;        <span class="hljs-comment">// 1</span>        <span class="hljs-keyword">if</span> ((p1.x = curPoint.x + <span class="hljs-number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y + <span class="hljs-number">1</span>) &lt; Y) &#123;            points.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(p1));        &#125;        <span class="hljs-comment">// 2</span>        <span class="hljs-keyword">if</span> ((p1.x = curPoint.x + <span class="hljs-number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y + <span class="hljs-number">2</span>) &lt; Y) &#123;            points.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(p1));        &#125;        <span class="hljs-comment">// 3</span>        <span class="hljs-keyword">if</span> ((p1.x = curPoint.x - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; (p1.y = curPoint.y + <span class="hljs-number">2</span>) &lt; Y) &#123;            points.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(p1));        &#125;        <span class="hljs-comment">// 4</span>        <span class="hljs-keyword">if</span> ((p1.x = curPoint.x - <span class="hljs-number">2</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; (p1.y = curPoint.y + <span class="hljs-number">1</span>) &lt; Y) &#123;            points.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(p1));        &#125;        <span class="hljs-keyword">return</span> points;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(ArrayList&lt;Point&gt; points)</span> &#123;        points.sort((o1, o2) -&gt; &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">size1</span> <span class="hljs-operator">=</span> next(o1).size();            <span class="hljs-type">int</span> <span class="hljs-variable">size2</span> <span class="hljs-operator">=</span> next(o2).size();            <span class="hljs-keyword">return</span> size1 - size2;        &#125;);    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Floyd算法</title>
    <link href="/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_Floyd%E7%AE%97%E6%B3%95/"/>
    <url>/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_Floyd%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h1><h2 id="弗洛伊德-Floyd-算法介绍"><a href="#弗洛伊德-Floyd-算法介绍" class="headerlink" title="弗洛伊德(Floyd)算法介绍"></a>弗洛伊德(Floyd)算法介绍</h2><p>（1）和Dijkstra算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。</p><p>（2）弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径。</p><p>（3）迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。</p><p>（4）弗洛伊德算法VS迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。</p><h2 id="弗洛伊德-Floyd-算法分析"><a href="#弗洛伊德-Floyd-算法分析" class="headerlink" title="弗洛伊德(Floyd)算法分析"></a>弗洛伊德(Floyd)算法分析</h2><p>（1）设置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi到vj的路径为Lij，则vi到vj的最短路径为: min((Lik+Lkj),Lij)，vk的取值为图中所有顶点，则可获得vi到vj的最短路径</p><p>（2）至于vi到vk的最短路径Lik或者k到vj的最短路径Lkj，是以同样的方式获得</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Floyd</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">char</span>[] vertex = &#123;<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>&#125;;        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[vertex.length][vertex.length];        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">65535</span>; <span class="hljs-comment">// 表示不可连接</span>        matrix[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, N, N, N, <span class="hljs-number">2</span>&#125;;        matrix[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, N, <span class="hljs-number">9</span>, N, N, <span class="hljs-number">3</span>&#125;;        matrix[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">7</span>, N, <span class="hljs-number">0</span>, N, <span class="hljs-number">8</span>, N, N&#125;;        matrix[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;N, <span class="hljs-number">9</span>, N, <span class="hljs-number">0</span>, N, <span class="hljs-number">4</span>, N&#125;;        matrix[<span class="hljs-number">4</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;N, N, <span class="hljs-number">8</span>, N, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;;        matrix[<span class="hljs-number">5</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;N, N, N, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>&#125;;        matrix[<span class="hljs-number">6</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, N, N, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>&#125;;        <span class="hljs-type">Graph</span> <span class="hljs-variable">graph</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>(vertex, matrix);        graph.floyd();        graph.show();    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">private</span> <span class="hljs-type">char</span>[] vertex; <span class="hljs-comment">// 存放顶点的数组</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] dis; <span class="hljs-comment">// 保存从各个顶点出发到其他顶点的距离</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] pre; <span class="hljs-comment">// 保存前驱结点</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Graph</span><span class="hljs-params">(<span class="hljs-type">char</span>[] vertex, <span class="hljs-type">int</span>[][] matrix)</span> &#123;        <span class="hljs-built_in">this</span>.vertex = vertex;        <span class="hljs-built_in">this</span>.dis = matrix;        <span class="hljs-built_in">this</span>.pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[vertex.length][vertex.length];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertex.length; i++) &#123;            Arrays.fill(pre[i], i);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">char</span>[] vertex = &#123;<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>&#125;;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; dis.length; k++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pre.length; i++) &#123;                System.out.print(vertex[pre[k][i]] + <span class="hljs-string">&quot;       &quot;</span>);            &#125;            System.out.println();            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; dis.length; i++) &#123;                System.out.print(vertex[k] + <span class="hljs-string">&quot;-&gt;&quot;</span> + vertex[i] + <span class="hljs-string">&quot;:&quot;</span> + dis[k][i] + <span class="hljs-string">&quot; &quot;</span>);            &#125;            System.out.println();            System.out.println();        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">floyd</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">// k为中间结点</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; vertex.length; k++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertex.length; i++) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; vertex.length; j++) &#123;                    len = dis[i][k] + dis[k][j];                    <span class="hljs-keyword">if</span> (len &lt; dis[i][j]) &#123;                        dis[i][j] = len;                        pre[i][j] = pre[k][j];                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Graph</tag>
      
      <tag>图</tag>
      
      <tag>最短路径</tag>
      
      <tag>Floyd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dijkstra算法</title>
    <link href="/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_Dijkstra%E7%AE%97%E6%B3%95/"/>
    <url>/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_Dijkstra%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉(Dijkstra)算法"></a>迪杰斯特拉(Dijkstra)算法</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>设置出发顶点为v，顶点集合V{v1,v2,vi…}，v到V中各顶点的距离构成距离集合Dis，Dis{d1,d2,di…}]，Dis集合记录着v到图中各顶点的距离(到自身可以看作0，v到vi距离对应为di)</p><p>（1）从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径</p><p>（2）更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到v集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi到达的)</p><p>（3）重复执行两步骤，直到最短路径顶点为目标顶点即可结束</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dijkstra</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">char</span>[] vertex = &#123;<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>&#125;;        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[vertex.length][vertex.length];        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">65535</span>; <span class="hljs-comment">// 表示不可连接</span>        matrix[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;N, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, N, N, N, <span class="hljs-number">2</span>&#125;;        matrix[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">5</span>, N, N, <span class="hljs-number">9</span>, N, N, <span class="hljs-number">3</span>&#125;;        matrix[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">7</span>, N, N, N, <span class="hljs-number">8</span>, N, N&#125;;        matrix[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;N, <span class="hljs-number">9</span>, N, N, N, <span class="hljs-number">4</span>, N&#125;;        matrix[<span class="hljs-number">4</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;N, N, <span class="hljs-number">8</span>, N, N, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;;        matrix[<span class="hljs-number">5</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;N, N, N, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, N, <span class="hljs-number">6</span>&#125;;        matrix[<span class="hljs-number">6</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, N, N, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, N&#125;;        <span class="hljs-type">Graph</span> <span class="hljs-variable">graph</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>(vertex, matrix);        graph.showGraph();        graph.dijkstra(<span class="hljs-number">6</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">private</span> <span class="hljs-type">char</span>[] vertex;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] matrix;    <span class="hljs-keyword">private</span> VisitedVertex vv;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Graph</span><span class="hljs-params">(<span class="hljs-type">char</span>[] vertex, <span class="hljs-type">int</span>[][] matrix)</span> &#123;        <span class="hljs-built_in">this</span>.vertex = vertex;        <span class="hljs-built_in">this</span>.matrix = matrix;    &#125;    <span class="hljs-comment">// 显示图</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showGraph</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] link : matrix) &#123;            System.out.println(Arrays.toString(link));        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;        vv = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VisitedVertex</span>(vertex.length, index);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; vertex.length; j++) &#123;            index = vv.updateArr();            update(index);        &#125;        System.out.println(vv);    &#125;    <span class="hljs-comment">// 更新index下标顶点到周围顶点的距离和周结点的前驱结点</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;        <span class="hljs-type">int</span> len;        vv.visited[index] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; matrix[index].length; j++) &#123;            <span class="hljs-comment">//len含义是;出发顶点到index顶点的距离＋从index顶点到j顶点的距离的和</span>            len = vv.getDis(index) + matrix[index][j];            <span class="hljs-comment">// 如果j顶点没有被访问过，并且 len小于出发顶点到j顶点的距离，就需要更新</span>            <span class="hljs-keyword">if</span> (!vv.in(j) &amp;&amp; len &lt; vv.getDis(j)) &#123;                vv.updatePre(j, index);                vv.updateDis(j, len);            &#125;        &#125;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">VisitedVertex</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] visited;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] pre;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dis;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">VisitedVertex</span><span class="hljs-params">(<span class="hljs-type">int</span> length, <span class="hljs-type">int</span> index)</span> &#123;        <span class="hljs-built_in">this</span>.visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];        <span class="hljs-built_in">this</span>.pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];        <span class="hljs-built_in">this</span>.dis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];        Arrays.fill(dis, <span class="hljs-number">65535</span>);        <span class="hljs-built_in">this</span>.dis[index] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 判断结点是否被访问过</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">in</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;        <span class="hljs-keyword">return</span> visited[index] == <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 更新到index距离</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateDis</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> len)</span> &#123;        dis[index] = len;    &#125;    <span class="hljs-comment">// 更新pre的前驱结点为index</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updatePre</span><span class="hljs-params">(<span class="hljs-type">int</span> pre, <span class="hljs-type">int</span> index)</span> &#123;        <span class="hljs-built_in">this</span>.pre[pre] = index;    &#125;    <span class="hljs-comment">// 返回出发结点到index的距离</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDis</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;        <span class="hljs-keyword">return</span> dis[index];    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateArr</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">65535</span>, index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; visited.length; i++) &#123;            <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-number">0</span> &amp;&amp; dis[i] &lt; min) &#123;                min = dis[i];                index = i;            &#125;        &#125;        <span class="hljs-keyword">return</span> index;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;VisitedVertex&#123;&quot;</span> +                <span class="hljs-string">&quot;visited=&quot;</span> + Arrays.toString(visited) +                <span class="hljs-string">&quot;, pre=&quot;</span> + Arrays.toString(pre) +                <span class="hljs-string">&quot;, dis=&quot;</span> + Arrays.toString(dis) +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>Graph</tag>
      
      <tag>图</tag>
      
      <tag>最短路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kruskal算法</title>
    <link href="/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_Kruskal%E7%AE%97%E6%B3%95/"/>
    <url>/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_Kruskal%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>（1）克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。</p><p>（2）基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。</p><p>（3）具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。</p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：</p><p><strong>问题一</strong>：对图的所有边按照权值大小进行排序。<br><strong>问题二</strong>：将边添加到最小生成树中时，怎么样判断是否形成了回路。</p><p>问题一很好解决，采用排序算法进行排序即可。</p><p>问题二的处理方式是记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。</p><p>关于终点的说明：<br>就是将所有顶点按照从小到大的顺序排列好之后，某个顶点的终点就是”与它连通的最大顶点”。</p><h2 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h2><p>克鲁斯卡尔最佳实践-公交站问题</p><p>（1）有北京有新增7个站点(A,B,C, D,E,F,G)，现在需要修路把7个站点连通。</p><p>（2）各个站点的距离用边线表示(权)，比如A-B距离12公里</p><p>（3）问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短？</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KruskalCase</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> edgeNum;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">private</span> <span class="hljs-type">char</span>[] vertexes;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] matrix;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<span class="hljs-comment">// 表示两个顶点不能连通</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">char</span>[] vertexes = &#123;<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>&#125;;        <span class="hljs-type">int</span>[][] matrix = &#123;                &#123;<span class="hljs-number">0</span>, <span class="hljs-number">12</span>, INF, INF, INF, <span class="hljs-number">16</span>, <span class="hljs-number">14</span>&#125;,                &#123;<span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, INF, INF, <span class="hljs-number">7</span>, INF&#125;,                &#123;INF, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, INF&#125;,                &#123;INF, INF, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, INF, INF&#125;,                &#123;INF, INF, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>&#125;,                &#123;<span class="hljs-number">16</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, INF, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>&#125;,                &#123;<span class="hljs-number">14</span>, INF, INF, INF, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;,        &#125;;        <span class="hljs-type">KruskalCase</span> <span class="hljs-variable">kruskalCase</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KruskalCase</span>(vertexes, matrix);        kruskalCase.print();        kruskalCase.kruskal();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">KruskalCase</span><span class="hljs-params">(<span class="hljs-type">char</span>[] vertexes, <span class="hljs-type">int</span>[][] matrix)</span> &#123;        <span class="hljs-built_in">this</span>.vertexes = vertexes;        <span class="hljs-built_in">this</span>.matrix = matrix;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertexes.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; vertexes.length; j++) &#123;                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.matrix[i][j] != INF) &#123;                    edgeNum++;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">kruskal</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最后结果数组的索引</span>        <span class="hljs-type">int</span>[] ends = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[vertexes.length]; <span class="hljs-comment">// 各个顶点的终点</span>        <span class="hljs-comment">// 结构数组</span>        Edge[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>[edgeNum];        Edge[] edges = getEdges();        sortEdges(edges);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; edgeNum; i++) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> getPos(edges[i].start);            <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> getPos(edges[i].end);            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getEnd(ends, p1);            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> getEnd(ends, p2);            <span class="hljs-keyword">if</span> (m != n) &#123;                ends[m] = n;                res[index] = edges[i];                index++;            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;            System.out.println(res[i]);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;邻接矩阵为：&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertexes.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; vertexes.length; j++) &#123;                System.out.printf(<span class="hljs-string">&quot;%10d\t&quot;</span>, matrix[i][j]);            &#125;            System.out.println();        &#125;    &#125;    <span class="hljs-comment">// 对边进行冒泡排序</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortEdges</span><span class="hljs-params">(Edge[] edges)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; edges.length - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; edges.length - <span class="hljs-number">1</span> - i; j++) &#123;                <span class="hljs-keyword">if</span> (edges[j].weight &gt; edges[j + <span class="hljs-number">1</span>].weight) &#123;                    <span class="hljs-type">Edge</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> edges[j];                    edges[j] = edges[j + <span class="hljs-number">1</span>];                    edges[j + <span class="hljs-number">1</span>] = temp;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPos</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertexes.length; i++) &#123;            <span class="hljs-keyword">if</span> (vertexes[i] == c) &#123;                <span class="hljs-keyword">return</span> i;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">private</span> Edge[] getEdges() &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        Edge[] edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>[edgeNum];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertexes.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; vertexes.length; j++) &#123;                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.matrix[i][j] != INF) &#123;                    edges[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>(vertexes[i], vertexes[j], matrix[i][j]);                    index++;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> edges;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取下标为i的顶点的终点，用于后面判断两个顶点的终点是否重合</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ends 记录各个顶点对应的终点，在遍历过程中逐步形成</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> i    顶点下标</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 下标为i的顶点的终点的下标</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getEnd</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ends, <span class="hljs-type">int</span> i)</span> &#123;        <span class="hljs-keyword">while</span> (ends[i] != <span class="hljs-number">0</span>) &#123;            i = ends[i];        &#125;        <span class="hljs-keyword">return</span> i;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span> &#123;    <span class="hljs-type">char</span> start;    <span class="hljs-type">char</span> end;    <span class="hljs-type">int</span> weight;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Edge</span><span class="hljs-params">(<span class="hljs-type">char</span> start, <span class="hljs-type">char</span> end, <span class="hljs-type">int</span> weight)</span> &#123;        <span class="hljs-built_in">this</span>.start = start;        <span class="hljs-built_in">this</span>.end = end;        <span class="hljs-built_in">this</span>.weight = weight;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Edge&#123;&quot;</span> +                <span class="hljs-string">&quot;start=&quot;</span> + start +                <span class="hljs-string">&quot;, end=&quot;</span> + end +                <span class="hljs-string">&quot;, weight=&quot;</span> + weight +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div><p>输出：</p><div class="code-wrapper"><pre><code class="hljs java">邻接矩阵为：         <span class="hljs-number">0</span>        <span class="hljs-number">12</span><span class="hljs-number">2147483647</span><span class="hljs-number">2147483647</span><span class="hljs-number">2147483647</span>        <span class="hljs-number">16</span>        <span class="hljs-number">14</span>        <span class="hljs-number">12</span>         <span class="hljs-number">0</span>        <span class="hljs-number">10</span><span class="hljs-number">2147483647</span><span class="hljs-number">2147483647</span>         <span class="hljs-number">7</span><span class="hljs-number">2147483647</span><span class="hljs-number">2147483647</span>        <span class="hljs-number">10</span>         <span class="hljs-number">0</span>         <span class="hljs-number">3</span>         <span class="hljs-number">5</span>         <span class="hljs-number">6</span><span class="hljs-number">2147483647</span><span class="hljs-number">2147483647</span><span class="hljs-number">2147483647</span>         <span class="hljs-number">3</span>         <span class="hljs-number">0</span>         <span class="hljs-number">4</span><span class="hljs-number">2147483647</span><span class="hljs-number">2147483647</span><span class="hljs-number">2147483647</span><span class="hljs-number">2147483647</span>         <span class="hljs-number">5</span>         <span class="hljs-number">4</span>         <span class="hljs-number">0</span>         <span class="hljs-number">2</span>         <span class="hljs-number">8</span>        <span class="hljs-number">16</span>         <span class="hljs-number">7</span>         <span class="hljs-number">6</span><span class="hljs-number">2147483647</span>         <span class="hljs-number">2</span>         <span class="hljs-number">0</span>         <span class="hljs-number">9</span>        <span class="hljs-number">14</span><span class="hljs-number">2147483647</span><span class="hljs-number">2147483647</span><span class="hljs-number">2147483647</span>         <span class="hljs-number">8</span>         <span class="hljs-number">9</span>         <span class="hljs-number">0</span>Edge&#123;start=E, end=F, weight=<span class="hljs-number">2</span>&#125;Edge&#123;start=C, end=D, weight=<span class="hljs-number">3</span>&#125;Edge&#123;start=D, end=E, weight=<span class="hljs-number">4</span>&#125;Edge&#123;start=B, end=F, weight=<span class="hljs-number">7</span>&#125;Edge&#123;start=E, end=G, weight=<span class="hljs-number">8</span>&#125;Edge&#123;start=A, end=B, weight=<span class="hljs-number">12</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Graph</tag>
      
      <tag>图</tag>
      
      <tag>树</tag>
      
      <tag>Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Prim算法</title>
    <link href="/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_Prim%E7%AE%97%E6%B3%95/"/>
    <url>/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_Prim%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h1><ul><li><a href="#prim%E7%AE%97%E6%B3%95">Prim算法</a><ul><li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></li><li><a href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">最小生成树</a></li><li><a href="#%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D">算法介绍</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li></ul></li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>最短路径问题，给定带权无向连通图，选中尽可能少的线路，使各顶点连通，并且使总路程最小。</p><p>也就是最小生成树问题。</p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>最小生成树(Minimum CostSpanning Tree)，简称MST。</p><p>（1）给定一个带权的无向连通图，如何选取一棵生成树，使树上所有边上权的总和为最小，这叫最小生成树。</p><p>（2）N个顶点，一定有N-1条边<br>（3）包含全部顶点<br>（4）N-1条边都在图中<br>（5）求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法</p><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrimAlgorithm</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">char</span>[] data = &#123;<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>&#125;;        <span class="hljs-type">int</span> <span class="hljs-variable">verxs</span> <span class="hljs-operator">=</span> data.length;        <span class="hljs-type">int</span>[][] weight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;                &#123;<span class="hljs-number">10000</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">2</span>&#125;,                &#123;<span class="hljs-number">5</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">3</span>&#125;,                &#123;<span class="hljs-number">7</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>&#125;,                &#123;<span class="hljs-number">10000</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10000</span>&#125;,                &#123;<span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;,                &#123;<span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">6</span>&#125;,                &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10000</span>&#125;,        &#125;;        <span class="hljs-type">MGraph</span> <span class="hljs-variable">graph</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MGraph</span>(verxs);        <span class="hljs-type">MinTree</span> <span class="hljs-variable">minTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinTree</span>();        minTree.createGraph(graph, verxs, data, weight);        minTree.showGraph(graph);        <span class="hljs-type">int</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> minTree.prim(graph, <span class="hljs-number">0</span>);        System.out.println(<span class="hljs-string">&quot;最短长度：&quot;</span> + distance);    &#125;&#125;<span class="hljs-comment">// 创建最小生成树</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinTree</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createGraph</span><span class="hljs-params">(MGraph graph, <span class="hljs-type">int</span> verxs, <span class="hljs-type">char</span>[] data, <span class="hljs-type">int</span>[][] weight)</span> &#123;        <span class="hljs-type">int</span> i, j;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; verxs; i++) &#123;            graph.data[i] = data[i];            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; verxs; j++) &#123;                graph.weight[i][j] = weight[i][j];            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showGraph</span><span class="hljs-params">(MGraph graph)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] link : graph.weight) &#123;            System.out.println(Arrays.toString(link));        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prim</span><span class="hljs-params">(MGraph graph, <span class="hljs-type">int</span> v)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[graph.verxs];        visited[v] = <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">h1</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">h2</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">minWeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt; graph.verxs; k++) &#123;            <span class="hljs-comment">// 确定每一次遍历后，和哪个顶点的距离最近</span>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph.verxs; i++) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; graph.verxs; j++) &#123;                    <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-number">1</span> &amp;&amp; visited[j] == <span class="hljs-number">0</span> &amp;&amp; graph.weight[i][j] &lt; minWeight) &#123;                        minWeight = graph.weight[i][j];                        h1 = i;                        h2 = j;                    &#125;                &#125;            &#125;            System.out.println(<span class="hljs-string">&quot;边&lt;&quot;</span> + graph.data[h1] + <span class="hljs-string">&quot;,&quot;</span> + graph.data[h2] + <span class="hljs-string">&quot;&gt; 权值：&quot;</span> + minWeight);            distance += minWeight;            visited[h2] = <span class="hljs-number">1</span>;            minWeight = <span class="hljs-number">10000</span>;        &#125;        <span class="hljs-keyword">return</span> distance;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">MGraph</span> &#123;    <span class="hljs-type">int</span> verxs; <span class="hljs-comment">// 表示图的顶点个数</span>    <span class="hljs-type">char</span>[] data; <span class="hljs-comment">//存放顶点数据</span>    <span class="hljs-type">int</span>[][] weight; <span class="hljs-comment">// 邻接矩阵存放边的权值</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> verxs)</span> &#123;        <span class="hljs-built_in">this</span>.verxs = verxs;        data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[verxs];        weight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[verxs][verxs];    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Graph</tag>
      
      <tag>图</tag>
      
      <tag>最短路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法</title>
    <link href="/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><ul><li><a href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">贪心算法</a><ul><li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0">应用实现</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li></ul></li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>集合覆盖</strong></p><p>假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。如何选择最少的广播台，让所有的地区都可以接收到信号</p><table><thead><tr><th>广播台</th><th>覆盖地区</th></tr></thead><tbody><tr><td>K1</td><td>“北京”,”上海”,”天津”</td></tr><tr><td>K2</td><td>“广州”,”北京”,”深圳”</td></tr><tr><td>K3</td><td>“成都”,”上海”,”杭州”</td></tr><tr><td>K4</td><td>“上海”,”天津”</td></tr><tr><td>K5</td><td>“杭州”,”大连”</td></tr></tbody></table><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>（1）贪婪算法（贪心算法）是指在对问题进行求解时，在每一步选择中都采取最好或者最优（即最有利）的选择，从而希望能够导致结果是最好或者最优的算法。</p><p>（2）贪心算法所得到的结果不一定是最优的结果（有时候会是最优解），但是都是相对近似（接近）最优解的结果</p><h2 id="应用实现"><a href="#应用实现" class="headerlink" title="应用实现"></a>应用实现</h2><p>上面的集合覆盖问题使用贪婪算法，效率高。</p><p>目前并没有算法可以快速计算得到准备的值，使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合：</p><p>（1）遍历所有的广播电台，找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系)。</p><p>（2）将这个电台加入到一个集合中(比如ArrayList)，想办法把该电台覆盖的地区在下次比较时去掉。</p><p>（3）重复第1步直到覆盖了全部的地区。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 贪心算法解决集合覆盖问题</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GreedyAlgorithm</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        HashMap&lt;String, HashSet&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();        HashSet&lt;String&gt; hashSet1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();        hashSet1.add(<span class="hljs-string">&quot;BJ&quot;</span>);        hashSet1.add(<span class="hljs-string">&quot;SH&quot;</span>);        hashSet1.add(<span class="hljs-string">&quot;TJ&quot;</span>);        HashSet&lt;String&gt; hashSet2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();        hashSet2.add(<span class="hljs-string">&quot;GZ&quot;</span>);        hashSet2.add(<span class="hljs-string">&quot;BJ&quot;</span>);        hashSet2.add(<span class="hljs-string">&quot;SZ&quot;</span>);        HashSet&lt;String&gt; hashSet3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();        hashSet3.add(<span class="hljs-string">&quot;CD&quot;</span>);        hashSet3.add(<span class="hljs-string">&quot;SH&quot;</span>);        hashSet3.add(<span class="hljs-string">&quot;HZ&quot;</span>);        HashSet&lt;String&gt; hashSet4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();        hashSet4.add(<span class="hljs-string">&quot;SH&quot;</span>);        hashSet4.add(<span class="hljs-string">&quot;TJ&quot;</span>);        HashSet&lt;String&gt; hashSet5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();        hashSet5.add(<span class="hljs-string">&quot;HZ&quot;</span>);        hashSet5.add(<span class="hljs-string">&quot;DL&quot;</span>);        map.put(<span class="hljs-string">&quot;K1&quot;</span>, hashSet1);        map.put(<span class="hljs-string">&quot;K2&quot;</span>, hashSet2);        map.put(<span class="hljs-string">&quot;K3&quot;</span>, hashSet3);        map.put(<span class="hljs-string">&quot;K4&quot;</span>, hashSet4);        map.put(<span class="hljs-string">&quot;K5&quot;</span>, hashSet5);        HashSet&lt;String&gt; all = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();        all.add(<span class="hljs-string">&quot;BJ&quot;</span>);        all.add(<span class="hljs-string">&quot;SH&quot;</span>);        all.add(<span class="hljs-string">&quot;TJ&quot;</span>);        all.add(<span class="hljs-string">&quot;GZ&quot;</span>);        all.add(<span class="hljs-string">&quot;SZ&quot;</span>);        all.add(<span class="hljs-string">&quot;CD&quot;</span>);        all.add(<span class="hljs-string">&quot;HZ&quot;</span>);        all.add(<span class="hljs-string">&quot;DL&quot;</span>);        ArrayList&lt;String&gt; selected = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        HashSet&lt;String&gt; tempSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();        String maxKey;        <span class="hljs-keyword">while</span> (all.size() != <span class="hljs-number">0</span>) &#123;            maxKey = <span class="hljs-literal">null</span>;            <span class="hljs-keyword">for</span> (String key : map.keySet()) &#123;                tempSet.clear();                HashSet&lt;String&gt; areas = map.get(key);                tempSet.addAll(areas);                <span class="hljs-comment">// 求出交集，交集会赋值给tempSet</span>                tempSet.retainAll(all);                <span class="hljs-keyword">if</span> (tempSet.size() &gt; <span class="hljs-number">0</span> &amp;&amp; (maxKey == <span class="hljs-literal">null</span> || tempSet.size() &gt; map.get(maxKey).size())) &#123;                    maxKey = key;                &#125;            &#125;            <span class="hljs-keyword">if</span> (maxKey != <span class="hljs-literal">null</span>) &#123;                selected.add(maxKey);                all.removeAll(map.get(maxKey));            &#125;        &#125;        System.out.println(selected);    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_KMP%E7%AE%97%E6%B3%95/"/>
    <url>/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h2><p>如果用暴力匹配的思路，并假设现在str1匹配到i位置，子串str2匹配到j位置，则有：</p><p>（1）如果当前字符匹配成功，即<code>str1[i] == str2[i]</code>，则<code>i++,j++</code>，继续匹配下一个字符</p><p>（2）如果失败，即<code>str1[i] != str2[j]</code>，令<code>i=i-(j-1),j=0</code>。相当于每次匹配失败时，i回溯，j被置为0。</p><p>（3）用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)</p><h2 id="暴力匹配算法实现"><a href="#暴力匹配算法实现" class="headerlink" title="暴力匹配算法实现"></a>暴力匹配算法实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViolenceMatch</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你好啥时候回啊&quot;</span>;        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;啥时候回&quot;</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> violenceMatch(str1, str2);        System.out.println(index);    &#125;    <span class="hljs-comment">// 暴力匹配</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">violenceMatch</span><span class="hljs-params">(String str1, String str2)</span> &#123;        <span class="hljs-type">char</span>[] s1 = str1.toCharArray();        <span class="hljs-type">char</span>[] s2 = str2.toCharArray();        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (i &lt; s1.length &amp;&amp; j &lt; s2.length) &#123;            <span class="hljs-comment">// 保证匹配时，不越界</span>            <span class="hljs-keyword">if</span> (s1[i] == s2[j]) &#123;                i++;                j++;            &#125; <span class="hljs-keyword">else</span> &#123;                i = i - (j - <span class="hljs-number">1</span>);                j = <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span> (j == str2.length()) &#123;            <span class="hljs-keyword">return</span> i - j;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div><h2 id="KMP算法介绍"><a href="#KMP算法介绍" class="headerlink" title="KMP算法介绍"></a>KMP算法介绍</h2><p>（1）KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法。</p><p>（2）Knuth-Morris-Pratt字符串查找算法，简称为“KMP算法”，常用于在一个文本串s内查找一个模式串P的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。</p><p>（3）KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间。</p><h2 id="KMP算法思路"><a href="#KMP算法思路" class="headerlink" title="KMP算法思路"></a>KMP算法思路</h2><p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以“ABCDABD”为例：</p><ul><li>“A”的前缀和后缀都为空集,共有元素的长度为0;</li><li>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0;</li><li>“ABC”的前缀为[A,AB]，后缀为[BC,C]，共有元素的长度0;</li><li>“ABCD”的前缀为[A,AB,ABC]，后缀为[BCD,CD,D]，共有元素的长度为0;</li><li>“ABCDA”的前缀为[A,AB,ABC,ABCD]，后缀为[BCDA,CDA,DA,A]，共有元素为”A”，长度为1;</li><li>“ABCDAB”的前缀为[A,AB,ABC,ABCD,ABCDA]，后缀为[BCDAB,CDAB,DAB,AB,B]，共有元素为”AB”，长度为2;</li><li>“ABCDABD”的前缀为[A,AB,ABC,ABCD,ABCDA,ABCDAB]，后缀为[BCDABD,CDABD,DABD,ABD,BD,D],共有元素的长度为0。</li></ul><p>（1）先得到子串的部分匹配表</p><p>（2）使用部分匹配表完成KMP匹配</p><p>移动位数 &#x3D; 已匹配的字符数 – 对应的部分匹配值</p><h3 id="KMP算法实现"><a href="#KMP算法实现" class="headerlink" title="KMP算法实现"></a>KMP算法实现</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KMP</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ABCDABD&quot;</span>;        <span class="hljs-type">int</span>[] next = kmpNext(str2);        System.out.println(Arrays.toString(next));        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> kmpSearch2(str1, str2, next);        System.out.println(index);    &#125;    <span class="hljs-comment">/** 第一种</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str1 源字符串</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str2 子串</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> next 部分匹配表</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> -1表示未匹配到，否则返回第一次出现的下标</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kmpSearch</span><span class="hljs-params">(String str1, String str2, <span class="hljs-type">int</span>[] next)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; str1.length(); i++) &#123;            <span class="hljs-comment">// 核心！</span>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;                j = next[j - <span class="hljs-number">1</span>];            &#125;            <span class="hljs-keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;                j++;            &#125;            <span class="hljs-keyword">if</span> (j == str2.length()) &#123;                <span class="hljs-keyword">return</span> i - j + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/** 第二种</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str1 源字符串</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str2 子串</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> next 部分匹配表</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> -1表示未匹配到，否则返回第一次出现的下标</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kmpSearch2</span><span class="hljs-params">(String str1, String str2, <span class="hljs-type">int</span>[] next)</span> &#123;        <span class="hljs-type">char</span>[] s1 = str1.toCharArray();        <span class="hljs-type">char</span>[] s2 = str2.toCharArray();        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (i &lt; s1.length &amp;&amp; j &lt; s2.length) &#123;            <span class="hljs-comment">// 保证匹配时，不越界</span>            <span class="hljs-keyword">if</span> (s1[i] == s2[j]) &#123;                i++;                j++;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>) &#123;                    i = i - (j - <span class="hljs-number">1</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    i = i - next[j - <span class="hljs-number">1</span>];                    j = <span class="hljs-number">0</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span> (j == str2.length()) &#123;            <span class="hljs-keyword">return</span> i - j;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 获取部分匹配表</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] kmpNext(String dest) &#123;        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[dest.length()];        <span class="hljs-comment">// 字符串长度为1，部分匹配值为0</span>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; dest.length(); i++) &#123;            <span class="hljs-comment">// 核心！</span>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;                j = next[j - <span class="hljs-number">1</span>];            &#125;            <span class="hljs-keyword">if</span> (dest.charAt(i) == dest.charAt(j)) &#123;                j++;            &#125;            next[i] = j;        &#125;        <span class="hljs-keyword">return</span> next;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a><ul><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B3%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">动态规划解决背包问题</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">思路分析</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li></ul></li></ul></li></ul><p>（1）动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法。</p><p>（2）动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p><p>（3）与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。(即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解)</p><p>（4）动态规划可以通过填表的方式来逐步推进，得到最优解。</p><h2 id="动态规划解决背包问题"><a href="#动态规划解决背包问题" class="headerlink" title="动态规划解决背包问题"></a>动态规划解决背包问题</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包（完全背包指的是：每种物品都有无限件可用）</p><p>这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，c为背包的容量。再令v[i][i]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：</p><p>（1）<code>v[i][0]=v[0][i]=0</code>，表示填入表的第一行和第一列都是0。</p><p>（2）当<code>w[i]&gt;j</code>时：<code>v[i][j]=v[i-1][j]</code>，当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略</p><p>（3）当<code>j&gt;=w[i]</code>时：<code>v[i][j]=max&#123;v[i-1][j],v[i]+v[i-1][j-w[i]&#125;</code>，当准备加入新增的商品的容量小于等于当前背包的容量时，装入的方式。分析：</p><ul><li><code>v[i-1][j]</code>：上一个单元格的装入策略</li><li><code>v[i]</code>：表示当前商品的价值</li><li><code>v[i-1][j-w[i]]</code>：装入i-1商品到剩余空间<code>j-w[i]</code>最大值</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KnapsackProblem</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">int</span>[] w = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;;<span class="hljs-comment">// 物品重量</span>        <span class="hljs-type">int</span>[] v = &#123;<span class="hljs-number">1500</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">2000</span>&#125;;<span class="hljs-comment">// 物品价值</span>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<span class="hljs-comment">// 背包容量</span>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> v.length;<span class="hljs-comment">// 物品的个数</span>        <span class="hljs-comment">// 创建二维数组，表示在前i个物品中能够装入容量为m的背包中的最大价值</span>        <span class="hljs-type">int</span>[][] val = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];        <span class="hljs-comment">// 记录具体商品</span>        String[][] path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];        <span class="hljs-comment">// 使填入表的第一行和第一列都是0。</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m + <span class="hljs-number">1</span>; i++) &#123;            val[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;            path[<span class="hljs-number">0</span>][i] = <span class="hljs-string">&quot;&quot;</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;            val[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;            path[i][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;&quot;</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; m + <span class="hljs-number">1</span>; j++) &#123;                <span class="hljs-comment">// 当准备加入新增的商品的容量大于当前背包的容量时，</span>                <span class="hljs-comment">// 就直接使用上一个单元格的装入策略</span>                <span class="hljs-keyword">if</span> (w[i - <span class="hljs-number">1</span>] &gt; j) &#123;                    val[i][j] = val[i - <span class="hljs-number">1</span>][j];                    path[i][j] = path[i - <span class="hljs-number">1</span>][j];                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 当准备加入新增的商品的容量小于等于当前背包的容量时，装入的方式</span>                    <span class="hljs-keyword">if</span> (val[i - <span class="hljs-number">1</span>][j] &gt; v[i - <span class="hljs-number">1</span>] + val[i - <span class="hljs-number">1</span>][j - w[i - <span class="hljs-number">1</span>]]) &#123;                        val[i][j] = val[i - <span class="hljs-number">1</span>][j];                        path[i][j] = path[i - <span class="hljs-number">1</span>][j];                    &#125; <span class="hljs-keyword">else</span> &#123;                        val[i][j] = v[i - <span class="hljs-number">1</span>] + val[i - <span class="hljs-number">1</span>][j - w[i - <span class="hljs-number">1</span>]];                        path[i][j] = i - <span class="hljs-number">1</span> + <span class="hljs-string">&quot;号 &quot;</span> + path[i - <span class="hljs-number">1</span>][j - w[i - <span class="hljs-number">1</span>]];                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 输出</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;            System.out.println(Arrays.toString(val[i]));        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;            System.out.println(Arrays.toString(path[i]));        &#125;        System.out.println(<span class="hljs-string">&quot;背包的最大价值：&quot;</span> + val[n][m]);        System.out.println(<span class="hljs-string">&quot;背包里的物品号：&quot;</span> + path[n][m]);    &#125;&#125;</code></pre></div><p>输出</p><div class="code-wrapper"><pre><code class="hljs java">[<span class="hljs-number">0</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">3000</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">3500</span>][, <span class="hljs-number">0</span>号 , <span class="hljs-number">0</span>号 , <span class="hljs-number">0</span>号 , <span class="hljs-number">0</span>号 ][, <span class="hljs-number">0</span>号 , <span class="hljs-number">0</span>号 , <span class="hljs-number">0</span>号 , <span class="hljs-number">1</span>号 ][, <span class="hljs-number">0</span>号 , <span class="hljs-number">0</span>号 , <span class="hljs-number">2</span>号 , <span class="hljs-number">2</span>号 <span class="hljs-number">0</span>号 ]背包的最大价值：<span class="hljs-number">3500</span>背包里的物品号：<span class="hljs-number">2</span>号 <span class="hljs-number">0</span>号</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分治算法</title>
    <link href="/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    <url>/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题….直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换…</p><p>分治算法可以求解的一些经典问题：</p><ul><li><p>二分搜索</p></li><li><p>大整数乘法</p></li><li><p>棋盘覆盖</p></li><li><p>合并排序</p></li><li><p>快速排序</p></li><li><p>线性时间选择</p></li><li><p>最接近点对问题</p></li><li><p>循环赛日程表</p></li><li><p>汉诺塔</p></li></ul><h2 id="分治算法的基本步骤"><a href="#分治算法的基本步骤" class="headerlink" title="分治算法的基本步骤"></a>分治算法的基本步骤</h2><p>分治法在每一层递归上都有三个步骤：</p><p>（1）分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题。</p><p>（2）解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题。</p><p>（3）合并：将各个子问题的解合并为原问题的解。</p><h2 id="分治算法解决汉诺塔问题"><a href="#分治算法解决汉诺塔问题" class="headerlink" title="分治算法解决汉诺塔问题"></a>分治算法解决汉诺塔问题</h2><h3 id="汉诺塔的传说"><a href="#汉诺塔的传说" class="headerlink" title="汉诺塔的传说"></a>汉诺塔的传说</h3><p>汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><p>假如每秒钟一次，共需多长时间呢?移完这些金片需要5845.54亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>（1）如果只有一个盘，A-&gt;C</p><p>（2）如果我们有n&gt;&#x3D;2情况，我们总是可以看做是两个盘：</p><ul><li>最下边的盘</li><li>上面的盘</li></ul><p>（2.1）先把最上面的盘A-&gt;B<br>（2.2）把最下边的盘A-&gt;C<br>（2.3）把B塔的所有盘从B-&gt;C</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HanoiTower</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        hanoiTower(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>);        System.out.println(<span class="hljs-string">&quot;一共&quot;</span> + count + <span class="hljs-string">&quot;步&quot;</span>);    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 分治算法解决汉诺塔问题</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hanoiTower</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">char</span> a, <span class="hljs-type">char</span> b, <span class="hljs-type">char</span> c)</span> &#123;        <span class="hljs-comment">// 如果只有一个盘</span>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;            System.out.println(<span class="hljs-string">&quot;第1个盘从 &quot;</span> + a + <span class="hljs-string">&quot;-&gt;&quot;</span> + c);            count++;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 先把最上面的盘从A-&gt;B</span>            hanoiTower(num - <span class="hljs-number">1</span>, a, c, b);            <span class="hljs-comment">// 把最下边的盘从A-&gt;C</span>            System.out.println(<span class="hljs-string">&quot;第&quot;</span> + num + <span class="hljs-string">&quot;个盘从 &quot;</span> + a + <span class="hljs-string">&quot;-&gt;&quot;</span> + c);            count++;            <span class="hljs-comment">// 把B塔的所有盘从B-&gt;C</span>            hanoiTower(num - <span class="hljs-number">1</span>, b, a, c);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>分治算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%9B%BE/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><ul><li><a href="#%E5%9B%BE">图</a><ul><li><a href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">图的基本介绍</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%9B%BE">为什么要有图</a></li><li><a href="#%E5%9B%BE%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5">图的常用概念</a></li><li><a href="#%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F">图的表示方式</a><ul><li><a href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5">邻接矩阵</a></li><li><a href="#%E9%82%BB%E6%8E%A5%E8%A1%A8">邻接表</a></li></ul></li></ul></li><li><a href="#%E6%9E%84%E5%BB%BA%E5%9B%BE">构建图</a><ul><li><a href="#%E6%9E%84%E5%BB%BA%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">构建图的实现思路</a></li><li><a href="#%E6%9E%84%E5%BB%BA%E5%9B%BE%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">构建图的代码实现</a></li></ul></li><li><a href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86">图的遍历</a><ul><li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">深度优先遍历基本思想</a></li><li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">深度优先遍历实现思路</a></li><li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">深度优先遍历代码实现</a></li><li><a href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">广度优先遍历基本思想</a></li><li><a href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">广度优先遍历实现思路</a></li><li><a href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">广度优先遍历代码实现</a></li></ul></li></ul></li></ul><h2 id="图的基本介绍"><a href="#图的基本介绍" class="headerlink" title="图的基本介绍"></a>图的基本介绍</h2><h3 id="为什么要有图"><a href="#为什么要有图" class="headerlink" title="为什么要有图"></a>为什么要有图</h3><p>（1）线性表局限于一个直接前驱和一个直接后继的关系</p><p>（2）树也只能有一个直接前驱也就是父节点</p><p>（3）当我们需要表示多对多的关系时，这里我们就用到了图</p><h3 id="图的常用概念"><a href="#图的常用概念" class="headerlink" title="图的常用概念"></a>图的常用概念</h3><p>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。结点也可以称为顶点。</p><p>（1）顶点(vertex)<br>（2）边(edge)<br>（3）路径<br>（4）无向图：顶点之间的连接没有方向<br>（5）有向图：顶点之间的连接有方向<br>（6）带权图：边上带权值，也叫网。</p><h3 id="图的表示方式"><a href="#图的表示方式" class="headerlink" title="图的表示方式"></a>图的表示方式</h3><p>图的表示方式有两种：</p><ul><li><p>二维数组表示（邻接矩阵）</p></li><li><p>链表表示（邻接表）</p></li></ul><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1..….n个点。</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>（1）邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在，会造成空间的一定损失。</p><p>（2）邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成。</p><h2 id="构建图"><a href="#构建图" class="headerlink" title="构建图"></a>构建图</h2><h3 id="构建图的实现思路"><a href="#构建图的实现思路" class="headerlink" title="构建图的实现思路"></a>构建图的实现思路</h3><p>（1）用ArrayList存储顶点<br>（2）用二维数组存储路径</p><h3 id="构建图的代码实现"><a href="#构建图的代码实现" class="headerlink" title="构建图的代码实现"></a>构建图的代码实现</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;        String[] vertexes = &#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>&#125;;        <span class="hljs-type">Graph</span> <span class="hljs-variable">graph</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>(n);        <span class="hljs-keyword">for</span> (String vertex : vertexes) &#123;            graph.insertVertex(vertex);        &#125;        graph.insertEdges(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);        graph.insertEdges(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);        graph.insertEdges(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);        graph.insertEdges(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);        graph.insertEdges(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);        graph.showGraph();    &#125;    <span class="hljs-keyword">private</span> ArrayList&lt;String&gt; vertexList;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] edges;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> numOfEdges;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Graph</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;        vertexList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVertex</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> vertexList.size();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumOfEdges</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> numOfEdges;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span> &#123;        <span class="hljs-keyword">return</span> edges[v1][v2];    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getValueByIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;        <span class="hljs-keyword">return</span> vertexList.get(index);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showGraph</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : edges) &#123;            System.out.println(Arrays.toString(row));        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertVertex</span><span class="hljs-params">(String vertex)</span> &#123;        vertexList.add(vertex);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertEdges</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2, <span class="hljs-type">int</span> weight)</span> &#123;        edges[v1][v2] = weight;        edges[v2][v1] = weight;        numOfEdges++;    &#125;&#125;</code></pre></div><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略：</p><ul><li>深度优先遍历</li><li>广度优先遍历</li></ul><h3 id="深度优先遍历基本思想"><a href="#深度优先遍历基本思想" class="headerlink" title="深度优先遍历基本思想"></a>深度优先遍历基本思想</h3><p>图的深度优先搜索(Depth First Search)</p><p>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点，可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。</p><p>我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。</p><p>显然，深度优先搜索是一个递归的过程</p><h3 id="深度优先遍历实现思路"><a href="#深度优先遍历实现思路" class="headerlink" title="深度优先遍历实现思路"></a>深度优先遍历实现思路</h3><p>（1）首先选择一个起始结点<br>（2）遍历起始点的第一个邻接结点<br>（3）如果这个邻接结点存在，则转（4），否则从初始结点的下一个结点开始<br>（4）如果这个邻接结点没被访问过，则将此结点作为初始结点进行递归。<br>（5）查找初始结点的邻接结点的下一个邻接结点，这一步实际实现了回溯。</p><h3 id="深度优先遍历代码实现"><a href="#深度优先遍历代码实现" class="headerlink" title="深度优先遍历代码实现"></a>深度优先遍历代码实现</h3><p>获得邻接结点的方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 获得 i的邻接结点</span><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFirstNeighbor</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertexList.size(); i++) &#123;        <span class="hljs-keyword">if</span> (edges[index][i] &gt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> i;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获得 i的邻接结点的下一个结点</span><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNextNeighbor</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span> &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> v2 + <span class="hljs-number">1</span>; i &lt; vertexList.size(); i++) &#123;        <span class="hljs-keyword">if</span> (edges[v1][i] &gt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> i;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></div><p>广度优先遍历</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 广度优先遍历</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">boolean</span>[] isVisited)</span> &#123;    <span class="hljs-type">int</span> u; <span class="hljs-comment">// 队列头节点的下标</span>    <span class="hljs-type">int</span> w; <span class="hljs-comment">// 邻接结点</span>    System.out.print(getValueByIndex(i) + <span class="hljs-string">&quot;-&gt;&quot;</span>);    isVisited[i] = <span class="hljs-literal">true</span>;    LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();    queue.addLast(i);    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        u = queue.removeFirst();        w = getFirstNeighbor(u);        <span class="hljs-keyword">while</span> (w != -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">if</span> (!isVisited[w]) &#123;                System.out.print(getValueByIndex(w) + <span class="hljs-string">&quot;-&gt;&quot;</span>);                isVisited[w] = <span class="hljs-literal">true</span>;                queue.addLast(w);            &#125;            w = getNextNeighbor(u, w);        &#125;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">()</span> &#123;    isVisited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[getNumOfVertex()];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; getNumOfVertex(); i++) &#123;        <span class="hljs-keyword">if</span> (!isVisited[i]) &#123;            BFS(i, isVisited);        &#125;    &#125;&#125;</code></pre></div><h3 id="广度优先遍历基本思想"><a href="#广度优先遍历基本思想" class="headerlink" title="广度优先遍历基本思想"></a>广度优先遍历基本思想</h3><p>图的广度优先搜索(Broad First Search)。</p><p>类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点。</p><h3 id="广度优先遍历实现思路"><a href="#广度优先遍历实现思路" class="headerlink" title="广度优先遍历实现思路"></a>广度优先遍历实现思路</h3><p>（1）访问初始结点v并标记结点v为已访问。<br>（2）结点v入队列<br>（3）当队列非空时，继续执行，否则算法结束。<br>（4）出队列，取得队头结点u。<br>（5）查找结点u的第一个邻接结点w。<br>（6）若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：<br>（6.1）若结点w尚未被访问，则访问结点w并标记为已访问。<br>（6.2）结点w入队列<br>（6.3）查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</p><h3 id="广度优先遍历代码实现"><a href="#广度优先遍历代码实现" class="headerlink" title="广度优先遍历代码实现"></a>广度优先遍历代码实现</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">boolean</span>[] isVisited)</span> &#123;    <span class="hljs-type">int</span> u; <span class="hljs-comment">// 队列头节点的下标</span>    <span class="hljs-type">int</span> w; <span class="hljs-comment">// 邻接结点</span>    System.out.print(getValueByIndex(i) + <span class="hljs-string">&quot;-&gt;&quot;</span>);    isVisited[i] = <span class="hljs-literal">true</span>;    LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();    queue.addLast(i);    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        u = queue.removeFirst();        w = getFirstNeighbor(u);        <span class="hljs-keyword">while</span> (w != -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">if</span> (!isVisited[w]) &#123;                System.out.print(getValueByIndex(w) + <span class="hljs-string">&quot;-&gt;&quot;</span>);                isVisited[w] = <span class="hljs-literal">true</span>;                queue.addLast(w);            &#125;            w = getNextNeighbor(u, w);        &#125;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">()</span> &#123;    isVisited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[getNumOfVertex()];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; getNumOfVertex(); i++) &#123;        <span class="hljs-keyword">if</span> (!isVisited[i]) &#123;            BFS(i, isVisited);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Graph</tag>
      
      <tag>图</tag>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多叉树</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%A4%9A%E5%8F%89%E6%A0%91/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%A4%9A%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="多路查找树"><a href="#多路查找树" class="headerlink" title="多路查找树"></a>多路查找树</h1><ul><li><a href="#%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91">多路查找树</a><ul><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8Eb%E6%A0%91">二叉树与B树</a><ul><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">二叉树的问题分析</a></li><li><a href="#%E5%A4%9A%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">多叉树的基本介绍</a></li><li><a href="#b%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">B树的基本介绍</a></li><li><a href="#2-3%E6%A0%91%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">2-3树基本介绍</a></li><li><a href="#2-3%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E6%80%9D%E8%B7%AF">2-3树的构建思路</a></li></ul></li><li><a href="#b%E6%A0%91b%E6%A0%91%E5%92%8Cb%E6%A0%91">B树、B+树和B*树</a><ul><li><a href="#b%E6%A0%91%E7%9A%84%E4%BB%8B%E7%BB%8D">B树的介绍</a></li><li><a href="#b%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">B树的相关概念</a></li><li><a href="#b%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-1">B+树的相关概念</a></li><li><a href="#b%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-2">B*树的相关概念</a></li></ul></li></ul></li></ul><h2 id="二叉树与B树"><a href="#二叉树与B树" class="headerlink" title="二叉树与B树"></a>二叉树与B树</h2><h3 id="二叉树的问题分析"><a href="#二叉树的问题分析" class="headerlink" title="二叉树的问题分析"></a>二叉树的问题分析</h3><p>二叉树的操作效率较高，但是也存在问题。</p><p>二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多（比如1亿），就存在如下问题：</p><p>问题1：在构建二叉树时，需要多次进行I&#x2F;O操作（海量数据存在数据库或文件中），节点海量，构建二叉树时，会影响速度。</p><p>问题2：节点海量，也会造成二叉树的高度很大，降低操作速度。</p><h3 id="多叉树的基本介绍"><a href="#多叉树的基本介绍" class="headerlink" title="多叉树的基本介绍"></a>多叉树的基本介绍</h3><p>（1）在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树(multiway tree)</p><p>（2）后面我们讲解的2-3树，2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。</p><h3 id="B树的基本介绍"><a href="#B树的基本介绍" class="headerlink" title="B树的基本介绍"></a>B树的基本介绍</h3><p>B树通过重新组织节点，降低树的高度，并且减少I&#x2F;O读写次数来提升效率。</p><p>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页（页得大小通常为4k），这样每个节点只需要一次I&#x2F;O就可以完全载入。</p><p>将树的度M设置为1024，在600亿个元素中最多只需要4次I&#x2F;O操作就可以读取到想要的元素，B树（B+树）广泛应用于文件存储系统以及数据库系统中。</p><h3 id="2-3树基本介绍"><a href="#2-3树基本介绍" class="headerlink" title="2-3树基本介绍"></a>2-3树基本介绍</h3><p>2-3树是最简单的B树结构，具有如下特点：</p><p>（1）2-3树的所有叶子节点都在同一层。（只要是B树都满足这个条件）</p><p>（2）有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点。</p><p>（3）有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点。</p><p>（4）2-3树是由二节点和三节点构成的树。</p><h3 id="2-3树的构建思路"><a href="#2-3树的构建思路" class="headerlink" title="2-3树的构建思路"></a>2-3树的构建思路</h3><p>插入规则：</p><p>（1）2-3树的所有叶子节点都在同一层。（只要是B树都满足这个条件）</p><p>（2）有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点。</p><p>（3）有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点。</p><p>（4）当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3个条件。</p><p>（5）对于三节点的子树的值大小仍然遵守二叉排序树(BST)的规则</p><p><a href="https://www.bilibili.com/video/BV1E4411H73v?p=143&t=400">视频讲解</a></p><h2 id="B树、B-树和B-树"><a href="#B树、B-树和B-树" class="headerlink" title="B树、B+树和B*树"></a>B树、B+树和B*树</h2><h3 id="B树的介绍"><a href="#B树的介绍" class="headerlink" title="B树的介绍"></a>B树的介绍</h3><p>B-tree 即 B树，B 即 Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree就是指的B树。</p><h3 id="B树的相关概念"><a href="#B树的相关概念" class="headerlink" title="B树的相关概念"></a>B树的相关概念</h3><p>（1）B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4。</p><p>（2）B树的搜索：根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点。</p><p>（3）关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据。</p><p>（4）搜索有可能在非叶子结点结束。</p><p>（5）其搜索性能等价于在关键字全集内做一次二分查找。</p><h3 id="B-树的相关概念"><a href="#B-树的相关概念" class="headerlink" title="B+树的相关概念"></a>B+树的相关概念</h3><p>（1）B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找。</p><p>（2）所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点，也叫稠密索引)，且链表中的关键字（数据）恰好是有序的。</p><p>（3）不可能在非叶子结点命中</p><p>（4）非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层。</p><p>（5）更适合文件索引系统。</p><p>（6）B权和B+树各有自己的应用场景，不能说B+树完全<br>比B树好，反之亦然。</p><p>可以理解为将一条单链表切割成若干个小单链表，从而提升查找速度。</p><p><a href="https://www.bilibili.com/video/BV1E4411H73v?p=144&t=518.7">视频讲解</a></p><h3 id="B-树的相关概念-1"><a href="#B-树的相关概念-1" class="headerlink" title="B*树的相关概念"></a>B*树的相关概念</h3><p>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</p><p>（1）B*树定义了非叶子结点关键字个数至少为(2&#x2F;3)*M度，即块的最低使用率为2&#x2F;3，而B+树的块的最低使用率为B+树的1&#x2F;2。</p><p>（2）从第1个特点我们可以看出，B*树分配新结点<br>的概率比B+树要低，空间使用率更高。</p>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>树</tag>
      
      <tag>Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平衡二叉树</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树(AVL)"></a>平衡二叉树(AVL)</h1><ul><li><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91avl">平衡二叉树(AVL)</a><ul><li><a href="#%E8%83%8C%E6%99%AF%E5%BC%95%E5%85%A5">背景引入</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">实现思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li></ul></li></ul><h2 id="背景引入"><a href="#背景引入" class="headerlink" title="背景引入"></a>背景引入</h2><p>二叉排序树可能的问题：</p><p>给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST)，并分析问题所在。</p><p>BST存在的问题分析：</p><p>（1）左子树全部为空，从形式上看，更像一个单链表。<br>（2）插入速度没有影响<br>（3）查询速度明显降低（因为需要依次比较），不能发挥BST<br>的优势，因为每次还需要比较左子树，其查询速度比单链表还慢<br>（4）解决方案-平衡二叉树(AVL)</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>（1）平衡二叉树也叫平衡二叉搜索树(Self-balancing binary search tree)又被称为AVL树，可以保证查询效率较高。</p><p>（2）平衡二叉树具有以下特点：</p><p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>（1）每次添加都要判断左右子树的高度差</p><p>（2）如果高度差大于1</p><ul><li>如果左子树高度更高，执行右旋转</li><li>如果右子树高度更改，执行左旋转</li></ul><p><strong>（3）平衡方法</strong></p><p>（3.1）右旋转</p><ul><li>新建结点，值为当前结点</li><li>新节点的右子树指向当前结点的右子树</li><li>新节点的左子树指向当前结点的左子树的右子树</li><li>使当前结点的值等于右子结点的值</li><li>使当前结点的右子树指向右子树的右子树</li><li>使当前节点的左子树指向新结点</li></ul><p>（3.2）左旋转</p><ul><li>新建结点，值为当前结点</li><li>新节点的左子树指向当前结点的左子树</li><li>新节点的右子树指向当前结点的右子树的左子树</li><li>使当前结点的值等于左子结点的值</li><li>使当前结点的左子树指向左子树的左子树</li><li>使当前节点的右子树指向新结点</li></ul><p>（4）双旋转问题</p><p>虽然每次添加节点都会执行平衡过程（左旋转或者右旋转），但是对于一些特殊的二叉树，单次左旋转或者右旋转并不能平衡二叉树，所以要增加双旋转的情况。</p><p>在步骤（2）中</p><ul><li><p>如果右子树高度更高，且它的右子树的左子树高度大于右子树高度，则先对右子树进行右旋转，再对当前树进行左旋转。</p></li><li><p>如果左子树高度更高，且它的左子树的右子树高度大于左子树高度，则先对左子树进行左旋转，再对当前树进行右旋转。</p></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AVLTree</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BinarySortTree</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<span class="hljs-comment">//        int[] arr = &#123;&#125;;</span>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">44</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">14</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">19</span>, <span class="hljs-number">15</span>&#125;;        <span class="hljs-type">AVLTree</span> <span class="hljs-variable">avlTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AVLTree</span>();        <span class="hljs-comment">// 添加结点</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : arr) &#123;            avlTree.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AVLNode</span>(val));        &#125;        <span class="hljs-comment">// 遍历</span>        avlTree.infixOrder();        System.out.println(<span class="hljs-string">&quot;\n平衡后树的高度&quot;</span> + ((AVLNode) (avlTree.getRoot())).height());        System.out.println(<span class="hljs-string">&quot;平衡前树的左子树高度&quot;</span> + ((AVLNode) (avlTree.getRoot())).leftHeight());        System.out.println(<span class="hljs-string">&quot;平衡前树的右子树高度&quot;</span> + ((AVLNode) (avlTree.getRoot())).rightHeight());    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AVLNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AVLNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;        <span class="hljs-built_in">super</span>(val);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span> &#123;        <span class="hljs-built_in">super</span>.add(node);        <span class="hljs-keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 如果它的右子树的左子树高度大于右子树高度（双旋转）</span>            <span class="hljs-keyword">if</span> (right != <span class="hljs-literal">null</span> &amp;&amp; ((AVLNode) right).leftHeight() &gt; ((AVLNode) right).rightHeight())                <span class="hljs-comment">// 先对当前这个结点的右节点进行右旋转</span>                ((AVLNode) right).rightRotate();            <span class="hljs-comment">// 再对当前结点进行左旋转</span>            leftRotate();            <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 重要</span>        &#125;        <span class="hljs-keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 如果它的左子树的右子树高度大于左子树高度</span>            <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; ((AVLNode) left).rightHeight() &gt; ((AVLNode) left).leftHeight())                <span class="hljs-comment">// 先对当前这个结点的左节点进行左旋转</span>                ((AVLNode) left).leftRotate();            <span class="hljs-comment">// 再对当前结点进行右旋转</span>            rightRotate();        &#125;    &#125;    <span class="hljs-comment">// 左旋转</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">leftRotate</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// 创建一个新的节点,值等于当前根节点的值</span>        <span class="hljs-type">AVLNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AVLNode</span>(val);        <span class="hljs-comment">// 把新节点的左子树设置了当前节点的左子树</span>        newNode.left = left;        <span class="hljs-comment">// 把新节点的右子树设置为当前节点的右子树的左子树</span>        newNode.right = right.left;        <span class="hljs-comment">// 把当前节点的值换为右子节点的值</span>        val = right.val;        <span class="hljs-comment">// 把当前节点的右子树设置成右子树的右子树</span>        right = right.right;        <span class="hljs-comment">// 把当前节点的左子树设置为新节点</span>        left = newNode;    &#125;    <span class="hljs-comment">// 右旋转</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rightRotate</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">AVLNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AVLNode</span>(val);        newNode.right = right;        newNode.left = left.right;        val = left.val;        left = left.left;        right = newNode;    &#125;    <span class="hljs-comment">// 返回左子树的高度</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">leftHeight</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> ((AVLNode) left).height();    &#125;    <span class="hljs-comment">// 返回右子树的高度</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rightHeight</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> ((AVLNode) right).height();    &#125;    <span class="hljs-comment">// 返回以当前结点为根节点的书的高度</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">height</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> Math.max(                left == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : ((AVLNode) left).height(),                right == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : ((AVLNode) right).height()        ) + <span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>树</tag>
      
      <tag>Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉排序树</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉排序树-BST"><a href="#二叉排序树-BST" class="headerlink" title="二叉排序树(BST)"></a>二叉排序树(BST)</h1><ul><li><a href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91bst">二叉排序树(BST)</a><ul><li><a href="#%E8%83%8C%E6%99%AF%E5%BC%95%E5%85%A5">背景引入</a><ul><li><a href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">需求分析</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90">解决方案分析</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84">使用数组</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E9%93%BE%E8%A1%A8">使用链式存储（链表）</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91">使用二叉排序树</a></li></ul></li></ul></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">二叉排序树基本介绍</a></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%8E%92%E5%BA%8F">二叉排序树的创建与排序</a></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4">二叉排序树的删除</a><ul><li><a href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">思路分析</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li><li><a href="#%E6%8B%93%E5%B1%95%E7%BB%83%E4%B9%A0">拓展练习</a></li></ul></li></ul></li></ul><h2 id="背景引入"><a href="#背景引入" class="headerlink" title="背景引入"></a>背景引入</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>给你一个数列 (7,3,10,12,5,1,9)，要求能够高效的完成对数据的查询和添加</p><h3 id="解决方案分析"><a href="#解决方案分析" class="headerlink" title="解决方案分析"></a>解决方案分析</h3><h4 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h4><ul><li>数组未排序<ul><li>优点：直接在数组尾添加，速度快。</li><li>缺点：查找速度慢。</li></ul></li><li>数组排序<ul><li>优点：可以使用二分查找，查找速度快。</li><li>缺点：为了保证数组有序，在添加新数据时找到插入位置后，后面的数据需整体移动，速度慢。</li></ul></li></ul><h4 id="使用链式存储（链表）"><a href="#使用链式存储（链表）" class="headerlink" title="使用链式存储（链表）"></a>使用链式存储（链表）</h4><p>不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。</p><h4 id="使用二叉排序树"><a href="#使用二叉排序树" class="headerlink" title="使用二叉排序树"></a>使用二叉排序树</h4><h2 id="二叉排序树基本介绍"><a href="#二叉排序树基本介绍" class="headerlink" title="二叉排序树基本介绍"></a>二叉排序树基本介绍</h2><p>二叉排序树 BST (Binary Sort(Search) Tree)对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。</p><p>特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点</p><h2 id="二叉排序树的创建与排序"><a href="#二叉排序树的创建与排序" class="headerlink" title="二叉排序树的创建与排序"></a>二叉排序树的创建与排序</h2><p>直接上代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySortTree</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>&#125;;        <span class="hljs-type">BinarySortTree</span> <span class="hljs-variable">binarySortTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinarySortTree</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : arr) &#123;            binarySortTree.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(j));        &#125;        binarySortTree.infixOrder();        <span class="hljs-comment">// 1 3 5 7 9 10 12</span>    &#125;    Node root;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span> &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;            root = node;        &#125; <span class="hljs-keyword">else</span> &#123;            root.add(node);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;树为空&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        root.infixOrder();    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;    <span class="hljs-type">int</span> val;    Node left;    Node right;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;        <span class="hljs-built_in">this</span>.val = val;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span> &#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (node.val &lt; <span class="hljs-built_in">this</span>.val) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left == <span class="hljs-literal">null</span>)                <span class="hljs-built_in">this</span>.left = node;            <span class="hljs-keyword">else</span>                <span class="hljs-built_in">this</span>.left.add(node);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right == <span class="hljs-literal">null</span>)                <span class="hljs-built_in">this</span>.right = node;            <span class="hljs-keyword">else</span>                <span class="hljs-built_in">this</span>.right.add(node);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-built_in">this</span>.left.infixOrder();        &#125;        System.out.print(<span class="hljs-built_in">this</span>);        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-built_in">this</span>.right.infixOrder();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.val;    &#125;&#125;</code></pre></div><h2 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h2><p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑</p><ul><li>删除叶子节点</li><li>删除只有一颗子树的节点</li><li>删除有两颗子树的节点</li></ul><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p><strong>第一种情况</strong></p><p>删除叶子节点思路</p><p>（1）先找到要删除的结点targetNode<br>（2）找到targetNode的父结点parent<br>（3）确定targetNode是parent的左子结点还是右子结点<br>（4）根据前面的情况来对应删除</p><ul><li>左子结点<code>parent.left = null</code></li><li>右子结点<code>parent.right = null</code></li></ul><p><strong>第二种情况</strong></p><p>删除只有一颗子树的节点思路</p><p>（1）先找到要删除的结点targetNode<br>（2）找到targetNode的父结点parent<br>（3）确定targetNode的子结点是左子结点还是右子结点<br>（4）targetNode是parent的左子结点还是右子结点<br>（5）如果targetNode有左子结点</p><ul><li>如果targetNode是parent的左子结点<code>parent.left = targetNode.left</code></li><li>如果targetNode是parent的右子结点<code>parent.right = targetNode.left</code></li></ul><p>（6）如果targetNode有右子结点</p><ul><li>如果targetNode是parent的左子结点<code>parent.left = targetNode.right</code></li><li>如果targetNode是parent的右子结点<code>parent.right = targetNode.right</code></li></ul><p><strong>第三种情况</strong></p><p>删除有两颗子树的节点思路</p><p>（1）先找到要删除的结点targetNode<br>（2）从targetNode的右子树找到最小的结点，或者从左子树找最大的结点<br>（3）用一个临时变量，将最小结点的值保存temp &#x3D; min<br>（4）删除该最小结点<br>（5）<code>targetNode.value = temp</code></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li>在<code>Node</code>中添加<code>search</code>和<code>searchParent</code>方法</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 查找结点</span><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.val == val) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.val &gt; val) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.left.search(val);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.right.search(val);    &#125;&#125;<span class="hljs-comment">// 查找父结点</span><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">searchParent</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">this</span>.left.val == val) || <span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">this</span>.right.val == val) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.val &gt; val &amp;&amp; <span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.left.searchParent(val);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.val &lt;= val &amp;&amp; <span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.right.searchParent(val);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre></div><ul><li>在<code>BinarySortTree</code>类中添加<code>search</code>、<code>searchParent</code>和<code>delNode</code>方法</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-type">Node</span> <span class="hljs-variable">targetNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.search(val);    <span class="hljs-keyword">if</span> (targetNode == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 判断树是不是只有一个只根节点</span>    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;        root = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.searchParent(val);    <span class="hljs-keyword">if</span> (targetNode.left == <span class="hljs-literal">null</span> &amp;&amp; targetNode.right == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// 如果targetNode是叶子结点</span>        <span class="hljs-keyword">if</span> (parent.left != <span class="hljs-literal">null</span> &amp;&amp; parent.left == targetNode)            parent.left = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">if</span> (parent.right != <span class="hljs-literal">null</span> &amp;&amp; parent.right == targetNode)            parent.right = <span class="hljs-literal">null</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetNode.left != <span class="hljs-literal">null</span> &amp;&amp; targetNode.right == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// 如果targetNode只有一颗左子树</span>        <span class="hljs-keyword">if</span> (parent.left != <span class="hljs-literal">null</span> &amp;&amp; parent.left == targetNode)            <span class="hljs-comment">// 如果targetNode是parent的的左子结点</span>            parent.left = targetNode.left;        <span class="hljs-keyword">if</span> (parent.right != <span class="hljs-literal">null</span> &amp;&amp; parent.right == targetNode)            <span class="hljs-comment">// 如果targetNode是parent的的右子结点</span>            parent.right = targetNode.left;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetNode.left == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// 如果targetNode只有一颗右子树</span>        <span class="hljs-keyword">if</span> (parent.left != <span class="hljs-literal">null</span> &amp;&amp; parent.left == targetNode)            <span class="hljs-comment">// 如果targetNode是parent的的左子结点</span>            parent.left = targetNode.right;        <span class="hljs-keyword">if</span> (parent.right != <span class="hljs-literal">null</span> &amp;&amp; parent.right == targetNode)            <span class="hljs-comment">// 如果targetNode是parent的的右子结点</span>            parent.right = targetNode.right;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 如果targetNode有两颗子树</span>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> targetNode.right;        <span class="hljs-comment">// 找右子树的最小值</span>        <span class="hljs-keyword">while</span> (temp.left != <span class="hljs-literal">null</span>) &#123;            temp = temp.left;        &#125;        delNode(temp.val);        targetNode.val = temp.val;    &#125;&#125;<span class="hljs-comment">// 查找父结点</span><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">searchParent</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">return</span> root.searchParent(val);&#125;<span class="hljs-comment">// 查找结点</span><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">return</span> root.search(val);&#125;</code></pre></div><h3 id="拓展练习"><a href="#拓展练习" class="headerlink" title="拓展练习"></a>拓展练习</h3><p>将第三种情况的（2）改为从左子树找最大的结点</p><p>将第三种情况的代码改为</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 如果targetNode有两颗子树</span><span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> targetNode.left;<span class="hljs-comment">// 找左子树的最大值</span><span class="hljs-keyword">while</span> (temp.right != <span class="hljs-literal">null</span>) &#123;    temp = temp.right;&#125;delNode(temp.val);targetNode.val = temp.val;</code></pre></div><p><strong>存在BUG</strong></p><p>当第二种情况的目标结点为根结点是，目标结点的父结点为空，会出现空指针问题。</p><p>修改第二种情况的代码为：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (targetNode.left != <span class="hljs-literal">null</span> &amp;&amp; targetNode.right == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;        root = targetNode.left;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 如果targetNode只有一颗左子树</span>    <span class="hljs-keyword">if</span> (parent.left != <span class="hljs-literal">null</span> &amp;&amp; parent.left == targetNode)        <span class="hljs-comment">// 如果targetNode是parent的的左子结点</span>        parent.left = targetNode.left;    <span class="hljs-keyword">if</span> (parent.right != <span class="hljs-literal">null</span> &amp;&amp; parent.right == targetNode)        <span class="hljs-comment">// 如果targetNode是parent的的右子结点</span>        parent.right = targetNode.left;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetNode.left == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;        root = targetNode.right;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 如果targetNode只有一颗右子树</span>    <span class="hljs-keyword">if</span> (parent.left != <span class="hljs-literal">null</span> &amp;&amp; parent.left == targetNode)        <span class="hljs-comment">// 如果targetNode是parent的的左子结点</span>        parent.left = targetNode.right;    <span class="hljs-keyword">if</span> (parent.right != <span class="hljs-literal">null</span> &amp;&amp; parent.right == targetNode)        <span class="hljs-comment">// 如果targetNode是parent的的右子结点</span>        parent.right = targetNode.right;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>树</tag>
      
      <tag>Tree</tag>
      
      <tag>Sort</tag>
      
      <tag>Srarch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机基础</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="比特-bit-和字节-bytet"><a href="#比特-bit-和字节-bytet" class="headerlink" title="比特(bit)和字节(bytet)"></a>比特(bit)和字节(bytet)</h2><p>（1）一个 0 或者一个 1 存储为一个比特(bit)，是计算机中最小的存储单位。</p><p>（2）计算机中是最基本的存储单元是字节(byte)。每个字节由 8 个比特构成。</p><h2 id="二进制的原码、反码、补码"><a href="#二进制的原码、反码、补码" class="headerlink" title="二进制的原码、反码、补码"></a>二进制的原码、反码、补码</h2><p>（1）二进制的最高位是符号位：0表示正数，1表示负数（老韩口诀：0 -&gt; 0 1 -&gt; - ，旋转90°）</p><p>（2）正数的原码，反码，补码都一样（三码合一）</p><p>（3）负数的反码 &#x3D; 它的原码符号位不变，其它位取反（0 -&gt; 1，1 -&gt; 0）</p><p>（4）负数的补码 &#x3D; 它的反码 +1，负数的反码 &#x3D; 负数的补码 -1</p><p>（5）0的反码，补码都是 0</p><p>（6） java没有无符号数，换言之，java中的数都是有符号的</p><p>（7）在计算机运算的时候，都是以补码的方式来运算的。</p><p>（8）当我们看运算结果的时候，要看他的原码</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
      <tag>字节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈夫曼编码</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><ul><li><a href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">哈夫曼编码</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">实现思路</a></li><li><a href="#%E7%89%B9%E7%82%B9%E6%80%BB%E7%BB%93">特点总结</a></li><li><a href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">最佳实践</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E5%8F%8A%E8%A7%A3%E5%8E%8B">数据压缩及解压</a></li><li><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B">文件的压缩与解压</a></li><li><a href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">哈夫曼编码压缩文件注意事项</a></li></ul></li></ul></li></ul><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>（1）哈夫曼编码也翻译为哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，属于一种程序算法。</p><p>（2）哈夫曼编码是哈夫曼树在电讯通信中的经典的应用之一。</p><p>（3）哈夫曼编码广泛地用于数据文件压缩，其压缩率通常在20%~90%之间。</p><p>（4）哈夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>（1）统计字符串各个字符出现的次数。</p><p>（2）按照上面字符出现的次数构建一棵哈夫曼树，次数作为权值。</p><p>（3）根据哈夫曼树，给各个字符规定编码（前缀编码），向左的路径为0，向右的路径为1。这样，每个字符都有独一无二的编码，而且出现次数越多的字符，编码越短。</p><h2 id="特点总结"><a href="#特点总结" class="headerlink" title="特点总结"></a>特点总结</h2><p>（1）此编码满足前缀编码，即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性。</p><p>（2）生成的哈夫曼树根据排序方法不同，也可能不太一样，这样对应的哈夫曼编码也不完全一样，但是wpl是一样的，都是最小的。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="数据压缩及解压"><a href="#数据压缩及解压" class="headerlink" title="数据压缩及解压"></a>数据压缩及解压</h3><p>（1）构建结点类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Node&gt; &#123;    Byte data; <span class="hljs-comment">// 存放字符本身的 ASCII 码</span>    <span class="hljs-type">int</span> weight; <span class="hljs-comment">// 存放权值（字符出现的次数）</span>    Node left;    Node right;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Byte data， <span class="hljs-type">int</span> weight)</span> &#123;        <span class="hljs-built_in">this</span>.data = data;        <span class="hljs-built_in">this</span>.weight = weight;    &#125;    <span class="hljs-comment">// 前序遍历</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">perOrder</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-built_in">this</span>);        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-built_in">this</span>.left.perOrder();        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-built_in">this</span>.right.perOrder();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Node o)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.weight - o.weight;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node&#123;&quot;</span> + <span class="hljs-string">&quot;data=&quot;</span> + <span class="hljs-built_in">this</span>.data + <span class="hljs-string">&quot;， weight=&quot;</span> + <span class="hljs-built_in">this</span>.weight + <span class="hljs-string">&quot;&#125;&quot;</span>;    &#125;&#125;</code></pre></div><p>（2）构建<code>HuffmanCode</code>类，里面有个主方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuffmanCode</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">//主方法</span>    &#125;&#125;</code></pre></div><p>（3）在主方法中将字符串转为byte数组</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yorick yur bei yu Android java Hello World yorick你好&quot;</span>;<span class="hljs-type">byte</span>[] contentBytes = content.getBytes();</code></pre></div><p>（4）将byte数组的每个元素转化为二叉树结点，可以统计字符串各个字符出现的次数，作为权重。</p><ul><li><p>构建将byte数组的每个元素转化为二叉树结点的方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Node&gt; <span class="hljs-title function_">str2Node</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes)</span> &#123;    <span class="hljs-comment">// 存储结点的数据和权值</span>    Map&lt;Byte， Integer&gt; count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    <span class="hljs-keyword">for</span> (Byte b : bytes) &#123;        <span class="hljs-comment">// 当 key 存在时。value+1，key不存在时新建key，并另value=1</span>        count.merge(b， <span class="hljs-number">1</span>， Integer::sum);    &#125;    List&lt;Node&gt; nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">for</span> (Map.Entry&lt;Byte， Integer&gt; entry : count.entrySet()) &#123;        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(entry.getKey()， entry.getValue()));    &#125;    <span class="hljs-keyword">return</span> nodes;&#125;</code></pre></div></li><li><p>主方法调用</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Node&gt; nodes = str2Node(contentBytes);</code></pre></div><p>（5）生成哈夫曼树</p></li><li><p>根据结点生成哈夫曼树的方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">buildHuffmanTree</span><span class="hljs-params">(List&lt;Node&gt; nodes)</span> &#123;    <span class="hljs-keyword">while</span> (nodes.size() &gt; <span class="hljs-number">1</span>) &#123;        Collections.sort(nodes);        <span class="hljs-type">Node</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> nodes.get(<span class="hljs-number">0</span>);        <span class="hljs-type">Node</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nodes.get(<span class="hljs-number">1</span>);        nodes.remove(<span class="hljs-number">0</span>);        nodes.remove(<span class="hljs-number">0</span>);        <span class="hljs-type">Node</span> <span class="hljs-variable">pare</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>， left.weight + right.weight);        pare.left = left;        pare.right = right;        nodes.add(pare);    &#125;    <span class="hljs-keyword">return</span> nodes.get(<span class="hljs-number">0</span>);&#125;</code></pre></div></li><li><p>主方法调用</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> buildHuffmanTree(nodes);</code></pre></div><p>（6）根据哈夫曼树生成哈夫曼编码表</p></li><li><p>在主方法中声明两个静态属性</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 供递归入口使用，存储过程值</span><span class="hljs-keyword">static</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<span class="hljs-comment">// 存储递归结果</span><span class="hljs-keyword">static</span> Map&lt;Byte， String&gt; huffmanCode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();</code></pre></div></li><li><p>通过递归获取哈夫曼树中非叶子结点对应的路径字符串</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/** 递归获得哈夫曼编码</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node          结点</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> str           三种情况：”“、”0“、”1“</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> stringBuilder 可变字符串，记录路径</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getCodes</span><span class="hljs-params">(Node node， String str， StringBuilder stringBuilder)</span> &#123;    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(stringBuilder);    sb.append(str);    <span class="hljs-comment">// 判断node是否为叶子结点</span>    <span class="hljs-keyword">if</span> (node.data == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// 向左递归</span>        getCodes(node.left， <span class="hljs-string">&quot;0&quot;</span>， sb);        <span class="hljs-comment">// 向右递归</span>        getCodes(node.right， <span class="hljs-string">&quot;1&quot;</span>， sb);    &#125; <span class="hljs-keyword">else</span> &#123;        huffmanCode.put(node.data， String.valueOf(sb));    &#125;&#125;</code></pre></div></li><li><p>为了主方法调用方便，重载方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Byte， String&gt; tree2code(Node root) &#123;    getCodes(root， <span class="hljs-string">&quot;&quot;</span>， stringBuilder);    <span class="hljs-keyword">return</span> huffmanCode;&#125;</code></pre></div></li><li><p>在主方法中调用</p></li></ul><div class="code-wrapper"><pre><code class="hljs java">Map&lt;Byte， String&gt; huffmanCode = tree2code(root);<span class="hljs-comment">// 哈夫曼编码表：32-&gt;01  97-&gt;100  100-&gt;11000  117-&gt;11001  101-&gt;1110  118-&gt;11011  105-&gt;101  121-&gt;11010  106-&gt;0010  107-&gt;1111  108-&gt;000  111-&gt;0011 </span></code></pre></div><p>（7）根据编码表对字符进行压缩</p><ul><li>压缩方法<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] zip(<span class="hljs-type">byte</span>[] bytes， Map&lt;Byte， String&gt; huffmanCode) &#123;    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">codes</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();    <span class="hljs-keyword">for</span> (Byte b : bytes) &#123;        codes.append(huffmanCode.get(b));    &#125;    <span class="hljs-type">int</span> length;    <span class="hljs-keyword">if</span> (codes.length() % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>) &#123;        length = codes.length() / <span class="hljs-number">8</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        length = codes.length() / <span class="hljs-number">8</span> + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-type">byte</span>[] huffmanCodeBytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; codes.length(); i += <span class="hljs-number">8</span>) &#123;        String huffmanCodeStr;        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">8</span> &lt; codes.length()) &#123;            huffmanCodeStr = codes.substring(i， i + <span class="hljs-number">8</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            huffmanCodeStr = codes.substring(i);        &#125;        huffmanCodeBytes[index] = (<span class="hljs-type">byte</span>) Integer.parseInt(huffmanCodeStr， <span class="hljs-number">2</span>);        index++;    &#125;    <span class="hljs-keyword">return</span> huffmanCodeBytes;&#125;</code></pre></div></li><li>为了便于调用，将压缩方法封装</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] huffmanZip(<span class="hljs-type">byte</span>[] contentBytes) &#123;    <span class="hljs-comment">// 将字符串的每个字符转化为二叉树结点</span>    List&lt;Node&gt; nodes = str2Node(contentBytes);    <span class="hljs-comment">// 生成哈夫曼树</span>    <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> buildHuffmanTree(nodes);    <span class="hljs-comment">//perOder(buildHuffmanTree(nodes));</span>    <span class="hljs-comment">// 根据哈夫曼树生成哈夫曼编码表</span>    Map&lt;Byte， String&gt; huffmanCode = tree2code(root);    System.out.print(<span class="hljs-string">&quot;哈夫曼编码表：&quot;</span>);    <span class="hljs-keyword">for</span> (Map.Entry&lt;Byte， String&gt; entry : huffmanCode.entrySet()) &#123;        System.out.print(entry.getKey() + <span class="hljs-string">&quot;-&gt;&quot;</span> + entry.getValue() + <span class="hljs-string">&quot;  &quot;</span>);    &#125;    System.out.println();    <span class="hljs-keyword">return</span> zip(contentBytes， huffmanCode);&#125;</code></pre></div><ul><li>在主方法中调用</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] huffmanCodeBytes = huffmanZip(contentBytes);</code></pre></div><ul><li><p>输出压缩后内容</p><div class="code-wrapper"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;压缩后内容：&quot;</span> + Arrays.toString(huffmanCodeBytes));<span class="hljs-comment">// 压缩后内容：[-88， -65， -56， -65， -56， -65， -55， 77， -57， 6， -24， -14， -117， -4， -60， -90， 28]</span></code></pre></div><p>（8）解压内容</p></li><li><p>将单个byte转二进制字符串</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/** 单个byte转二进制字符串</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> b    单个byte</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> flag 是否需要补高位</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 对应的二进制补码的字符串</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">byte2BitString</span><span class="hljs-params">(<span class="hljs-type">byte</span> b， <span class="hljs-type">boolean</span> flag)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> b;    <span class="hljs-keyword">if</span> (flag) &#123;        <span class="hljs-comment">// 两个位都为0时，结果才为0 256 -&gt; 10000000</span>        temp |= <span class="hljs-number">256</span>;    &#125;    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> Integer.toBinaryString(temp);    <span class="hljs-keyword">if</span> (flag) &#123;        <span class="hljs-keyword">return</span> str.substring(str.length() - <span class="hljs-number">8</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> str;    &#125;&#125;</code></pre></div></li><li><p>解压</p></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] decode(Map&lt;Byte， String&gt; huffmanCode， <span class="hljs-type">byte</span>[] huffmanCodeBytes) &#123;    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">bitString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; huffmanCodeBytes.length; i++) &#123;        <span class="hljs-comment">// 判断是否位最后一个字节</span>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> i == (huffmanCodeBytes.length - <span class="hljs-number">1</span>);        bitString.append(byte2BitString(huffmanCodeBytes[i]， !flag));    &#125;    <span class="hljs-comment">//System.out.println(bitString);</span>    Map&lt;String， Byte&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    <span class="hljs-comment">// 反转map</span>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Byte， String&gt; entry : huffmanCode.entrySet()) &#123;        map.put(entry.getValue()， entry.getKey());    &#125;    List&lt;Byte&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bitString.length(); ) &#123;        <span class="hljs-type">Byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> (flag) &#123;            b = map.get(bitString.substring(i， i + count));            <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">null</span>) &#123;                count++;            &#125; <span class="hljs-keyword">else</span> &#123;                flag = <span class="hljs-literal">false</span>;            &#125;        &#125;        list.add(b);        i += count;    &#125;    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[list.size()];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; list.size(); j++) &#123;        bytes[j] = list.get(j);    &#125;    <span class="hljs-keyword">return</span> bytes;&#125;</code></pre></div><ul><li>在主方法中调用<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] resBytes = decode(huffmanCode， huffmanCodeBytes);</code></pre></div></li><li>输出解压后内容</li></ul><div class="code-wrapper"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;解压后内容：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(resBytes));</code></pre></div><h3 id="文件的压缩与解压"><a href="#文件的压缩与解压" class="headerlink" title="文件的压缩与解压"></a>文件的压缩与解压</h3><ul><li>文件压缩方法<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 文件压缩</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">zipFile</span><span class="hljs-params">(String src， String dst)</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-comment">// 输入</span>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);    <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[is.available()];    is.read(b);    <span class="hljs-type">byte</span>[] huffmanBytes = huffmanZip(b);    <span class="hljs-comment">// 输出</span>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dst);    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(os);    oos.writeObject(huffmanBytes);    oos.writeObject(huffmanCodes);    <span class="hljs-comment">// 关闭IO</span>    is.close();    oos.close();    os.close();&#125;</code></pre></div></li><li>文件解压方法</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 文件解压</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unZipFile</span><span class="hljs-params">(String src， String dst)</span> <span class="hljs-keyword">throws</span> IOException， ClassNotFoundException &#123;    <span class="hljs-comment">// 输入</span>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);    <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(is);    <span class="hljs-type">byte</span>[] huffmanBytes = (<span class="hljs-type">byte</span>[]) ois.readObject();    Map&lt;Byte， String&gt; huffmanCodes = (Map&lt;Byte， String&gt;) ois.readObject();    <span class="hljs-type">byte</span>[] bytes = decode(huffmanCodes， huffmanBytes);    <span class="hljs-comment">// 输出</span>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dst);    os.write(bytes);    os.close();    ois.close();    is.close();&#125;</code></pre></div><ul><li>主方法要添加异常签名<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException， ClassNotFoundException &#123;    zipFile(<span class="hljs-string">&quot;E://yy.bmp&quot;</span>， <span class="hljs-string">&quot;E://yy.bmp.huf&quot;</span>);    System.out.println(<span class="hljs-string">&quot;压缩完成&quot;</span>);    unZipFile(<span class="hljs-string">&quot;E://yy.bmp.huf&quot;</span>，<span class="hljs-string">&quot;E://yy_1.bmp&quot;</span>);    System.out.println(<span class="hljs-string">&quot;解压完成&quot;</span>);&#125;</code></pre></div></li></ul><h3 id="哈夫曼编码压缩文件注意事项"><a href="#哈夫曼编码压缩文件注意事项" class="headerlink" title="哈夫曼编码压缩文件注意事项"></a>哈夫曼编码压缩文件注意事项</h3><p>（1）如果文件本身就是经过压缩处理的，那么使用哈夫曼编码再压缩效率不会有明显变化，比如视频，ppt等等文件</p><p>（2）哈夫曼编码是按字节来处理的，因此可以处理所有的文件（二进制文件、文本文件）</p><p>（3）如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显。</p>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>树</tag>
      
      <tag>Tree</tag>
      
      <tag>Huffman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈夫曼树</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="哈夫曼树-HuffmanTree"><a href="#哈夫曼树-HuffmanTree" class="headerlink" title="哈夫曼树(HuffmanTree)"></a>哈夫曼树(HuffmanTree)</h1><ul><li><a href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91huffmantree">哈夫曼树(HuffmanTree)</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a><ul><li><a href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%92%8C%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E">哈夫曼树几个重要概念和举例说明</a></li></ul></li><li><a href="#%E6%9E%84%E5%BB%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%80%9D%E8%B7%AF">构建哈夫曼树的思路</a></li><li><a href="#%E6%9E%84%E5%BB%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E4%BB%A3%E7%A0%81">构建哈夫曼树的代码</a></li></ul></li></ul><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>（1）给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(HuffmanTree)，还有的书翻译为霍夫曼树。</p><p>（2）哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><h3 id="哈夫曼树几个重要概念和举例说明"><a href="#哈夫曼树几个重要概念和举例说明" class="headerlink" title="哈夫曼树几个重要概念和举例说明"></a>哈夫曼树几个重要概念和举例说明</h3><p>（1）路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。</p><p>（2）结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。</p><p>（3）树的带权路径长度:树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</p><p>（4）WPL最小的就是哈夫曼树。</p><h2 id="构建哈夫曼树的思路"><a href="#构建哈夫曼树的思路" class="headerlink" title="构建哈夫曼树的思路"></a>构建哈夫曼树的思路</h2><p>构成哈夫曼树的步骤：</p><ol><li>从小到大进行排序，将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗最简单的二叉树。</li><li>取出根节点权值最小的两颗二叉树。</li><li>组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和。</li><li>再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到一颗哈夫曼树。</li></ol><h2 id="构建哈夫曼树的代码"><a href="#构建哈夫曼树的代码" class="headerlink" title="构建哈夫曼树的代码"></a>构建哈夫曼树的代码</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Collections;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuffmanTree</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BinaryTree</span> &#123;    <span class="hljs-comment">// 测试</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">13</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">29</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>&#125;;        <span class="hljs-type">HuffmanTree</span> <span class="hljs-variable">huffmanTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuffmanTree</span>(arr);        huffmanTree.infixOrder();    &#125;    <span class="hljs-comment">// 待构建的数组</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] arr;    <span class="hljs-comment">// 构造哈夫曼树</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HuffmanTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;        List&lt;TreeNode&gt; nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : arr) &#123;            nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val));        &#125;        <span class="hljs-keyword">while</span> (nodes.size() &gt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 排序</span>            Collections.sort(nodes);            <span class="hljs-comment">// 取出两个最小</span>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> nodes.get(<span class="hljs-number">0</span>);            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nodes.get(<span class="hljs-number">1</span>);            <span class="hljs-comment">// 从nodes中删除</span>            nodes.remove(<span class="hljs-number">0</span>);            nodes.remove(<span class="hljs-number">0</span>);            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pare</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(left.getId() + right.getId());            pare.left = left;            pare.right = right;            nodes.add(pare);        &#125;        <span class="hljs-built_in">this</span>.setRoot(nodes.get(<span class="hljs-number">0</span>));    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>树</tag>
      
      <tag>Tree</tag>
      
      <tag>Huffman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="堆排序基本介绍"><a href="#堆排序基本介绍" class="headerlink" title="堆排序基本介绍"></a>堆排序基本介绍</h2><ol><li>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为 O(nlogn)，它也是不稳定排序。</li><li>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆。注意：没有要求结点的左孩子的值和右孩子的值的大小关系。</li><li>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</li><li>一般升序采用大顶堆，降序采用小顶堆</li></ol><h2 id="堆排序的实现思路"><a href="#堆排序的实现思路" class="headerlink" title="堆排序的实现思路"></a>堆排序的实现思路</h2><ol><li>将待排序序列构造成一个大顶堆</li><li>此时，整个序列的最大值就是堆顶的根节点。</li><li>将其与末尾元素进行交换，此时末尾就为最大值。</li><li>然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了。<br>可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了。</li></ol><p><strong>那么我们如何将待排序序列构造成一个大顶堆？</strong></p><ol><li>设结点个数为n（即数组长度为n），则最后一个非叶子结点的下标为<code>n/2-1</code></li><li>判断此节点的值是否大于左右子树的值，是则需要交换。</li><li>依次向前重复2过程，直到n&#x3D;0，即到根结点</li><li>因为向前重复的过程中可能存在改变了左右孩子的值的情况，从而影响了下面的树，所以在每次循环中，都要向下进行验证，保证每个父结点的值都大于左右孩子的值。</li></ol><h2 id="堆排序的代码实现"><a href="#堆排序的代码实现" class="headerlink" title="堆排序的代码实现"></a>堆排序的代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;    <span class="hljs-type">int</span> temp;    <span class="hljs-comment">// 自下而上初始化堆</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        buildHeap(arr, i, arr.length);    &#125;    <span class="hljs-comment">// 取最值进行交换</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j--) &#123;        <span class="hljs-comment">// 保存数组最后一个元素</span>        temp = arr[j];        <span class="hljs-comment">// 将最后一个元素和堆顶元素进行交换</span>        arr[j] = arr[<span class="hljs-number">0</span>];        arr[<span class="hljs-number">0</span>] = temp;        buildHeap(arr, <span class="hljs-number">0</span>, j);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr    表示待处理地数组</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> i      表示处理的非叶子结点的位置</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> length 表示需要处理的长度</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> length)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];    <span class="hljs-comment">// 每次调整都是自上而下的</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>; k &lt; length; k = <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">if</span> (k + <span class="hljs-number">1</span> &lt; length &amp;&amp; arr[k + <span class="hljs-number">1</span>] &gt; arr[k]) &#123;            k++;        &#125;        <span class="hljs-keyword">if</span> (arr[k] &gt; temp) &#123;            arr[i] = arr[k];        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;        i = k;        arr[i] = temp;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Sort</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树和二叉树</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><ul><li><a href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91">树和二叉树</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%A0%91%E8%BF%99%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">为什么需要树这种数据结构</a></li><li><a href="#%E6%A0%91">树</a><ul><li><a href="#%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5">树的概念</a></li><li><a href="#%E6%A0%91%E7%9A%84%E6%9C%AF%E8%AF%AD">树的术语</a></li></ul></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a><ul><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BD%A2%E6%80%81">二叉树的形态</a></li><li><a href="#%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91">特殊二叉树</a></li></ul></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">二叉树的遍历</a><ul><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">二叉树遍历的实现思路</a><ul><li><a href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">前序遍历</a></li><li><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">中序遍历</a></li><li><a href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">后序遍历</a></li></ul></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">二叉树遍历的代码实现</a></li></ul></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE">二叉树的查找</a><ul><li><a href="#%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%80%9D%E8%B7%AF">前序中序后序查找思路</a><ul><li><a href="#%E5%89%8D%E5%BA%8F%E6%9F%A5%E6%89%BE">前序查找</a></li><li><a href="#%E4%B8%AD%E5%BA%8F%E6%9F%A5%E6%89%BE">中序查找</a></li><li><a href="#%E5%90%8E%E5%BA%8F%E6%9F%A5%E6%89%BE">后序查找</a></li></ul></li><li><a href="#%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%9F%A5%E6%89%BE%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">前序中序后序查找代码实现</a></li></ul></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9">二叉树删除结点</a><ul><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%80%9D%E8%B7%AF">二叉树删除结点思路</a></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">二叉树删除结点代码实现</a></li></ul></li><li><a href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91">顺序存储二叉树</a><ul><li><a href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">顺序存储二叉树代码实现</a></li><li><a href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">顺序存储二叉树应用场景</a></li></ul></li><li><a href="#%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91">线索化二叉树</a><ul><li><a href="#%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">线索化二叉树基本概念</a></li><li><a href="#%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">线索化二叉树代码实现</a></li><li><a href="#%E9%81%8D%E5%8E%86%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91">遍历线索化二叉树</a></li></ul></li></ul></li></ul><h2 id="为什么需要树这种数据结构"><a href="#为什么需要树这种数据结构" class="headerlink" title="为什么需要树这种数据结构"></a>为什么需要树这种数据结构</h2><ol><li><p>数组存储方式的分析<br>优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。<br>缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低。</p><p> <img src="/./img/arrayList.png" alt="数组存储方式的分析"></p></li><li><p>链式存储方式的分析<br>优点：在一定程度上对数组存储方式有优化（比如：插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好）。<br>缺点：在进行检索时，效率仍然较低，比如（检索某个值，需要从头节点开始遍历）。<br> <img src="/./img/LinkedListOp.png" alt="链表操作示意图"></p></li><li><p>树存储方式的分析<br>二叉排序能提高数据存储，读取的效率，比如利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。<br> <img src="/./img/TreeOp.png" alt="树存储方式的分析"></p></li></ol><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h3><p>树(Tree)是n(n≧0)个结点的有限集。n&#x3D;0时称为空树。在任意一颗非空树中：有且仅有一个特定的称为根的结点。当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、T3……、Tm，其中每个集合本身又是一棵树，并且称为根的子树。</p><h3 id="树的术语"><a href="#树的术语" class="headerlink" title="树的术语"></a>树的术语</h3><p><img src="/img/TreeDef.png" alt="树的术语"></p><p>（一）节点的度：一个节点含有的子树的个数称为该节点的度<br>（二）树的度：一棵树中，最大的节点的度称为树的度<br>（三）叶节点或终端节点：度为0的节点<br>（四）父亲节点或父节点：若一个节点含有子节点，则这个节点 称为其子节点的父节点<br>（五）孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点<br>（六）兄弟节点：具有相同父节点的节点互称为兄弟节点<br>（七）节点的层次：从根开始定义起，根为第一层， 根的子节点为第二层，以此类推<br>（八）树的高度或深度：树中节点的最大层次<br>（九）堂兄弟节点：父节点在同一层的节点互为堂兄弟节点<br>（十）节点的祖先：从根到该节点所经分支上的所有节点<br>（十一）子孙：以某节点为根的子树中任一节点都称为该节点的子孙<br>（十二）森林：由m(m&gt;&#x3D;0)棵互不相交的树的集合称为森林</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是n(n&gt;&#x3D;0)个结点的有限集合，该集合或者为空集（空二叉树）、或者由一个根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p><p>特点：</p><ul><li>二叉树中每个结点最多有两颗子树，度没有超过2的。</li><li>左子树和右子树是有顺序的，不能颠倒。</li></ul><h3 id="二叉树的形态"><a href="#二叉树的形态" class="headerlink" title="二叉树的形态"></a>二叉树的形态</h3><p>（1）空二叉树树</p><p>（2）只有一个根结点</p><p>（3）根结点只有左子树</p><p>（4）根结点只有右子树</p><p>（5）根结点既有右子树又有右子树</p><h3 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h3><ol><li><p>斜树</p><ul><li>左斜树：所有结点都只有左子树的二叉树</li><li>右斜树：所有结点都只有右子树的二叉树<br><img src="/./img/SpecilTree_1.png" alt="斜树"></li></ul></li><li><p>满二叉树</p><p>在二叉树中，所有的分支结点都有左子树和右子树，并且所有的叶子都在同一层。该二叉树的所有叶子节点都在最后一层，并且结点总数为 $2^n - 1$ ，n为层数。<br><img src="/./img/SpecilTree_2.png" alt="满二叉树"></p></li><li><p>完全二叉树</p><ul><li>叶子节点只能出现在最下两层。</li><li>最下层的叶子一定集中在左部连续位置。</li><li>倒数第二层，若有叶子结点，一定在右部连续位置。</li><li>如果结点度为1，则该结点只有左孩子。</li><li>同样结点的二叉树，完全二叉树的深度最小。<br><img src="/./img/SpecilTree_3.png" alt="完全二叉树"></li></ul></li></ol><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>前序遍历：先输出父节点，再遍历左子树和右子树<br>中序遍历：先遍历左子树，再输出父节点，再遍历右子树<br>后序遍历：先遍历左子树，再遍历右子树，最后输出父节点<br>小结：看输出父节点的顺序，就确定是前序，中序还是后序</p><h3 id="二叉树遍历的实现思路"><a href="#二叉树遍历的实现思路" class="headerlink" title="二叉树遍历的实现思路"></a>二叉树遍历的实现思路</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><ul><li>先输出当前节点(初始的时候是root节点)</li><li>如果左子节点不为空，则递归继续前序遍历</li><li>如果右子节点不为空，则递归继续前序遍历</li></ul><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><ul><li>如果当前节点的左子节点不为空，则递归中序遍历</li><li>输出当前节点</li><li>如果当前节点的右子节点不为空，则递归中序遍历</li></ul><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><ul><li>如果当前节点的左子节点不为空，则递归后序遍历</li><li>如果当能节点的右子节点不为空，则递归中序遍历</li><li>输出当前节点</li></ul><h3 id="二叉树遍历的代码实现"><a href="#二叉树遍历的代码实现" class="headerlink" title="二叉树遍历的代码实现"></a>二叉树遍历的代码实现</h3><p>首先定义树的结点类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">public</span> TreeNode left;    <span class="hljs-keyword">public</span> TreeNode right;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TreeNode&#123;&quot;</span> +                <span class="hljs-string">&quot;id=&quot;</span> + id +                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div><p>递归实现前、中、后序遍历，作为结点的方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">()</span> &#123;    System.out.println(<span class="hljs-built_in">this</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">this</span>.left.preOrder();    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">this</span>.right.preOrder();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">this</span>.left.infixOrder();    &#125;    System.out.println(<span class="hljs-built_in">this</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">this</span>.right.infixOrder();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">this</span>.left.postOrder();    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">this</span>.right.postOrder();    &#125;    System.out.println(<span class="hljs-built_in">this</span>);&#125;</code></pre></div><p>定义二叉树类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span> &#123;    <span class="hljs-comment">// 定义根结点</span>    <span class="hljs-keyword">private</span> TreeNode root;    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">getRoot</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoot</span><span class="hljs-params">(TreeNode root)</span> &#123;        <span class="hljs-built_in">this</span>.root = root;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.root.preOrder();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.root.infixOrder();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.root.postOrder();    &#125;&#125;</code></pre></div><p>测试方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">()</span> &#123;    System.out.println(<span class="hljs-built_in">this</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">this</span>.left.preOrder();    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">this</span>.right.preOrder();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">this</span>.left.infixOrder();    &#125;    System.out.println(<span class="hljs-built_in">this</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">this</span>.right.infixOrder();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">this</span>.left.postOrder();    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">this</span>.right.postOrder();    &#125;    System.out.println(<span class="hljs-built_in">this</span>);&#125;</code></pre></div><p>预期结果</p><div class="code-wrapper"><pre><code class="hljs java">前序遍历TreeNode&#123;id=<span class="hljs-number">1</span>, name=<span class="hljs-string">&#x27;Yorick&#x27;</span>&#125;TreeNode&#123;id=<span class="hljs-number">2</span>, name=<span class="hljs-string">&#x27;Merry&#x27;</span>&#125;TreeNode&#123;id=<span class="hljs-number">4</span>, name=<span class="hljs-string">&#x27;Tom&#x27;</span>&#125;TreeNode&#123;id=<span class="hljs-number">3</span>, name=<span class="hljs-string">&#x27;Jack&#x27;</span>&#125;TreeNode&#123;id=<span class="hljs-number">5</span>, name=<span class="hljs-string">&#x27;Lily&#x27;</span>&#125;中序遍历TreeNode&#123;id=<span class="hljs-number">4</span>, name=<span class="hljs-string">&#x27;Tom&#x27;</span>&#125;TreeNode&#123;id=<span class="hljs-number">2</span>, name=<span class="hljs-string">&#x27;Merry&#x27;</span>&#125;TreeNode&#123;id=<span class="hljs-number">1</span>, name=<span class="hljs-string">&#x27;Yorick&#x27;</span>&#125;TreeNode&#123;id=<span class="hljs-number">3</span>, name=<span class="hljs-string">&#x27;Jack&#x27;</span>&#125;TreeNode&#123;id=<span class="hljs-number">5</span>, name=<span class="hljs-string">&#x27;Lily&#x27;</span>&#125;后序遍历TreeNode&#123;id=<span class="hljs-number">4</span>, name=<span class="hljs-string">&#x27;Tom&#x27;</span>&#125;TreeNode&#123;id=<span class="hljs-number">2</span>, name=<span class="hljs-string">&#x27;Merry&#x27;</span>&#125;TreeNode&#123;id=<span class="hljs-number">5</span>, name=<span class="hljs-string">&#x27;Lily&#x27;</span>&#125;TreeNode&#123;id=<span class="hljs-number">3</span>, name=<span class="hljs-string">&#x27;Jack&#x27;</span>&#125;TreeNode&#123;id=<span class="hljs-number">1</span>, name=<span class="hljs-string">&#x27;Yorick&#x27;</span>&#125;</code></pre></div><h2 id="二叉树的查找"><a href="#二叉树的查找" class="headerlink" title="二叉树的查找"></a>二叉树的查找</h2><h3 id="前序中序后序查找思路"><a href="#前序中序后序查找思路" class="headerlink" title="前序中序后序查找思路"></a>前序中序后序查找思路</h3><h4 id="前序查找"><a href="#前序查找" class="headerlink" title="前序查找"></a>前序查找</h4><ul><li>先判断当前结点的值是否等于要查找的</li><li>如果是相等，则返回当前结点</li><li>如果不等，则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</li><li>如果左递归前序查找，找到结点，则返回，否继续判断当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找，</li></ul><h4 id="中序查找"><a href="#中序查找" class="headerlink" title="中序查找"></a>中序查找</h4><ul><li>判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</li><li>如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点，否则继续进行右递归的中序查找</li><li>如果右递归中序查找，找到就返回，否则返回<code>null</code></li></ul><h4 id="后序查找"><a href="#后序查找" class="headerlink" title="后序查找"></a>后序查找</h4><ul><li>判断当前结点的左子节点是否为空，如果不为空，则递归后序查找</li><li>如果找到，就返回，如果没有找到，就判断当前结点的右子节点是否为空，如果不为空，则右递归进行后序查找，如果找到，就返回</li><li>如果不等就和当前结点进行比较，如果是则返回，否则返回<code>null</code></li></ul><h3 id="前序中序后序查找代码实现"><a href="#前序中序后序查找代码实现" class="headerlink" title="前序中序后序查找代码实现"></a>前序中序后序查找代码实现</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">preOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.id == id) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125;    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-comment">// 向左查找</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;        res = <span class="hljs-built_in">this</span>.left.preOrderSearch(id);    &#125;    <span class="hljs-keyword">if</span> (res != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">// 向右查找</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;        res = <span class="hljs-built_in">this</span>.right.preOrderSearch(id);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">infixOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;        res = <span class="hljs-built_in">this</span>.left.infixOrderSearch(id);    &#125;    <span class="hljs-keyword">if</span> (res != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.id == id) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;        res = <span class="hljs-built_in">this</span>.right.infixOrderSearch(id);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">postOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;        res = <span class="hljs-built_in">this</span>.left.postOrderSearch(id);    &#125;    <span class="hljs-keyword">if</span> (res != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;        res = <span class="hljs-built_in">this</span>.right.postOrderSearch(id);    &#125;    <span class="hljs-keyword">if</span> (res != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.id == id) &#123;        res = <span class="hljs-built_in">this</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h2 id="二叉树删除结点"><a href="#二叉树删除结点" class="headerlink" title="二叉树删除结点"></a>二叉树删除结点</h2><p><strong>要求</strong></p><ul><li>如果删除的节点是叶子节点，则删除该节点</li><li>如果删除的节点是非叶子节点，则删除该子树</li></ul><h3 id="二叉树删除结点思路"><a href="#二叉树删除结点思路" class="headerlink" title="二叉树删除结点思路"></a>二叉树删除结点思路</h3><ol><li>因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点。</li><li>如果当前结点的左子结点不为空，并且左子结点就是要删除结点，就将<code>this.left = null;</code>并且返回(结束递归删除)</li><li>如果当前结点的右子结点不为空，并且右子结点就是要删除结点，就将<code>this.right=null;</code>并且返回(结束递归删除)</li><li>如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</li><li>如果第4步也没有删除结点，则应当向右子树进行递归删除。</li><li>如果树是空树，即只有一个root结点，则等价将二叉树置空</li></ol><h3 id="二叉树删除结点代码实现"><a href="#二叉树删除结点代码实现" class="headerlink" title="二叉树删除结点代码实现"></a>二叉树删除结点代码实现</h3><p>结点类方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delNode</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">this</span>.left.id == id) &#123;        <span class="hljs-built_in">this</span>.left = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">this</span>.right.id == id) &#123;        <span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">this</span>.left.delNode(id);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">this</span>.right.delNode(id);    &#125;&#125;</code></pre></div><p>二叉树类方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delNode</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;    <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">null</span>)&#123;        System.out.println(<span class="hljs-string">&quot;树为空&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 根节点且符合删除的情况</span>    <span class="hljs-keyword">if</span> (root.getId() == id) &#123;        root = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">return</span>;    &#125;    root.delNode(id);&#125;</code></pre></div><h2 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a>顺序存储二叉树</h2><p>顺序存储二叉树的特点：</p><ul><li>顺序二叉树通常只考虑完全二叉树</li><li>第 n 个元素的左子节点为<code>2*n+1</code></li><li>第 n 个元素的右子节点为<code>2*n+2</code></li><li>第 n 个元素的父节点为<code>(n-1)/2</code></li></ul><p>n 表示二叉树中的第几个元素(按 0 开始编号)</p><h3 id="顺序存储二叉树代码实现"><a href="#顺序存储二叉树代码实现" class="headerlink" title="顺序存储二叉树代码实现"></a>顺序存储二叉树代码实现</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrBinaryTree</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>,&#125;;        <span class="hljs-type">ArrBinaryTree</span> <span class="hljs-variable">binaryTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrBinaryTree</span>(arr);        System.out.print(<span class="hljs-string">&quot;前序遍历 &quot;</span>);        binaryTree.preOrder(<span class="hljs-number">0</span>);        System.out.println();        System.out.print(<span class="hljs-string">&quot;中序遍历 &quot;</span>);        binaryTree.infixOrder(<span class="hljs-number">0</span>);        System.out.println();        System.out.print(<span class="hljs-string">&quot;后序遍历 &quot;</span>);        binaryTree.postOrder(<span class="hljs-number">0</span>);        System.out.println();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] arr; <span class="hljs-comment">// 存储结点的数组</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrBinaryTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;        <span class="hljs-built_in">this</span>.arr = arr;    &#125;    <span class="hljs-comment">// 顺序存储二叉树的前序遍历</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty())            <span class="hljs-keyword">return</span>;        System.out.print(arr[n] + <span class="hljs-string">&quot; &quot;</span>);        <span class="hljs-keyword">if</span> ((n * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &lt; arr.length) &#123;            preOrder(n * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">if</span> ((n * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>) &lt; arr.length) &#123;            preOrder(n * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>);        &#125;    &#125;    <span class="hljs-comment">// 顺序存储二叉树的中序遍历</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty())            <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> ((n * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &lt; arr.length) &#123;            infixOrder(n * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);        &#125;        System.out.print(arr[n] + <span class="hljs-string">&quot; &quot;</span>);        <span class="hljs-keyword">if</span> ((n * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>) &lt; arr.length) &#123;            infixOrder(n * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>);        &#125;    &#125;    <span class="hljs-comment">// 顺序存储二叉树的后序遍历</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty())            <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> ((n * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &lt; arr.length) &#123;            postOrder(n * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">if</span> ((n * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>) &lt; arr.length) &#123;            postOrder(n * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>);        &#125;        System.out.print(arr[n] + <span class="hljs-string">&quot; &quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;            System.out.println(<span class="hljs-string">&quot;树为空&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre></div><h3 id="顺序存储二叉树应用场景"><a href="#顺序存储二叉树应用场景" class="headerlink" title="顺序存储二叉树应用场景"></a>顺序存储二叉树应用场景</h3><p><a href="./19_%E5%A0%86%E6%8E%92%E5%BA%8F.md">堆排序</a></p><h2 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h2><h3 id="线索化二叉树基本概念"><a href="#线索化二叉树基本概念" class="headerlink" title="线索化二叉树基本概念"></a>线索化二叉树基本概念</h3><ol><li>n 个结点的二叉链表中含有<code>n+1</code>公式<code>2n-(n-1)=n+1</code>个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”）。</li><li>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树<br>(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种。</li><li>一个结点的前一个结点，称为前驱结点</li><li>一个结点的后一个结点，称为后继结点</li></ol><p>当线索化二叉树后，Node节点的属性<code>left</code>和<code>right</code>，有如下情况：</p><ul><li><code>left</code>指向的是左子树，也可能是指向的前驱节点。</li><li><code>right</code>指向的是右子树，也可能是指向的后驱节点。</li></ul><h3 id="线索化二叉树代码实现"><a href="#线索化二叉树代码实现" class="headerlink" title="线索化二叉树代码实现"></a>线索化二叉树代码实现</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yur.tree;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadedBinaryTree</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BinaryTree</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">ThreadedBinaryTree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadedBinaryTree</span>();        <span class="hljs-type">ThreadedTreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadedTreeNode</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Yorick&quot;</span>);        tree.setRoot(root);        <span class="hljs-type">ThreadedTreeNode</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadedTreeNode</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Merry&quot;</span>);        <span class="hljs-type">ThreadedTreeNode</span> <span class="hljs-variable">node3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadedTreeNode</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Jack&quot;</span>);        <span class="hljs-type">ThreadedTreeNode</span> <span class="hljs-variable">node4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadedTreeNode</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Tom&quot;</span>);        <span class="hljs-type">ThreadedTreeNode</span> <span class="hljs-variable">node5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadedTreeNode</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;Lily&quot;</span>);        root.left = node2;        root.right = node3;        node2.left = node4;        node3.right = node5;        tree.threadedNodes(root);        System.out.println(node4.right);        System.out.println(node2.right);        System.out.println(node5.left);        System.out.println(node3.left);        System.out.println(<span class="hljs-string">&quot;线索化中序遍历&quot;</span>);        <span class="hljs-comment">// 线索化遍历（中序）</span>        tree.threadedList();    &#125;    <span class="hljs-keyword">private</span> ThreadedTreeNode pre;    <span class="hljs-comment">// 中序线索化</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadedNodes</span><span class="hljs-params">(ThreadedTreeNode node)</span> &#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 处理左子树</span>        threadedNodes((ThreadedTreeNode) node.left);        <span class="hljs-comment">// 处理node</span>        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span>) &#123;            node.left = pre;            node.leftType = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span> &amp;&amp; pre.right == <span class="hljs-literal">null</span>) &#123;            pre.right = node;            pre.rightType = <span class="hljs-number">1</span>;        &#125;        pre = node;        <span class="hljs-comment">// 处理右子树</span>        threadedNodes((ThreadedTreeNode) node.right);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadedTreeNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TreeNode</span> &#123;    <span class="hljs-comment">// 规定结点的指针类型，默认为 0 代表指向子树，为 1 代表指向前驱或后驱结点</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">leftType</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">rightType</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadedTreeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;        <span class="hljs-built_in">super</span>(id, name);    &#125;&#125;</code></pre></div><h3 id="遍历线索化二叉树"><a href="#遍历线索化二叉树" class="headerlink" title="遍历线索化二叉树"></a>遍历线索化二叉树</h3><p>说明：对前面的中序线索化的二叉树，进行遍历<br>分析：因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。<strong>遍历的次序应当和中序遍历保持一致</strong>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 线索化遍历（中序）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadedList</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">ThreadedTreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> (ThreadedTreeNode) getRoot();    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// 向左找的第一个被线索化处理过的结点</span>        <span class="hljs-keyword">while</span> (node.leftType == <span class="hljs-number">0</span>) &#123;            node = (ThreadedTreeNode) node.left;        &#125;        System.out.println(node);        <span class="hljs-comment">//如果当前结点的右指针指向的是后继结点,就一直输出</span>        <span class="hljs-keyword">while</span> (node.rightType == <span class="hljs-number">1</span>) &#123;            node = (ThreadedTreeNode) node.right;            System.out.println(node);        &#125;        node = (ThreadedTreeNode) node.right;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>树</tag>
      
      <tag>Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><ul><li><a href="#%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a><ul><li><a href="#%E5%BA%94%E7%94%A8%E8%83%8C%E6%99%AF">应用背景</a><ul><li><a href="#google%E4%B8%8A%E6%9C%BA%E9%A2%98">Google上机题</a></li><li><a href="#%E5%87%8F%E5%B0%91%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E6%AC%A1%E6%95%B0">减少数据库查询次数</a></li></ul></li><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">实现思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li></ul></li></ul><h2 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h2><h3 id="Google上机题"><a href="#Google上机题" class="headerlink" title="Google上机题"></a>Google上机题</h3><p>看一个实际需求，Google公司的一个上机题：</p><p>有一个公司，当有新的员工来报道时，要求将该员工的信息加入（id，性别，年龄，住址…），当输入该员工的id时，要求查找到该员工的所有信息.<br>要求：不使用数据库，尽量节省内存，速度越快越好</p><p>这时候就暗示要使用哈希表（散列）</p><h3 id="减少数据库查询次数"><a href="#减少数据库查询次数" class="headerlink" title="减少数据库查询次数"></a>减少数据库查询次数</h3><p>可用于数据库和业务层（Java程序）之间的缓存层，从而减少数据库查询次数。</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>散列表 (Hash table，也叫哈希表)，是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p><img src="/./img/HashTable.png" alt="HashTable"></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>创建一个数组，数组每个元素存放一条链表，使用一种散列函数（如除余），使每个结点分散存放到指定链表。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><code>hashTable</code>类，包括测试</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span> &#123;    <span class="hljs-comment">// 测试</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">HashTable</span> <span class="hljs-variable">hashTable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashTable</span>(<span class="hljs-number">8</span>);        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Yorick&quot;</span>);        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Jerry&quot;</span>);        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Lily&quot;</span>);        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Tom&quot;</span>);        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Sia&quot;</span>);        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp10</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;Jim&quot;</span>);        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp11</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>(<span class="hljs-number">11</span>, <span class="hljs-string">&quot;Merry&quot;</span>);        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp12</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>(<span class="hljs-number">12</span>, <span class="hljs-string">&quot;Jack&quot;</span>);        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp13</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>(<span class="hljs-number">13</span>, <span class="hljs-string">&quot;Mike&quot;</span>);        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp23</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>(<span class="hljs-number">23</span>, <span class="hljs-string">&quot;Smith&quot;</span>);        hashTable.add(emp1);        hashTable.add(emp2);        hashTable.add(emp3);        hashTable.add(emp4);        hashTable.add(emp5);        hashTable.add(emp10);        hashTable.add(emp11);        hashTable.add(emp12);        hashTable.add(emp13);        hashTable.add(emp23);        hashTable.list();        hashTable.find(<span class="hljs-number">11</span>);        hashTable.del(<span class="hljs-number">3</span>);        hashTable.list();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> size;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EmpLinkedList[] empLinkedLists;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashTable</span><span class="hljs-params">(<span class="hljs-type">int</span> tableLength)</span> &#123;        <span class="hljs-built_in">this</span>.size = tableLength;        empLinkedLists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmpLinkedList</span>[tableLength];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            empLinkedLists[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmpLinkedList</span>();        &#125;    &#125;    <span class="hljs-comment">// 增加</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Emp emp)</span> &#123;        getListNo(emp.getId());        empLinkedLists[emp.getId() % size].add(emp);    &#125;    <span class="hljs-comment">// 遍历</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">list</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            System.out.print(<span class="hljs-string">&quot;第 &quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; 条 &quot;</span>);            empLinkedLists[i].list();        &#125;    &#125;    <span class="hljs-comment">// 查找</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;        <span class="hljs-type">EmpLinkedList</span> <span class="hljs-variable">empLinkedList</span> <span class="hljs-operator">=</span> getListNo(id);        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> empLinkedList.find(id);        <span class="hljs-keyword">if</span> (emp == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;未找到ID为 &quot;</span> + id + <span class="hljs-string">&quot; 的结点&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;此ID对应姓名为：&quot;</span> + emp.getName());        &#125;    &#125;    <span class="hljs-comment">// 删除</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">del</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;        empLinkedLists[id % size].del(id);    &#125;    <span class="hljs-comment">// 获取id所在链表</span>    <span class="hljs-keyword">public</span> EmpLinkedList <span class="hljs-title function_">getListNo</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;        <span class="hljs-keyword">return</span> empLinkedLists[id % size];    &#125;&#125;</code></pre></div><p>单链表<code>EmpLinkedList</code>类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmpLinkedList</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">Emp</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-comment">// 增加结点</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Emp emp)</span> &#123;        <span class="hljs-comment">// 如果链表为空，将第一个插入值作为头结点</span>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            head = emp;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 辅助指针</span>        <span class="hljs-type">Emp</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> head;        <span class="hljs-keyword">while</span> (helper.next != <span class="hljs-literal">null</span> &amp;&amp; emp.getId() &gt; helper.next.getId()) &#123;            helper = helper.next;        &#125;        <span class="hljs-type">Emp</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> helper.next;        helper.next = emp;        emp.next = temp;    &#125;    <span class="hljs-comment">// 遍历链表</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">list</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            System.out.println(<span class="hljs-string">&quot;NULL&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">Emp</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> head;        <span class="hljs-keyword">while</span> (helper != <span class="hljs-literal">null</span>) &#123;            System.out.printf(<span class="hljs-string">&quot;ID:%d NAME:%s\t&quot;</span>, helper.getId(), helper.getName());            helper = helper.next;        &#125;        System.out.println();    &#125;    <span class="hljs-keyword">public</span> Emp <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            System.out.println(<span class="hljs-string">&quot;链表为空&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-type">Emp</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> head;        <span class="hljs-keyword">while</span> (helper != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (helper.getId() == id) &#123;                <span class="hljs-keyword">return</span> helper;            &#125;            helper = helper.next;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">del</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            System.out.println(<span class="hljs-string">&quot;链表为空&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (head.getId() == id) &#123;            head = head.next;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">Emp</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> head;        <span class="hljs-keyword">while</span> (helper.next != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (helper.next.getId() == id) &#123;                helper.next = helper.next.next;                <span class="hljs-keyword">break</span>;            &#125;            helper = helper.next;        &#125;        System.out.println(<span class="hljs-string">&quot;未找到ID为 &quot;</span> + id + <span class="hljs-string">&quot; 的结点&quot;</span>);    &#125;    <span class="hljs-comment">// 判断非空</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> head == <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre></div><p>节点类<code>Emp</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Emp</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">public</span> Emp next;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Emp</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashTable</tag>
      
      <tag>Java</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查找</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><ul><li><a href="#%E6%9F%A5%E6%89%BE">查找</a><ul><li><a href="#%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE">常用查找</a></li><li><a href="#%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE">线性查找</a></li><li><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a><ul><li><a href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">思路分析</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a><ul><li><a href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0">递归实现</a></li><li><a href="#%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0">非递归实现</a></li></ul></li></ul></li><li><a href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE">插值查找</a><ul><li><a href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-1">思路分析</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1">代码实现</a></li></ul></li><li><a href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE">斐波那契查找</a><ul><li><a href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-2">思路分析</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2">代码实现</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li></ul></li></ul><h2 id="常用查找"><a href="#常用查找" class="headerlink" title="常用查找"></a>常用查找</h2><ol><li>顺序（线性）查找</li><li>二分查找&#x2F;折半查找</li><li>插值查找</li><li>斐波那契查按</li></ol><h2 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 简单的线性查找，找到一个val就返回下标</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">seqSearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> val)</span> &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;        <span class="hljs-keyword">if</span> (arr[i] == val) &#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></div><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>前提：待查找数组有序</p><p>二分查找法的运行时间为对数时间O(logn)，即查找到需要的目标位置最多只需要logn步，假设从[0,99]的队列（100个数，即n&#x3D;100）中寻到目标数30，则需要查找步数为log100，即最多需要查找7次($2^6 &lt; 100 &lt; 2^7$)</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>递归实现思路：</p><ol><li>首先确定该数组的中间的下标 <code>mid = (left+right) / 2</code></li><li>然后让需要查找的数<code>findval</code>和<code>arr[mid]</code>比较<br>2.1 <code>findVal &gt; arr[mid]</code>，说明你要查找的数在<code>mid</code>的右边，因此需要递归的向右查找。<br>2.2 <code>findval &lt; arr[mid]</code>，说明你要查找的数在<code>mid</code>的左边，因此需要递归的向左查找。<br>2.3 <code>findval == arr[mid]</code>说明找到，就返回<br>什么时候我们需要结束递归？<ul><li>找到就结束递归</li><li>递归完整个数组，仍然没有找到<code>findval</code>，也需要结束递归，当<code>left &gt; right</code>就需要退出</li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 二分查找，只返回第一个元素下标</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">BinarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> findVal, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;    <span class="hljs-comment">// 未找到</span>    <span class="hljs-keyword">if</span> (left &gt; right) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span> (findVal &lt; arr[mid]) &#123;        <span class="hljs-keyword">return</span> BinarySearch(arr, findVal, left, mid - <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (findVal &gt; arr[mid]) &#123;        <span class="hljs-keyword">return</span> BinarySearch(arr, findVal, mid + <span class="hljs-number">1</span>, right);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> mid;    &#125;&#125;<span class="hljs-comment">// 二分查找，返回所有元素的下标集合，这里用ArrayList存储，也可以用数组存储</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">BinaryMultiSearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> findVal, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;    <span class="hljs-comment">// 未找到</span>    <span class="hljs-keyword">if</span> (left &gt; right) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span> (findVal &lt; arr[mid]) &#123;        <span class="hljs-keyword">return</span> BinaryMultiSearch(arr, findVal, left, mid - <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (findVal &gt; arr[mid]) &#123;        <span class="hljs-keyword">return</span> BinaryMultiSearch(arr, findVal, mid + <span class="hljs-number">1</span>, right);    &#125; <span class="hljs-keyword">else</span> &#123;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        res.add(mid);        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> mid - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (temp &gt;= left &amp;&amp; arr[temp] == findVal) &#123;            res.add(temp);            temp--;        &#125;        temp = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (temp &lt;= right &amp;&amp; arr[temp] == findVal) &#123;            res.add(temp);            temp++;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h4 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySearch</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">84</span>&#125;;        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> binarySearch(arr, <span class="hljs-number">84</span>);        System.out.println(<span class="hljs-string">&quot;下表为：&quot;</span>+index);    &#125;    <span class="hljs-comment">// 二分查找的非递归实现</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> target)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (target == arr[mid]) &#123;                <span class="hljs-keyword">return</span> mid;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; arr[mid]) &#123;                right = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid]) &#123;                left = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div><h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>插值查找算法又称插值搜索算法，是在二分查找算法的基础上改进得到的一种查找算法。</p><p>插值查找算法只适用于有序序列，换句话说，它只能在升序序列或者降序序列中查找目标元素。作为“改进版”的二分查找算法，当有序序列中的元素呈现均匀分布时，插值查找算法的查找效率要优于二分查找算法；反之，如果有序序列不满足均匀分布的特征，插值查找算法的查找效率不如二分查找算法。</p><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><ol><li>插值查找算法类似于二分查找，不同的是插值查找每次从自适应<code>mid</code>处开始查找。</li><li>将二分查找中的求<code>mid</code>索引的公式，<code>left</code>表示左边索引，<code>right</code>表示右边索引，<code>findVal</code>表示待查找的值。</li></ol><p>$mid &#x3D; \frac{left+right}{2} &#x3D; left+\frac{1}{2}(right-left) \Rightarrow mid &#x3D; left + \frac{key-arr[low]}{arr[right]-arr[left]}(right-left)$  </p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 插值查找，只返回第一个元素</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpolationSearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> findVal, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;    <span class="hljs-comment">// 未找到，保证mid不越界</span>    <span class="hljs-keyword">if</span> (left &gt; right || findVal &lt; arr[left] || findVal &gt; arr[right]) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//如果搜索区域内只有一个元素，判断其是否为目标元素</span>    <span class="hljs-keyword">if</span> (left == right) &#123;        <span class="hljs-keyword">if</span> (findVal == arr[left]) &#123;            <span class="hljs-keyword">return</span> left;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (findVal - arr[left]) * (right - left) / (arr[right] - arr[left]);    <span class="hljs-keyword">if</span> (findVal &lt; arr[mid]) &#123;        <span class="hljs-keyword">return</span> interpolationSearch(arr, findVal, left, mid - <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (findVal &gt; arr[mid]) &#123;        <span class="hljs-keyword">return</span> interpolationSearch(arr, findVal, mid + <span class="hljs-number">1</span>, right);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> mid;    &#125;&#125;</code></pre></div><h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><p>斐波那契(黄金分割法)查找基本介绍：</p><ol><li>黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是<code>0.618</code>。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意想不到的效果。</li><li>斐波那契数列<code>&#123;1,1,2,3,5,8,13,21,34,55&#125;</code>，发现斐波那契数列的两个相邻数的比例，无限接近黄金分割值<code>0.618</code>。</li><li>前提：有序数组</li></ol><h3 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h3><p>参考链接：</p><p><a href="https://www.cnblogs.com/lpfuture/p/7112450.html">C语言版本</a><br><a href="https://blog.csdn.net/Scccc_/article/details/107101647">图解</a></p><p>斐波那契查找原理与前两种相似，仅仅改变了中间结点<code>mid</code>的位置，<code>mid</code>不再是中间或插值得到，而是位于黄金分割点附近，即<code>mid=low+F(k-1)-1</code>(F代表斐波那契数列），如下图所示</p><p><img src="/./img/fib.png" alt="fib"></p><p><strong>对<code>F(k-1)-1</code>的理解：</strong></p><ol><li>由斐波那契数列<code>F[k]=F[k-1]+F[k-2]</code>的性质，可以得到<code>(F[k]-1)=(F[k-1]-1)+(F[k-2]-1)+1</code>。<br>该式说明：只要顺序表的长度为<code>F[k]-1</code>，则可以将该表分成长度为<code>F[k-1]-1</code>和<code>F[k-2]-1</code>的两段，即如上图所示。从而中间位置为<code>mid=low+F(k-1)-1</code>。</li><li>类似的，每一子段也可以用相同的方式分割。</li><li>但顺序表长度<code>n</code>不一定刚好等于<code>F[k]-1</code>，所以需要将原来的顺序表长度<code>n</code>增加至<code>F[k]-1</code>。这里的<code>k</code>值只要能使得<code>F[k]-1</code>恰好大于或等于<code>n</code>即可，由以下代码得到，顺序表长度增加后，新增的位置（从<code>n+1</code>到<code>F[k]-1</code>位置），都赋为<code>n</code>位置的值即可。<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(n &gt; fib(k)-<span class="hljs-number">1</span>)&#123;   k++;&#125;</code></pre></div><strong>为什么要求<code>n=F(k)-1</code></strong></li></ol><p>假如待查找数组长度为<code>F(k)</code>：<br>不考虑<code>mid</code>的情况下，左边为<code>F(k-1)</code>，右边为<code>F(k-2)</code>；<br>考虑<code>mid</code>的情况下，要不左边是<code>F(k-1)-1</code>或者右边是<code>F(k - 2)-1</code>，逻辑不好写。<br> <br>但顺序表长度<code>n</code>不一定刚好等于<code>F[k]-1</code>，所以需要将原来的顺序表长度<code>n</code>增加至<code>F[k]-1</code>。<br>这里的<code>k</code>值只要能使得<code>F[k]-1</code>恰好大于或等于<code>n</code>即可</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 斐波那契查找（非递归实现）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fibonacciSearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> findVal)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示斐波那契分割数值的下标</span>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 定义斐波那契数列</span>    <span class="hljs-type">int</span>[] F = fib();    <span class="hljs-comment">// 确定斐波那契分割数值的下标</span>    <span class="hljs-keyword">while</span> (high &gt; F[k] - <span class="hljs-number">1</span>) &#123;        k++;    &#125;    <span class="hljs-comment">// 使数列长度为斐波那契数小一</span>    <span class="hljs-type">int</span>[] temp = Arrays.copyOf(arr, F[k] - <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> high + <span class="hljs-number">1</span>; i &lt; F[k] - <span class="hljs-number">1</span>; i++) &#123;        temp[i] = arr[high];    &#125;    arr = temp;    <span class="hljs-comment">// 开始循环查找</span>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;        mid = low + F[k - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (findVal &lt; arr[mid]) &#123;            high = mid - <span class="hljs-number">1</span>;            k--;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (findVal &gt; arr[mid]) &#123;            low = mid + <span class="hljs-number">1</span>;            k -= <span class="hljs-number">2</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 因为数组扩大了，mid可能存在大于high的情况</span>            <span class="hljs-keyword">return</span> Math.min(mid, high);        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>斐波那契查找算法只进行加减法，而二分查找需要用到除法（在计算机中乘除法都要转成加法运算，因为计算机只能进行加法运算，所以乘除法很耗时间），所以斐波那契查找效率高于二分查找，但是它们的时间复杂度都为 $O(log(n))$</p>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Search</tag>
      
      <tag>查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基数排序</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><ul><li><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">基本思想</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li><li><a href="#%E7%89%B9%E7%82%B9%E6%80%BB%E7%BB%93">特点总结</a></li></ul></li></ul><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol><li>基数排序(Radix Sort）属于“分配式排序” (distribution sort)，又称“桶子法”(bucket sort)或 bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用。</li><li>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法。</li><li>基数排序(Radix Sort)是桶排序的扩展。</li><li>基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的:将整数按位数切割成不同的数字，然后按每个位数分别比较。</li></ol><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p><p><a href="https://www.bilibili.com/video/BV1E4411H73v?p=72">视频讲解</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 基数排序</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;    <span class="hljs-comment">// 二维数组存放数据</span>    <span class="hljs-type">int</span>[][] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][arr.length];    <span class="hljs-comment">// 记录每个桶里有多少个数</span>    <span class="hljs-type">int</span>[] bucketElementCounts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 确定最大值</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> item : arr) &#123;        <span class="hljs-keyword">if</span> (item &gt; max) &#123;            max = item;        &#125;    &#125;    max = (max + <span class="hljs-string">&quot;&quot;</span>).length();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, num = <span class="hljs-number">1</span>; j &lt; max; j++, num *= <span class="hljs-number">10</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">digitOfElement</span> <span class="hljs-operator">=</span> (value / num) % <span class="hljs-number">10</span>;            <span class="hljs-comment">// 另外一种，速度较慢</span>            <span class="hljs-comment">// int digitOfElement = (arr[i] % (num * 10)) / num;</span>            <span class="hljs-comment">// 放入对应的桶</span>            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = value;            bucketElementCounts[digitOfElement]++;        &#125;        <span class="hljs-comment">// 按照这个桶的顺序(一维数组的下标依次取出数据,放入原来数组)</span>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;            <span class="hljs-keyword">if</span> (bucketElementCounts[k] &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; n &lt; bucketElementCounts[k]; n++) &#123;                    arr[index] = bucket[k][n];                    index++;                &#125;                bucketElementCounts[k] = <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="特点总结"><a href="#特点总结" class="headerlink" title="特点总结"></a>特点总结</h2><ol><li>基数排序是对传统桶排序的扩展，速度很快。</li><li>基数排序是经典的空间换时间的方式，占用内存很大，当对海量数据排序时容易造成<code>OutOfMemoryError</code>。</li><li>基数排序时稳定的。（注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，<code>r[i]=r[j]</code>，且<code>r[i]</code>在<code>r[j]</code>之前，而在排序后的序列中，<code>r[i]</code>仍在<code>r[j]</code>之前，则称这种排序算法是稳定的；否则称为不稳定的。）</li><li>基数排序不适用有负数的数组。</li></ol>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Sort</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>归并排序(MERGE-SORT)是利用归并的思想实现的排序方法，该算法采用经典的分治(divide-and-conquer)策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之）。</p><p><a href="https://www.bilibili.com/video/BV1E4411H73v?p=70">视频讲解</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 归并排序</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span>[] temp)</span> &#123;    <span class="hljs-keyword">if</span> (left &lt; right) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 中间索引</span>        <span class="hljs-comment">// 向左递归进行分解</span>        mergeSort(arr, left, mid, temp);        <span class="hljs-comment">// 向右递归进行分解</span>        mergeSort(arr, mid + <span class="hljs-number">1</span>, right, temp);        <span class="hljs-comment">// 合并</span>        merge(arr, left, mid, right, temp);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 合并有序数组</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr   排序的原始数组</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> left  左边有序数组的初始索引</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> mid   中间索引</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> right 右边索引</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> temp  中转数组</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span>[] temp)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; <span class="hljs-comment">// 左边有序数组的初始索引</span>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 右边有序数组的初始索引</span>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 指向 temp 数组的当前索引</span>    <span class="hljs-comment">// 先把左右两边的有序数据按照规则填充到 temp数组</span>    <span class="hljs-comment">// 直到左右两边的有序序列,有一边处理完毕为止</span>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;        <span class="hljs-comment">// 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span>        <span class="hljs-comment">// 即将左边的当前元素,填充到 temp数组</span>        <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) &#123;            temp[t] = arr[i];            t++;            i++;        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 反之,将右边有序序列的当前元素,填充到temp数组</span>            temp[t] = arr[j];            t++;            j++;        &#125;    &#125;    <span class="hljs-comment">// 把有剩余数据的一边的数据依次全部填充到temp</span>    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;        temp[t] = arr[i];        t++;        i++;    &#125;    <span class="hljs-keyword">while</span> (j &lt;= right) &#123;        temp[t] = arr[j];        t++;        j++;    &#125;    <span class="hljs-comment">// 将 temp数组的元素拷贝到 arr</span>    <span class="hljs-comment">// 注意,并不是每次都拷贝所有</span>    t = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">tempLeft</span> <span class="hljs-operator">=</span> left;    <span class="hljs-keyword">while</span> (tempLeft &lt;= right) &#123;        arr[tempLeft] = temp[t];        t++;        tempLeft++;    &#125;&#125;</code></pre></div><p>使用时要实例化 temp 数组</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Sort</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><ul><li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li><li><a href="#%E7%89%B9%E7%82%B9%E5%8F%8A%E6%80%A7%E8%83%BD">特点及性能</a></li></ul></li></ul><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p><a href="https://www.bilibili.com/video/BV1at411T75o">视频讲解</a></p><ol><li>选定Pivot中心轴</li><li>将大于Pivot的数字放在Pivot的右边</li><li>将小于Pivot的数字放在Pivot的左边</li><li>分别对左右子序列重复前三步操作</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 快速排序交换式</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> left;    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> right;    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[(left + right) / <span class="hljs-number">2</span>];    <span class="hljs-type">int</span> temp;    <span class="hljs-keyword">while</span> (l &lt; r) &#123;        <span class="hljs-keyword">while</span> (arr[l] &lt; pivot) &#123;            l++;        &#125;        <span class="hljs-keyword">while</span> (arr[r] &gt; pivot) &#123;            r--;        &#125;        <span class="hljs-comment">// 说明已经满足条件</span>        <span class="hljs-keyword">if</span> (l &gt;= r) &#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-comment">// 交换位置</span>        temp = arr[l];        arr[l] = arr[r];        arr[r] = temp;        <span class="hljs-keyword">if</span> (arr[l] == pivot) &#123;            r--;        &#125;        <span class="hljs-keyword">if</span> (arr[r] == pivot) &#123;            l++;        &#125;        <span class="hljs-keyword">if</span> (l == r) &#123;            l++;            r--;        &#125;        <span class="hljs-keyword">if</span> (left &lt; r) &#123;            quickSort(arr, left, r);        &#125;        <span class="hljs-keyword">if</span> (l &lt; right) &#123;            quickSort(arr, l, right);        &#125;    &#125;&#125;<span class="hljs-comment">// 快速排序填坑式 速度快</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[left];    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> left;    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> right;    <span class="hljs-keyword">while</span> (l &lt; r) &#123;        <span class="hljs-keyword">while</span> (arr[r] &gt; pivot &amp;&amp; l &lt; r) &#123;            r--;        &#125;        <span class="hljs-keyword">if</span> (l == r) &#123;            <span class="hljs-keyword">break</span>;        &#125;        arr[l] = arr[r];        l++;        <span class="hljs-keyword">while</span> (arr[l] &lt; pivot &amp;&amp; l &lt; r) &#123;            l++;        &#125;        <span class="hljs-keyword">if</span> (l == r) &#123;            <span class="hljs-keyword">break</span>;        &#125;        arr[r] = arr[l];        r--;    &#125;    arr[l] = pivot;    <span class="hljs-keyword">if</span> (l &gt; left) &#123;        quickSort2(arr, left, l - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">if</span> (r &lt; right) &#123;        quickSort2(arr, r + <span class="hljs-number">1</span>, right);    &#125;&#125;</code></pre></div><p>快速排序填坑式的另一种，速度稍慢，但代码简洁</p><p><a href="http://data.biancheng.net/view/117.html">快速排序</a></p><h2 id="特点及性能"><a href="#特点及性能" class="headerlink" title="特点及性能"></a>特点及性能</h2><p>快速排序是在冒泡排序的基础上改进而来的，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。</p><p>但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是 O(n2)，实际上每次比较都需要交换，但是这种情况并不常见。我们可以思考一下如果每次比较都需要交换，那么数列的平均时间复杂度是 O(nlogn)，事实上在大多数时候，排序的速度要快于这个平均时间复杂度。这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来。</p><p>快速排序只是使用数组原本的空间进行排序，所以所占用的空间应该是常量级的，但是由于每次划分之后是递归调用，所以递归调用在运行的过程中会消耗一定的空间，在一般情况下的空间复杂度为 O(logn)，在最差的情况下，若每次只完成了一个元素，那么空间复杂度为 O(n)。所以我们一般认为快速排序的空间复杂度为 O(logn)。</p><p>快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。</p><p>快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。</p>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Sort</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>希尔排序</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>希尔排序是希尔(Donald Shell)于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 希尔排序移动式，时间复杂度为 O(n^2)，效率高</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;    <span class="hljs-type">int</span> insertVal;    <span class="hljs-type">int</span> insertIndex;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;        <span class="hljs-comment">// 这个循环的次数为分成的组数，有几组进行几次插入排序</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; n &lt; gap; n++) &#123;            <span class="hljs-comment">// 插入排序，不同组起点不同</span>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n + gap; i &lt; arr.length; i += gap) &#123;                insertVal = arr[i]; <span class="hljs-comment">// 待插入值</span>                insertIndex = i - gap; <span class="hljs-comment">// 有序数列末尾元素的序号</span>                <span class="hljs-keyword">while</span> (insertIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;                    arr[insertIndex + gap] = arr[insertIndex];                    insertIndex -= gap;                &#125;                <span class="hljs-keyword">if</span> (insertIndex + gap != i) &#123;                    arr[insertIndex + gap] = insertVal;                &#125;            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">// 希尔排序交换式，时间复杂度为 O(n^2)，效率低</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shellSort2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;    <span class="hljs-type">int</span> insertVal;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;        <span class="hljs-comment">// 这个循环的次数为分成的组数，有几组进行几次插入排序</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> gap; n &lt; arr.length; n++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - gap; i &gt;= <span class="hljs-number">0</span>; i -= gap) &#123;                <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + gap]) &#123;                    insertVal = arr[i];                    arr[i] = arr[i + gap];                    arr[i + gap] = insertVal;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Sort</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><ul><li><a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li><li><a href="#%E7%AE%80%E5%8D%95%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">简单插入排序存在的问题</a></li></ul></li></ul><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。</p><p>插入排序(Insertion Sorting)的基本思想是：把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 插入排序，时间复杂度 O(n^2)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;    <span class="hljs-type">int</span> insertVal;    <span class="hljs-type">int</span> insertIndex;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;        insertVal = arr[i]; <span class="hljs-comment">// 待插入值</span>        insertIndex = i - <span class="hljs-number">1</span>; <span class="hljs-comment">// 有序数列末尾元素的序号</span>        <span class="hljs-comment">// insertIndex &gt;= 0 阻止数组越界，&lt; 改 &gt; 则从大到小</span>        <span class="hljs-keyword">while</span> (insertIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;            arr[insertIndex + <span class="hljs-number">1</span>] = arr[insertIndex];            insertIndex--;        &#125;        <span class="hljs-comment">// while结束后代表位置已经找到</span>        <span class="hljs-keyword">if</span> (insertIndex + <span class="hljs-number">1</span> != i) &#123;            arr[insertIndex + <span class="hljs-number">1</span>] = insertVal;        &#125;    &#125;&#125;</code></pre></div><h2 id="简单插入排序存在的问题"><a href="#简单插入排序存在的问题" class="headerlink" title="简单插入排序存在的问题"></a>简单插入排序存在的问题</h2><p>我们看简单的插入排序可能存在的问题。<br>数组<code>arr = &#123;2,3,4,5,6,1&#125;</code>这时需要插入的数1(最小)，这样的过程是:</p><div class="code-wrapper"><pre><code class="hljs java">&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>&#125;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;</code></pre></div><p>结论：当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响。</p>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Sort</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>选择排序(select sorting)也是一种简单的排序方法。它的基本思想是：第一次从<code>arr[0]~arr[n-1]</code>中选取最小值，与<code>arr[0]</code>交换，第二次从<code>arr[1]~arr[n-1]</code>中选取最小值，与<code>arr[1]</code>交换，第三次从<code>arr[2]~arr[n-1]</code>中选取最小值，与<code>arr[2]</code>交换，…，第<code>i</code>次从<code>arr[i-1]~arr[n-1]</code>中选取最小值，与<code>arr[i-1]</code>交换，…，第<code>n-1</code>次从<code>arr[n-2]~arr[n-1]</code>中选取最小值，与<code>arr[n-2]</code>交换，总共通过<code>n-1</code>次，得到一个按排序码从小到大排列的有序序列。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 选择排序，时间复杂度 O(n^2)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;    <span class="hljs-type">int</span> min; <span class="hljs-comment">// 记录最小值</span>    <span class="hljs-type">int</span> minIndex; <span class="hljs-comment">// 记录交最小值的位置位置</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; start &lt; arr.length - <span class="hljs-number">1</span>; start++) &#123;        min = arr[start];        minIndex = start;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">if</span> (arr[i + <span class="hljs-number">1</span>] &lt; min) &#123;                min = arr[i + <span class="hljs-number">1</span>];                minIndex = i + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span> (minIndex != start) &#123;            arr[minIndex] = arr[start];            arr[start] = min;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Sort</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>冒泡排序(Bubble Sorting)的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒。</p><p>因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序。因此要在排序过程中设置一个标志flag判断元素是否进行过交换，从而减少不必要的比较。</p><p>特点：</p><ol><li>一共进行数组的大小-1次大的循环；</li><li>每一趟排序的次数在逐渐的减少；</li><li>如果一趟比较下来没有进行过交换，可以提前结束排序。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 时间复杂度 O(n^2)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;    <span class="hljs-type">int</span> temp;    <span class="hljs-type">boolean</span> flag; <span class="hljs-comment">// 标记存在位置调换，默认为否</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span>; j++) &#123;        flag = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span> - j; i++) &#123;            <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) &#123;                temp = arr[i];                arr[i] = arr[i + <span class="hljs-number">1</span>];                arr[i + <span class="hljs-number">1</span>] = temp;                flag = <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span> (!flag) &#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-comment">//System.out.println(&quot;第 &quot; + j + &quot; 次：&quot; + Arrays.toString(arr));</span>    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Sort</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间复杂度与空间复杂度</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="时间复杂度与空间复杂度"><a href="#时间复杂度与空间复杂度" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h1><ul><li><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度与空间复杂度</a><ul><li><a href="#%E5%BA%A6%E9%87%8F%E7%A8%8B%E5%BA%8F%E7%AE%97%E6%B3%95%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95">度量程序(算法)执行时间的方法</a><ul><li><a href="#%E4%BA%8B%E5%90%8E%E7%BB%9F%E8%AE%A1">事后统计</a></li><li><a href="#%E4%BA%8B%E5%89%8D%E4%BC%B0%E7%AE%97">事前估算</a></li></ul></li><li><a href="#%E6%97%B6%E9%97%B4%E9%A2%91%E5%BA%A6">时间频度</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E">举例说明</a></li><li><a href="#%E6%97%B6%E9%97%B4%E9%A2%91%E5%BA%A6%E7%9A%84%E6%80%A7%E8%B4%A8">时间频度的性质</a><ul><li><a href="#%E5%BF%BD%E7%95%A5%E5%B8%B8%E6%95%B0%E9%A1%B9">忽略常数项</a></li><li><a href="#%E5%BF%BD%E7%95%A5%E9%AB%98%E6%AC%A1%E9%A1%B9%E7%9A%84%E7%B3%BB%E6%95%B0%E5%92%8C%E4%BD%8E%E6%AC%A1%E9%A1%B9">忽略高次项的系数和低次项</a></li></ul></li></ul></li><li><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度</a><ul><li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">常见的时间复杂度</a><ul><li><a href="#%E5%B8%B8%E6%95%B0%E9%98%B6-o1">常数阶 $O(1)$</a></li><li><a href="#%E5%AF%B9%E6%95%B0%E9%98%B6-olog_2n">对数阶 $O(\log_{2}{n})$</a></li><li><a href="#%E7%BA%BF%E6%80%A7%E9%98%B6-on">线性阶 $O(n)$</a></li><li><a href="#%E7%BA%BF%E6%80%A7%E5%AF%B9%E6%95%B0%E9%98%B6-onlog_2n">线性对数阶 $O(n\log_{2}{n})$</a></li><li><a href="#%E5%B9%B3%E6%96%B9%E9%98%B6-on2">平方阶 $O(n^2)$</a></li><li><a href="#%E7%AB%8B%E6%96%B9%E9%98%B6-on3">立方阶 $O(n^3)$</a></li><li><a href="#k%E6%AC%A1%E6%96%B9%E9%98%B6-onk">k次方阶 $O(n^k)$</a></li></ul></li><li><a href="#%E5%B9%B3%E5%9D%87%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E6%9C%80%E5%9D%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">平均时间复杂度和最坏时间复杂度</a></li></ul></li><li><a href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">空间复杂度</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1">基本介绍</a></li></ul></li></ul></li></ul><h2 id="度量程序-算法-执行时间的方法"><a href="#度量程序-算法-执行时间的方法" class="headerlink" title="度量程序(算法)执行时间的方法"></a>度量程序(算法)执行时间的方法</h2><h3 id="事后统计"><a href="#事后统计" class="headerlink" title="事后统计"></a>事后统计</h3><p>这种方法可行，但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素,这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。</p><h3 id="事前估算"><a href="#事前估算" class="headerlink" title="事前估算"></a>事前估算</h3><p>通过分析某个算法的时间复杂度来判断哪个算法更优。</p><h2 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为 $T(n)$。</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>计算1-100所有数字之和</p><ol><li><p>使用for循环计算</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt;= end;i++)&#123;    total++;&#125;</code></pre></div><p>$T(n)&#x3D;n+1$</p></li><li><p>直接用公式计算</p><div class="code-wrapper"><pre><code class="hljs java">total = (<span class="hljs-number">1</span>+end)*end/<span class="hljs-number">2</span></code></pre></div><p>$T(n)&#x3D;1$</p></li></ol><h3 id="时间频度的性质"><a href="#时间频度的性质" class="headerlink" title="时间频度的性质"></a>时间频度的性质</h3><p>时间频度随着 $n$ 趋近无限大有以下性质</p><h4 id="忽略常数项"><a href="#忽略常数项" class="headerlink" title="忽略常数项"></a>忽略常数项</h4><p>$T(n)&#x3D;2n+10 \Rightarrow T(n)&#x3D;2n$</p><h4 id="忽略高次项的系数和低次项"><a href="#忽略高次项的系数和低次项" class="headerlink" title="忽略高次项的系数和低次项"></a>忽略高次项的系数和低次项</h4><p>$T(n)&#x3D;2n^2+3n+10 \Rightarrow T(n)&#x3D;n^2$</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ol><li><p>一般情况下，算法中的基本操作语句的重复执行次数是问题规模 $n$ 的某个函数，用 $T(n)$ 表示，若有某个辅助函数 $f(n)$，使得当n趋近于无穷大时， $T(n) &#x2F; f(n)$ 的极限值为不等于零的常数，则称 $f(n)$ 是 $T(n)$ 的同数量级函数。记作 $T(n)&#x3D;O(f(n))$，称 $O(f(n))$ 为算法的渐进时间复杂度，简称时间复杂度。</p></li><li><p>$T(n)$不同，但时间复杂度可能相同。如: $T(n)&#x3D;n^2+7n+6$ 与 $T(n)&#x3D;3n^2+2n+2$ 它们的 $T(n)$ 不同，但时间复杂度相同，都为 $O(n^2)$ 。</p></li><li><p>计算时间复杂度的方法:</p></li></ol><ul><li>用常数 $1$ 代替运行时间中的所有加法常数</li><li>修改后的运行次数函数中，只保留最高阶项</li><li>去除最高阶项的系数</li></ul><h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><ol><li>常数阶 $O(1)$</li><li>对数阶 $O(\log_{2}{n})$</li><li>线性阶 $O(n)$</li><li>线性对数阶 $O(n\log_{2}{n})$</li><li>平方阶 $O(n^2)$</li><li>立方阶 $O(n^3)$</li><li>k次方阶 $O(n^k)$</li><li>指数阶 $O(2^n)$</li></ol><ul><li>常见的算法时间复杂度由小到大依次为：<br>$O(1)&lt;O(\log_{2}{n})&lt;O(n)&lt;O(n\log_{2}{n})&lt;O(n^2)&lt;O(n^3)&lt;O(n^k)&lt;O(2^n)$，随着问题规模 $n$ 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</li><li>由图可见，我们应该尽可能避免使用指数阶的算法</li></ul><p><img src="/./img/time_complexity.png" alt="time_complexity"></p><h4 id="常数阶-O-1"><a href="#常数阶-O-1" class="headerlink" title="常数阶 $O(1)$"></a>常数阶 $O(1)$</h4><p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是 $O(1)$</p><h4 id="对数阶-O-log-2-n"><a href="#对数阶-O-log-2-n" class="headerlink" title="对数阶 $O(\log_{2}{n})$"></a>对数阶 $O(\log_{2}{n})$</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(i &lt; n)&#123;  i = i * <span class="hljs-number">2</span>;&#125;</code></pre></div><p>说明：在while循环里面，每次都将 i 乘以 2 ，乘完之后，i 距离 n 就越来越近了。假设循环 x 次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 $x&#x3D;\log_{2}{n}$ 也就是说当循环 $\log_{2}{n}$ 次以后，这个代码就结束了。因此这个代码的时间复杂度为：$O(\log_{2}{n})$ 。$O(\log_{2}{n})$ 的这个 2 时间上是根据代码变化的，若<code>i = i * 3</code>，则是 $O(\log_{3}{n})$。</p><h4 id="线性阶-O-n"><a href="#线性阶-O-n" class="headerlink" title="线性阶 $O(n)$"></a>线性阶 $O(n)$</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; n;i++)&#123;  j++;&#125;</code></pre></div><p>说明：这段代码，for循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用 $O(n)$ 来表示它的时间复杂度。</p><h4 id="线性对数阶-O-n-log-2-n"><a href="#线性对数阶-O-n-log-2-n" class="headerlink" title="线性对数阶 $O(n\log_{2}{n})$"></a>线性对数阶 $O(n\log_{2}{n})$</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;m &lt; n;m++)&#123;  <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span>(i &lt; n)&#123;    i = i * <span class="hljs-number">2</span>;  &#125;&#125;</code></pre></div><p>说明：线性对数阶 $O(n\log_{2}{n})$ 其实非常容易理解，将时间复杂度为 $O(\log_{2}{n})$ 的代码循环 $n$ 遍的话，那么它的时间复杂度就是  $n*O(\log_{2}{n})$ ，也就是 $O(n\log_{2}{n})$ 。</p><h4 id="平方阶-O-n-2"><a href="#平方阶-O-n-2" class="headerlink" title="平方阶 $O(n^2)$"></a>平方阶 $O(n^2)$</h4><p>常见于双层循环嵌套</p><h4 id="立方阶-O-n-3"><a href="#立方阶-O-n-3" class="headerlink" title="立方阶 $O(n^3)$"></a>立方阶 $O(n^3)$</h4><p>常见于三层循环嵌套</p><h4 id="k次方阶-O-n-k"><a href="#k次方阶-O-n-k" class="headerlink" title="k次方阶 $O(n^k)$"></a>k次方阶 $O(n^k)$</h4><p>常见于 k 层循环嵌套</p><h3 id="平均时间复杂度和最坏时间复杂度"><a href="#平均时间复杂度和最坏时间复杂度" class="headerlink" title="平均时间复杂度和最坏时间复杂度"></a>平均时间复杂度和最坏时间复杂度</h3><ol><li>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。</li><li>最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是:最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。</li><li>平均时间复杂度和最坏时间复杂度是否一致，和算法有关。</li></ol><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。</li><li>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。</li><li>在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间。</li></ol>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%8E%92%E5%BA%8F/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。</p><h2 id="排序的分类"><a href="#排序的分类" class="headerlink" title="排序的分类"></a>排序的分类</h2><ol><li>内部排序，指将需要处理的所有数据都加载到内部存储器（内存）中进行排序。</li><li>外部排序法，数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。</li></ol><p><img src="/./img/sequence.png" alt="sequence"> </p><h2 id="常用排序算法总结和对比"><a href="#常用排序算法总结和对比" class="headerlink" title="常用排序算法总结和对比"></a>常用排序算法总结和对比</h2><p><img src="/./img/sort.jpg" alt="sort"></p>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Sort</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%80%92%E5%BD%92/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><ul><li><a href="#%E9%80%92%E5%BD%92">递归</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a><ul><li><a href="#%E9%80%92%E5%BD%92%E9%9C%80%E8%A6%81%E9%81%B5%E5%AE%88%E7%9A%84%E9%87%8D%E8%A6%81%E8%A7%84%E5%88%99">递归需要遵守的重要规则</a></li><li><a href="#%E9%80%92%E5%BD%92%E5%8F%AF%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">递归可解决的问题</a></li><li><a href="#%E8%BF%B7%E5%AE%AB%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98">迷宫回溯问题</a><ul><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li></ul></li><li><a href="#%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98">八皇后问题</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1">基本介绍</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF">解决思路</a><ul><li><a href="#%E6%96%B9%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92%E8%A7%A3%E5%86%B3">方法一：递归解决</a></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>递归（recursion）就是方法自己调用自己，每次调用时传入不同的变量。递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。</p><p><img src="/img/recursion.png" alt="recursion"></p><h3 id="递归需要遵守的重要规则"><a href="#递归需要遵守的重要规则" class="headerlink" title="递归需要遵守的重要规则"></a>递归需要遵守的重要规则</h3><ol><li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li><li>方法的局部变量是独立的，不会相互影响</li><li>如果方法中使用的是引用类型变量，就会共享该引用类型的数据。</li><li>递归必须向退出递归的条件逼近，否则就是无限递归，死龟了:)</li><li>当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li></ol><h3 id="递归可解决的问题"><a href="#递归可解决的问题" class="headerlink" title="递归可解决的问题"></a>递归可解决的问题</h3><ol><li>各种数学问题如：8皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题(google编程大赛)</li><li>各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等。</li><li>将用栈解决的问题-&gt;第归代码比较简洁</li></ol><h3 id="迷宫回溯问题"><a href="#迷宫回溯问题" class="headerlink" title="迷宫回溯问题"></a>迷宫回溯问题</h3><p>使用递归解决迷宫回溯问题</p><p>得到的路径，和程序员设置的找路策略有关即找路的上下左右的顺序相关</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Maze</span> &#123;    <span class="hljs-comment">// 地图基本属性</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> length;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> width;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] map;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> endX;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> endY;    <span class="hljs-comment">// 地图构造器</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Maze</span><span class="hljs-params">(<span class="hljs-type">int</span> length, <span class="hljs-type">int</span> width)</span> &#123;        <span class="hljs-comment">// 最小3X3</span>        <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-number">3</span> || width &lt; <span class="hljs-number">3</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;数值不合法&quot;</span>);        &#125;        <span class="hljs-built_in">this</span>.length = length;        <span class="hljs-built_in">this</span>.width = width;        <span class="hljs-built_in">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length][width];        <span class="hljs-comment">// 默认终点右下角</span>        endX = length - <span class="hljs-number">2</span>;        endY = width - <span class="hljs-number">2</span>;        <span class="hljs-comment">// 填充 0</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; width; j++) &#123;                map[i][j] = <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-comment">// 上下边为 1</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; width; i++) &#123;            map[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;            map[length - <span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 左右边为 1</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;            map[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;            map[i][width - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] getMap() &#123;        <span class="hljs-keyword">return</span> map;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMap</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] map)</span> &#123;        <span class="hljs-built_in">this</span>.map = map;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getEndX</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> endX;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEndX</span><span class="hljs-params">(<span class="hljs-type">int</span> endX)</span> &#123;        <span class="hljs-built_in">this</span>.endX = endX;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getEndY</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> endY;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEndY</span><span class="hljs-params">(<span class="hljs-type">int</span> endY)</span> &#123;        <span class="hljs-built_in">this</span>.endY = endY;    &#125;    <span class="hljs-comment">// 打印地图</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printMap</span><span class="hljs-params">()</span> &#123;        System.out.printf(<span class="hljs-string">&quot;\033[34m&quot;</span> + <span class="hljs-string">&quot;%d\t&quot;</span>, <span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;            System.out.printf(<span class="hljs-string">&quot;\033[34m&quot;</span> + <span class="hljs-string">&quot;%d\t&quot;</span>, i);        &#125;        System.out.println();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;            System.out.printf(<span class="hljs-string">&quot;\033[34m&quot;</span> + <span class="hljs-string">&quot;%d\t&quot;</span>, i);            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">this</span>.width; j++) &#123;                <span class="hljs-keyword">if</span> (map[i][j] == <span class="hljs-number">2</span>) &#123;                    System.out.printf(<span class="hljs-string">&quot;\033[31m&quot;</span> + <span class="hljs-string">&quot;%d\t&quot;</span>, map[i][j]);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map[i][j] == <span class="hljs-number">1</span>) &#123;                    System.out.printf(<span class="hljs-string">&quot;\033[32m&quot;</span> + <span class="hljs-string">&quot;%d\t&quot;</span>, map[i][j]);                &#125; <span class="hljs-keyword">else</span> &#123;                    System.out.printf(<span class="hljs-string">&quot;\033[30m&quot;</span> + <span class="hljs-string">&quot;%d\t&quot;</span>, map[i][j]);                &#125;            &#125;            System.out.println();        &#125;    &#125;    <span class="hljs-comment">// 设置障碍</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;        <span class="hljs-keyword">if</span> (x * y &lt; <span class="hljs-number">0</span> &amp;&amp; x &gt; length - <span class="hljs-number">1</span> &amp;&amp; y &gt; width - <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;数值错误&quot;</span>);        &#125;        map[x][y] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 设置终点</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEnd</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;        <span class="hljs-built_in">this</span>.endX = x;        <span class="hljs-built_in">this</span>.endY = y;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRandomBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> times)</span> &#123;        <span class="hljs-type">int</span> x;        <span class="hljs-type">int</span> y;        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; times; i++) &#123;            x = random.nextInt(width - <span class="hljs-number">1</span>);            y = random.nextInt(length - <span class="hljs-number">1</span>);            setBarrier(x, y);        &#125;    &#125;    <span class="hljs-comment">// 计算路线1</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getWay1</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;        <span class="hljs-keyword">if</span> (map[endX][endY] == <span class="hljs-number">2</span>) &#123;            <span class="hljs-comment">// 表示找到</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (map[x][y] == <span class="hljs-number">0</span>) &#123;                map[x][y] = <span class="hljs-number">2</span>;                <span class="hljs-comment">// 右-下-左-上</span>                <span class="hljs-keyword">if</span> (getWay1(x, y + <span class="hljs-number">1</span>)) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getWay1(x + <span class="hljs-number">1</span>, y)) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getWay1(x, y - <span class="hljs-number">1</span>)) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getWay1(x - <span class="hljs-number">1</span>, y)) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 死路</span>                    map[x][y] = <span class="hljs-number">3</span>;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 计算路线2</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getWay2</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;        <span class="hljs-keyword">if</span> (map[endX][endY] == <span class="hljs-number">2</span>) &#123;            <span class="hljs-comment">// 表示找到</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (map[x][y] == <span class="hljs-number">0</span>) &#123;                map[x][y] = <span class="hljs-number">2</span>;                <span class="hljs-comment">// 下-右-上-左</span>                <span class="hljs-keyword">if</span> (getWay2(x + <span class="hljs-number">1</span>, y)) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getWay2(x, y + <span class="hljs-number">1</span>)) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getWay2(x - <span class="hljs-number">1</span>, y)) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getWay2(x, y - <span class="hljs-number">1</span>)) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 死路</span>                    map[x][y] = <span class="hljs-number">3</span>;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 还原</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">this</span>.width; j++) &#123;                <span class="hljs-keyword">if</span> (map[i][j] == <span class="hljs-number">3</span>) &#123;                    map[i][j] = <span class="hljs-number">0</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map[i][j] == <span class="hljs-number">2</span>) &#123;                    map[i][j] = <span class="hljs-number">0</span>;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>测试类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMaze</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">// 7 行 8 列</span>        <span class="hljs-type">Maze</span> <span class="hljs-variable">maze</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Maze</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>);        maze.setRandomBarrier(<span class="hljs-number">100</span>);        maze.setEnd(<span class="hljs-number">9</span>,<span class="hljs-number">9</span>);        maze.getWay1(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);        maze.printMap();        maze.restore();        maze.getWay2(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);        maze.printMap();    &#125;&#125;</code></pre></div><h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出:在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：<strong>任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法</strong>。</p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><h5 id="方法一：递归解决"><a href="#方法一：递归解决" class="headerlink" title="方法一：递归解决"></a>方法一：递归解决</h5><ol><li>第一个皇后先放第一行第一列</li><li>第二个皇后放在第二行第一列，然后判断是否ok，如果不ok，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</li><li>继续第三个皇后，还是第一列、第二.列….直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</li><li>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到。</li><li>然后回头继续第一个皇后放第二列，后面继续循环执行1，2，3，4的步骤</li></ol><p>说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题。</p><div class="code-wrapper"><pre><code class="hljs java">arr[<span class="hljs-number">8</span>] =&#123;<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;<span class="hljs-comment">// 对应arr下标表示第几行，即第几个皇后，arr[i] = val </span><span class="hljs-comment">// val表示第i+1个皇后，放在第i+1行的第val+1列</span></code></pre></div><p>代码实现：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EightQueensPuzzle</span> &#123;    <span class="hljs-comment">// 定义一个 max表示共有多少个皇后</span>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;    <span class="hljs-comment">// 定义数组 array，保存皇后放置位置的结果,比如 arr = &#123;0,4,7,5,2,6,1,3&#125;</span>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max];    <span class="hljs-comment">// 统计解法数量</span>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> count;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">EightQueensPuzzle</span> <span class="hljs-variable">eightQueensPuzzle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EightQueensPuzzle</span>();        eightQueensPuzzle.check(<span class="hljs-number">0</span>);        System.out.println(<span class="hljs-string">&quot;一共有 &quot;</span> + EightQueensPuzzle.count + <span class="hljs-string">&quot; 种解法&quot;</span>);    &#125;    <span class="hljs-comment">// 放置第 n个皇后</span>    <span class="hljs-comment">// 特别注意: check是每一次递归时，进入到check中都有 for(int i = 0; i &lt; max;i++)，因此会产生回溯</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;        <span class="hljs-comment">// 判断是否放好</span>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">8</span>) &#123;            print();            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 依次放置皇后，并判断是否冲突</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; max; i++) &#123;            array[n] = i;            <span class="hljs-keyword">if</span> (judge(n)) &#123;                <span class="hljs-comment">// 若不冲突 接着放 n+1</span>                check(n + <span class="hljs-number">1</span>);            &#125;            <span class="hljs-comment">// 若冲突，就继续执行 array[n] = i;即 将第 n个皇后，放置在本行得后移的一个位置</span>        &#125;    &#125;    <span class="hljs-comment">// 查看当放置第 n个皇后，就去检测该皇后是否和前面已经摆放的皇后冲突</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;        <span class="hljs-comment">// array[i] == array[n] 表示判断第 n个皇后是否和前面的 n-1个皇后在同一列</span>        <span class="hljs-comment">// Math.abs(n - i) == Math.abs(array[n] - array[i] 表示判断第 n个皇后是否和第 i皇后是否在同一斜线</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">if</span> (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-comment">// 打印 array</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : array) &#123;            System.out.print(n + <span class="hljs-string">&quot; &quot;</span>);        &#125;        count++;        System.out.println();    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>递归</tag>
      
      <tag>recursion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><ul><li><a href="#%E6%A0%88">栈</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">实现思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88">使用数组模拟栈</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%A8%A1%E6%8B%9F%E6%A0%88">使用双链表模拟栈</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88%E8%AE%A1%E7%AE%97%E5%99%A8">使用栈实现综合计算器</a><ul><li><a href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">思路分析</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1">代码实现</a></li></ul></li><li><a href="#%E5%89%8D%E7%BC%80%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">前缀、中缀、后缀表达式（逆波兰表达式）</a><ul><li><a href="#%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">前缀表达式</a></li><li><a href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">中缀表达式</a></li><li><a href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">后缀表达式</a></li></ul></li><li><a href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">中缀表达式转后缀表达式</a><ul><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2">代码实现</a></li></ul></li></ul></li></ul><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol><li>栈(stack)是一个先入后出(FILO-First ln Last Out)的有序列表。</li><li>栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另—端为固定的一端，称为栈底(Bottom)。</li><li>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除。</li><li>出栈(pop)，入栈(push)</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。</li><li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</li><li>表达式的转换与求值（实际解决）。</li><li>二叉树的遍历（中缀表达式转后缀表达式）。</li><li>图形的深度优先(depth—first)搜索法。</li></ol><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol><li>使用数组模拟栈</li><li>定义一个 top 来表示栈顶，初始化为 -1</li><li>入栈的操作：当有数据加入到栈时，<br><code>top++; stack[top] = data;</code></li><li>出栈的操作：<br><code>int value = stack[top]; top--; return value;</code></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="使用数组模拟栈"><a href="#使用数组模拟栈" class="headerlink" title="使用数组模拟栈"></a>使用数组模拟栈</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayStackDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">ArrayStack</span> <span class="hljs-variable">arrayStack</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayStack</span>(<span class="hljs-number">4</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-type">boolean</span> <span class="hljs-variable">loop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);        <span class="hljs-keyword">while</span> (loop) &#123;            System.out.println(<span class="hljs-string">&quot;show: 显示栈&quot;</span>);            System.out.println(<span class="hljs-string">&quot;push: 入栈&quot;</span>);            System.out.println(<span class="hljs-string">&quot;pop: 显示栈&quot;</span>);            System.out.println(<span class="hljs-string">&quot;exit: 退出&quot;</span>);            System.out.println(<span class="hljs-string">&quot;请输入你的选择&quot;</span>);            key = scanner.next();            <span class="hljs-keyword">switch</span> (key) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;show&quot;</span>:                    arrayStack.list();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;push&quot;</span>:                    System.out.println(<span class="hljs-string">&quot;请输入一个数&quot;</span>);                    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> scanner.nextInt();                    arrayStack.push(value);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pop&quot;</span>:                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> arrayStack.pop();                        System.out.printf(<span class="hljs-string">&quot;出栈的数据是 %d\n&quot;</span>, res);                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                        System.out.println(e.getMessage());                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;exit&quot;</span>:                    scanner.close();                    loop = <span class="hljs-literal">false</span>;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">default</span>:                    <span class="hljs-keyword">break</span>;            &#125;        &#125;        System.out.println(<span class="hljs-string">&quot;程序退出&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayStack</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize; <span class="hljs-comment">// 栈的大小</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] stack; <span class="hljs-comment">// 数组模拟栈</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 栈顶</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayStack</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span> &#123;        <span class="hljs-built_in">this</span>.maxSize = maxSize;        <span class="hljs-built_in">this</span>.stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[maxSize];    &#125;    <span class="hljs-comment">// 判断栈满</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> top == maxSize - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 栈空</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> top == -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 入栈-push</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;        <span class="hljs-keyword">if</span> (isFull()) &#123;            System.out.println(<span class="hljs-string">&quot;栈满&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        top++;        stack[top] = value;    &#125;    <span class="hljs-comment">// 出栈-pop</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;栈空&quot;</span>);        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> stack[top];        top--;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-comment">// 遍历栈，从栈顶开始遍历</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">list</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            System.out.println(<span class="hljs-string">&quot;栈空，没有数据&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> top; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            System.out.printf(<span class="hljs-string">&quot;stack[%d] = %d\n&quot;</span>, i, stack[i]);        &#125;    &#125;&#125;</code></pre></div><h3 id="使用双链表模拟栈"><a href="#使用双链表模拟栈" class="headerlink" title="使用双链表模拟栈"></a>使用双链表模拟栈</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yur.stack;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListStackDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">// 测试</span>        <span class="hljs-type">LinkedListStack</span> <span class="hljs-variable">stack</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedListStack</span>();        <span class="hljs-comment">// 入栈</span>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedListStackNode</span>(<span class="hljs-number">1</span>));        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedListStackNode</span>(<span class="hljs-number">2</span>));        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedListStackNode</span>(<span class="hljs-number">3</span>));        stack.list();        <span class="hljs-comment">// 出栈</span>        stack.pop();        stack.pop();        stack.list();    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListStack</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">LinkedListStackNode</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedListStackNode</span>(-<span class="hljs-number">1</span>);    <span class="hljs-comment">// 判断栈空</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> top.getVal() == -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 入栈</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(LinkedListStackNode node)</span> &#123;        top.next = node;        node.pre = top;        top = node;    &#125;    <span class="hljs-comment">// 出栈</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            System.out.println(<span class="hljs-string">&quot;栈空&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        System.out.println(top.getVal()+<span class="hljs-string">&quot; 出栈&quot;</span>);        top = top.pre;        top.next = <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">// 遍历</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">list</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            System.out.println(<span class="hljs-string">&quot;栈空&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">LinkedListStackNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> top;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            System.out.println(temp.getVal());            <span class="hljs-keyword">if</span> (temp.pre.getVal() == -<span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            temp = temp.pre;        &#125;    &#125;&#125;<span class="hljs-comment">// 节点类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListStackNode</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> val;    <span class="hljs-keyword">public</span> LinkedListStackNode next;    <span class="hljs-keyword">public</span> LinkedListStackNode pre;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedListStackNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;        <span class="hljs-built_in">this</span>.val = val;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVal</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> val;    &#125;&#125;</code></pre></div><h2 id="使用栈实现综合计算器"><a href="#使用栈实现综合计算器" class="headerlink" title="使用栈实现综合计算器"></a>使用栈实现综合计算器</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><ol><li>创建两个栈，分别存放数字和符号；</li><li>通过一个<code>index</code>值（索引），来遍历我们的表达式；</li><li>如果是一个数字，就直接入数栈；</li><li>如果扫描到是一个符号，就分如下情况：</li></ol><ul><li>如果发现当前的符号栈为空，就直接入栈；</li><li>如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或者等于栈中的操作符，就需要从数栈中<code>pop</code>出两个数，在从符号栈中<code>pop</code>出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈（这里存在问题）；</li><li>如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈；</li></ul><ol start="5"><li>当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行；</li><li>最后在数栈只有一个数字，就是表达式的结果；</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;7-9*8+2*6&quot;</span>;        <span class="hljs-comment">// 创建两个栈，分别存放数字和符号</span>        <span class="hljs-type">ArrayStackForCal</span> <span class="hljs-variable">numStack</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayStackForCal</span>(<span class="hljs-number">10</span>);        <span class="hljs-type">ArrayStackForCal</span> <span class="hljs-variable">operStack</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayStackForCal</span>(<span class="hljs-number">10</span>);        <span class="hljs-comment">// 通过一个`index`值（索引），来遍历我们的表达式</span>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-comment">// 保存每次扫描的字符</span>        <span class="hljs-type">String</span> <span class="hljs-variable">keepNum</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 拼接多位数字</span>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            ch = expression.substring(index, index + <span class="hljs-number">1</span>).charAt(<span class="hljs-number">0</span>);            <span class="hljs-comment">// 如果发现扫描到一个符号，就分如下情况</span>            <span class="hljs-keyword">if</span> (operStack.isOper(ch)) &#123;                <span class="hljs-comment">// 如果符号栈有操作符，就进行比较，</span>                <span class="hljs-keyword">if</span> (!operStack.isEmpty()) &#123;                    <span class="hljs-comment">// 如果当前的操作符的优先级小于或者等于栈中的操作符，</span>                    <span class="hljs-keyword">if</span> (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;                        <span class="hljs-comment">// 从数栈中`pop`出两个数，在从符号栈中`pop`出一个符号，</span>                        num1 = numStack.pop();                        num2 = numStack.pop();                        oper = operStack.pop();                        <span class="hljs-comment">// 进行运算</span>                        res = numStack.cal(num1, num2, oper);                        <span class="hljs-comment">// 将得到结果，入数栈</span>                        numStack.push(res);                        <span class="hljs-comment">// 将当前的操作符入符号栈</span>                        operStack.push(ch);                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">// 如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈</span>                        operStack.push(ch);                    &#125;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 如果发现当前的符号栈为空，就直接入栈；</span>                    operStack.push(ch);                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 分析思路</span>                <span class="hljs-comment">// 1.当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数</span>                <span class="hljs-comment">// 2，在处理数，需要向expression的表达式的index后再看一位，如果是数就进行扫描，如果是符号才入栈</span>                <span class="hljs-comment">// 3. 此我们需要定义一个变量字符串,用于拼接</span>                keepNum += ch;                <span class="hljs-comment">// 如果ch已经是expression的最后一位,就直接入栈</span>                <span class="hljs-keyword">if</span> (index == expression.length() - <span class="hljs-number">1</span>) &#123;                    numStack.push(Integer.parseInt(keepNum));                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈</span>                    <span class="hljs-keyword">if</span> (operStack.isOper(expression.substring(index + <span class="hljs-number">1</span>, index + <span class="hljs-number">2</span>).charAt(<span class="hljs-number">0</span>))) &#123;                        numStack.push(Integer.parseInt(keepNum));                        <span class="hljs-comment">// 清空keepNum！！！</span>                        keepNum = <span class="hljs-string">&quot;&quot;</span>;                    &#125;                &#125;            &#125;            index++;            <span class="hljs-keyword">if</span> (index &gt;= expression.length()) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-comment">// 如果符号栈为空，计算结束，此时数栈只有一个元素即为结果</span>            <span class="hljs-keyword">if</span> (operStack.isEmpty()) &#123;                <span class="hljs-keyword">break</span>;            &#125;            num1 = numStack.pop();            num2 = numStack.pop();            oper = operStack.pop();            res = operStack.cal(num1, num2, oper);            numStack.push(res); <span class="hljs-comment">// 入栈</span>        &#125;        System.out.printf(<span class="hljs-string">&quot;表达式 %s = %d\n&quot;</span>, expression, numStack.pop());    &#125;&#125;<span class="hljs-comment">// 供计算机调用的数组栈</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayStackForCal</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize; <span class="hljs-comment">// 栈的大小</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] stack; <span class="hljs-comment">// 数组模拟栈</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 栈顶</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayStackForCal</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span> &#123;        <span class="hljs-built_in">this</span>.maxSize = maxSize;        <span class="hljs-built_in">this</span>.stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[maxSize];    &#125;    <span class="hljs-comment">// 判断栈满</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> top == maxSize - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 栈空</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> top == -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 入栈-push</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;        <span class="hljs-keyword">if</span> (isFull()) &#123;            System.out.println(<span class="hljs-string">&quot;栈满&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        top++;        stack[top] = value;    &#125;    <span class="hljs-comment">// 出栈-pop</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;栈空&quot;</span>);        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> stack[top];        top--;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-comment">// 遍历栈，从栈顶开始遍历</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">list</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            System.out.println(<span class="hljs-string">&quot;栈空，没有数据&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> top; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            System.out.printf(<span class="hljs-string">&quot;stack[%d] = %d\n&quot;</span>, i, stack[i]);        &#125;    &#125;    <span class="hljs-comment">// 返回栈顶值</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> stack[top];    &#125;    <span class="hljs-comment">// 返回运算优先级</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">priority</span><span class="hljs-params">(<span class="hljs-type">int</span> oper)</span> &#123;        <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&#x27;*&#x27;</span> || oper == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&#x27;+&#x27;</span> || oper == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">// 判断是不是一个运算符</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOper</span><span class="hljs-params">(<span class="hljs-type">char</span> val)</span> &#123;        <span class="hljs-keyword">return</span> val == <span class="hljs-string">&#x27;+&#x27;</span> || val == <span class="hljs-string">&#x27;-&#x27;</span> || val == <span class="hljs-string">&#x27;*&#x27;</span> || val == <span class="hljs-string">&#x27;/&#x27;</span>;    &#125;    <span class="hljs-comment">// 计算方法</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2, <span class="hljs-type">int</span> oper)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">switch</span> (oper) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:                res = num1 + num2;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:                res = num2 - num1; <span class="hljs-comment">// 注意顺序</span>                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:                res = num1 * num2;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:                res = num2 / num1;                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h2 id="前缀、中缀、后缀表达式（逆波兰表达式）"><a href="#前缀、中缀、后缀表达式（逆波兰表达式）" class="headerlink" title="前缀、中缀、后缀表达式（逆波兰表达式）"></a>前缀、中缀、后缀表达式（逆波兰表达式）</h2><h3 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h3><p>运算符再数字之前，从右向左扫描</p><p>例如: $(3+4)×5-6$ 对应的前缀表达式就是 $-×+3456$</p><h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><p>例如: $(3+4)×5-6$ </p><h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><p>运算符再数字之后，从左向右扫描</p><p>例如: $(3+4)×5-6$ 对应的后缀表达式就是 $34+5×6-$</p><h2 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h2><ol><li>初始化两个栈：运算符栈s1和储存中间结果的栈s2；</li><li>从左至右扫描中缀表达式；</li><li>遇到操作数时，将其压s2；</li><li>遇到运算符时，比较其与s1栈顶运算符的优先级：<br> 4.1 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；<br> 4.2 否则，若优先级比栈顶运算符的高，也将运算符压入s1;<br> 4.3 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；</li><li>遇到括号时：<br> 5.1 如果是左括号“(”，则直接压入s1；<br> 5.2 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃；</li><li>重复步骤2至5，直到表达式的最右边；</li><li>将s1中剩余的运算符依次弹出并压入s2；</li><li>依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式；</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolandNotation</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">// 定义中缀表达式</span>        <span class="hljs-type">String</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1+((2+3)*4)-5&quot;</span>;        <span class="hljs-comment">// 中缀表达式转为 list</span>        List&lt;String&gt; expressionList = toInfixExpression(expression);        <span class="hljs-comment">// 中缀表达式list转后缀表达式list</span>        List&lt;String&gt; suffixExpressionList = parseSuffixExpressionList(expressionList);        System.out.println(<span class="hljs-string">&quot;后缀表达式：&quot;</span>+suffixExpressionList);        System.out.println(expression + <span class="hljs-string">&quot;=&quot;</span> + Calculator(suffixExpressionList));    &#125;    <span class="hljs-comment">// 中缀表达式list转后缀表达式list</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">parseSuffixExpressionList</span><span class="hljs-params">(List&lt;String&gt; ls)</span> &#123;        Stack&lt;String&gt; s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 运算符栈</span>        Stack&lt;String&gt; s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 存储中间结果</span>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-keyword">for</span> (String item : ls) &#123;            <span class="hljs-keyword">if</span> (item.matches(<span class="hljs-string">&quot;\\d+&quot;</span>)) &#123;                <span class="hljs-comment">// 遇到操作数时，将其压s2</span>                s2.push(item);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.equals(<span class="hljs-string">&quot;(&quot;</span>)) &#123;                <span class="hljs-comment">// 如果是左括号 “(”，则直接压入s1</span>                s1.push(item);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.equals(<span class="hljs-string">&quot;)&quot;</span>)) &#123;                <span class="hljs-comment">// 如果是右括号 “)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                    <span class="hljs-type">String</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> s1.pop();                    <span class="hljs-keyword">if</span> (num.equals(<span class="hljs-string">&quot;(&quot;</span>)) &#123;                        <span class="hljs-keyword">break</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        s2.push(num);                    &#125;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                    <span class="hljs-comment">// 遇到运算符时，比较其与 s1栈顶运算符的优先级</span>                    <span class="hljs-comment">// 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</span>                    <span class="hljs-comment">// 否则，若优先级比栈顶运算符的高，也将运算符压入s1;</span>                    <span class="hljs-keyword">if</span> (s1.empty() || s1.peek().equals(<span class="hljs-string">&quot;(&quot;</span>) || priority(item) &gt; priority(s1.peek())) &#123;                        s1.push(item);                        <span class="hljs-keyword">break</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">// 否则，将 s1栈顶的运算符弹出并压入到 s2中，再次转到(4.1)与 s1中新的栈顶运算符相比较</span>                        s2.push(s1.pop());                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">while</span> (!s1.empty()) &#123;            s2.push(s1.pop());        &#125;        <span class="hljs-keyword">while</span> (!s2.empty()) &#123;            res.add(s2.pop());        &#125;        <span class="hljs-comment">// 反转list</span>        Collections.reverse(res);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">// 计算后缀表达式</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Calculator</span><span class="hljs-params">(List&lt;String&gt; list)</span> &#123;        Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();        <span class="hljs-keyword">for</span> (String item : list) &#123;            <span class="hljs-keyword">if</span> (item.matches(<span class="hljs-string">&quot;\\d+&quot;</span>)) &#123;                stack.push(item);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> Integer.parseInt(stack.pop());<span class="hljs-comment">// 栈顶</span>                <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> Integer.parseInt(stack.pop());<span class="hljs-comment">// 次顶</span>                <span class="hljs-type">int</span> res;                <span class="hljs-keyword">switch</span> (item) &#123;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:                        res = num1 + num2;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:                        res = num2 - num1;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:                        res = num1 * num2;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:                        res = num2 / num1;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">default</span>:                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;运算符出错&quot;</span>);                &#125;                stack.push(<span class="hljs-string">&quot;&quot;</span> + res);            &#125;        &#125;        <span class="hljs-keyword">return</span> Integer.parseInt(stack.pop());    &#125;    <span class="hljs-comment">// 中缀表达式转为 list</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">toInfixExpression</span><span class="hljs-params">(String s)</span> &#123;        List&lt;String&gt; ls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        String str; <span class="hljs-comment">// 多位数拼接</span>        <span class="hljs-type">char</span> c; <span class="hljs-comment">// 每次遍历的字符</span>        <span class="hljs-keyword">do</span> &#123;            <span class="hljs-comment">// 如果是字符</span>            <span class="hljs-keyword">if</span> ((c = s.charAt(i)) &lt; <span class="hljs-number">48</span> || (c = s.charAt(i)) &gt; <span class="hljs-number">57</span>) &#123;                ls.add(<span class="hljs-string">&quot;&quot;</span> + c);                i++;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 如果是数字</span>                str = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// &#x27;o&#x27; [48]-&gt; &#x27;9&#x27;[57]</span>                <span class="hljs-keyword">while</span> (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt;= <span class="hljs-number">48</span> &amp;&amp; (c = s.charAt(i)) &lt;= <span class="hljs-number">57</span>) &#123;                    str += c;                    i++;                &#125;                ls.add(str);            &#125;        &#125; <span class="hljs-keyword">while</span> (i &lt; s.length());        <span class="hljs-keyword">return</span> ls;    &#125;    <span class="hljs-comment">// 返回运算优先级</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">priority</span><span class="hljs-params">(String oper)</span> &#123;        <span class="hljs-keyword">if</span> (oper.equals(<span class="hljs-string">&quot;*&quot;</span>) || oper.equals(<span class="hljs-string">&quot;/&quot;</span>)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper.equals(<span class="hljs-string">&quot;+&quot;</span>) || oper.equals(<span class="hljs-string">&quot;-&quot;</span>)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>栈</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单向环形链表与约瑟夫问题</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%8D%95%E5%90%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E4%B8%8E%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%8D%95%E5%90%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E4%B8%8E%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="单向环形链表与约瑟夫问题"><a href="#单向环形链表与约瑟夫问题" class="headerlink" title="单向环形链表与约瑟夫问题"></a>单向环形链表与约瑟夫问题</h1><ul><li><a href="#%E5%8D%95%E5%90%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E4%B8%8E%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98">单向环形链表与约瑟夫问题</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">实现思路</a><ul><li><a href="#%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98">约瑟夫问题</a></li><li><a href="#%E6%9E%84%E5%BB%BA%E5%8D%95%E5%90%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8">构建单向环形链表</a></li><li><a href="#%E9%81%8D%E5%8E%86%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8">遍历环形链表</a></li><li><a href="#%E5%87%BA%E5%9C%88">出圈</a></li></ul></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li></ul></li></ul><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Josephu问题为：设编号为 1，2，…n 的 n 个人围坐一圈，约定编号为k (1&lt;&#x3D;k&lt;&#x3D;n)的人从1开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h3><p>用一个不带头结点的循环链表来处理Josephu问题：先构成一个有 n 个结点的单循环链表然后由 k 结点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。</p><h3 id="构建单向环形链表"><a href="#构建单向环形链表" class="headerlink" title="构建单向环形链表"></a>构建单向环形链表</h3><ol><li>先创建第一个节点，让first指向该节点，并形成环形</li><li>后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可。</li></ol><h3 id="遍历环形链表"><a href="#遍历环形链表" class="headerlink" title="遍历环形链表"></a>遍历环形链表</h3><ol><li>先让一个辅助指针(变量)cur，指向first节点</li><li>然后通过一个while循环遍历该环形链表即可，当<code>cur.next == first</code>结束</li></ol><h3 id="出圈"><a href="#出圈" class="headerlink" title="出圈"></a>出圈</h3><ol><li>定义一个辅助节点helper，最终目的是让它指向待出圈节点的前一个结点</li><li>首先遍历使helper指向first节点的前一个节点，也就是环形链表的“尾部”</li><li>根据起点序号k，让first指向起点前一个结点，即移动<code>k-1</code>次</li><li>循环移动m-1次，每次数到 m 输出<code>help.next</code>的值，并判断<code>help.next == helper</code>,即判断是否还有一个节点，是则退出循环，否则使<code>helper.next == helper.next.next</code>，即使<code>help.next</code>置空</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Josephu</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">CircleSingleLinkedList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircleSingleLinkedList</span>();        list.add(<span class="hljs-number">9</span>);        list.list();        list.getOrder(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>);    &#125;&#125;<span class="hljs-comment">// 环形单向链表</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleSingleLinkedList</span> &#123;    <span class="hljs-comment">// 创建一个first节点，当前没有编号</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">CircleNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircleNode</span>(-<span class="hljs-number">1</span>);    <span class="hljs-comment">// 添加nums个节点</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> nums)</span> &#123;        <span class="hljs-comment">// 对 nums 进行数据校验</span>        <span class="hljs-keyword">if</span> (nums &lt; <span class="hljs-number">1</span>) &#123;            System.out.println(<span class="hljs-string">&quot;nums不合法&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 创建辅助指针cur</span>        <span class="hljs-type">CircleNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-comment">// 使用for循环创建环形链表</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums; i++) &#123;            <span class="hljs-comment">// 根据编号创建节点</span>            <span class="hljs-type">CircleNode</span> <span class="hljs-variable">circleNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircleNode</span>(i);            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;                first = circleNode;                circleNode.next = circleNode;            &#125; <span class="hljs-keyword">else</span> &#123;                cur.next = circleNode;                circleNode.next = first;            &#125;            cur = circleNode;        &#125;    &#125;    <span class="hljs-comment">// 遍历输出链表</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">list</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;链表为空&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">CircleNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> first;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            System.out.println(cur.getNum());            <span class="hljs-keyword">if</span> (cur.next == first) &#123;                <span class="hljs-keyword">break</span>;            &#125;            cur = cur.next;        &#125;    &#125;        <span class="hljs-comment">/** 输出出圈顺序</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start 起点</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> count 每次数的节点个数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums  初始节点数量</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> count, <span class="hljs-type">int</span> nums)</span> &#123;        <span class="hljs-comment">// 数据校验</span>        <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span> || start &lt; <span class="hljs-number">1</span> || start &gt; nums) &#123;            System.out.println(<span class="hljs-string">&quot;参数输入有误&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 创建一个辅助指针</span>        <span class="hljs-type">CircleNode</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> first;        <span class="hljs-comment">// 使用 while循环让 helper指向最后一个节点</span>        <span class="hljs-keyword">while</span> (helper.next != first) &#123;            helper = helper.next;        &#125;        <span class="hljs-comment">// 定位起点，移动helper到起点前面的节点、</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; start - <span class="hljs-number">1</span>; i++) &#123;            helper = helper.next;        &#125;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-comment">// 开始数数</span>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count - <span class="hljs-number">1</span>; i++) &#123;                helper = helper.next;            &#125;            System.out.print(helper.next.getNum() + <span class="hljs-string">&quot; &quot;</span>);            <span class="hljs-comment">// 圈中只有一个节点时退出循环</span>            <span class="hljs-keyword">if</span> (helper.next == helper.next.next) &#123;                <span class="hljs-keyword">break</span>;            &#125;            helper.next = helper.next.next;        &#125;    &#125;&#125;<span class="hljs-comment">// 环形单向链表的节点</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleNode</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num; <span class="hljs-comment">// 编号</span>    <span class="hljs-keyword">public</span> CircleNode next; <span class="hljs-comment">// 指向下一个节点，默认null</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CircleNode</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;        <span class="hljs-built_in">this</span>.num = num;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNum</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> num;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;        <span class="hljs-built_in">this</span>.num = num;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>链表</tag>
      
      <tag>LinkedList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双链表</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1><ul><li><a href="#%E5%8F%8C%E9%93%BE%E8%A1%A8">双链表</a><ul><li><a href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90">单链表的缺点分析</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">实现思路</a><ul><li><a href="#%E9%81%8D%E5%8E%86">遍历</a></li><li><a href="#%E6%B7%BB%E5%8A%A0">添加</a></li><li><a href="#%E4%BF%AE%E6%94%B9">修改</a></li><li><a href="#%E5%88%A0%E9%99%A4">删除</a></li></ul></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li></ul></li></ul><h2 id="单链表的缺点分析"><a href="#单链表的缺点分析" class="headerlink" title="单链表的缺点分析"></a>单链表的缺点分析</h2><ol><li><p>单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。</p></li><li><p>单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp，temp是待删除节点的前一个节点</p></li></ol><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>和单链表一样，但是双链表可以向前查找</p><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><ol><li>默认加入到链表的最后<br>（1）先找的双向链表的最后节点<br>（2）<code>temp.next = newHeroNode</code><br>（3）<code>newHeroNode.pre = temp</code></li><li>按顺序添加节点到链表<br>（1）建立辅助指针 temp ，初始位置在链表头节点<br>（2）首先遍历找第一个序号比节点序号大的节点前一个结点<br>（3）若找到则退出循环，找不到temp指向链表尾部，若找到相同值节点，则退出循环，输出该序号已存在节点。<br>（4）将待加入节点的next指向待加入位置上的节点<br>（5）将待加入节点的pre指向待加入位置的节点的上个节点<br>（6）判断待加入位置的前一个节点是否在链表尾部<br>（7）否则将待加入位置的前一个节点next指向待加入节点<br>（8）最后将待加入位置的节点的上个节点next指向待加入节点   <div class="code-wrapper"><pre><code class="hljs java">doubleLinkedNode.next = temp.next;doubleLinkedNode.pre = temp;<span class="hljs-keyword">if</span> (temp.next != <span class="hljs-literal">null</span>) &#123;      temp.next.pre = doubleLinkedNode;&#125;temp.next = doubleLinkedNode;</code></pre></div></li></ol><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>和单链表一样</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>（1）因为是双向链表，因此可以实现自我删除<br>（2）直接找到待删除节点temp<br>（3）<code>temp.pre.next = temp.next</code><br>（4）<code>temp.next.pre = temp.pre</code></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleLinkedListDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">DoubleLinkedList</span> <span class="hljs-variable">doubleLinkedList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleLinkedList</span>();<span class="hljs-comment">//        doubleLinkedList.add(new DoubleLinkedNode(1));</span><span class="hljs-comment">//        doubleLinkedList.add(new DoubleLinkedNode(2));</span><span class="hljs-comment">//        doubleLinkedList.add(new DoubleLinkedNode(3));</span><span class="hljs-comment">//        doubleLinkedList.add(new DoubleLinkedNode(4));</span>        doubleLinkedList.addByOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleLinkedNode</span>(<span class="hljs-number">1</span>));        doubleLinkedList.addByOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleLinkedNode</span>(<span class="hljs-number">3</span>));        doubleLinkedList.addByOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleLinkedNode</span>(<span class="hljs-number">2</span>));        doubleLinkedList.addByOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleLinkedNode</span>(<span class="hljs-number">4</span>));        doubleLinkedList.List();        doubleLinkedList.del(<span class="hljs-number">1</span>);        System.out.println(<span class="hljs-string">&quot;删除后&quot;</span>);        doubleLinkedList.List();    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleLinkedList</span> &#123;    <span class="hljs-comment">// 初始化一个头节点</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">DoubleLinkedNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleLinkedNode</span>(<span class="hljs-number">0</span>);    <span class="hljs-keyword">public</span> DoubleLinkedNode <span class="hljs-title function_">getHead</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-comment">// 遍历</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">List</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// 判断非空</span>        <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;链表为空&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 辅助指针</span>        <span class="hljs-type">DoubleLinkedNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">null</span>) &#123;            System.out.println(temp);            temp = temp.next;        &#125;    &#125;    <span class="hljs-comment">// 添加（尾插法）</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(DoubleLinkedNode doubleLinkedNode)</span> &#123;        <span class="hljs-type">DoubleLinkedNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;        <span class="hljs-keyword">while</span> (temp.next != <span class="hljs-literal">null</span>) &#123;            temp = temp.next;        &#125;        temp.next = doubleLinkedNode;        doubleLinkedNode.pre = temp;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addByOrder</span><span class="hljs-params">(DoubleLinkedNode doubleLinkedNode)</span> &#123;        <span class="hljs-comment">// 新建辅助指针temp</span>        <span class="hljs-type">DoubleLinkedNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 标识节点val是否存在</span>        <span class="hljs-keyword">while</span> (temp.next != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// 找到第一个比 doubleLinkedNode 大的节点的前一个节点</span>            <span class="hljs-keyword">if</span> (temp.next.val &gt; doubleLinkedNode.val) &#123;                <span class="hljs-keyword">break</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp.next.val == doubleLinkedNode.val) &#123;                flag = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            &#125;            temp = temp.next;        &#125;        <span class="hljs-comment">// 此时 temp 在待加入位置的前一个节点</span>        <span class="hljs-comment">// 或者 没找到第一个比 doubleLinkedNode 大的节点的前一个节点</span>        <span class="hljs-comment">// temp 即为最后一个节点</span>        <span class="hljs-keyword">if</span> (flag) &#123;            System.out.println(<span class="hljs-string">&quot;该编号已经存在&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            doubleLinkedNode.next = temp.next;            doubleLinkedNode.pre = temp;            <span class="hljs-keyword">if</span> (temp.next != <span class="hljs-literal">null</span>) &#123;                temp.next.pre = doubleLinkedNode;            &#125;            temp.next = doubleLinkedNode;        &#125;    &#125;    <span class="hljs-comment">// 修改一个节点的内容</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(DoubleLinkedNode doubleLinkedNode)</span> &#123;        <span class="hljs-comment">// 判断非空</span>        <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;链表为空&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">DoubleLinkedNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (temp.val == doubleLinkedNode.val) &#123;                flag = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            &#125;            temp = temp.next;        &#125;        <span class="hljs-keyword">if</span> (flag) &#123;            temp.val = doubleLinkedNode.val;        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;没有找到&quot;</span>);        &#125;    &#125;    <span class="hljs-comment">// 删除节点</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">del</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;        <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;链表为空，无法删除&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 辅助指针</span>        <span class="hljs-type">DoubleLinkedNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (temp.val == val) &#123;                flag = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            &#125;            temp = temp.next;        &#125;        <span class="hljs-keyword">if</span> (flag) &#123;            temp.pre.next = temp.next;            <span class="hljs-comment">// 如果是最后一个节点,就不需要执行下面这句话,否则出现空指针</span>            <span class="hljs-keyword">if</span> (temp.next != <span class="hljs-literal">null</span>) &#123;                temp.next.pre = temp.pre;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;未找到该节点&quot;</span>);        &#125;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleLinkedNode</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> val;    <span class="hljs-keyword">public</span> DoubleLinkedNode next;    <span class="hljs-keyword">public</span> DoubleLinkedNode pre;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoubleLinkedNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;        <span class="hljs-built_in">this</span>.val = val;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoubleLinkedNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val, DoubleLinkedNode next, DoubleLinkedNode pre)</span> &#123;        <span class="hljs-built_in">this</span>.val = val;        <span class="hljs-built_in">this</span>.next = next;        <span class="hljs-built_in">this</span>.pre = pre;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DoubleLinkedNode&#123;&quot;</span> +                <span class="hljs-string">&quot;val=&quot;</span> + val +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>链表</tag>
      
      <tag>LinkedList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单链表</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul><li><a href="#%E9%93%BE%E8%A1%A8">链表</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">实现思路</a><ul><li><a href="#%E6%B7%BB%E5%8A%A0%E5%88%9B%E5%BB%BA">添加（创建)</a></li><li><a href="#%E9%81%8D%E5%8E%86">遍历</a></li><li><a href="#%E4%BF%AE%E6%94%B9">修改</a></li><li><a href="#%E5%88%A0%E9%99%A4">删除</a></li></ul></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE">相关题目：</a><ul><li><a href="#%E6%B1%82%E5%8D%95%E9%93%BE%E8%A1%A8%E6%9C%89%E6%95%88%E8%8A%82%E7%82%B9%E6%95%B0">求单链表有效节点数</a></li><li><a href="#%E6%9F%A5%E6%89%BE%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9">查找单链表中的倒数第k个节点</a></li><li><a href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">反转链表</a></li><li><a href="#%E9%80%86%E5%BA%8F%E6%89%93%E5%8D%B0%E5%8D%95%E9%93%BE%E8%A1%A8">逆序打印单链表</a></li><li><a href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8">合并两个有序的链表</a><ul><li><a href="#%E6%96%B9%E6%B3%95%E4%B8%80-%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92">方法一 使用递归</a></li><li><a href="#%E6%96%B9%E6%B3%95%E4%BA%8C">方法二</a></li></ul></li><li><a href="#%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">删除排序链表中的重复元素</a><ul><li><a href="#%E5%88%9D%E8%A7%A3%E6%80%9D%E8%B7%AF">初解思路</a></li><li><a href="#%E4%BC%98%E5%8C%96%E8%A7%A3%E6%B3%95">优化解法</a></li><li><a href="#%E7%BB%88%E6%9E%81%E8%A7%A3%E6%B3%95">终极解法</a></li></ul></li><li><a href="#%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8">相交链表</a><ul><li><a href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">思路分析</a></li></ul></li><li><a href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8">环形链表</a></li></ul></li></ul></li></ul><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>链表是有序的列表，但是它在内存中是存储如下</p><p><img src="/img/LinkedList.png" alt="LinkedList"></p><ol><li>链表是以节点的方式来存储</li><li>每个节点包含data域， next域：指向下一个节点</li><li>如图：发现链表的各个节点不一定是连续存储</li><li>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</li></ol><p>单链表（带头结点）的逻辑结构</p><p><img src="/img/LinkedList_1.png" alt="LinkedList_1"></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="添加（创建"><a href="#添加（创建" class="headerlink" title="添加（创建)"></a>添加（创建)</h3><ol><li>先创建一个head头节点,作用就是表示单链表的头</li><li>每添加一个节点，默认加入到链表的最后</li><li>如果要添加新节点newNode到指定位置，要创建辅助指针temp，通过遍历找到新添加的节点的位置，然后将<code>newNode.next = temp.next</code>，将<code>temp.next = newNode</code></li></ol><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>通过一个辅助指针，辅助遍历整个链表</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>先遍历链表，找到要修改的节点位置，用新节点的信息替换旧节点</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ol><li>使用辅助指针temp，找到并指向需要删除的节点的前一个结点</li><li><code>temp.next = temp.next.next</code></li><li>被删除的节点将不会有引用指向，会被垃圾回收机制回收</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleLinkedListDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">// 创建节点</span>        <span class="hljs-type">HeroNode</span> <span class="hljs-variable">hero_1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;宋江&quot;</span>, <span class="hljs-string">&quot;及时雨&quot;</span>);        <span class="hljs-type">HeroNode</span> <span class="hljs-variable">hero_2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;卢俊义&quot;</span>, <span class="hljs-string">&quot;玉麒麟&quot;</span>);        <span class="hljs-type">HeroNode</span> <span class="hljs-variable">hero_3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;吴用&quot;</span>, <span class="hljs-string">&quot;智多星&quot;</span>);        <span class="hljs-type">HeroNode</span> <span class="hljs-variable">hero_4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;公孙胜&quot;</span>, <span class="hljs-string">&quot;入云龙&quot;</span>);        <span class="hljs-type">HeroNode</span> <span class="hljs-variable">hero_5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;林冲&quot;</span>, <span class="hljs-string">&quot;豹子头&quot;</span>);        <span class="hljs-comment">// 创建链表</span>        <span class="hljs-type">SingleLinkedList</span> <span class="hljs-variable">singleLinkedList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleLinkedList</span>();        <span class="hljs-comment">// 加入</span><span class="hljs-comment">//        singleLinkedList.add(hero_1);</span><span class="hljs-comment">//        singleLinkedList.add(hero_2);</span><span class="hljs-comment">//        singleLinkedList.add(hero_3);</span><span class="hljs-comment">//        singleLinkedList.add(hero_4);</span><span class="hljs-comment">//        singleLinkedList.add(hero_5);</span>        <span class="hljs-comment">// 按照编号顺序添加</span>        singleLinkedList.addByOrder(hero_1);        singleLinkedList.addByOrder(hero_4);        singleLinkedList.addByOrder(hero_3);        singleLinkedList.addByOrder(hero_2);        singleLinkedList.addByOrder(hero_5);        System.out.println(<span class="hljs-string">&quot;原始链表&quot;</span>);        singleLinkedList.list();        singleLinkedList.update(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;林冲u&quot;</span>, <span class="hljs-string">&quot;豹子头u&quot;</span>));        singleLinkedList.update(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;林冲u&quot;</span>, <span class="hljs-string">&quot;豹子头u&quot;</span>));        <span class="hljs-comment">// 输出链表</span>        System.out.println(<span class="hljs-string">&quot;修改后链表&quot;</span>);        singleLinkedList.list();        singleLinkedList.del(<span class="hljs-number">5</span>);        singleLinkedList.del(<span class="hljs-number">2</span>);        singleLinkedList.del(<span class="hljs-number">1</span>);        System.out.println(<span class="hljs-string">&quot;删除后链表&quot;</span>);        singleLinkedList.list();    &#125;&#125;<span class="hljs-comment">// 定义SingleLinkedList 管理英雄</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleLinkedList</span> &#123;    <span class="hljs-comment">// 初始化一个头节点</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">HeroNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);    <span class="hljs-comment">// 添加节点到单向链表</span>    <span class="hljs-comment">// 1. 找到当前链表的最后节点</span>    <span class="hljs-comment">// 2. 将最后这个节点的next指向新的节点</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(HeroNode heroNode)</span> &#123;        <span class="hljs-comment">// 因为 head节点不能动，因此我们需要一个辅助变量 temp</span>        <span class="hljs-type">HeroNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;        <span class="hljs-comment">// 遍历链表，找的最后节点</span>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-comment">// 找到链表的最后</span>            <span class="hljs-keyword">if</span> (temp.next == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">// 没有找到最后，将temp后移</span>            temp = temp.next;        &#125;        <span class="hljs-comment">// 当退出while循环时，temp就指向链表最后</span>        temp.next = heroNode;    &#125;    <span class="hljs-comment">// 第二种方式在添加英雄时,根据排名将英雄插入到指定位置</span>    <span class="hljs-comment">// (如果有这个排名,则添加失败,并给出提示)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addByOrder</span><span class="hljs-params">(HeroNode heroNode)</span> &#123;        <span class="hljs-comment">// 因为 head节点不能动，因此我们需要一个辅助变量 temp</span>        <span class="hljs-comment">// 因为单链表，因为我们找的temp是位于添加位置的前一个节点，否则插入不了</span>        <span class="hljs-type">HeroNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 标志添加的编号是否存在,默认为false</span>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-keyword">if</span> (temp.next == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;                <span class="hljs-comment">// 位置找到,就在temp的后面插入</span>                <span class="hljs-keyword">break</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp.next.no == heroNode.no) &#123;                <span class="hljs-comment">// 说明希望添加的heroNode的编号已然存在</span>                flag = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            &#125;            temp = temp.next; <span class="hljs-comment">// 后移，遍历当前链表</span>        &#125;        <span class="hljs-comment">// 判断flag的值</span>        <span class="hljs-keyword">if</span> (flag) &#123;            <span class="hljs-comment">// 不能添加，说明编号已存在</span>            System.out.printf(<span class="hljs-string">&quot;准备插入的英雄编号 %d 已经存在了，不能加入\n&quot;</span>, heroNode.no);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 插入链表中，temp的后面</span>            heroNode.next = temp.next;            temp.next = heroNode;        &#125;    &#125;    <span class="hljs-comment">// 根据no编号修改节点信息</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(HeroNode newHeroNode)</span> &#123;        <span class="hljs-comment">// 判断是否为空</span>        <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;链表为空&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 根据no编号找到需要修改的节点</span>        <span class="hljs-type">HeroNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 表示是否找到该节点</span>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 链表遍历完毕</span>            &#125;            <span class="hljs-keyword">if</span> (temp.no == newHeroNode.no) &#123;                <span class="hljs-comment">// 找到</span>                flag = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            &#125;            temp = temp.next;        &#125;        <span class="hljs-keyword">if</span> (flag) &#123;            <span class="hljs-comment">// 找到</span>            temp.name = newHeroNode.name;            temp.nickName = newHeroNode.nickName;        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.printf(<span class="hljs-string">&quot;没有找到编号为 %d 的节点\n&quot;</span>, newHeroNode.no);        &#125;    &#125;    <span class="hljs-comment">//删除指定节点</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">del</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;        <span class="hljs-type">HeroNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 标志是否找到代删除的节点</span>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-keyword">if</span> (temp.next == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span> (temp.next.no == no) &#123;                <span class="hljs-comment">//找到了待删除节点的前一个节点</span>                flag = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            &#125;            temp = temp.next;        &#125;        <span class="hljs-keyword">if</span> (flag) &#123;            temp.next = temp.next.next;        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.printf(<span class="hljs-string">&quot;待删除的节点 %d 不存在\n&quot;</span>, no);        &#125;    &#125;    <span class="hljs-comment">// 遍历链表</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">list</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// 判断链表是否为空</span>        <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;链表为空&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 因为 head节点不能动，因此我们需要一个辅助变量 temp</span>        <span class="hljs-type">HeroNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-comment">// 判断是否到链表最后</span>            <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            System.out.println(temp);            temp = temp.next;        &#125;    &#125;&#125;<span class="hljs-comment">// 定义HeroNode，每个HeroNode 对象就是一个节点</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroNode</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> no;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-keyword">public</span> String nickName;    <span class="hljs-keyword">public</span> HeroNode next; <span class="hljs-comment">// 指向下一个节点</span>    <span class="hljs-comment">// 构造器</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HeroNode</span><span class="hljs-params">(<span class="hljs-type">int</span> no, String name, String nickName)</span> &#123;        <span class="hljs-built_in">this</span>.no = no;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.nickName = nickName;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HeroNode&#123;&quot;</span> +                <span class="hljs-string">&quot;no=&quot;</span> + no +                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, nickName=&#x27;&quot;</span> + nickName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div><h2 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a>相关题目：</h2><h3 id="求单链表有效节点数"><a href="#求单链表有效节点数" class="headerlink" title="求单链表有效节点数"></a>求单链表有效节点数</h3><p>思路：遍历当前链表，<code>length++</code>  </p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 输出有效节点数</span><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>) &#123;        System.out.println(<span class="hljs-string">&quot;链表为空&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">HeroNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head.next;    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;        length++;        cur = cur.next;    &#125;    <span class="hljs-keyword">return</span> length;&#125;</code></pre></div><p>测试：</p><div class="code-wrapper"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;有效节点长度为 &quot;</span> + singleLinkedList.getLength()); <span class="hljs-comment">// 5</span></code></pre></div><h3 id="查找单链表中的倒数第k个节点"><a href="#查找单链表中的倒数第k个节点" class="headerlink" title="查找单链表中的倒数第k个节点"></a>查找单链表中的倒数第k个节点</h3><p>思路：</p><ol><li>求出链表总长度<code>size</code></li><li>倒数第k个节点就为正数第<code>size-k+1</code>个节点</li></ol><p>代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 查找单链表中的倒数第k个结点</span><span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">findLastIndexNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;    <span class="hljs-comment">// 判断非空</span>    <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">// 第一次遍历得到链表的节点个数</span>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getLength();    <span class="hljs-comment">// 第二次遍历，首先判断 index 合法性</span>    <span class="hljs-keyword">if</span> (index &lt;= <span class="hljs-number">0</span> || index &gt; size) &#123;        System.out.println(<span class="hljs-string">&quot;index不合法&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">// 定义一个辅助变量，通过for 循环到达指定位置</span>    <span class="hljs-type">HeroNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head.next;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size - index; i++) &#123;        cur = cur.next;    &#125;    <span class="hljs-keyword">return</span> cur;&#125;</code></pre></div><p>测试：</p><div class="code-wrapper"><pre><code class="hljs java">System.out.println(singleLinkedList.findLastIndexNode(<span class="hljs-number">3</span>));</code></pre></div><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>思路：</p><ol><li>先定义一个节点reverseHead</li><li>从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端，原来的链表的<code>head.next =reverseHead.next</code></li></ol><p>代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 反转单链表</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseList</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 若当前链表为空或者只有一个节点则无需反转</span>    <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span> || head.next.next == <span class="hljs-literal">null</span>) &#123;        System.out.println(<span class="hljs-string">&quot;当前链表为空或者只有一个节点，无需反转&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span>    <span class="hljs-type">HeroNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head.next;    <span class="hljs-type">HeroNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 指向当前节点的[cur]的下一个节点</span>    <span class="hljs-type">HeroNode</span> <span class="hljs-variable">reverseHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroNode</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);    <span class="hljs-comment">// 遍历原来的链表</span>    <span class="hljs-comment">// 每遍历一个节点，就将其取出,并放在新的链表 reverseHead 的最前端</span>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;        next = cur.next; <span class="hljs-comment">// 先暂时保存当前节点的下一个节点</span>        cur.next = reverseHead.next; <span class="hljs-comment">// 将cur的下一个节点指向新的链表的头部</span>        reverseHead.next = cur;        cur = next; <span class="hljs-comment">// 让cur后移</span>    &#125;    <span class="hljs-comment">// 换</span>    head.next = reverseHead.next;&#125;</code></pre></div><h3 id="逆序打印单链表"><a href="#逆序打印单链表" class="headerlink" title="逆序打印单链表"></a>逆序打印单链表</h3><p>思路：</p><ol><li>先反转单链表，再遍历打印（破坏原始单链表的结构，不建议）</li><li>将每个节点压入到栈中，利用栈先进后出的特点实现逆序打印</li></ol><p>代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reversePrint</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 空链表，不能打印</span>    &#125;    <span class="hljs-comment">// 创建栈，</span>    Stack&lt;HeroNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();    <span class="hljs-type">HeroNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head.next;    <span class="hljs-comment">// 将各个节点压入栈中</span>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;        stack.push(cur); <span class="hljs-comment">// 压入栈中</span>        cur = cur.next;    &#125;    <span class="hljs-comment">// 将栈中的节点进行打印，出栈</span>    <span class="hljs-keyword">while</span> (stack.size() &gt; <span class="hljs-number">0</span>) &#123;        System.out.println(stack.pop()); <span class="hljs-comment">//</span>    &#125;&#125;</code></pre></div><h3 id="合并两个有序的链表"><a href="#合并两个有序的链表" class="headerlink" title="合并两个有序的链表"></a>合并两个有序的链表</h3><h4 id="方法一-使用递归"><a href="#方法一-使用递归" class="headerlink" title="方法一 使用递归"></a>方法一 使用递归</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;        <span class="hljs-keyword">if</span>(list2 == <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">return</span> list1;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list1 == <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">return</span> list2;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list1.val &gt;= list2.val)&#123;            list2.next =             mergeTwoLists(list1,list2.next);            <span class="hljs-keyword">return</span> list2;        &#125;<span class="hljs-keyword">else</span>&#123;            list1.next =             mergeTwoLists(list1.next,list2);            <span class="hljs-keyword">return</span> list1;        &#125;    &#125;&#125;</code></pre></div><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><div class="code-wrapper"><pre><code class="hljs java"></code></pre></div><h3 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h3><h4 id="初解思路"><a href="#初解思路" class="headerlink" title="初解思路"></a>初解思路</h4><p>双循环，双指针，新建辅助指针temp循环遍历，再建立辅助指针cur，初始指向<code>temp.next</code>，循环与temp比较值，相等是让<code>temp.next = cur.next</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">return</span> head;        &#125;        <span class="hljs-comment">// 让temp指向头节点</span>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;        <span class="hljs-comment">// 循环</span>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            <span class="hljs-keyword">if</span>(temp.next == <span class="hljs-literal">null</span>)&#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> temp.next;            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 标记cur是否指向末尾</span>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;                <span class="hljs-keyword">if</span>(temp.val == cur.val)&#123;                    temp.next = cur.next;                 &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-comment">// 此条件要退出两个循环</span>                <span class="hljs-keyword">if</span>(cur.next == <span class="hljs-literal">null</span>)&#123;                    flag = <span class="hljs-literal">true</span>;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-comment">// 此条件只退出一个循环</span>                <span class="hljs-keyword">if</span>(cur.next.val &gt; temp.val)&#123;                     <span class="hljs-keyword">break</span>;                &#125;                cur = cur.next;            &#125;            <span class="hljs-comment">// 判断cur是否指向末尾</span>            <span class="hljs-keyword">if</span>(flag)&#123;                <span class="hljs-keyword">break</span>;            &#125;            temp = temp.next;        &#125;        <span class="hljs-keyword">return</span> head;    &#125;&#125;</code></pre></div><h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h4><p>单指针，单循环，用<code>temp</code>和<code>temp.next</code>比较，如果相等则让<code>temp.next = temp.next.next</code>，不相等则让<code>temp = temp.next</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-comment">// 让temp指向头节点</span>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;    <span class="hljs-comment">// 循环</span>    <span class="hljs-keyword">while</span>(temp.next != <span class="hljs-literal">null</span>)&#123;        <span class="hljs-keyword">if</span>(temp.next.val == temp.val)&#123;            temp.next = temp.next.next;            <span class="hljs-comment">// 如果下面用else，下面这个判断就不用写了</span>            <span class="hljs-keyword">if</span>(temp.next == <span class="hljs-literal">null</span>)&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">// 这里绕弯子了，直接else就行</span>        <span class="hljs-keyword">if</span>(temp.next.val &gt; temp.val)&#123;            temp = temp.next;        &#125;    &#125;    <span class="hljs-keyword">return</span> head;&#125;</code></pre></div><h4 id="终极解法"><a href="#终极解法" class="headerlink" title="终极解法"></a>终极解法</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-comment">// 让temp指向头节点</span>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;    <span class="hljs-comment">// 循环</span>    <span class="hljs-keyword">while</span>(temp.next != <span class="hljs-literal">null</span>)&#123;        <span class="hljs-keyword">if</span>(temp.next.val == temp.val)&#123;            temp.next = temp.next.next;        &#125;<span class="hljs-keyword">else</span>&#123;            temp = temp.next;        &#125;    &#125;    <span class="hljs-keyword">return</span> head;&#125;</code></pre></div><h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/">力扣链接</a></p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>我的解法：双指针，等于则<code>return</code><br>官方的第二种解法很妙</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;        <span class="hljs-comment">// 过滤空链表情况</span>        <span class="hljs-keyword">if</span>(headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> headA;        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp2</span> <span class="hljs-operator">=</span> headB;        <span class="hljs-keyword">while</span>(temp1 != <span class="hljs-literal">null</span>)&#123;           temp2 = headB;            <span class="hljs-keyword">while</span>(temp2 != <span class="hljs-literal">null</span>)&#123;                <span class="hljs-keyword">if</span>(temp1 == temp2)&#123;                    <span class="hljs-keyword">return</span> temp1;                &#125;                temp2 = temp2.next;            &#125;            temp1 = temp1.next;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre></div><p>官方解法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;        <span class="hljs-keyword">while</span> (pA != pB) &#123;            pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;            pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;        &#125;        <span class="hljs-keyword">return</span> pA;    &#125;&#125;</code></pre></div><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/">力扣链接</a></p><p>可以直接用哈希表秒杀，快慢指针法有意思！</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next;        <span class="hljs-keyword">while</span> (slow != fast) &#123;            <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;            slow = slow.next;            fast = fast.next.next;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>链表</tag>
      
      <tag>LinkedList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>稀疏数组和队列</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="稀疏数组和队列"><a href="#稀疏数组和队列" class="headerlink" title="稀疏数组和队列"></a>稀疏数组和队列</h1><ul><li><a href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97">稀疏数组和队列</a><ul><li><a href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84">稀疏数组</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">实现思路</a><ul><li><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BD%AC%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E7%9A%84%E6%80%9D%E8%B7%AF">二维数组转稀疏数组的思路</a></li><li><a href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8E%9F%E5%A7%8B%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%80%9D%E8%B7%AF">稀疏数组转原始的二维数组的思路</a></li></ul></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li></ul></li><li><a href="#%E9%98%9F%E5%88%97">队列</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1">基本介绍</a></li><li><a href="#%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97">数组模拟队列</a><ul><li><a href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-1">实现思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1">代码实现</a></li><li><a href="#%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98">存在问题</a></li><li><a href="#%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF">优化思路</a></li></ul></li><li><a href="#%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97">数组模拟环形队列</a><ul><li><a href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">思路分析</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2">代码实现</a></li></ul></li></ul></li></ul></li></ul><h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p><p>稀疏数组的处理方法是：</p><ol><li>记录数组一共有几行几列，有多少个不同的值</li><li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</li></ol><p><img src="/img/sparse_array.png" alt="sparse_array"></p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p><img src="/img/sparse_array_imp.png" alt="sparse_array_imp"></p><h4 id="二维数组转稀疏数组的思路"><a href="#二维数组转稀疏数组的思路" class="headerlink" title="二维数组转稀疏数组的思路"></a>二维数组转稀疏数组的思路</h4><ol><li>遍历原始的二维数组,得到有效数据的个数sum</li><li>根据 sum 就可以创建稀疏数组 sparseArr int[sum+1][3]</li><li>将二维数组的有效数据数据存入到稀疏数组</li></ol><h4 id="稀疏数组转原始的二维数组的思路"><a href="#稀疏数组转原始的二维数组的思路" class="headerlink" title="稀疏数组转原始的二维数组的思路"></a>稀疏数组转原始的二维数组的思路</h4><ol><li>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2&#x3D;int[11][11]</li><li>再读取稀疏数组后几行的数据，并赋给原始的二维数组即可.</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SparseArray</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">// 创建一个原始的二维数组 11*11</span>        <span class="hljs-comment">// 0:表示没有棋子,1 表示 黑子, 2 表示 白子</span>        <span class="hljs-type">int</span>[][] chessArr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];        chessArr1[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;        chessArr1[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;        chessArr1[<span class="hljs-number">5</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">2</span>;        <span class="hljs-comment">// 输出原始的二维数组</span>        System.out.println(<span class="hljs-string">&quot;原始的二维数组&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : chessArr1) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> data : row) &#123;                System.out.printf(<span class="hljs-string">&quot;%d\t&quot;</span>, data);            &#125;            System.out.println();        &#125;        <span class="hljs-comment">// 将二维数组转为稀疏数组</span>        <span class="hljs-comment">// 1. 遍历原始的二维数组,得到有效数据的个数sum</span>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">11</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">11</span>; j++) &#123;                <span class="hljs-keyword">if</span> (chessArr1[i][j] != <span class="hljs-number">0</span>) &#123;                    sum++;                &#125;            &#125;        &#125;        System.out.println(sum);        <span class="hljs-comment">// 2. 根据 sum 就可以创建稀疏数组 sparseArr int[sum+1][3]</span>        <span class="hljs-type">int</span>[][] sparseArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[sum + <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];        <span class="hljs-comment">// 3. 将二维数组的有效数据数据存入到稀疏数组</span>        sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">11</span>;        sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">11</span>;        sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = sum;        <span class="hljs-comment">// 遍历二维数组,将非O的值存放到sparseArr中</span>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">11</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">11</span>; j++) &#123;                <span class="hljs-keyword">if</span> (chessArr1[i][j] != <span class="hljs-number">0</span>) &#123;                    sparseArr[count][<span class="hljs-number">0</span>] = i;                    sparseArr[count][<span class="hljs-number">1</span>] = j;                    sparseArr[count][<span class="hljs-number">2</span>] = chessArr1[i][j];                    count++;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 输出稀疏数组</span>        System.out.println(<span class="hljs-string">&quot;稀疏数组&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : sparseArr) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> data : row) &#123;                System.out.printf(<span class="hljs-string">&quot;%d\t&quot;</span>, data);            &#125;            System.out.println();        &#125;        <span class="hljs-comment">// 将sparseArr 写入磁盘</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;map.data&quot;</span>);            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(out);            objectOutputStream.writeObject(sparseArr);            out.close();            objectOutputStream.close();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-comment">// 将sparseArr 从磁盘中读取</span>        <span class="hljs-type">int</span>[][] sparseArr2 = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;map.data&quot;</span>);            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(in);            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> objectInputStream.readObject();            sparseArr2 = (<span class="hljs-type">int</span>[][]) obj;            in.close();            objectInputStream.close();        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-comment">// 稀疏数组转原始的二维数组</span>        <span class="hljs-comment">// 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2=int[11][11]</span>        <span class="hljs-keyword">assert</span> sparseArr2 != <span class="hljs-literal">null</span>;        <span class="hljs-type">int</span>[][] chessArr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[sparseArr2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]][sparseArr2[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; sparseArr.length; i++) &#123;            chessArr2[sparseArr2[i][<span class="hljs-number">0</span>]][sparseArr2[i][<span class="hljs-number">1</span>]] = sparseArr2[i][<span class="hljs-number">2</span>];        &#125;        System.out.println(<span class="hljs-string">&quot;还原的二维数组&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : chessArr2) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> data : row) &#123;                System.out.printf(<span class="hljs-string">&quot;%d\t&quot;</span>, data);            &#125;            System.out.println();        &#125;    &#125;&#125;</code></pre></div><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>队列是一个有序列表，可以用数组或是链表来实现。</li><li>遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出</li></ol><h3 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h3><h4 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h4><ul><li>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图，其中maxSize是该队列的最大容量。</li><li>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量front及rear分别记录队列前后端的下标，front会随着数据输出而改变，而rear则是随着数据输入而改变,</li></ul><p><img src="/img/queue.png" alt="queue"></p><p>当我们将数据存入队列时称为”addQueue”，addQueue的处理需要有两个步骤:</p><ol><li>将尾指针往后移:rear+1，当front &#x3D;&#x3D; rear(空)</li><li>若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear &#x3D;&#x3D; maxSize-1(队列满)</li></ol><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayQueueDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">//创建队列</span>        <span class="hljs-type">ArrayQueue</span> <span class="hljs-variable">arrayQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayQueue</span>(<span class="hljs-number">3</span>);        <span class="hljs-type">char</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-comment">// 接收用户·输入</span>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);        <span class="hljs-type">boolean</span> <span class="hljs-variable">loop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 输出菜单</span>        <span class="hljs-keyword">while</span> (loop) &#123;            System.out.println(<span class="hljs-string">&quot;s(show): 显示队列&quot;</span>);            System.out.println(<span class="hljs-string">&quot;a(add): 添加元素&quot;</span>);            System.out.println(<span class="hljs-string">&quot;g(get): 取出元素&quot;</span>);            System.out.println(<span class="hljs-string">&quot;h(head): 查看头部&quot;</span>);            System.out.println(<span class="hljs-string">&quot;e(exit): 退出程序&quot;</span>);            key = scanner.next().charAt(<span class="hljs-number">0</span>); <span class="hljs-comment">// 接收一个字符</span>            <span class="hljs-keyword">switch</span> (key) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:                    arrayQueue.showQueue();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:                    System.out.println(<span class="hljs-string">&quot;输入一个数字&quot;</span>);                    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> scanner.nextInt();                    arrayQueue.addQueue(value);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;g&#x27;</span>:                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> arrayQueue.getQueue();                        System.out.println(<span class="hljs-string">&quot;取出的数据是&quot;</span> + res);                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                        System.out.println(e.getMessage());                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> arrayQueue.headQueue();                        System.out.println(<span class="hljs-string">&quot;取出的队列头数据是&quot;</span> + res);                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                        System.out.println(e.getMessage());                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>:                    scanner.close();                    loop = <span class="hljs-literal">false</span>;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">default</span>:                    <span class="hljs-keyword">break</span>;            &#125;        &#125;        System.out.println(<span class="hljs-string">&quot;程序退出&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 使用数组模拟队列</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayQueue</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize; <span class="hljs-comment">// 表示数组最大容量</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> front; <span class="hljs-comment">// 队列头</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rear; <span class="hljs-comment">// 队列尾</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] arr; <span class="hljs-comment">// 用数组模拟队列</span>    <span class="hljs-comment">// 创建队列的构造器,初始化队列</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span> &#123;        <span class="hljs-built_in">this</span>.maxSize = maxSize;        arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[maxSize];        front = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 指向队列头部（不包含，指向队列头的前一个位置）</span>        rear = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 指向队列尾部（包含队列最后一个数据）</span>    &#125;    <span class="hljs-comment">// 判断队列是否为满</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> rear == maxSize - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 判断队列是否为空</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> rear == front;    &#125;    <span class="hljs-comment">//添加数据到队列</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;        <span class="hljs-comment">//判断队列是否为满</span>        <span class="hljs-keyword">if</span> (isFull()) &#123;            System.out.println(<span class="hljs-string">&quot;该队列已满，无法添加数据&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        rear++; <span class="hljs-comment">// rear后移</span>        arr[rear] = n;    &#125;    <span class="hljs-comment">//获取队列的数据，出队列</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getQueue</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-comment">//抛出异常</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;队列空，无法取出数据&quot;</span>);        &#125;        front++;        <span class="hljs-keyword">return</span> arr[front];    &#125;    <span class="hljs-comment">//显示队列所有数据</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showQueue</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-comment">//抛出异常</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;队列空，无法取出数据&quot;</span>);        &#125;        <span class="hljs-comment">//遍历</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;arr.length;i++) &#123;            System.out.printf(<span class="hljs-string">&quot;arr[%d]=%d\n&quot;</span>, i,arr[i]);        &#125;    &#125;    <span class="hljs-comment">//显示队列的头数据,注意不是取出数据</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">headQueue</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-comment">//抛出异常</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;队列空，无数据&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> arr[front + <span class="hljs-number">1</span>];    &#125;&#125;</code></pre></div><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><p>目前数组使用一次就不能用，没有达到复用的效果</p><h4 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h4><p>将这个数组使用算法改进成一个环形的数组</p><h3 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h3><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><ol><li>front变量的含义：front就指向队列的第一个元素,也就是说<code>arr[front]</code>就是队列的第一个元素，front的初始值&#x3D;0</li><li>rear变量的含义：rear指向队列的最后一个元素的后一个位置，因为需要空出一个空间做为约定，rear的初始值&#x3D;0</li><li>当队列满时，条件是<code>(rear+1)%maxSize=front</code></li><li>对队列为空的条件是<code>rear=front</code></li><li>队列中有效的数据的个数<code>(rear+maxSize-front)%maxSize</code></li></ol><p><img src="/img/circleQueue.png" alt="circleQueue"></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleQueueDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">CircleQueue</span> <span class="hljs-variable">circleQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircleQueue</span>(<span class="hljs-number">6</span>);        <span class="hljs-type">char</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-comment">// 接收用户·输入</span>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);        <span class="hljs-type">boolean</span> <span class="hljs-variable">loop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 输出菜单</span>        <span class="hljs-keyword">while</span> (loop) &#123;            System.out.println(<span class="hljs-string">&quot;s(show): 显示队列&quot;</span>);            System.out.println(<span class="hljs-string">&quot;a(add): 添加元素&quot;</span>);            System.out.println(<span class="hljs-string">&quot;g(get): 取出元素&quot;</span>);            System.out.println(<span class="hljs-string">&quot;h(head): 查看头部&quot;</span>);            System.out.println(<span class="hljs-string">&quot;e(exit): 退出程序&quot;</span>);            key = scanner.next().charAt(<span class="hljs-number">0</span>); <span class="hljs-comment">// 接收一个字符</span>            <span class="hljs-keyword">switch</span> (key) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:                    circleQueue.showQueue();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:                    System.out.println(<span class="hljs-string">&quot;输入一个数字&quot;</span>);                    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> scanner.nextInt();                    circleQueue.addQueue(value);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;g&#x27;</span>:                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> circleQueue.removeQueue();                        System.out.println(<span class="hljs-string">&quot;取出的数据是&quot;</span> + res);                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                        System.out.println(e.getMessage());                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> circleQueue.headQueue();                        System.out.println(<span class="hljs-string">&quot;取出的队列头数据是&quot;</span> + res);                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                        System.out.println(e.getMessage());                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>:                    scanner.close();                    loop = <span class="hljs-literal">false</span>;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">default</span>:                    <span class="hljs-keyword">break</span>;            &#125;        &#125;        System.out.println(<span class="hljs-string">&quot;程序退出&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleQueue</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> front;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rear;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] arr;    <span class="hljs-comment">// 初始化环形数组</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CircleQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span> &#123;        <span class="hljs-built_in">this</span>.maxSize = maxSize;        arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[maxSize];        front = <span class="hljs-number">0</span>;        rear = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> (rear + <span class="hljs-number">1</span>) % maxSize == front;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> rear == front;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;        <span class="hljs-keyword">if</span> (isFull()) &#123;            System.out.println(<span class="hljs-string">&quot;队列已满，无法添加&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        arr[rear] = num;<span class="hljs-comment">//        if (rear &lt; maxSize - 1) &#123;</span><span class="hljs-comment">//            rear++;</span><span class="hljs-comment">//        &#125; else &#123;</span><span class="hljs-comment">//            rear = 0;</span><span class="hljs-comment">//        &#125;</span>        rear = (rear + <span class="hljs-number">1</span>) % maxSize;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeQueue</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            System.out.println(<span class="hljs-string">&quot;队列为空，无法出队&quot;</span>);            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> arr[front];<span class="hljs-comment">//        if (front &lt; maxSize - 1) &#123;</span><span class="hljs-comment">//            front++;</span><span class="hljs-comment">//        &#125; else &#123;</span><span class="hljs-comment">//            front = 0;</span><span class="hljs-comment">//        &#125;</span>        front = (front + <span class="hljs-number">1</span>) % maxSize;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">//显示队列所有数据</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showQueue</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            System.out.println(<span class="hljs-string">&quot;队列为空，无法显示所有数据&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//遍历</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> front; i &lt; front + getSize(); i++) &#123;            System.out.printf(<span class="hljs-string">&quot;arr[%d]=%d\n&quot;</span>, i % maxSize, arr[i % maxSize]);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">headQueue</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            System.out.println(<span class="hljs-string">&quot;队列为空，无法获取头部&quot;</span>);            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> arr[front];    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> (rear + maxSize - front) % maxSize;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数组</tag>
      
      <tag>array</tag>
      
      <tag>队列</tag>
      
      <tag>queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性结构和非线性结构</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="线性结构和非线性结构"><a href="#线性结构和非线性结构" class="headerlink" title="线性结构和非线性结构"></a>线性结构和非线性结构</h1><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><ol><li>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系</li><li>线性结构有两种不同的存储结构，即顺序存储结构（数组）和链式存储结构（链表）。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的</li><li>链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地<br>址信息</li><li>线性结构常见的有：数组、队列、链表和栈，后面我们会详细讲解。</li></ol><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>顺序表是指采用顺序存储方式来存储数据元素的线性表。在顺序表中，我们通常将结点依次存放在一组地址连续的存储空间。</p><h2 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h2><p>非线性结构包括：二维数组，多维数组，广义表，树结构，图结构</p>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java网络编程</title>
    <link href="/Java/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/Java/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h1><ul><li><a href="#java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">Java网络编程</a><ul><li><a href="#tcpip%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80">TCP&#x2F;IP编程基础</a><ul><li><a href="#lnetadress%E7%B1%BB">lnetAdress类</a></li><li><a href="#ip%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7">IP和端口号</a></li><li><a href="#tcp%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">TCP程序设计</a></li><li><a href="#tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">TCP网络编程</a></li></ul></li><li><a href="#url--urlconnection">URL &amp; URLConnection</a></li></ul></li></ul><p>网络编程的目的就是指值接或间接地通过网络协议与其它计算机进行通讯。</p><p>网络编程中有两个主要的问题，</p><ul><li>如何准确地定位网络上一台或多台主机</li><li>找到主机后如何可靠高效地进行数据传输。</li></ul><p>要想让处于网络中的主机互相通信，只是知道通信双方地址还是不够的了，还必须遵循一定的规则。有两套参考模型：</p><ul><li>OSI参考模型:模型过于理想化，未能在因特网上进行广泛推广</li><li>TCP&#x2F;IP参考模型(或TCPAIP协议)：事实上的国际标准。</li></ul><h2 id="TCP-IP编程基础"><a href="#TCP-IP编程基础" class="headerlink" title="TCP&#x2F;IP编程基础"></a>TCP&#x2F;IP编程基础</h2><h3 id="lnetAdress类"><a href="#lnetAdress类" class="headerlink" title="lnetAdress类"></a>lnetAdress类</h3><p>InetAddress类对象含有一个Internet主机地址的域名和IP地址:<code>www.yorick.com/101.43.43.234</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">InetAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;www.yorick.com&quot;</span>);System.out.println(address);<span class="hljs-type">InetAddress</span> <span class="hljs-variable">address1</span> <span class="hljs-operator">=</span> InetAddress.getLocalHost();System.out.println(address1);<span class="hljs-comment">//www.yorick.com/35.186.238.101</span><span class="hljs-comment">//YursPC/10.12.0.16</span></code></pre></div><h3 id="IP和端口号"><a href="#IP和端口号" class="headerlink" title="IP和端口号"></a>IP和端口号</h3><p>IP地址标识Internet 上的计算机，端口号标识正在计算机上运行的进程（程序)。</p><p>端口号与IP地址的组合得出一个网络套接字。</p><p>端口号被规定为一个16位的整数<code>0~65535</code>。其中，<br><code>0~1023</code>被预先定义的服务通信占用（如telnet占用端口23，http占用端口80等）。除非我们需要访问这些特定服务否则，就应该使用<code>1024~65535</code>这些端口中的某一个进行通信，以免发生端口冲突。</p><h3 id="TCP程序设计"><a href="#TCP程序设计" class="headerlink" title="TCP程序设计"></a>TCP程序设计</h3><p>利用套接字(Socket)接口开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。套接字能执行7种基本操作：</p><ul><li>连接到远程主机</li><li>绑定到端口</li><li>接收从远程机器来的连接请求</li><li>监听到达的数据</li><li>发送数据</li><li>接收数据</li><li>关闭连接TCP网络编程</li></ul><h3 id="TCP网络编程"><a href="#TCP网络编程" class="headerlink" title="TCP网络编程"></a>TCP网络编程</h3><p>两个Java应用程序可通过一个双向的网络通信连接实现数据交换，这个双向链路的一段称为一个Socket（套接字）。Socket通常用来实现<code>Client/Server</code>连接。</p><p>Java语言的基于套接字编程分为服务器编程和客户端编程，其通信模型如图所示：</p><p><img src="/./img/TCPSocket.png" alt="TCPSocket"></p><p>实例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//客户端</span><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testClientSocket</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-type">InetAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);    <span class="hljs-comment">//创建Socket对象同时向服务端发出请求</span>    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(address, <span class="hljs-number">9898</span>);    <span class="hljs-comment">//通过输入输出流和服务端进行交互  </span>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(inputStream));    System.out.println(<span class="hljs-string">&quot;^_^:&quot;</span> + reader.readLine());    inputStream.close();    reader.close();    socket.close();&#125;<span class="hljs-comment">//服务端</span><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testServerSocket</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-comment">//创建ServerSocket对象 </span>    <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9898</span>);    <span class="hljs-comment">//接受客户端的请求，并得到Socket对象</span>    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();    <span class="hljs-comment">//通过输入输出流和客户端进行交互  </span>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> socket.getOutputStream();    <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(outputStream);    writer.write(<span class="hljs-string">&quot;来自服务端的问候  &quot;</span>);    writer.close();    outputStream.close();    socket.close();&#125;<span class="hljs-comment">//^_^:来自服务端的问候</span></code></pre></div><p>练习：服务端向客户端传递一个文件﹐客户端读取文件并保存到本地。</p><p>图示：<br><img src="/./img/Socket.png" alt="Socket"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testServerSocket1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8888</span>);    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;flyCat.gif&quot;</span>);    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> socket.getOutputStream();    <span class="hljs-keyword">while</span> ((len = in.read(buffer)) != -<span class="hljs-number">1</span>) &#123;        outputStream.write(buffer, <span class="hljs-number">0</span>, len);    &#125;    outputStream.close();    in.close();    socket.close();    serverSocket.close();&#125;<span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testClientSocket1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-type">InetAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(address, <span class="hljs-number">8888</span>);    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> socket.getInputStream();    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;d:\\flyCat.gif&quot;</span>);    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> ((len = in.read(buffer)) != -<span class="hljs-number">1</span>) &#123;        outputStream.write(buffer, <span class="hljs-number">0</span>, len);    &#125;    in.close();    outputStream.close();    socket.close();&#125;</code></pre></div><h2 id="URL-URLConnection"><a href="#URL-URLConnection" class="headerlink" title="URL &amp; URLConnection"></a>URL &amp; URLConnection</h2><p>URL (Uniform Resource Locator) ：统一资源定位符，它表示 Internet上某一资源的地址。通过URL我们可以访问Internet 上的各种网络资源，比如最常见的www , ftp站点。浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源。</p><p>URL的基本结构由5部分组成：</p><ul><li>&lt;传输协议&gt;:&#x2F;&#x2F;&lt;主机名&gt;:&lt;端口号&gt;&#x2F;&lt;文件名&gt;</li><li>例如：<a href="http://192.168.1.100:8080/helloworld/index.jsp">http://192.168.1.100:8080/helloworld/index.jsp</a></li></ul><p>示例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testURL</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://127.0.0.1:8080/examples/hello.txt&quot;</span>);    System.out.println(url.getPath());    System.out.println(url.getFile());    System.out.println(url.getQuery());    <span class="hljs-comment">//如url为：http://127.0.0.1:8080/examples/hello.txt?name=Yorick</span>    <span class="hljs-comment">//获取name=Yorick</span>    <span class="hljs-type">URLConnection</span> <span class="hljs-variable">urlConnection</span> <span class="hljs-operator">=</span> url.openConnection();    System.out.println(urlConnection);    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> urlConnection.getInputStream();    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> ((len = in.read(buffer)) != -<span class="hljs-number">1</span>) &#123;        outputStream.write(buffer, <span class="hljs-number">0</span>, len);    &#125;    in.close();    outputStream.close();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP/IP</tag>
      
      <tag>UDP</tag>
      
      <tag>网络</tag>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程</title>
    <link href="/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><ul><li><a href="#java%E5%A4%9A%E7%BA%BF%E7%A8%8B">Java多线程</a><ul><li><a href="#%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E4%BB%BB%E5%8A%A1">程序、进程与多任务</a></li><li><a href="#%E7%BA%BF%E7%A8%8B">线程</a><ul><li><a href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B">创建多线程</a><ul><li><a href="#%E6%96%B9%E5%BC%8F%E4%B8%80%E7%BB%A7%E6%89%BFthread%E7%B1%BB">方式一：继承Thread类</a></li><li><a href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%E5%AE%9E%E7%8E%B0runnable%E6%8E%A5%E5%8F%A3">方式二：实现Runnable接口</a></li></ul></li><li><a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">线程的生命周期</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6">线程调度</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5">线程同步</a><ul><li><a href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">线程安全</a></li><li><a href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97">Synchronized关键字</a></li></ul></li><li><a href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1">线程通信</a></li></ul></li></ul></li></ul><h2 id="程序、进程与多任务"><a href="#程序、进程与多任务" class="headerlink" title="程序、进程与多任务"></a>程序、进程与多任务</h2><p>程序（program）是对数据描述与操作的代码的集合，是应用程序执行的脚本。</p><p>进程（process）是程序的一次执行过程，是系统运行程序的基本单位。程序是静态的，进程是动态的。系统运行一个程序即是一个进程从创建运行到消亡的过程。</p><p>多任务（multi task）在一个系统中可以同时运行多个程序，即有多个独立运行的任务﹐每个任务对应一个进程。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程（thread）：比进程更小的运行单位，是程序中单个顺序的流控制。一个进程中可以包含多个线程。</p><p>简单来讲,线程是一个独立的执行流，是进程内部的一个独立执行单元，相当于一个子程序。</p><p>一个进程中的所有线程都在该进程的虚拟地址空间中，<strong>使用该进程的全局变量和系统资源</strong>。</p><p>操作系统给每个线程分配不同的CPU时间片,在某一时刻，CPU只执行一个时间片内的线程,多个时间片中的相应线程在CPU内轮流执行。</p><h3 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h3><p>每个Java程序启动后，虚拟机将自动创建一个主线程<br>可以通过以下两种方式自定义线程类：</p><ul><li>创建<code>java.lang.Thread</code>类的子类，重写该类的run方法</li><li>创建<code>java.lang.Runnable</code>接口的实现类，实现接口中的run方法</li></ul><h4 id="方式一：继承Thread类"><a href="#方式一：继承Thread类" class="headerlink" title="方式一：继承Thread类"></a>方式一：继承Thread类</h4><p>实例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 线程体在 run()方法中</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            System.out.println(threadName + <span class="hljs-string">&quot; : &quot;</span> + i);        &#125;    &#125;&#125;</code></pre></div><p>在主线程里调用 FirstThread</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    <span class="hljs-comment">// 1. 创建线程对象</span>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FirstThread</span>();    <span class="hljs-comment">// 2. 调用线程的 start() 方法启动线程</span>    thread.start();    <span class="hljs-comment">//主线程main</span>    <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;        System.out.println(threadName + <span class="hljs-string">&quot; : &quot;</span> + i);    &#125;&#125;</code></pre></div><p>部分输出：</p><div class="code-wrapper"><pre><code class="hljs java">main : <span class="hljs-number">63</span>main : <span class="hljs-number">64</span>main : <span class="hljs-number">65</span>Thread-<span class="hljs-number">0</span> : <span class="hljs-number">18</span>main : <span class="hljs-number">66</span>Thread-<span class="hljs-number">0</span> : <span class="hljs-number">19</span>main : <span class="hljs-number">67</span>Thread-<span class="hljs-number">0</span> : <span class="hljs-number">20</span>main : <span class="hljs-number">68</span>Thread-<span class="hljs-number">0</span> : <span class="hljs-number">21</span>Thread-<span class="hljs-number">0</span> : <span class="hljs-number">22</span>Thread-<span class="hljs-number">0</span> : <span class="hljs-number">23</span></code></pre></div><p>发现两个线程交替运行</p><p>注意：调用线程的<code>start()</code>方法启动线程，而不是<code>run()</code>方法</p><p>练习：</p><p>不考虑线程安全的问题，使用 Thread 类,创建两个线程，共同打印1-100</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintNumber</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        NumberThread.setI(i);        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberThread</span>(<span class="hljs-string">&quot;Thread_1&quot;</span>);        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberThread</span>(<span class="hljs-string">&quot;Thread_2&quot;</span>);        thread1.start();        thread2.start();    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumberThread</span><span class="hljs-params">(String threadName)</span> &#123;        <span class="hljs-built_in">super</span>(threadName);    &#125;    <span class="hljs-comment">//使用静态属性</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> i;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setI</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;        NumberThread.i = i;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-number">100</span>; i++) &#123;            System.out.println(getName() + <span class="hljs-string">&quot; : &quot;</span> + i);        &#125;    &#125;&#125;</code></pre></div><p>另一种方式：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintNumber</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">PrintNumber</span> <span class="hljs-variable">printNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintNumber</span>();        <span class="hljs-comment">//两个线程对同一个对象进行操作</span>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberThread</span>(<span class="hljs-string">&quot;Thread_1&quot;</span>, printNumber);        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberThread</span>(<span class="hljs-string">&quot;Thread_2&quot;</span>, printNumber);        thread1.start();        thread2.start();    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;    PrintNumber printNumber;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumberThread</span><span class="hljs-params">(String threadName, PrintNumber printNumber)</span> &#123;        <span class="hljs-built_in">super</span>(threadName);        <span class="hljs-built_in">this</span>.printNumber = printNumber;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (; printNumber.i &lt; <span class="hljs-number">100</span>; printNumber.i++) &#123;            System.out.println(getName() + <span class="hljs-string">&quot; : &quot;</span> + printNumber.i);        &#125;    &#125;&#125;</code></pre></div><p>部分输出：</p><div class="code-wrapper"><pre><code class="hljs java">Thread_1 : <span class="hljs-number">0</span>Thread_2 : <span class="hljs-number">0</span>Thread_1 : <span class="hljs-number">1</span>Thread_1 : <span class="hljs-number">3</span>Thread_1 : <span class="hljs-number">4</span>Thread_1 : <span class="hljs-number">5</span>Thread_1 : <span class="hljs-number">6</span>Thread_1 : <span class="hljs-number">7</span>Thread_1 : <span class="hljs-number">8</span>Thread_1 : <span class="hljs-number">9</span>Thread_1 : <span class="hljs-number">10</span>Thread_2 : <span class="hljs-number">2</span>Thread_1 : <span class="hljs-number">11</span>Thread_2 : <span class="hljs-number">12</span>Thread_1 : <span class="hljs-number">13</span>Thread_2 : <span class="hljs-number">14</span>Thread_2 : <span class="hljs-number">16</span>Thread_2 : <span class="hljs-number">17</span>Thread_2 : <span class="hljs-number">18</span>Thread_2 : <span class="hljs-number">19</span>Thread_2 : <span class="hljs-number">20</span>Thread_2 : <span class="hljs-number">21</span>Thread_2 : <span class="hljs-number">22</span>Thread_2 : <span class="hljs-number">23</span>Thread_2 : <span class="hljs-number">24</span>Thread_2 : <span class="hljs-number">25</span>Thread_1 : <span class="hljs-number">15</span>Thread_2 : <span class="hljs-number">26</span>Thread_1 : <span class="hljs-number">27</span>Thread_2 : <span class="hljs-number">28</span>Thread_1 : <span class="hljs-number">29</span>Thread_2 : <span class="hljs-number">30</span>Thread_1 : <span class="hljs-number">31</span>Thread_2 : <span class="hljs-number">32</span>Thread_1 : <span class="hljs-number">33</span></code></pre></div><p>发现除了存在部分线程安全问题，两个线程同时对 i 实施自增操作的。</p><h4 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h4><p>当需要定义的线程类已经显式继承了一个其他的类，即无法继承Thread类时，我们可以使用Runnable接口来实现多线程</p><p>Runnable接口中只有一个未实现的run方法，实现该接口的类必须重写该方法。</p><p>Runnable接口和Thread类之间的区别</p><ul><li>Runnable接口必须实现run方法，而Thread类中的run方法是一个空方法，可以不重写</li><li>Runnable接口的实现类并不是真正的线程类，只是线程运行的目标类。要想以线程的方式执行run方法，必须依靠Thread类</li><li><strong>Runnable接口适合于资源的共享</strong></li></ul><p>实现Runnable接口的方式;</p><ol><li>创建实现 Runnable接口的实现类：必须实现<code>run()</code>方法</li><li>创建 1 中对应的 Runnable接口的实现类对象</li><li>使用 <code>new Thread (Runnable target)</code> 创建Thread对象</li><li>调用 Thread 类<code>start()</code>方法启动线程。</li></ol><p>实例：用Runnable接口实现上面的练习</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1. 创建实现 Runnable接口的实现类：必须实现 run() 方法</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();        <span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-number">100</span>; i++) &#123;            System.out.println(threadName + <span class="hljs-string">&quot; : &quot;</span> + i);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">//2. 创建 1 中对应的 Runnable接口的实现类对象</span>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">mr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();        <span class="hljs-comment">//3. 使用 `new Thread (Runnable target)` 创建Thread对象，</span>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mr);        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mr);        <span class="hljs-comment">//4. 调用 Thread 类`start()`方法启动线程。</span>        thread1.start();        thread2.start();    &#125;&#125;</code></pre></div><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>线程的生命周期：</p><ul><li>指线程从创建到启动，直至运行结束</li><li>可以通过调用Thread类的相关方法影响线程的运行状态</li></ul><p>线程的运行状态：</p><ul><li>新建 (New)</li><li>可执行 (Runnable)</li><li>运行 (Running)</li><li>阻塞（Blocking)</li><li>死亡 (Dead)</li></ul><p><img src="/./img/threadLife.png" alt="ThreadLife"></p><p>新建状态(New)</p><ul><li>当创建了一个Thread对象时，该对象就处于“新建状态”</li><li>没有启动，因此无法运行</li></ul><p>可执行状态(Runnable)</p><ul><li>其他线程调用了处于新建状态线程的start方法，该线程对象将转换到“可执行状态”</li><li>线程拥有获得CPU控制权的机会，处在等待调度阶段。</li></ul><p>运行状态（Running )</p><ul><li>处在“可执行状态”的线程对象一旦获得了CPU控制权就会转换到“执行状态”<br>在“执行状态”下,线程状态占用CPU时间片段 , 执行 run 方法中的代码</li><li>处在“执行状态”下的线程可以调用yield方法,该方法用于主动出让CPU 控制权。线程对象出让控制器后回到“可执行状态”，重新等待调度。<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YieldThreadTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;      <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">YieldThreadTest</span>(<span class="hljs-string">&quot;Thread_1&quot;</span>);      <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">YieldThreadTest</span>(<span class="hljs-string">&quot;Thread_2&quot;</span>);      t1.start();      t2.start();  &#125;  <span class="hljs-keyword">public</span> <span class="hljs-title function_">YieldThreadTest</span><span class="hljs-params">(String name)</span> &#123;      <span class="hljs-built_in">super</span>(name);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;          System.out.println(getName() + <span class="hljs-string">&quot; : &quot;</span> + i);          <span class="hljs-keyword">if</span> (i%<span class="hljs-number">10</span>==<span class="hljs-number">0</span>)&#123;              <span class="hljs-keyword">yield</span>();          &#125;      &#125;  &#125;&#125;</code></pre></div>阻塞状态(Blocking)</li><li>线程在“执行状态”下由于受某种条件的影响会被迫出让CPU控制权，进入“阻塞状态”。</li></ul><p>进入阻塞状态的三种情况</p><ul><li><p>调用<code>sleep</code>方法</p><ul><li>Thread类的sleep方法用于让当前线程暂时休眠一段时间</li><li>参数 millis 的单位是毫秒<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SleepThreadTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;      <span class="hljs-keyword">new</span> <span class="hljs-title class_">SleepThreadTest</span>().start();  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;          <span class="hljs-keyword">try</span> &#123;              Thread.sleep(<span class="hljs-number">1000</span>);          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;              e.printStackTrace();          &#125;          System.out.println(getName() + <span class="hljs-string">&quot; : &quot;</span> + i);      &#125;  &#125;&#125;</code></pre></div></li></ul></li><li><p>调用<code>join</code>方法（合并某个线程）</p><ul><li>处在“执行状态”的线程如果调用了其他线程的<code>join</code>方法，将被挂起进入“阻塞状态”</li><li>目标线程执行完毕后才会解除阻塞，回到“可执行状态”<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JoinThreadTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;      <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JoinThreadTest</span>();      thread.start();      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;          System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + i);          <span class="hljs-keyword">if</span> (i == <span class="hljs-number">10</span>) &#123;              <span class="hljs-keyword">try</span> &#123;                  thread.join();              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                  e.printStackTrace();              &#125;          &#125;      &#125;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;          System.out.println(getName() + <span class="hljs-string">&quot; : &quot;</span> + i);      &#125;  &#125;&#125;</code></pre></div></li></ul></li><li><p>执行IO操作</p><ul><li>线程在执行过程中如果因为访问外部资源（等待用户键盘输入、访问网络）时发生了阻塞，也会导致当前线程进入“阻塞状态”。</li></ul></li></ul><p>解除阻塞</p><ul><li><p>睡眠状态超时</p></li><li><p>调用<code>join</code>后等待其他线程执行完毕</p></li><li><p>I&#x2F;O操作执行完毕</p></li><li><p>调用阻塞线程的<code>interrupt</code>方法（线程睡眠时，调用该线程的<code>interrupt</code>方法会抛出<code>InterruptedException</code>）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptThreadTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;      <span class="hljs-type">InterruptThreadTest</span> <span class="hljs-variable">itt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptThreadTest</span>();      itt.start();      itt.interrupt();  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;          System.out.println(getName() + <span class="hljs-string">&quot; : &quot;</span> + i);          <span class="hljs-keyword">if</span> (i == <span class="hljs-number">10</span>) &#123;              <span class="hljs-keyword">try</span> &#123;                  Thread.sleep(<span class="hljs-number">100000</span>);              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                  e.printStackTrace();              &#125;          &#125;      &#125;  &#125;&#125;</code></pre></div><p>死亡状态(Dead)</p></li><li><p>处于“执行状态”的线程一旦从<code>run</code>方法返回(无论是正常退出还是抛出异常)就会进入“死亡状态”。</p></li><li><p>已经“死亡”的线程不能重新运行，否则会抛出<code>IllegalThreadStateException</code></p></li><li><p>可以使用 Thread类的<code>isAlive</code>方法判断线程是否活着</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IsAliveThreadTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;      <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IsAliveThreadTest</span>();      System.out.println(thread.isAlive());<span class="hljs-comment">//false</span>      thread.start();      System.out.println(thread.isAlive());<span class="hljs-comment">//true</span>      <span class="hljs-keyword">try</span> &#123;          thread.join();      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;          e.printStackTrace();      &#125;      System.out.println(thread.isAlive());<span class="hljs-comment">//false</span>      <span class="hljs-comment">//已经结束的线程无法再被执行</span>      <span class="hljs-comment">//thread.start();</span>  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;          System.out.println(getName() + <span class="hljs-string">&quot; : &quot;</span> + i);      &#125;  &#125;&#125;</code></pre></div></li></ul><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>线程调度</p><ul><li>按照特定机制为线程分配CPU时间片段的行为</li><li>Java程序运行时，由Java虚拟机负责线程的调度</li></ul><p>线程调度的实现方式</p><ul><li>分时调度模型：让所有线程轮流获得CPU的控制权，并且为每个线程平均分配CPU时间片段</li><li>抢占式调度模型：选择优先级相对较高的线程执行，如果所有线程的优先级相同，则随机选择一个线程执行。Java虚拟机采用此种调度模型。</li></ul><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>多线程应用程序同时访问共享对象时，由于线程间相互抢占CPU的控制权，造成一个线程夹在另一个线程的执行过程中运行，所以可能导致错误的执行结果。</p><h4 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h4><p>为了防止共享对象在并发访问时出现错误Java中提供了<code>synchronized</code>关键字。</p><p><code>synchronized</code>关键字</p><ul><li>确保共享对象在同一时刻只能被一个线程访问，这种处理机制称为“线程同步”或“线程互斥”。Java中的“线程同步”基于“对象锁”的概念。</li></ul><p>使用<code>synchronized</code>关键字</p><ul><li>修饰方法</li><li>修饰代码块</li></ul><p>注意：</p><ul><li><p>同步块的作用与同步方法一样，只是控制范围有所区别</p></li><li><p>使用synchronized 代码块解决线程安全的问题：需要在synchronized 代码块中参照共同的一个对象</p></li></ul><p>实例：两个线程同步打印26个字母</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintLetters</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//修饰代码块</span>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;            <span class="hljs-keyword">if</span> (c &lt; +<span class="hljs-string">&#x27;z&#x27;</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + c);                c++;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">10</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> print();        <span class="hljs-keyword">while</span> (flag) &#123;            flag = print();        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">PrintLetters</span> <span class="hljs-variable">letters</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintLetters</span>();        <span class="hljs-type">Thread</span> <span class="hljs-variable">th1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(letters);        <span class="hljs-type">Thread</span> <span class="hljs-variable">th2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(letters);        th1.setName(<span class="hljs-string">&quot;线程1&quot;</span>);        th2.setName(<span class="hljs-string">&quot;线程2&quot;</span>);        th1.start();        th2.start();    &#125;&#125;</code></pre></div><p>修饰方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">if</span> (c &lt; +<span class="hljs-string">&#x27;z&#x27;</span>) &#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + c);        c++;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">10</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></div><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>当一个线程正在使用同步方法时，其他线程就不能使用这个同步方法，而有时涉及一些特殊情况：</p><ul><li>当一个人在一个售票窗口排队买电影票时，如果她给售票员的不是零钱，而售票员有没有售票员找她，那么她必须等待，并允许后面的人买票，以便售票员获取零钱找她，如果第2个人也没有零钱，那么她俩必须同时等待。</li></ul><p>当一个线程使用的同步方法中用到某个变量，而此变量又需要其他线程修改后才能符合本线程的需要，那么可以在同步方法中使用<code>wait()</code>方法</p><p><code>wait()</code>方法：</p><ul><li>中断方法的执行，使本线程等待，暂时让出cpu的使用权，并允许其他线程使用这个同步方法。</li></ul><p><code>notify()</code>方法：</p><ul><li>唤醒由于使用这个同步方法而处于等待线程的某一个结束等待</li></ul><p><code>notifyall()</code>方法：  </p><ul><li>唤醒所有由于使用这个同步方法而处于等待的线程结束等待<br>实例：刘关张买票，票价五元一张，售票员只有五元零钱，张飞有二十元整钱，刘关各有五元</li></ul><div class="code-wrapper"><pre><code class="java">public class TicketHouse implements Runnable &#123;    private int fiveCount = 1, tenCount = 0, twentyCount = 0;    public synchronized void buy() &#123;        String name = Thread.currentThread().getName();        if (&quot;zf&quot;.equals(name)) &#123;            if (fiveCount &lt; 3) &#123;                try &#123;                    System.out.println(&quot;五元面值 &quot; + fiveCount + &quot; 张，张飞必须等待&quot;);                    wait();                    System.out.println(&quot;五元面值 &quot; + fiveCount + &quot; 张，卖一张票给张飞，找零 15&quot;);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125; else if (&quot;gy&quot;.equals(name)) &#123;            fiveCount++;            System.out.println(&quot;卖一张票给关羽，钱正好，&quot; + &quot;五元面值 &quot; + fiveCount + &quot; 张&quot;);        &#125; else if (&quot;lb&quot;.equals(name)) &#123;            fiveCount++;            System.out.println(&quot;卖一张票给刘备，钱正好，&quot; + &quot;五元面值 &quot; + fiveCount + &quot; 张&quot;);        &#125;        //唤醒        if (fiveCount == 3)            notifyAll();    &#125;    @Override    public void run() &#123;        buy();    &#125;    public static void main(String[] args) &#123;        Runnable runnable = new TicketHouse();        Thread th1 = new Thread(runnable);        th1.setName(&quot;zf&quot;);        Thread th2 = new Thread(runnable);        th2.setName(&quot;gy&quot;);        Thread th3 = new Thread(runnable);        th3.setName(&quot;lb&quot;);        th1.start();        th2.start();        th3.start();    &#125;&#125;``</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java多线程</tag>
      
      <tag>Thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java动态代理</title>
    <link href="/Java/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/Java/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><h2 id="使用动态代理实现AOP"><a href="#使用动态代理实现AOP" class="headerlink" title="使用动态代理实现AOP"></a>使用动态代理实现AOP</h2><p>AOP(Aspect Orient Program，面向切面编程)</p><p>代理设计模式的原理：</p><p>使用一个代理将对象包装起来，然后用该代理对象取代原始对象，任何对原始对象的调用都要通过代理，代理对象决定是否以及何时将方法调用转到原始对象上。</p><p>实例：</p><p>定义接口 ArithmeticCalculator</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ArithmeticCalculator</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;    <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;&#125;</code></pre></div><p>实现接口</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArithmeticCalculatorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ArithmeticCalculator</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;        <span class="hljs-keyword">return</span> i + j;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;        <span class="hljs-keyword">return</span> i - j;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;        System.out.println(i * j);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;        System.out.println(i / j);    &#125;&#125;</code></pre></div><p>用代理包装对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testProxy</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">ArithmeticCalculator</span> <span class="hljs-variable">arithmeticCalculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticCalculatorImpl</span>();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * ClassLoader loader:</span><span class="hljs-comment">     * 由动态代理产生的对象由哪个类加载器来加载.</span><span class="hljs-comment">     * 通常情况下和被代理对象使用一样的类加载器</span><span class="hljs-comment">     * <span class="hljs-doctag">@NotNull</span> Class&lt;?&gt;[] interfaces:</span><span class="hljs-comment">     * 由动态代理产生的对象必须实现的接口的 Class 数组</span><span class="hljs-comment">     * <span class="hljs-doctag">@NotNull</span> reflect.InvocationHandler h</span><span class="hljs-comment">     * 当具体调用代理对象的方法时,将产生什么行为</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">final</span> <span class="hljs-type">ArithmeticCalculator</span> <span class="hljs-variable">proxyInstance</span> <span class="hljs-operator">=</span>            (ArithmeticCalculator) Proxy.newProxyInstance(                    arithmeticCalculator.getClass().getClassLoader(),                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;ArithmeticCalculator.class&#125;,                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;                        <span class="hljs-comment">/**</span><span class="hljs-comment">                         *</span><span class="hljs-comment">                         * <span class="hljs-doctag">@param</span> proxy</span><span class="hljs-comment">                         * <span class="hljs-doctag">@param</span> method: 正在被调用的方法</span><span class="hljs-comment">                         * <span class="hljs-doctag">@param</span> args: 调用方法时传入的参数</span><span class="hljs-comment">                         * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">                         * <span class="hljs-doctag">@throws</span> Throwable</span><span class="hljs-comment">                         */</span>                        <span class="hljs-meta">@Override</span>                        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, </span><span class="hljs-params">                                             Method method, </span><span class="hljs-params">                                             Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;                            System.out.print(<span class="hljs-string">&quot;计算；&quot;</span> + args[<span class="hljs-number">0</span>] +                                     method.getName() + args[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot; = &quot;</span>);                            <span class="hljs-type">Object</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> method.invoke(arithmeticCalculator, args);                            <span class="hljs-keyword">return</span> res;                        &#125;                    &#125;);    <span class="hljs-comment">//测试</span>    proxyInstance.mul(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> proxyInstance.add(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);    System.out.println(res);&#125;</code></pre></div><p> 关于动态代理的细节</p><ol><li>需要一个被代理的对象。</li><li>类加载器通常是和被代理对象使用相同的类加载器</li><li>一般地，<code>Proxy.newProxyInstance()</code>的返回值是一个被代理对象实现的接口的类型.当然也可以是其他的接口的类型。<br> 提示:若代理对象不需要额外实现被代理对象实现的接口以外的接口,<br> 可以使用<code>target.getClass(().getInterfaces()</code></li><li><code>InvocationHandler</code> 通常使用匿名内部类的方式，被代理对象需要是 final 类型的。</li><li><code>InvocationHandler</code> 的 <code>invoke()</code> 方法中的第一个参数 Object 类型的 proxy<br> 指的是正在被返回的那个代理对象，一般不使用</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java反射</title>
    <link href="/Java/Java%E5%8F%8D%E5%B0%84/"/>
    <url>/Java/Java%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h1><ul><li><a href="#java%E5%8F%8D%E5%B0%84">Java反射</a><ul><li><a href="#class">Class</a><ul><li><a href="#class%E5%AE%9A%E4%B9%89">Class定义</a></li><li><a href="#%E8%8E%B7%E5%8F%96class%E5%AF%B9%E8%B1%A1">获取Class对象</a></li><li><a href="#class%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">Class类的常用方法</a></li><li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">类加载器</a></li></ul></li><li><a href="#method">Method</a><ul><li><a href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95">获取类的方法</a></li><li><a href="#%E8%B0%83%E7%94%A8%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95">调用类的方法</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BB">获取类的父类</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E7%88%B6%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95">获取父类的方法</a></li></ul></li><li><a href="#field">Field</a><ul><li><a href="#%E8%8E%B7%E5%8F%96field">获取Field</a></li><li><a href="#%E8%8E%B7%E5%8F%96field%E7%9A%84%E5%80%BC">获取Field的值</a></li><li><a href="#%E8%AE%BE%E7%BD%AEfield%E7%9A%84%E5%80%BC">设置Field的值</a></li></ul></li><li><a href="#constructor">Constructor</a><ul><li><a href="#%E8%8E%B7%E5%8F%96constructor%E6%9E%84%E9%80%A0%E5%99%A8">获取Constructor构造器</a></li><li><a href="#%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">调用构造器的方法创建对象</a></li></ul></li><li><a href="#annotation">Annotation</a><ul><li><a href="#%E8%8E%B7%E5%8F%96annotation">获取Annotation</a></li></ul></li><li><a href="#%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%8F%8D%E5%B0%84">泛型和反射</a></li></ul></li></ul><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="Class定义"><a href="#Class定义" class="headerlink" title="Class定义"></a>Class定义</h3><ul><li><p>关于Class:</p><ol><li>class是一个类，是一个描述类的类；</li><li>对象照镜子后可以得到的信息：某个类的数据成员名、方法和构造器、某个类到底实现了哪些接口；</li><li>对于每个类而言，JRE 都为其保留一个不变的Class类型的对象。一个Class对象包含了特定某个类的有关信息。</li></ol></li><li><p>Class对象只能由系统建立对象</p></li><li><p>一个类在JVM中只会有一个Class实例</p></li><li><p>每个类的实例都会记得自己是由哪个Class 实例所生成</p></li></ul><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><p>获取Class对象的三种方式</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;    <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-comment">//1.获取Class对象的方式</span>    <span class="hljs-comment">//1.1直接通过 类名.class 的方式得到</span>    clazz = Person.class;    <span class="hljs-comment">//1.2通过对象调用 getClass() 方法获取</span>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();    clazz = obj.getClass();    <span class="hljs-comment">//1.3通过全类名的方式获取（最常用）</span>    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.yur.java.Person&quot;</span>;    clazz = Class.forName(className);    <span class="hljs-comment">//Field[] fields= clazz.getDeclaredFields();//字段集合</span>    System.out.println();&#125;</code></pre></div><h3 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h3><p><code>getConstructor()</code>返回指定参数类型public的构造器。<br><code>getDeclaredConstructor()</code>返回指定参数类型的private和public构造器。但在使用private的构造器时，必须设置<code>setAccessible()</code>为true,才可以获取并操作该Constructor对象。</p><p>实例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yur.java;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;    <span class="hljs-comment">//供反射使用</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;无参数的构造器&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.age = age;        System.out.println(<span class="hljs-string">&quot;有参数的构造器&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;        <span class="hljs-built_in">this</span>.age = age;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, age=&quot;</span> + age +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>+name);    &#125;&#125;</code></pre></div><p>测试：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testNewInstance</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span>   <span class="hljs-string">&quot;com.yur.java.Person&quot;</span>;    <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);    <span class="hljs-comment">//利用Class对象的getConstructor()方法来调用类的无参构造器</span>    <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clazz.getConstructor();    <span class="hljs-comment">//使用该无参构造构造实例</span>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> constructor.newInstance();&#125;<span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testNewInstance1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span>   <span class="hljs-string">&quot;com.yur.java.Person&quot;</span>;    <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);    <span class="hljs-comment">//利用Class对象的getDeclaredConstructor()方法来调用类的无参私有构造器</span>    <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor();    constructor.setAccessible(<span class="hljs-literal">true</span>);    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> constructor.newInstance();&#125;<span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testNewInstance2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span>   <span class="hljs-string">&quot;com.yur.java.Person&quot;</span>;    <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);    <span class="hljs-comment">//利用Class对象的getDeclaredConstructor()方法来调用类的有参构造器</span>    <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor(String.class);    <span class="hljs-comment">//使用该够惨凄创建实例对象</span>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;Yorick&quot;</span>);&#125;</code></pre></div><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>ClassLoader<br>类装载器是用来把类(class)装载进JVM的。<br>JVM规范定义了两种类型的类装载器：启动类装载器(bootstrap)和用户自定义装载器(user-defined class loader)。JVM在运行时会产生3个类加载器组成的初始化加载器层次结构，如下图所示：</p><p><img src="/./img/classLoader.png" alt="classLoader"></p><p>实例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testClassLoader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, FileNotFoundException &#123;    <span class="hljs-comment">//1.获取一个系统的类加载器</span>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();    System.out.println(classLoader);    <span class="hljs-comment">//2.获取系统类加载器的父类加载器</span>    classLoader = classLoader.getParent();    System.out.println(classLoader);    <span class="hljs-comment">//3.获取扩展类加载器的父类加载器.</span>    classLoader = classLoader.getParent();    System.out.println(classLoader);    <span class="hljs-comment">//4.测试当前类由哪个类加载器加载</span>    classLoader = Class.forName(<span class="hljs-string">&quot;com.yur.java.Person&quot;</span>).getClassLoader();    System.out.println(classLoader);    <span class="hljs-comment">//5.测试JDK 提供的Object 类由哪个类加载器负责加载</span>    classLoader = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getClassLoader();    System.out.println(classLoader);    <span class="hljs-comment">//6.关于类加载器的主要方法（重要）</span>    <span class="hljs-comment">//调用getResourceAsStream获取类路径下的文件对应的输入流·</span>    <span class="hljs-comment">//InputStream in = new FileInputStream(&quot;test.properties&quot;);</span>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    in = <span class="hljs-built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;test.properties&quot;</span>);    System.out.println(in);&#125;</code></pre></div><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>Method: 对应类中的方法。</p><h3 id="获取类的方法"><a href="#获取类的方法" class="headerlink" title="获取类的方法"></a>获取类的方法</h3><ul><li>获取类的方法的数组:<br> <code>clazz.getDeclaredMethods();</code></li><li>获取类的指定的方法:<br> <code>getDeclaredMethod(String name, class&lt;?&gt;... parameterTypes)</code><br> name：方法名<br> parameterTypes：方法的参数类型(使用Class来描述)的列表  <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);method = clazz.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class, <span class="hljs-type">int</span>.class);</code></pre></div></li></ul><h3 id="调用类的方法"><a href="#调用类的方法" class="headerlink" title="调用类的方法"></a>调用类的方法</h3><p>通过method对象执行方法：<br><code>public Object invoke(object obj, Object... args)</code><br>obj：执行哪个对象的方法；<br>args：执行方法时需要传入的参数。</p><p>如果方法是 private 修饰的，需要先调用 Method 的 setAccessible(true)，使其变为可访间</p><p>实例：获取类的方法并执行</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.yur.java.Person&quot;</span>);    <span class="hljs-comment">//1.得到clazz对应的类中有哪些方法（无法获取私有方法）</span>    Method[] methods = clazz.getMethods();    <span class="hljs-keyword">for</span> (Method method : methods) &#123;        System.out.println(<span class="hljs-string">&quot;-&quot;</span> + method.getName());    &#125;    <span class="hljs-comment">//2.获取所有的方法，包括private方法，且只获取当前类声明的方法</span>    Method[] methods1 = clazz.getDeclaredMethods();    <span class="hljs-keyword">for</span> (Method method : methods1) &#123;        System.out.println(<span class="hljs-string">&quot;~&quot;</span> + method.getName());    &#125;    <span class="hljs-comment">//3.获取指定的方法</span>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);    System.out.println(method);    method = clazz.getDeclaredMethod(<span class="hljs-string">&quot;sayHello&quot;</span>);    System.out.println(method);    method = clazz.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class, <span class="hljs-type">int</span>.class);    System.out.println(method);    <span class="hljs-comment">//4.执行方法</span>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.getConstructor().newInstance();    method.invoke(obj, <span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-number">22</span>);&#125;</code></pre></div><h3 id="获取类的父类"><a href="#获取类的父类" class="headerlink" title="获取类的父类"></a>获取类的父类</h3><p>获取当前类的父类，直接调用Class对象的<code>getSuperclass()</code>方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetSuperClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.yur.java.Student&quot;</span>;    <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);    <span class="hljs-type">Class</span> <span class="hljs-variable">superClazz</span> <span class="hljs-operator">=</span> clazz.getSuperclass();    System.out.println(superClazz);    <span class="hljs-comment">//class com.yur.java.Person</span>&#125;</code></pre></div><h3 id="获取父类的方法"><a href="#获取父类的方法" class="headerlink" title="获取父类的方法"></a>获取父类的方法</h3><p>实例：可以获取自身或父类的方法（包括私有方法）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> className:  某个类的全类名</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> methodName: 类的一个方法的方法名。（包括私有方法或者父类方法）</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args:       调用该方法</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>: 调用方法后的返回值</span><span class="hljs-comment"> * 该方法实际调用了下面的方法</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke2</span><span class="hljs-params">(String className, String methodName, Object... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;    Class[] parameterTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[args.length];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;        parameterTypes[i] = args[i].getClass();        System.out.println(parameterTypes[i]);    &#125;    <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">for</span> (; clazz != Object.class; clazz = clazz.getSuperclass()) &#123;        <span class="hljs-keyword">try</span> &#123;            method = clazz.getDeclaredMethod(methodName, parameterTypes);            method.setAccessible(<span class="hljs-literal">true</span>);            obj = clazz.getConstructor().newInstance();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;&#125;    &#125;    <span class="hljs-keyword">return</span> method.invoke(obj, args);&#125;</code></pre></div><p>测试：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInvoke2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    <span class="hljs-comment">//Student类的method1方法被调用,打印&quot;private void method1 &quot; + age</span>    invoke1(<span class="hljs-string">&quot;com.yur.java.Student&quot;</span>, <span class="hljs-string">&quot;method1&quot;</span>, <span class="hljs-number">10</span>);    <span class="hljs-comment">//Student 类的父类的method2()方法被调用，返回值为&quot;private String method2&quot;</span>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invoke2(<span class="hljs-string">&quot;com.yur.java.Student&quot;</span>, <span class="hljs-string">&quot;method2&quot;</span>);    System.out.println(result);&#125;</code></pre></div><p>练习：将通过反射读取并调用类的方法封装为一个工具类</p><p>Code1：接收全类名，使用<code>getMethod()</code>可读取父级方法,但是无法获取私有方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> className:  某个类的全类名</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> methodName: 类的一个方法的方法名。（包括父级方法）</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args:       调用该方法</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>: 调用方法后的返回值</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(String className, String methodName, Object... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;    Class[] parameterTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[args.length];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;        parameterTypes[i] = args[i].getClass();        System.out.println(parameterTypes[i]);    &#125;    <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getMethod(methodName, parameterTypes);    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.getConstructor().newInstance();    <span class="hljs-keyword">return</span> method.invoke(obj, args);&#125;</code></pre></div><p>Code2：接收全类名，由类名新建一个类的对象，再调用Code3的方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> className:  某个类的全类名</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> methodName: 类的一个方法的方法名。（包括私有方法）</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args:       调用该方法</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>: 调用方法后的返回值</span><span class="hljs-comment"> * 该方法实际调用了下面的方法</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke1</span><span class="hljs-params">(String className, String methodName, Object... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;   <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;   obj = Class.forName(className).getConstructor().newInstance();   invoke(obj,methodName,args);   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre></div><p>Code3：接收对象，使用<code>getDeclaredMethod()</code>获取方法，可获取私有方法，但是不能获取父类方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> obj:        方法执行的那个对象.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> methodName: 类的一个方法的方法名。该方法也可能是私有方法·</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args:       调用该方法</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>: 调用方法后的返回值</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object obj, String methodName, Object... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;    Class[] parameterTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[args.length];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;        parameterTypes[i] = args[i].getClass();        System.out.println(parameterTypes[i]);    &#125;    <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> obj.getClass();    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(methodName, parameterTypes);    <span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> clazz.getConstructor().newInstance();    <span class="hljs-keyword">return</span> method.invoke(obj1, args);&#125;</code></pre></div><p>测试Code3：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInvoke</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();    invoke(obj, <span class="hljs-string">&quot;setName&quot;</span>, <span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-number">1</span>);&#125;</code></pre></div><p>测试Code1和Code2：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInvoke1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    invoke(<span class="hljs-string">&quot;com.yur.java.Person&quot;</span>,<span class="hljs-string">&quot;setName&quot;</span>, <span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-number">10</span>);    invoke1(<span class="hljs-string">&quot;com.yur.java.Person&quot;</span>,<span class="hljs-string">&quot;setName&quot;</span>, <span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-number">20</span>);    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> invoke(<span class="hljs-string">&quot;java.text.SimpleDateFormat&quot;</span>,<span class="hljs-string">&quot;format&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());    System.out.println(obj);&#125;</code></pre></div><h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><p>字段</p><h3 id="获取Field"><a href="#获取Field" class="headerlink" title="获取Field"></a>获取Field</h3><ul><li>获取 Field 的数组<br><code>clazz.getDeclaredFields()</code></li><li>获取指定名字的 Field<br><code>clazz.getDeclaredField(String fieldName);</code></li></ul><h3 id="获取Field的值"><a href="#获取Field的值" class="headerlink" title="获取Field的值"></a>获取Field的值</h3><ul><li>若该字段是私有的，需要调用<br><code>setAccessible(true</code>)</li><li>获取对象所对应的字段值<br><code>field.get(Object obj)</code></li></ul><h3 id="设置Field的值"><a href="#设置Field的值" class="headerlink" title="设置Field的值"></a>设置Field的值</h3><ul><li>设置指定对象的Field的值<br><code>field.set(Object obj, Object value);</code><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Filed:封装了字段的信息</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.yur.java.Person&quot;</span>;    <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);    <span class="hljs-comment">//1.获取字段</span>    <span class="hljs-comment">//1.1获取 Field 的数组</span>    Field fields[] = clazz.getDeclaredFields();    <span class="hljs-keyword">for</span> (Field field : fields) &#123;        System.out.println(field.getName());    &#125;    <span class="hljs-comment">//1.2获取指定名字的Field</span>    <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);    System.out.println(field.getName());    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;ABC&quot;</span>,<span class="hljs-number">12</span>);    <span class="hljs-comment">//2.获取指定对象的指定Field的值</span>    <span class="hljs-comment">//若该字段是私有的，需要调用setAccessible(true)方法</span>    field.setAccessible(<span class="hljs-literal">true</span>);    <span class="hljs-type">Object</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> field.get(person);    System.out.println(val);    <span class="hljs-comment">//3.设置指定对象的Field的值</span>    field.set(person,<span class="hljs-string">&quot;Yorick&quot;</span>);    System.out.println(person.getName());&#125;</code></pre></div>工具方法：<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testClassField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.yur.java.Student&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">fieldName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;age&quot;</span>;<span class="hljs-comment">//可能为私有，可能再其父类中</span>    <span class="hljs-type">Object</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);    field = getField(fieldName, field, clazz);    clazz = Class.forName(className);    obj = clazz.getConstructor().newInstance();    field.setAccessible(<span class="hljs-literal">true</span>);    field.set(obj, val);    <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> (Student) obj;    System.out.println(stu.getAge());<span class="hljs-comment">//20</span>&#125;<span class="hljs-keyword">private</span> Field <span class="hljs-title function_">getField</span><span class="hljs-params">(String fieldName, Field field, Class clazz)</span> &#123;    <span class="hljs-keyword">for</span> (; clazz != Object.class; clazz = clazz.getSuperclass()) &#123;        <span class="hljs-keyword">try</span> &#123;            field = clazz.getDeclaredField(fieldName);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        &#125;    &#125;    <span class="hljs-keyword">return</span> field;&#125;</code></pre></div></li></ul><h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><p>构造器</p><h3 id="获取Constructor构造器"><a href="#获取Constructor构造器" class="headerlink" title="获取Constructor构造器"></a>获取Constructor构造器</h3><ul><li>获取全部Constructor对象<br><code>getConstructors()</code></li><li>获取某一个指定的Constructor对象<br><code>getConstructor(class&lt;?&gt;... parameterTypes)</code></li></ul><h3 id="调用构造器的方法创建对象"><a href="#调用构造器的方法创建对象" class="headerlink" title="调用构造器的方法创建对象"></a>调用构造器的方法创建对象</h3><p><code>Object obj = constructor.newInstance(&quot;Yorick&quot;, 21);</code></p><p>实例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Constructor：构造器</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ClassNotFoundException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NoSuchMethodException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InvocationTargetException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InstantiationException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalAccessException</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.yur.java.Person&quot;</span>;    Class&lt;Person&gt; clazz = (Class&lt;Person&gt;) Class.forName(className);    <span class="hljs-comment">//1.获取全部Constructor对象</span>    Constructor&lt;Person&gt;[] constructors =     (Constructor&lt;Person&gt;[]) Class.forName(className).getConstructors();    <span class="hljs-keyword">for</span> (Constructor&lt;Person&gt; constructor : constructors) &#123;        System.out.println(constructor);    &#125;    <span class="hljs-comment">//2.获取某一个指定的Constructor对象</span>    Constructor&lt;Person&gt; constructor =     clazz.getConstructor(String.class, <span class="hljs-type">int</span>.class);    System.out.println(constructor);    <span class="hljs-comment">//3.调用构造器的newInstance()方法创建对象</span>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;Yorick&quot;</span>, <span class="hljs-number">21</span>);&#125;</code></pre></div><h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><h3 id="获取Annotation"><a href="#获取Annotation" class="headerlink" title="获取Annotation"></a>获取Annotation</h3><ul><li><code>getAnnotation()</code></li><li><code>getDeclaredAnnotations()</code></li></ul><p>实例：<br>新建注解类：AgeValidator</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<span class="hljs-keyword">import</span> java.lang.annotation.Retention;<span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<span class="hljs-keyword">import</span> java.lang.annotation.Target;<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Target(value = ElementType.METHOD)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AgeValidator &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">()</span>;&#125;</code></pre></div><p>对Person类的setAge()方法进行注解</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@AgeValidator(min = 18,max = 35)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;    <span class="hljs-built_in">this</span>.age = age;&#125;</code></pre></div><p>通过反射获取注解里的范围，对属性值进行限制</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAnnotation</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.yur.java.Person&quot;</span>;    <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.getConstructor().newInstance();    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;setAge&quot;</span>, <span class="hljs-type">int</span>.class);    <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;    <span class="hljs-type">Annotation</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> method.getAnnotation(AgeValidator.class);    <span class="hljs-keyword">if</span> (annotation != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">if</span> (annotation <span class="hljs-keyword">instanceof</span> AgeValidator) &#123;            <span class="hljs-type">AgeValidator</span> <span class="hljs-variable">ageValidator</span> <span class="hljs-operator">=</span> (AgeValidator) annotation;            <span class="hljs-keyword">if</span> (val &lt; ageValidator.min() || val &gt; ageValidator.max()) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;年龄非法&quot;</span>);            &#125;        &#125;    &#125;    method.invoke(obj, val);    System.out.println(obj);&#125;</code></pre></div><h2 id="泛型和反射"><a href="#泛型和反射" class="headerlink" title="泛型和反射"></a>泛型和反射</h2><p>实例：<br>通过反射，获得定义Class 时声明的父类的泛型参数的类型</p><ul><li>获取带泛型参数的父类<br><code>getGenericSuperclass()</code></li><li><code>Type</code> 的子接口：<code>ParameterizedType</code></li><li>可以调用<code>ParameterizedType</code>的<code>Type[] getActualTypeArguments()</code>获取泛型参数的数组。</li></ul><p>BaseDao类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseDao</span>&lt;T,PK&gt; &#123;&#125;</code></pre></div><p>类EmployeeDao继承自BaseDao类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmployeeDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseDao</span>&lt;Employee,String&gt;&#123;&#125;</code></pre></div><p>目标：通过反射，获得定义Class 时声明的父类的泛型参数的类型</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 通过反射，获得定义Class 时声明的父类的泛型参数的类型</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> clazz:子类对应的Class对象</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index:子类继承父类时传入的泛型的索引，从0开始</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class <span class="hljs-title function_">getSuperClassGenericType</span><span class="hljs-params">(Class clazz, <span class="hljs-type">int</span> index)</span> &#123;    <span class="hljs-comment">//获取父类</span>    <span class="hljs-type">Type</span> <span class="hljs-variable">genType</span> <span class="hljs-operator">=</span> clazz.getGenericSuperclass();    <span class="hljs-comment">//获取具体的泛型参数</span>    <span class="hljs-keyword">if</span> (!(genType <span class="hljs-keyword">instanceof</span> ParameterizedType)) &#123;        <span class="hljs-keyword">return</span> Object.class;    &#125;    <span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">parameterizedType</span> <span class="hljs-operator">=</span>            (ParameterizedType) genType;    Type[] params = parameterizedType.getActualTypeArguments();    <span class="hljs-keyword">if</span> (index &gt; params.length - <span class="hljs-number">1</span> || index &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> Object.class;    &#125;    <span class="hljs-keyword">if</span> (!(params[index] <span class="hljs-keyword">instanceof</span> Class)) &#123;        <span class="hljs-keyword">return</span> Object.class;    &#125;    <span class="hljs-keyword">return</span> (Class) params[index];&#125;</code></pre></div><p>测试：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testgetSuperClassGenericType</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> EmployeeDao.class;    <span class="hljs-comment">//Employee.class</span>    <span class="hljs-type">Class</span> <span class="hljs-variable">argClazz</span> <span class="hljs-operator">=</span> getSuperClassGenericType(clazz, <span class="hljs-number">0</span>);    System.out.println(argClazz);    <span class="hljs-comment">//String.class</span>    argClazz = getSuperClassGenericType(clazz, <span class="hljs-number">1</span>);    System.out.println(argClazz);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java反射</tag>
      
      <tag>reflect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java常用类</title>
    <link href="/Java/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    <url>/Java/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h1><ul><li><a href="#java%E5%B8%B8%E7%94%A8%E7%B1%BB">Java常用类</a><ul><li><a href="#string%E7%B1%BB">String类</a><ul><li><a href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">不可变性</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%93%E5%86%B2%E6%B1%A0">字符串缓冲池</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">字符串常用方法</a></li></ul></li><li><a href="#stringbufferstringbuilder%E7%B1%BB">StringBuffer、StringBuilder类</a></li><li><a href="#date%E7%B1%BB--dateformat%E7%B1%BB">Date类 &amp; DateFormat类</a></li><li><a href="#randommath">Random、Math</a></li></ul></li></ul><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><h4 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h4><p>实例一：<br>String是不可变的字符序列</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;www.yorick.com&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> str.replace(<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>);    System.out.println(str);    System.out.println(newStr);&#125;</code></pre></div><p>实例二：<br>对比person对象和str，体会字符串的不可变性</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPassRef</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;ABC&quot;</span>,<span class="hljs-number">12</span>);    System.out.println(person);    changePerson(person);    System.out.println(person);    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcd&quot;</span>;    changeString(str);    System.out.println(str);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changePerson</span><span class="hljs-params">(Person person)</span> &#123;    person.setName(<span class="hljs-string">&quot;Yorick&quot;</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeString</span><span class="hljs-params">(String str)</span> &#123;    str.replace(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);&#125;<span class="hljs-comment">/*out：</span><span class="hljs-comment">Person&#123;name=&#x27;ABC&#x27;, age=12&#125;</span><span class="hljs-comment">Person&#123;name=&#x27;Yorick&#x27;, age=12&#125;</span><span class="hljs-comment">abcd</span><span class="hljs-comment">*/</span></code></pre></div><h4 id="字符串缓冲池"><a href="#字符串缓冲池" class="headerlink" title="字符串缓冲池"></a>字符串缓冲池</h4><p>关于字符串缓冲池:直接通过<code>=</code>为字符串赋值，会先在缓冲池中查找有没有一样的字符串，<br>如果有就把那个引用赋给字符串变量，否则，会创建一个新的字符串，并把对应的字符串放入到缓冲池中。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testNewString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello Yorick&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello Yorick&quot;</span>;    System.out.println(str1 == str2);<span class="hljs-comment">//true</span>    System.out.println(str1.hashCode());<span class="hljs-comment">//-911844285</span>    System.out.println(str2.hashCode());<span class="hljs-comment">//-911844285</span>    <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abcde&quot;</span>);    <span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abcde&quot;</span>);    System.out.println(str3 == str4);<span class="hljs-comment">//false</span>&#125;</code></pre></div><h4 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h4><ol><li>trim():去除前后空格<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTrim</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;   Yorick   &quot;</span>;    System.out.println(<span class="hljs-string">&quot;--&quot;</span> + str + <span class="hljs-string">&quot;--&quot;</span>);    System.out.println(<span class="hljs-string">&quot;--&quot;</span> + str.trim() + <span class="hljs-string">&quot;--&quot;</span>);    <span class="hljs-comment">//--Yorick--</span>&#125;</code></pre></div></li><li>求子字符串的方法:<br>subString(fromIndex)：从fromIndex开始，包含fromIndex，且 String的字索引从0开始<br>subString(fromIndex, toIndex)：[fromIndex,toIndex)<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSubString</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://www.yorick.com/index.jsp?name=Yorick&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> str.substring(<span class="hljs-number">8</span>);    System.out.println(str1);<span class="hljs-comment">//www.yorick.com/index.jsp?name=Yorick</span>    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> str.substring(<span class="hljs-number">12</span>, <span class="hljs-number">18</span>);    System.out.println(str2);<span class="hljs-comment">//yorick</span>&#125;</code></pre></div></li><li>indexOf:求指定字符的索引<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testIndexOf</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://www.yorick.com/index.jsp?name=Yorick&quot;</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">beginIndex</span> <span class="hljs-operator">=</span> str.indexOf(<span class="hljs-string">&#x27;/&#x27;</span>);    <span class="hljs-type">int</span> <span class="hljs-variable">endIndex</span> <span class="hljs-operator">=</span> str.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>);    System.out.println(beginIndex);<span class="hljs-comment">//6</span>    System.out.println(endIndex);<span class="hljs-comment">//22</span>    System.out.println(str.substring(beginIndex + <span class="hljs-number">2</span>, endIndex));    <span class="hljs-comment">//www.yorick.com</span>&#125;</code></pre></div></li><li>split(String regex):把字符串拆分成字符串数组<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSplit</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a-b-c-d-e-f-g&quot;</span>;    String[] values = str.split(<span class="hljs-string">&quot;-&quot;</span>);    <span class="hljs-keyword">for</span> (String s : values) &#123;        System.out.print(s);<span class="hljs-comment">//abcdefg</span>    &#125;&#125;</code></pre></div></li><li>equals():比较字符串内容是否相等必须使用该方法,而不能直接使用”&#x3D;&#x3D;”</li><li>charAt():用于返回指定索引处的字符。索引范围为从 0 到 length() - 1</li><li>练习：<br>给定一个字符串,如：acmfnz<br>经过运算求每个字符都向后串一位的字符串：bdngoa<br>若某个字符已经是z，则返回到最开始的a</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTransforString</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;acmfnz123uidqweidg&#x27;&#x27;dasd2qedq&gt;e23,&quot;</span>;    System.out.println(str);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> str.charAt(i);        <span class="hljs-comment">//System.out.print(ch);</span>        <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;z&#x27;</span>)&#123;                ch = <span class="hljs-string">&#x27;a&#x27;</span>;            &#125;<span class="hljs-keyword">else</span> &#123;                ch = (<span class="hljs-type">char</span>) (ch + <span class="hljs-number">1</span>);            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &#123;            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;Z&#x27;</span>)&#123;                ch = <span class="hljs-string">&#x27;A&#x27;</span>;            &#125;<span class="hljs-keyword">else</span> &#123;                ch = (<span class="hljs-type">char</span>) (ch + <span class="hljs-number">1</span>);            &#125;        &#125;        System.out.print(ch);    &#125;&#125;</code></pre></div><h3 id="StringBuffer、StringBuilder类"><a href="#StringBuffer、StringBuilder类" class="headerlink" title="StringBuffer、StringBuilder类"></a>StringBuffer、StringBuilder类</h3><p>StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样<br>String：不可变字符序列<br>StringBuilder：可变字符序列、效率高、线程不安全（推荐使用）<br>StringBuffer：可变字符序列、效率低、线程安全（多线程情况下使用）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBufferTest</span> &#123;    <span class="hljs-comment">// append()方法：把字符串加入到字符串序列的后面</span>    <span class="hljs-comment">// 注意：append() 方法的返回值还是当前的StringBuffer对象，可以使用方法的连缀。</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAppend</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        stringBuilder.append(<span class="hljs-string">&quot;&lt;html&gt;&quot;</span>)                .append(<span class="hljs-string">&quot;&lt;body&gt;&quot;</span>)                .append(<span class="hljs-string">&quot;&lt;/body&gt;&quot;</span>)                .append(<span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>);        System.out.println(stringBuilder);    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStringBuilder</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;abcde&quot;</span>);        System.out.println(stringBuffer);        stringBuffer.replace(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;mvp&quot;</span>);        System.out.println(stringBuffer);    &#125;&#125;</code></pre></div><h3 id="Date类-DateFormat类"><a href="#Date类-DateFormat类" class="headerlink" title="Date类 &amp; DateFormat类"></a>Date类 &amp; DateFormat类</h3><p>Date()封装了时期和时间<br>DateFormat:把日期对象格式化为一个字符串或者把一个字符串转为一个 Date对象<br>实例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> java.text.DateFormat;<span class="hljs-keyword">import</span> java.text.ParseException;<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateFormatTest</span> &#123;    <span class="hljs-comment">//Date()封装了时期和时间</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDate</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();        System.out.println(date);    &#125;    <span class="hljs-comment">//DateFormat:把日期对象格式化为一个字符串&amp;把一个字符串转为一个 Date对象</span>    <span class="hljs-comment">//1.DateFormat:是一个抽象类.抽象类获取对象的方式;</span>    <span class="hljs-comment">//1)．创建其子类对象</span>    <span class="hljs-comment">//2). 有的抽象类中提供了静态工厂方法来获取抽象类的实例。</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDateFormat</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ParseException &#123;        <span class="hljs-type">DateFormat</span> <span class="hljs-variable">dateFormat</span> <span class="hljs-operator">=</span> DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.SHORT);        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();        <span class="hljs-type">String</span> <span class="hljs-variable">dateStr</span> <span class="hljs-operator">=</span> dateFormat.format(date);        System.out.println(dateStr);        dateStr = <span class="hljs-string">&quot;2022年5月7日 上午11:46&quot;</span>;        <span class="hljs-type">Date</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> dateFormat.parse(dateStr);        System.out.println(date1);    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSimpleDateFormat</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ParseException &#123;        <span class="hljs-type">DateFormat</span> <span class="hljs-variable">dateFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();        System.out.println(dateFormat.format(date));        <span class="hljs-type">String</span> <span class="hljs-variable">dateStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2012-12-12 12:12:12&quot;</span>;        <span class="hljs-type">Date</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> dateFormat.parse(dateStr);        System.out.println(date1);    &#125;&#125;</code></pre></div><h3 id="Random、Math"><a href="#Random、Math" class="headerlink" title="Random、Math"></a>Random、Math</h3><p>Random中封装了随机相关的方法:返回随机的基本数据类型的值。<br>Math中封装了常用的数学方法。<br>实例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-comment">//静态导入，导入指定类的静态属性和静态方法</span><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.*;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomTest</span> &#123;    <span class="hljs-comment">// Random中封装了随机相关的方法:返回随机的基本数据类型的值</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRandom</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();        System.out.println(random.nextInt());        System.out.println(random.nextInt(<span class="hljs-number">10</span>));<span class="hljs-comment">//10以内</span>    &#125;    <span class="hljs-comment">// Math中封装了常用的数学方法</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMath</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//System.out.println(Math.sin(Math.PI/6));</span>        <span class="hljs-comment">//静态导入后效果</span>        System.out.println(sin(PI/<span class="hljs-number">6</span>));    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaIO</title>
    <link href="/Java/JavaIO/"/>
    <url>/Java/JavaIO/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h1><ul><li><a href="#java-io">Java IO</a><ul><li><a href="#io%E6%A6%82%E8%BF%B0">IO概述</a></li><li><a href="#file%E7%B1%BB">File类</a></li><li><a href="#io%E6%B5%81%E5%88%86%E7%B1%BB">IO流分类</a></li><li><a href="#lnputstream--reader">lnputStream &amp; Reader</a></li><li><a href="#outputstream--writer">OutputStream &amp; Writer</a></li><li><a href="#%E7%BC%93%E5%86%B2%E6%B5%81">缓冲流</a></li><li><a href="#%E8%BD%AC%E6%8D%A2%E6%B5%81">转换流</a></li><li><a href="#randomaccessfile%E7%B1%BB">RandomAccessFile类</a></li><li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96">对象的序列化</a></li></ul></li></ul><h3 id="IO概述"><a href="#IO概述" class="headerlink" title="IO概述"></a>IO概述</h3><p>Java的IO流主要包括输入、输出两种IO流，每种输入输出流有可分为字节流和字符流两大类:</p><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>File类代表与平台无关的文件和目录。<br>File能新建、删除、重命名文件和目录，但File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入&#x2F;输出流。<br>相关方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IOTest</span> &#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-comment">//创建File对象</span>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;file.txt&quot;</span>);        <span class="hljs-comment">//测试File对象的方法</span>        <span class="hljs-comment">//文件名相关的方法</span>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> file.getName();        System.out.println(fileName);        <span class="hljs-comment">//访问文件的绝对路径</span>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> file.getAbsolutePath();        System.out.println(path);        <span class="hljs-comment">//为文件重命名</span>        file.renameTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:\\hello.txt&quot;</span>));        <span class="hljs-comment">//文件检测相关方法</span>        System.out.println(file.exists());<span class="hljs-comment">//false</span>        <span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;hello&quot;</span>);        System.out.println(dir.isDirectory());<span class="hljs-comment">//true</span>        <span class="hljs-comment">//获取文件的常规信息</span>        System.out.println(file.length());        <span class="hljs-comment">//文件操作相关</span>        <span class="hljs-comment">//新建文件</span>        <span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;aa.txt&quot;</span>);        file1.createNewFile();    &#125;&#125;</code></pre></div><h3 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h3><p>按流向分：</p><ul><li>输入流</li><li>输出流</li></ul><p>按处理的单位：</p><ul><li>字节流(8位的字节)，所有二进制文件通用</li><li>字符流(16位的字节)，只能处理纯字符文本文件</li></ul><p>按流的角色：</p><ul><li>节点流:可以从一个特定的IO设备读&#x2F;写数据的流</li><li>处理流:对一个已存在的流进行连接和封装，通过封装后的流来实现数据读&#x2F;写操作</li></ul><p>IO流体系<br><img src="/./img/IOStream.png" alt="IO流体系"></p><h3 id="lnputStream-Reader"><a href="#lnputStream-Reader" class="headerlink" title="lnputStream &amp; Reader"></a>lnputStream &amp; Reader</h3><p>InputStream和 Reader是所有输入流的基类。<br>InputStream(典型实现:FileInputStream ) :</p><div class="code-wrapper"><pre><code class="hljs java">- <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>- <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b)</span>- <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span></code></pre></div><p>Reader (典型实现:FileReader ) :</p><div class="code-wrapper"><pre><code class="hljs java">- <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>- <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">char</span>[] c)</span>- <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">char</span>[] c, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span></code></pre></div><p>程序中打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO资源。<br>实例：<br>字节输入流</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//字节输入流，本段代码仅示例，实际运行要注释掉一部分</span><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-comment">//创建一个字节输入流</span>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;file.txt&quot;</span>);    <span class="hljs-comment">//读取文件的内容</span>    <span class="hljs-comment">//读取一个字节,效率很低，不建议，</span>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> in.read();    <span class="hljs-comment">//-1表示读取到文件的末尾</span>    <span class="hljs-keyword">while</span> (result != -<span class="hljs-number">1</span>) &#123;           System.out.print((<span class="hljs-type">char</span>) result);           result = in.read();    &#125;        一次读一组,一组<span class="hljs-number">10</span>个字节    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span>];    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//返回读取的字节数，若为-1表示读取到文件的结尾</span>    <span class="hljs-keyword">while</span> ((len = in.read(buffer)) != -<span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">//末尾容易出错</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : buffer) &#123;            System.out.print((<span class="hljs-type">char</span>) b);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            System.out.print((<span class="hljs-type">char</span>) buffer[i]);        &#125;    &#125;    <span class="hljs-comment">//把内容读取到字节数组的部分连续的元素中</span>    <span class="hljs-type">byte</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">10</span>];    in.read(result, <span class="hljs-number">10</span>, in.available());    <span class="hljs-comment">//关闭流资源</span>    in.close();&#125;</code></pre></div><p>字符输入流</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//字符输入流</span><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testReader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-comment">//利用字符输入流读取hello.txt文档的内容，输出到控制台.</span>    <span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;file.txt&quot;</span>);    <span class="hljs-type">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">10</span>];    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> ((len = reader.read(buffer)) != -<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            System.out.print(buffer[i]);        &#125;    &#125;&#125;</code></pre></div><h3 id="OutputStream-Writer"><a href="#OutputStream-Writer" class="headerlink" title="OutputStream &amp; Writer"></a>OutputStream &amp; Writer</h3><p>OutputStream和Writer也非常相似:</p><div class="code-wrapper"><pre><code class="hljs java">- <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span> write/<span class="hljs-type">int</span> c)</span>- <span class="hljs-keyword">void</span> []/<span class="hljs-type">char</span>[] buff)- <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span>[]/<span class="hljs-type">char</span>[] buff, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span>;</code></pre></div><p>因为字符流直接以字符作为操作单位，所以 Writer可以用字符串来替换字符数组，即以 String对象作为参数</p><div class="code-wrapper"><pre><code class="hljs java">- <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String str)</span>;- <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span></code></pre></div><p>实例：</p><div class="code-wrapper"><pre><code class="hljs java">    <span class="hljs-comment">//测试字节输出流</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testOutputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;abcd.txt&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;www.yorick.com\n\rHello Yorick&quot;</span>;<span class="hljs-comment">//        byte[] buffer = new byte[10];</span><span class="hljs-comment">//        int len = 10;</span><span class="hljs-comment">//</span><span class="hljs-comment">//        int time = content.length() / 10;</span><span class="hljs-comment">//</span><span class="hljs-comment">//</span><span class="hljs-comment">//        byte[] contentBytes = content.getBytes();</span><span class="hljs-comment">//</span><span class="hljs-comment">//        for (int i = 0; i &lt; content.length() / 10; i++) &#123;</span><span class="hljs-comment">//            //把String拆分为多个buffer</span><span class="hljs-comment">//            out.write(contentBytes, i * 10, len);</span><span class="hljs-comment">//        &#125;</span><span class="hljs-comment">//</span><span class="hljs-comment">//        if (content.length() % 10 != 0) &#123;</span><span class="hljs-comment">//           out.write(contentBytes,10*(content.length()/10),</span><span class="hljs-comment">//                   content.length()-10*(content.length()/10));</span><span class="hljs-comment">//        &#125;</span>        out.write(content.getBytes(StandardCharsets.UTF_8));        out.close();    &#125;</code></pre></div><p>文件复制实例：</p><p>利用字节输入输出流。完成hello.txt文件的复制把该文件复制为hello2.txt</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCopyFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException&#123;    <span class="hljs-comment">//1。创建定位到hello.txt的文件的输入流</span>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);    <span class="hljs-comment">//2．创建定位到 hello2.txt的文件输出流</span>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;hello2.txt&quot;</span>);    <span class="hljs-comment">//3．创建一个 byte数组，用于读写文件</span>    <span class="hljs-type">byte</span> [] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[ <span class="hljs-number">1024</span>*<span class="hljs-number">10</span>];    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//4．读写文件:</span>    <span class="hljs-comment">//in.read( buffer); out.write(buffer, 0, len);</span>    <span class="hljs-keyword">while</span> ((len =in.read(buffer)) !=-<span class="hljs-number">1</span>)&#123;        out.write(buffer,<span class="hljs-number">0</span>,len);    &#125;    <span class="hljs-comment">//5. 关闭流资源</span>    in.close();    out.close();&#125;</code></pre></div><p>利用字符输入输出流。完成hello.txt文件的复制把该文件复制为hello2.txt</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCopyByReaderAndWriter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-comment">//1，创建字符输入，输出流</span>    <span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);    <span class="hljs-type">Writer</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;hello2.txt&quot;</span>);    <span class="hljs-comment">//3. 创建一个字符数组。</span>    <span class="hljs-type">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">10</span>];    <span class="hljs-comment">//4. 利用循环读取源文件，并向目标文件写入</span>    <span class="hljs-comment">//5. 注意:使用的写入的方法:write(char[] buf，int off, int len)</span>    <span class="hljs-comment">//而不能直接使用write(char[] buf)|</span>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> ((len = reader.read(buffer)) != -<span class="hljs-number">1</span>) &#123;        writer.write(buffer, <span class="hljs-number">0</span>, len);        System.out.println(len);    &#125;    <span class="hljs-comment">//2. 关闭流资源</span>    reader.close();    writer.close();&#125;</code></pre></div><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>文件复制（字符流）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//复制hello.txt 为 hello3.txt</span><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBufferedReaderAndBufferedWrite</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-comment">//1。创建 BufferedReader和 BufferedWriter</span>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>));    <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;hello3.txt&quot;</span>));    <span class="hljs-comment">//2. 进行读写操作</span>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> ((str = bufferedReader.readLine()) !=<span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>)            bufferedWriter.write(<span class="hljs-string">&quot;\n&quot;</span>);        bufferedWriter.write(str);        i++;    &#125;    <span class="hljs-comment">//3.关闭IO流,直接关闭包装流 ，内部会关闭节点流</span>    bufferedReader.close();    bufferedWriter.close();&#125;</code></pre></div><p>缓冲字节流，最常用的文件复制方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBufferedInputStreamAndBufferedOutputStream</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> IOException&#123;    <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bIS</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>));    <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bOT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;hello4.txt&quot;</span>));    <span class="hljs-type">byte</span> [] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> ((len = bIS.read(buffer))!= -<span class="hljs-number">1</span>)&#123;        bOT.write(buffer,<span class="hljs-number">0</span>,len);    &#125;    bIS.close();    bOT.close();&#125;</code></pre></div><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>字节流和字符流相互转换<br>实例一：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInputStreamReader</span><span class="hljs-params">()</span> throwsIOException &#123;    <span class="hljs-comment">//指向文档的字节流</span>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);    <span class="hljs-comment">//把上面的流转为字符流</span>    <span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(in);    <span class="hljs-comment">//把字符流转为带缓冲的字符流</span>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(reader);    <span class="hljs-comment">//打印文本内容</span>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">while</span> ((str = bufferedReader.readLine()) != <span class="hljs-literal">null</span>) &#123;        System.out.println(str);    &#125;    <span class="hljs-comment">//关闭</span>    in.close();    reader.close();    bufferedReader.close();&#125;</code></pre></div><p>实例二：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testOutStreamReader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-comment">//先创建两个字节输入输出流:分别指向hello.txt, hello5.txt</span>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;hello5.txt&quot;</span>);    <span class="hljs-comment">//然后再转为字符输入输出流</span>    <span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(in);    <span class="hljs-type">Writer</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(out);    <span class="hljs-comment">//再转为带缓冲的字符输入输出流</span>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(reader);    <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(writer);    <span class="hljs-comment">//完成文件的复制</span>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">while</span> ((str = bufferedReader.readLine()) != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>)            writer.write(<span class="hljs-string">&quot;\n&quot;</span>);        writer.write(str);        i++;    &#125;    <span class="hljs-comment">//关闭</span>    in.close();    reader.close();    bufferedReader.close();    bufferedWriter.close();    writer.close();    out.close();&#125;</code></pre></div><h3 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h3><p>RandomAccessFile类既可以读取文件内容，也可以向文件输出数据。<br>RandomAccessFile类支持“随机访问”的方式，程序可以直接跳到文件的任意地方来读写文件。</p><ul><li>支持只访问文件的部分内容</li><li>可以向已存在的文件后追加内容</li></ul><p>RandomAccessFile对象包含一个记录指针，用以标示当前读写处的位置。RandomAccessFile类对象可以自由移动记录指针：</p><ul><li>long getFilePointer()：获取文件记录指针的当前位置</li><li>void seek(long pos)：将文件记录指针定位到pos 位置</li></ul><p>创建RandomAccessFile类可以指定一个mode参数，该参数指定RandomAccessFile的访问模式：</p><ul><li>r：以只读方式打开</li><li>rw：以读、写方式打开</li></ul><p>实例一：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRandomAccessFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-comment">//1.创建 RandomAccessFile类</span>    <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">accessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);    <span class="hljs-comment">//3. 对文件进行读取</span>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">while</span> ((str = accessFile.readLine()) != <span class="hljs-literal">null</span>) &#123;        System.out.println(str);    &#125;    <span class="hljs-comment">//4.向文件结尾写入</span>    accessFile.writeBytes(<span class="hljs-string">&quot;www.yorick.com&quot;</span>);    <span class="hljs-comment">//2.关闭</span>&#125;</code></pre></div><p>实例二：<br>向hello.txt文件中插入一行:I Love KongFu，<br>插入到第二行，原内容下移。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRandomAccessFile2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-comment">//创建 RandomAccessFile类</span>    <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">accessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);    <span class="hljs-comment">//先读一行</span>    <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> accessFile.readLine();    <span class="hljs-comment">//把第一行后面的内容先读取到一个byte数组中</span>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>) (accessFile.length() - line.length())];    accessFile.read(buffer);    <span class="hljs-comment">//移动指针到第一行的后面</span>    accessFile.seek(line.length());    <span class="hljs-comment">//写入字符</span>    accessFile.writeBytes(<span class="hljs-string">&quot;\nI Love KongFu\n&quot;</span>);    <span class="hljs-comment">//写入第二行往后的内容</span>    accessFile.write(buffer);    <span class="hljs-comment">//关闭</span>    accessFile.close();&#125;</code></pre></div><h3 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h3><p>对象序列化的目标是将对象保存到磁盘上，或允许在网络中直接传输对象。<br>序列化是 RMI ( Remote Method Invoke-远程方法调用）过程的参数和返回值都必须实现的机制，而RMI是JavaEE的基础。因此序列化机制是JavaEE平台的基础。<br>如果需要让某个对象支持序列化机制，则必须让的类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一︰</p><ul><li>Serializable</li><li>Externalizable</li></ul><p>若某个类实现了Serializable接口，该类的对象就是可序列化的：</p><ul><li>创建一个ObjectOutputStream</li><li>调用ObjectOutputStream对象的writeObiect()方法输出可序列化对象</li></ul><p>反序列化：</p><ul><li>创建一个ObjectInputStream</li><li>调用readObject(方法读取六种的对象</li></ul><p>如果某个类的字段不是基本数据类型或 String类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field的类也不能序列化<br>实例：<br>Person类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;        <span class="hljs-comment">// 类的版本号:用于对象的序列化。具体用于读取对象时比对硬盘上对象的版本和</span>    <span class="hljs-comment">// 程序中对象的版本是否一致,若不一致读取失败，并抛出异常。</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">8461301440305913644L</span>;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;    <span class="hljs-keyword">private</span> Address address;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.age = age;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;        <span class="hljs-built_in">this</span>.age = age;    &#125;    <span class="hljs-keyword">public</span> Address <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> address;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddress</span><span class="hljs-params">(Address address)</span> &#123;        <span class="hljs-built_in">this</span>.address = address;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, age=&quot;</span> + age +                <span class="hljs-string">&quot;, address=&quot;</span> + address +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div><p>包含字段Address，Address类也要序列化</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1872787737087373355L</span>;    <span class="hljs-keyword">private</span> String city;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">(String city)</span> &#123;        <span class="hljs-built_in">this</span>.city = city;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCity</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> city;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCity</span><span class="hljs-params">(String city)</span> &#123;        <span class="hljs-built_in">this</span>.city = city;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Address&#123;&quot;</span> +                <span class="hljs-string">&quot;city=&#x27;&quot;</span> + city + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div><p>序列化，将person对象写入磁盘</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSerializable</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-number">12</span>);    person.setAddress(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;BeiJing&quot;</span>));    <span class="hljs-comment">//使用ObjectOutputStream 把对象写到硬盘上</span>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;d:\\obj.txt&quot;</span>);    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(out);    objectOutputStream.writeObject(person);    out.close();    objectOutputStream.close();&#125;</code></pre></div><p>反序列化，从磁盘读取person对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testObjectInputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;d:\\obj.txt&quot;</span>);    <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(inputStream);    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> objectInputStream.readObject();    System.out.println(obj);    objectInputStream.close();    inputStream.close();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
      <tag>文件读写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java注解</title>
    <link href="/Java/Java%E6%B3%A8%E8%A7%A3/"/>
    <url>/Java/Java%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h1><ul><li><a href="#java%E6%B3%A8%E8%A7%A3">Java注解</a><ul><li><a href="#%E6%B3%A8%E8%A7%A3%E6%A6%82%E8%BF%B0">注解概述</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E7%9A%84annotation">基本的Annotation</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89annotation">自定义Annotation</a></li><li><a href="#%E6%8F%90%E5%8F%96annotation%E4%BF%A1%E6%81%AF">提取Annotation信息</a></li><li><a href="#jdk%E7%9A%84%E5%85%83annotation">JDK的元Annotation</a></li></ul></li></ul><h3 id="注解概述"><a href="#注解概述" class="headerlink" title="注解概述"></a>注解概述</h3><p>Annotation其实就是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。<br>Annotation可以像修饰符一样被使用，可用于修饰包，类，构造器，方法，成员变量，参数，局部变量的声明，这些信息被保存在Annotation的<code>name = value</code>对中。</p><h3 id="基本的Annotation"><a href="#基本的Annotation" class="headerlink" title="基本的Annotation"></a>基本的Annotation</h3><p>使用Annotation时要在其前面增加@符号，并把该Annotation当成一个修饰符使用，用于修饰它支持的程序元素。  </p><p>三个基本的Annotation:</p><ul><li>@Override:限定重写父类方法，该注释只能用于方法。</li><li>@Deprecated:用于表示某个程序元素(类，方法等)已过时</li><li>@SuppressWarnings:抑制编译器警告。</li></ul><p>实例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAnnotation</span> &#123;    <span class="hljs-meta">@SuppressWarnings(&quot;unused&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();        a.method2();        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;&#125;    <span class="hljs-meta">@Deprecated</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;&#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;&#125;&#125;</code></pre></div><h3 id="自定义Annotation"><a href="#自定义Annotation" class="headerlink" title="自定义Annotation"></a>自定义Annotation</h3><p>定义新的Annotation类型使用<code>@interface</code>关键字。<br>Annotation的成员变量在Annotation定义中以无参数方法的形式来声明，其方法名和返回值定义了该成员的名字和类型（类似接口方法声明）。<br>可以在定义Annotation的成员变量时为其指定初始值，指定成员变量的初始值可使用default关键字。<br>没有成员定义的Annotation称为标记；包含成员变量的Annotation称为元数据Annotation。</p><p>实例：</p><p>定义注解HelloAnnotation</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> HelloAnnotation &#123;    <span class="hljs-comment">//指定成员变量的初始值可使用default关键字</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;&#125;</code></pre></div><p>使用注解HelloAnnotation</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@HelloAnnotation()</span><span class="hljs-comment">//用了default，可空</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;    <span class="hljs-meta">@HelloAnnotation(name = &quot;method&quot;)</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;&#125;&#125;</code></pre></div><h3 id="提取Annotation信息"><a href="#提取Annotation信息" class="headerlink" title="提取Annotation信息"></a>提取Annotation信息</h3><p>反射</p><h3 id="JDK的元Annotation"><a href="#JDK的元Annotation" class="headerlink" title="JDK的元Annotation"></a>JDK的元Annotation</h3><p>JDK的元Annotation用于修饰其他Annotation定义</p><p>@Retention:只能用于修饰一个Annotation定义，用于指定该Annotation可以保留多长时间，@Rentention包含一个RetentionPolicy类型的成员变量，使用@Rentention时必须为该value成员变量指定值:</p><ul><li>RetentionPolicy.CLASS:编译器将把注释记录在class文件中.当运行Java程序时，JVM不会保留注释。这是默认值</li><li>RetentionPolicy.RUNTIME:编译器将把注释记录在class文件中，当运行Java程序时，JVM会保留注释。程序可以通过反射获取该注释（常用）</li><li>RetentionPolicy.SOURCE:编译器直接丢弃这种策略的注释</li></ul><p>@Target：用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素。@Target也包含一个名为value的成员变量。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//限定此注解只能修饰方法和类</span><span class="hljs-meta">@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> HelloAnnotation &#123;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;&#125;</code></pre></div><p>@Documented:用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档。<br>@Inherited:被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注释</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>注解</tag>
      
      <tag>Annotation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java枚举</title>
    <link href="/Java/Java%E6%9E%9A%E4%B8%BE/"/>
    <url>/Java/Java%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><ul><li><a href="#%E6%9E%9A%E4%B8%BE">枚举</a><ul><li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li><li><a href="#%E8%87%AA%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE%E7%B1%BB">自实现枚举类</a></li><li><a href="#%E4%BD%BF%E7%94%A8enum%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB">使用enum定义枚举类</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB">实现接口的枚举类</a></li><li><a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95">枚举类的方法</a></li></ul></li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>枚举类概述:<br>在某些情况下，一个类的对象是有限而且固定的，例如季节类，只能有4个对象<br>手动实现枚举类∶</p><ul><li><code>private</code>修饰构造器</li><li>属性使用<code>private final</code>修饰</li><li>把该类的所有实例都使用<code>public static final</code>来修饰</li></ul><h3 id="自实现枚举类"><a href="#自实现枚举类" class="headerlink" title="自实现枚举类"></a>自实现枚举类</h3><p>定义Season类<br>实例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Season</span> &#123;    <span class="hljs-comment">//1.因为枚举类的对象是有限个，所以不能在类的外部创建类的对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Season</span><span class="hljs-params">(String name, String desc)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.desc = desc;    &#125;    <span class="hljs-comment">//2.因为对象是固定的,所以属性是常量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;    <span class="hljs-comment">//3.在类的内部创建对象，但需要在类的外部能访问到该对象，而且还不能更改</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">SPRING</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>(<span class="hljs-string">&quot;春天&quot;</span>, <span class="hljs-string">&quot;春风又绿江南岸&quot;</span>);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">SUMMER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>(<span class="hljs-string">&quot;夏天&quot;</span>, <span class="hljs-string">&quot;映日荷花别样红&quot;</span>);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">AUTUMN</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>(<span class="hljs-string">&quot;秋天&quot;</span>, <span class="hljs-string">&quot;秋水共长天一色&quot;</span>);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">WINTER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>(<span class="hljs-string">&quot;冬 天&quot;</span>, <span class="hljs-string">&quot;窗含西岭千秋雪&quot;</span>);    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDesc</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> desc;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Season&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div><p>测试:</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SeasonTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Season</span> <span class="hljs-variable">SPRING</span> <span class="hljs-operator">=</span> Season.SPRING;        System.out.println(SPRING);    &#125;&#125;<span class="hljs-comment">//输出：Season&#123;name=&#x27;春天&#x27;, desc=&#x27;春风又绿江南岸&#x27;&#125;</span></code></pre></div><h3 id="使用enum定义枚举类"><a href="#使用enum定义枚举类" class="headerlink" title="使用enum定义枚举类"></a>使用enum定义枚举类</h3><p>枚举类和普通类的区别:</p><ul><li>使用enum定义的枚举类默认继承了java.lang.Enum类</li><li>枚举类的构造器只能使用private 访问控制符</li><li>枚举类的所有实例必须在枚举类中显式列出(,分隔;结尾).列出的实例系统会自动添加 public static final修饰</li><li>所有的枚举类都提供了一个values方法,该方法可以很方便地遍历所有的枚举值</li></ul><p>若枚举只有一个成员，则可以作为一种单子模式的实现方式</p><p>实例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season2</span> &#123;    <span class="hljs-comment">//必须在枚举类的第一行写出有哪些枚举值。</span>    SPRING(<span class="hljs-string">&quot;春天&quot;</span>, <span class="hljs-string">&quot;春风又绿江南岸&quot;</span>),    SUMMER(<span class="hljs-string">&quot;夏天&quot;</span>, <span class="hljs-string">&quot;映日荷花别样红&quot;</span>),    AUTUMN(<span class="hljs-string">&quot;秋天&quot;</span>, <span class="hljs-string">&quot;秋水共长天一色&quot;</span>),    WINTER(<span class="hljs-string">&quot;冬天&quot;</span>, <span class="hljs-string">&quot;窗含西岭千秋雪&quot;</span>);    Season2(String name, String desc) &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.desc = desc;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDesc</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> desc;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;        <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Season2&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div><p>测试：</p><div class="code-wrapper"><pre><code class="hljs java">System.out.println(Season2.SPRING);<span class="hljs-comment">//Season2&#123;name=&#x27;春天&#x27;, desc=&#x27;春风又绿江南岸&#x27;&#125;</span><span class="hljs-comment">//所有的枚举类都提供了一个values方法,该方法可以很方便地遍历所有的枚举值</span>        <span class="hljs-keyword">for</span> (Season2 s :Season2.values())&#123;            System.out.println(s);        &#125;<span class="hljs-comment">/*</span><span class="hljs-comment">Season2&#123;name=&#x27;春天&#x27;, desc=&#x27;春风又绿江南岸&#x27;&#125;</span><span class="hljs-comment">Season2&#123;name=&#x27;夏天&#x27;, desc=&#x27;映日荷花别样红&#x27;&#125;</span><span class="hljs-comment">Season2&#123;name=&#x27;秋天&#x27;, desc=&#x27;秋水共长天一色&#x27;&#125;</span><span class="hljs-comment">Season2&#123;name=&#x27;冬天&#x27;, desc=&#x27;窗含西岭千秋雪&#x27;&#125;</span><span class="hljs-comment">*/</span></code></pre></div><h3 id="实现接口的枚举类"><a href="#实现接口的枚举类" class="headerlink" title="实现接口的枚举类"></a>实现接口的枚举类</h3><p>和普通Java类一样枚举类可以实现一个或多个接口<br>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式,则可以让每个枚举值分别来实现该方法</p><p>实例：<br>定义TimeInfo接口</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TimeInfo</span> &#123;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTimeInfo</span><span class="hljs-params">()</span>;&#125;</code></pre></div><p>修改Season2类</p><div class="code-wrapper"><pre><code class="hljs java">SPRING(<span class="hljs-string">&quot;春天&quot;</span>, <span class="hljs-string">&quot;春风又绿江南岸&quot;</span>)&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTimeInfo</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2-5&quot;</span>;        &#125;    &#125;,    SUMMER(<span class="hljs-string">&quot;夏天&quot;</span>, <span class="hljs-string">&quot;映日荷花别样红&quot;</span>) &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTimeInfo</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;5-8&quot;</span>;        &#125;    &#125;,    AUTUMN(<span class="hljs-string">&quot;秋天&quot;</span>, <span class="hljs-string">&quot;秋水共长天一色&quot;</span>) &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTimeInfo</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;8-11&quot;</span>;        &#125;    &#125;,    WINTER(<span class="hljs-string">&quot;冬天&quot;</span>, <span class="hljs-string">&quot;窗含西岭千秋雪&quot;</span>) &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTimeInfo</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;11-2&quot;</span>;        &#125;    &#125;;</code></pre></div><p>测试：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Season2 s :Season2.values())&#123;    System.out.println(s);    System.out.println(s.getTimeInfo());&#125;<span class="hljs-comment">/*输出：</span><span class="hljs-comment">SPRING</span><span class="hljs-comment">2-5</span><span class="hljs-comment">SUMMER</span><span class="hljs-comment">5-8</span><span class="hljs-comment">AUTUMN</span><span class="hljs-comment">8-11</span><span class="hljs-comment">WINTER</span><span class="hljs-comment">11-2</span><span class="hljs-comment">*/</span></code></pre></div><h3 id="枚举类的方法"><a href="#枚举类的方法" class="headerlink" title="枚举类的方法"></a>枚举类的方法</h3><p>使用一个字符串获取对应的枚举类对象，可以使用valueof 方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Season2</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Season2.valueOf(Season2.class,str);System.out.println(s.getName());</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>枚举</tag>
      
      <tag>enum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java异常</title>
    <link href="/Java/Java%E5%BC%82%E5%B8%B8/"/>
    <url>/Java/Java%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li><p>Error：JVM系统内部错误、资源耗尽等严重情况</p></li><li><p>Exception：其它因编程错误或偶然的外在因素导致的—般性问题,具体又分为RuntimeException、IOExeption等例如：</p></li></ol><ul><li>空指针访问</li><li>试图读取不存在的文件</li><li>网络连接中断</li></ul><h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><ol><li><p>ArithmeticException 数学异常</p></li><li><p>ArrayIndexOutOfBoundsException 数组越界异常</p></li><li><p>ClassCastException 类型转换异常</p></li><li><p>NullPointerException 空指针异常</p></li></ol><h3 id="Java异常处理机制"><a href="#Java异常处理机制" class="headerlink" title="Java异常处理机制"></a>Java异常处理机制</h3><p>Java采用异常处理机制，将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁，并易于维护。</p><p>Java采用<strong>抓抛模型</strong>，java程序运行过程将异常生成异常类对象并提交JVM，这个过程称之为<strong>抛出(throw)异常</strong>。  </p><p>如果一个方法内抛出异常，该异常会被抛到调用方法中。如果异常没有在调用方法中处理，它继续被抛给这个调用方法的调用者。这个过程将一直继续下去，直到异常被处理。这―过程称为<strong>捕获(catch)异常</strong>。</p><p>如果一个异常回到<code>main()</code>方法,并且<code>main()</code>也不处理，则程序运行终止。</p><p>异常处理是通过<code>try-catch-finally</code>语句实现的。</p><p>不论在<code>try-catch</code>代码块中是否发生了异常事件,<code>finally</code>块中的语句都会被执行。</p><p>用<code>finally</code>可以没有<code>catch</code></p><h4 id="声明抛出异常"><a href="#声明抛出异常" class="headerlink" title="声明抛出异常"></a>声明抛出异常</h4><ol><li>在Java中使用<code>throws</code>关键字声明抛出异常。</li><li><code>throws</code>方法抛出的异常可以是方法中出现的异常的类型或其父类类型。</li><li><code>throws</code>可以声明抛出多个异常，多个异常使用<code>,</code>分割。</li><li>运行时异常不需要使用<code>throws</code>关键字进行显式的抛出，而编译时异常一定要处理。</li><li>重写方法不能抛出比被重写方法范围更大的异常类型</li></ol><h4 id="人工抛出异常"><a href="#人工抛出异常" class="headerlink" title="人工抛出异常"></a>人工抛出异常</h4><p>创建一个异常类对象，在方法内部用<code>throw</code>关键字把异常类对象抛出去</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//1.创建一个异常类对象</span>        <span class="hljs-type">RuntimeException</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();        <span class="hljs-comment">//2.把异常类对象抛出去</span>        <span class="hljs-keyword">throw</span> ex;    &#125;</code></pre></div><h4 id="创建用户自定义异常类"><a href="#创建用户自定义异常类" class="headerlink" title="创建用户自定义异常类"></a>创建用户自定义异常类</h4><ol><li>用户自定义异常类通常继承自RuntimeException（也可以继承Exception）</li><li>自定义的异常类就是被人工抛出的</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异常</tag>
      
      <tag>Exception</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合</title>
    <link href="/Java/Java%E9%9B%86%E5%90%88/"/>
    <url>/Java/Java%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><p>目录：</p><ul><li><a href="#java%E9%9B%86%E5%90%88">Java集合</a><ul><li><a href="#collection">Collection</a><ul><li><a href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0">添加元素</a></li><li><a href="#%E8%AE%BF%E9%97%AE%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95">访问集合的方法</a></li><li><a href="#%E7%A7%BB%E9%99%A4%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0">移除集合中的元素</a></li><li><a href="#%E6%A3%80%E6%B5%8B%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95">检测集合的方法</a></li><li><a href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95">集合的其他方法</a></li></ul></li><li><a href="#set">Set</a><ul><li><a href="#hashset">HashSet</a></li><li><a href="#linkedhashset">LinkedHashSet</a></li><li><a href="#treeset">TreeSet</a><ul><li><a href="#%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F">自然排序</a></li><li><a href="#%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F">定制排序</a></li></ul></li></ul></li><li><a href="#list">List</a></li><li><a href="#map">Map</a><ul><li><a href="#hashmap">HashMap</a></li><li><a href="#hashtable">Hashtable</a></li><li><a href="#linkedhashmap">LinkedHashMap</a></li><li><a href="#treemap">TreeMap</a></li><li><a href="#properties">Properties</a></li></ul></li><li><a href="#collections-%E5%B7%A5%E5%85%B7%E7%B1%BB">Collections 工具类</a><ul><li><a href="#%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95">排序方法</a></li><li><a href="#%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%B3%95">查找&amp;替换方法</a></li><li><a href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95">同步控制方法</a></li></ul></li><li><a href="#enumeration">Enumeration</a></li></ul></li></ul><p>Java集合就像一种容器，可以把多个对象的引用放入容器中。  </p><p>Java集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。</p><p>Java集合可分为 Set、List 和 Map 三种体系</p><ul><li>Set：无序、不可重复的集合</li><li>List：有序、可重复的集合</li><li>Map：具有映射关系的集合</li></ul><p>在Java5之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成Object类型处理；从Java5增加了<strong>泛型</strong>以后，Java集合可以记住容器中对象的数据类型。</p><p><img src="/./img/javaAssemble.png" alt="JavaAssemble"></p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>创建一个Collection接口的对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Collection</span> <span class="hljs-variable">collection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();</code></pre></div><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><ol><li><code>add()</code>参数为要添加的元素对象 <div class="code-wrapper"><pre><code class="hljs java">collection.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>());</code></pre></div></li><li><code>addAll()</code>参数为要添加的集合对象 <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Collection</span> <span class="hljs-variable">collection2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();collection2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>());collection2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>());collection.addAll(collection2);</code></pre></div></li></ol><h4 id="访问集合的方法"><a href="#访问集合的方法" class="headerlink" title="访问集合的方法"></a>访问集合的方法</h4><ol><li><code>size()</code>获取集合长度 <div class="code-wrapper"><pre><code class="hljs java">System.out.println(collection.size());</code></pre></div></li><li><code>iterator()</code>对集合进行遍历，<code>iterator()</code>可以得到对应的<code>Iterator</code>对象。<br><code>Iterator</code>:迭代器<br>使用方法： <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取Iterator接口对象</span><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> collection.iterator();<span class="hljs-comment">//使用while循环和Iterator遍历集合的每一个元素。</span><span class="hljs-comment">//具体使用Iterator接口的hasNext()和next()方法。</span><span class="hljs-keyword">while</span> (iterator.hasNext())&#123;    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> iterator.next();    System.out.println(obj);&#125;</code></pre></div></li><li>使用增强for循环的方式来对集合进行遍历 <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Object obj: collection)&#123;    System.out.println(obj);&#125;</code></pre></div></li></ol><h4 id="移除集合中的元素"><a href="#移除集合中的元素" class="headerlink" title="移除集合中的元素"></a>移除集合中的元素</h4><ol><li><code>remove()</code>移除某一个指定的对象。通过<code>equals()</code>方法来判断要移除的那个元素在集合中是否存在，以及是否能够成功移除。参数为要移除的元素对象，返回是否成功的布尔值。   <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> collection.remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>());System.out.printIn(result);<span class="hljs-comment">//返回：false</span></code></pre></div></li><li><code>removeAll()</code>参数为要移除的元素集合对象。 <div class="code-wrapper"><pre><code class="hljs java">    <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> collection.removeAll(collection2);    System.out.printIn(result);<span class="hljs-number">3.</span> `clear()`使集合元素置空。   ```java   collection.clear()</code></pre></div></li></ol><h4 id="检测集合的方法"><a href="#检测集合的方法" class="headerlink" title="检测集合的方法"></a>检测集合的方法</h4><ol><li><code>contains()</code>检测集合是否包含某一元素<div class="code-wrapper"><pre><code class="hljs java">System.out.println(collection.contains(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()));<span class="hljs-comment">//返回：false</span></code></pre></div></li><li><code>containsAll()</code>检测集合是否包含某一元素集合<div class="code-wrapper"><pre><code class="hljs java">System.out.println(collection.containsAll(collection2));</code></pre></div></li><li><code>isEmpty()</code>检测集合是否为空<div class="code-wrapper"><pre><code class="hljs java">System.out.println(collection.isEmpty());<span class="hljs-comment">//false</span>collection.clear();System.out.println(collection.isEmpty());<span class="hljs-comment">//true</span></code></pre></div></li></ol><h4 id="集合的其他方法"><a href="#集合的其他方法" class="headerlink" title="集合的其他方法"></a>集合的其他方法</h4><ol><li><code>toArry()</code> <div class="code-wrapper"><pre><code class="hljs java">Object [] objects = collection.toArray();System.out.println(objects.length);</code></pre></div></li><li><code>toArry(T[])</code>涉及泛型</li><li><code>equals()</code>比较两集合是否相等<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//有序集合</span><span class="hljs-type">Collection</span> <span class="hljs-variable">collection3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();collection3.add(p1);collection3.add(p2);<span class="hljs-type">Collection</span> <span class="hljs-variable">collection4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();collection4.add(p2);collection4.add(p1);System.out.println(collection3.equals(collection4));<span class="hljs-comment">//返回false</span><span class="hljs-comment">//无序集合</span><span class="hljs-type">Collection</span> <span class="hljs-variable">collection3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();collection3.add(p1);collection3.add(p2);<span class="hljs-type">Collection</span> <span class="hljs-variable">collection4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();collection4.add(p2);collection4.add(p1);System.out.println(collection3.equals(collection4));<span class="hljs-comment">//返回true</span></code></pre></div></li><li><code>hasCode()</code></li><li>使用增强for循环的方式来对集合进行遍历<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Object obj : collection) &#123;    System.out.println(obj);    &#125;</code></pre></div></li></ol><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ol><li>Set是 Collection 的子接口</li><li>Set中不允许存放相同的元素。</li><li>判定相同元素的标准是，两个对象<strong>各</strong>调用<code>equals()</code>方法，返回<code>true</code>。</li></ol><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>HashSet是Set接口的典型实现。</p><p>基本特征：</p><ol><li>不能保证元素的排列顺序（无序）</li><li>HashSet 不是线程安全的</li><li>集合元素可以使<code>null</code><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Set</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();set.add(<span class="hljs-literal">null</span>);System.out.println(set.size());<span class="hljs-comment">//输出1</span></code></pre></div></li><li>对于 HashSet：如果两个对象通过<code>equals()</code>方法返回 true，这两个对象的 hashCode 值也应该相同。<div class="code-wrapper"><pre><code class="hljs java">set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;xx&quot;</span>,<span class="hljs-number">12</span>));set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;xx&quot;</span>,<span class="hljs-number">12</span>));System.out.println(set.size());<span class="hljs-comment">//正常情况下输出4，两个对象不相同</span><span class="hljs-comment">//在Person类中重写equals方法和hashcode方法</span><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) o;     <span class="hljs-keyword">return</span> age == person.age &amp;&amp; name.equals(person.name);&#125;<span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;     <span class="hljs-keyword">return</span> Objects.hash(name, age);&#125;<span class="hljs-comment">//重写后返回3</span></code></pre></div></li><li>由根据元素自身属性计算的 hashCode 决定位置，所以可重写hashCode实现重复（不推荐）和有序类似 LinkedHashSet<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//在Person类中重写hashCode方法</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">return</span> init++;&#125;</code></pre></div></li></ol><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ol><li>LinkedHashSet 是 HashSet 的子类</li><li>使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的，也因此性能稍弱</li><li>LinkedHashset 不允许集合元素重复</li><li>重写类的<code>hashCode()</code>方法也可以在 HashSet 实现序列化</li></ol><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态</p><h5 id="自然排序"><a href="#自然排序" class="headerlink" title="自然排序"></a>自然排序</h5><p>TreeSet 会调用集合元素的<code>compareTo(Object obj)</code>方法来比较元素之间的大小关系，然后将集合元素按升序排列如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。</p><p>实现 Comparable 的类必须实现<code>compareTo(Object obj)</code>方法，两个对象即通过<code>compareTo(Object obj)</code>方法的返回值来比较大小，返回值类型为int，正数表示当前元素大，负数表示参数元素大，返回0代表两元素相等。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//实现Comparable接口</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Students</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span> &#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> score;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Students</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> score)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.score = score;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> score;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setScore</span><span class="hljs-params">(<span class="hljs-type">int</span> score)</span> &#123;        <span class="hljs-built_in">this</span>.score = score;    &#125;&#125;</code></pre></div><ol><li><p>因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是<strong>同一个类</strong>的对象，否则可能发生类型转换异常。</p></li><li><p>当需要把一个对象放入 TreeSet 中,重写该对象对应的<code>equals()</code>方法时，应保证该方法与<code>compareTo(Object obj)</code>方法有一致的结果：如果两个对象通过<code>equals()</code>方法比较返回<code>true</code>，则通过<code>compareTo(Object obj)</code>方法比较应返回<code>0</code>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;     <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Students) &#123;         <span class="hljs-type">Students</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> (Students) o;         <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.score - stu.score;<span class="hljs-comment">//分数升序排</span>         <span class="hljs-keyword">return</span> - <span class="hljs-built_in">this</span>.score + stu.score;<span class="hljs-comment">//分数降序排</span>         <span class="hljs-comment">//return -this.name.compareTo(stu.name);//按name字母顺序降序排</span>     &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassCastException</span>(<span class="hljs-string">&quot;不是一个Student对象&quot;</span>);     &#125; &#125;</code></pre></div></li></ol><h5 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h5><p>创建 TreeSet 对象时，传入 Comparator 的接口实现类。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Comparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;        <span class="hljs-keyword">if</span> (o1 <span class="hljs-keyword">instanceof</span> Person &amp;&amp; oinstanceof Person) &#123;            <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> (Person) o1;            <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> (Person) o2;            <span class="hljs-keyword">return</span> -p1.getAge() + p2.getAge;<span class="hljs-comment">//年龄降序</span>        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassCastException</span>(<span class="hljs-string">&quot;不能转为 Person&quot;</span>);        &#125;    &#125;&#125;;<span class="hljs-type">Set</span> <span class="hljs-variable">set1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(comparator);set1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-number">12</span>));set1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-number">15</span>));set1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-number">9</span>));set1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-number">16</span>));<span class="hljs-keyword">for</span> (Object p : set1) &#123;    System.out.println(p);&#125;<span class="hljs-comment">//输出：</span><span class="hljs-comment">//Person&#123;name=&#x27;AA&#x27;, age=16&#125;</span><span class="hljs-comment">//Person&#123;name=&#x27;AA&#x27;, age=15&#125;</span><span class="hljs-comment">//Person&#123;name=&#x27;AA&#x27;, age=12&#125;</span><span class="hljs-comment">///Person&#123;name=&#x27;AA&#x27;, age=9&#125;</span></code></pre></div><p>这样Person就不需要实现<code>compareTo</code>接口<br>要求：Comparator 接口的<code>compare()</code>方法的返回值和两个元素的<code>equals()</code>要一致。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ol><li>List 代表一个元素有序、且可重复的集合，集合中的每个元素都有其对应的顺序索引。</li><li>List 允许使用重复元素，可以通过索引来访间指定位置的集合元素。</li><li>List 默认按元素的添加顺序设置元素的索引。</li></ol><p>方法：</p><div class="code-wrapper"><pre><code class="hljs java">- <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Objed ele)</span><span class="hljs-comment">//将元素插入到指定位置</span>- <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection eles)</span><span class="hljs-comment">//将集合插入到指定位置</span>- Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span><span class="hljs-comment">//获取指定位置的对象</span>- <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Objed obj)</span><span class="hljs-comment">//获取指定元素的索引，用equals方法判定，重复元素取第一个。</span>- <span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexOf</span><span class="hljs-params">(Objed obj)</span><span class="hljs-comment">//重复元素取最后一个</span>- Object <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span><span class="hljs-comment">//移除指定位置的对象</span>- Object <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index,Objed ele)</span> <span class="hljs-comment">//替换指定位置元素</span>- List <span class="hljs-title function_">subList</span><span class="hljs-params">(<span class="hljs-type">int</span> fromlndex, <span class="hljs-type">int</span> tolndex)</span> <span class="hljs-comment">//取区间内元素，前闭后开</span><span class="hljs-type">List</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> list.subList(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<span class="hljs-comment">//2,3,4</span><span class="hljs-keyword">for</span> (Object obj : list2) &#123;    System.out.println(obj);&#125;</code></pre></div><p>List额外提供了一个listIterator()方法，该方法返回一个ListLterator对象，Listerator接口继承了Iterator接口，提供了专门操作List的方法：</p><div class="code-wrapper"><pre><code class="hljs java">- <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPrevious</span><span class="hljs-params">()</span>- Object <span class="hljs-title function_">previous</span><span class="hljs-params">()</span>- <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span></code></pre></div><p>ArrayList是List接口的典型实现</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();</code></pre></div><p>遍历：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//使用Iterator</span><span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> list.iterator();<span class="hljs-keyword">while</span> (it.hasNext()) &#123;    System.out.println(it.next());&#125;<span class="hljs-comment">//使用增强for循环</span><span class="hljs-keyword">for</span> (Object o : list) &#123;    System.out.println(o);&#125;<span class="hljs-comment">//使用for循环和List的get(int)方法</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;    System.out.println(list.get(i));&#125;<span class="hljs-comment">//使用ListIterator</span><span class="hljs-type">ListIterator</span> <span class="hljs-variable">lit</span> <span class="hljs-operator">=</span> list.listIterator();<span class="hljs-keyword">while</span> (lit.hasNext()) &#123;    System.out.println(lit.next());&#125;</code></pre></div><p>Vector也是List接口的远古典型实现，虽然线程安全但是不推荐使用。</p><p>Arrays.asList(…)方法返回的 List 集合既不是 ArrayList实例，也不是Vector实例。Arrays.asL.ist(…)返回值是一个固定长度的 List集合。</p><div class="code-wrapper"><pre><code class="hljs java">System.out.println(Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;MM&quot;</span>,<span class="hljs-number">23</span>),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;NN&quot;</span>,<span class="hljs-number">22</span>)));<span class="hljs-comment">//[Person&#123;name=&#x27;MM&#x27;, age=23&#125;, Person&#123;name=&#x27;NN&#x27;, age=22&#125;]</span></code></pre></div><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>Map用于保存具有映射关系的数据，因此Map集合里保存着两组值，一组值用于保存Map里的 Key，另外一组用于保存Map里的Value。</li><li>Map中的 key 和 value 都可以是任何引用类型的数据</li><li><strong>Map中的 Key 不允许重复</strong>，即同一个Map对象的任何两个Key通过equals方法比较中返回false</li><li>Key和 Value之间存在单向一对一关系，即通过指定的Key总能找到唯一的，确定的Value。</li></ul><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap是Map接口的典型实现</p><div class="code-wrapper"><pre><code class="hljs java">Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();</code></pre></div><p>常用方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.添加元素</span>map.put(<span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-number">12</span>));<span class="hljs-comment">//被覆盖</span>map.put(<span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-number">12</span>));map.put(<span class="hljs-string">&quot;CC&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;CCC&quot;</span>, <span class="hljs-number">12</span>));map.put(<span class="hljs-string">&quot;MM&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;MMM&quot;</span>, <span class="hljs-number">12</span>));map.put(<span class="hljs-string">&quot;DD&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;DDD&quot;</span>, <span class="hljs-number">12</span>));<span class="hljs-comment">//2.取出元素（遍历）</span><span class="hljs-comment">//2.1得到键的集合，再利用键得到值</span><span class="hljs-type">Set</span> <span class="hljs-variable">keySet</span> <span class="hljs-operator">=</span> map.keySet();<span class="hljs-keyword">for</span> (Object key : keySet) &#123;    System.out.println(key + <span class="hljs-string">&quot;: &quot;</span> + map.get(key));&#125;<span class="hljs-comment">//2.2直接得到value的集合</span><span class="hljs-type">Collection</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> map.values();System.out.println(values.getClass());<span class="hljs-keyword">for</span> (Object val : values) &#123;    System.out.println(val);&#125;<span class="hljs-comment">//2.3得到键值对的集合</span><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();    <span class="hljs-type">Object</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> entry.getValue();    System.out.println(key + <span class="hljs-string">&quot;: &quot;</span> + val);&#125;<span class="hljs-comment">//3.移除元素</span>map.remove(<span class="hljs-string">&quot;AA&quot;</span>);<span class="hljs-comment">//4.工具方法</span>System.out.println(map.size());<span class="hljs-comment">//3</span>System.out.println(map);<span class="hljs-comment">//contains(); isEmpty()</span>System.out.println(map.containsKey(<span class="hljs-string">&quot;CC&quot;</span>));<span class="hljs-comment">//true</span>System.out.println(map.isEmpty());<span class="hljs-comment">//false</span></code></pre></div><p>HashMap和HashSet：<a href="#hashset">HashSet</a> 是由HashMap定义的</p><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p>HashMap是Map接口的古老典型实现，不建议使用<br>Hashtable不允许使用null 作为key和 value，而 HashMap可以</p><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>LinkedHashMap 是 HashMap 的子类<br>LinkedHashMap可以维护 Map 的迭代顺序:迭代顺序与Key-Value对的插入顺序一致<br><a href="#linkedhashset">LinkedHashSet</a> 是由 LinkedHashMap 定义的</p><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap存储Key-Value 对时，需要根据Key对key-value 对进行排序。TreeMap可以保证所有<br>的Key-Value对处于有序状态。<br>方法参考 <a href="#treeset">TreeSet</a></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Comparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span>&#123;        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> (Person) o1;        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> (Person) o2;        <span class="hljs-keyword">return</span> p1.getAge() - p2.getAge();<span class="hljs-comment">//增序</span>    &#125;&#125;;<span class="hljs-comment">//注意要传入comparator参数，只能对key进行排序</span><span class="hljs-type">TreeMap</span> <span class="hljs-variable">tm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>(comparator);tm.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-number">12</span>), <span class="hljs-string">&quot;AAA&quot;</span>);tm.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;BB&quot;</span>, <span class="hljs-number">32</span>), <span class="hljs-string">&quot;AAA&quot;</span>);tm.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;CC&quot;</span>, <span class="hljs-number">25</span>), <span class="hljs-string">&quot;AAA&quot;</span>);tm.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;DD&quot;</span>, <span class="hljs-number">22</span>), <span class="hljs-string">&quot;AAA&quot;</span>);<span class="hljs-comment">//遍历</span>keySet = tm.keySet();<span class="hljs-keyword">for</span> (Object key : keySet) &#123;    <span class="hljs-type">Object</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> tm.get(key);    System.out.println(key + <span class="hljs-string">&quot;：&quot;</span> + val);&#125;<span class="hljs-comment">/*输出</span><span class="hljs-comment">Person [name=&#x27;AA&#x27;, age=12]：AAA</span><span class="hljs-comment">Person [name=&#x27;DD&#x27;, age=22]：AAA</span><span class="hljs-comment">Person [name=&#x27;CC&#x27;, age=25]：AAA</span><span class="hljs-comment">Person [name=&#x27;BB&#x27;, age=32]：AAA</span><span class="hljs-comment">*/</span></code></pre></div><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><p>Properties类是Hashtable的子类，该对象用于处理属性文件<br>由于属性文件里的key、value都是字符串类型，所以properties里的 Key和 Value都是字符串类型的</p><p>properties文件在Java中对一个的是一个 Properties类的对象</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql:///test</span><span class="hljs-attr">driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-attr">user</span>=<span class="hljs-string">root</span><span class="hljs-attr">password</span>=<span class="hljs-string">964538</span></code></pre></div><p>方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1。创建一个Properties类的对象</span><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<span class="hljs-comment">//2，使用 IO 流加载对应的properties文件，注意抛异常</span>properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jdbproperties&quot;</span>));<span class="hljs-comment">//3．得到对应的属性值</span><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;url&quot;</span>);System.out.println(url);<span class="hljs-comment">//输出：jdbc:mysql:///test</span></code></pre></div><h3 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h3><p>Collections是一个操作Set、List和 Map等集合的工具类</p><h4 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h4><div class="code-wrapper"><pre><code class="hljs java">reverse(List)<span class="hljs-comment">//反转List中元素的顺序</span>shuffle(List)<span class="hljs-comment">//对List集合元素进行随机排序</span>sort(List)<span class="hljs-comment">//根据元素的自然顺序对指定List集合元秦按升序排序</span>sort(List , Comparator):<span class="hljs-comment">//根据指定的Comparator产生的顺序对List集合元秦进行排序</span>swap(List , <span class="hljs-type">int</span> , <span class="hljs-type">int</span>)<span class="hljs-comment">//将指定list集合中的i处元素和j处元秦进行交换</span></code></pre></div><p>实例：</p><p>根据指定的Comparator产生的顺序对List集合元秦进行排序</p><div class="code-wrapper"><pre><code class="hljs java">Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> (Person) o1;        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> (Person) o2;        <span class="hljs-keyword">return</span> p1.getAge() - p2.getAge();    &#125;&#125;);</code></pre></div><h4 id="查找-替换方法"><a href="#查找-替换方法" class="headerlink" title="查找&amp;替换方法"></a>查找&amp;替换方法</h4><div class="code-wrapper"><pre><code class="hljs java">Object <span class="hljs-title function_">max</span><span class="hljs-params">(Collection)</span><span class="hljs-comment">//根据元素的自然顺序,返回给定集合中的最大元素</span>Object <span class="hljs-title function_">max</span><span class="hljs-params">(Collection , Comparator)</span><span class="hljs-comment">//根据Comparator指定的顺序,返回给定集合中的最大元素</span>Object <span class="hljs-title function_">min</span><span class="hljs-params">(Collection)</span>Object <span class="hljs-title function_">min</span><span class="hljs-params">(Collection , Comparator)</span><span class="hljs-type">int</span> <span class="hljs-title function_">frequency</span><span class="hljs-params">(Collection , Object)</span><span class="hljs-comment">//返回指疋集合甲指疋兀素的出现次数</span><span class="hljs-type">boolean</span> <span class="hljs-title function_">replaceAll</span><span class="hljs-params">(List list , Object oldVal , Object newVal)</span><span class="hljs-comment">//使用新值替换List对象的所有旧值</span></code></pre></div><p>实例：</p><p>根据Comparator指定的顺序,返回给定集合中的最大元素</p><div class="code-wrapper"><pre><code class="hljs java">System.out.println(Collections.max(list,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> (Person) o1;        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> (Person) o2;        <span class="hljs-keyword">return</span> p1.getAge() - p2.getAge();    &#125;&#125;));</code></pre></div><h4 id="同步控制方法"><a href="#同步控制方法" class="headerlink" title="同步控制方法"></a>同步控制方法</h4><p>使用 synchronizedList(),将参数里的集合变成线程安全的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取线程安全的List 对象，使用 synchronizedList()</span><span class="hljs-type">List</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> Collections.synchronizedList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());</code></pre></div><h3 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h3><p>Enumeration 接口是lterator迭代器的“古老版本”</p><p>实例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//对Enumeration对象进行遍历 hasMoreElements() nextElement()</span><span class="hljs-type">Enumeration</span> <span class="hljs-variable">names</span> <span class="hljs-operator">=</span> Collections.enumerati(list);<span class="hljs-keyword">while</span> (names.hasMoreElements())&#123;    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> names.nextElement();    System.out.println(obj);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
      <tag>Collection</tag>
      
      <tag>Set</tag>
      
      <tag>TreeSet</tag>
      
      <tag>List</tag>
      
      <tag>Map</tag>
      
      <tag>HashMap</tag>
      
      <tag>HashTable</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java泛型</title>
    <link href="/Java/Java%E6%B3%9B%E5%9E%8B/"/>
    <url>/Java/Java%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h1><ul><li><a href="#java%E6%B3%9B%E5%9E%8B">Java泛型</a><ul><li><a href="#%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B">在集合中使用泛型</a></li><li><a href="#%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95%E7%9A%84%E6%B3%9B%E5%9E%8B">定义简单的泛型</a></li><li><a href="#%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF">泛型和子类继承</a><ul><li><a href="#%E9%80%9A%E9%85%8D%E7%AC%A6">通配符</a></li></ul></li><li><a href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">泛型方法</a></li></ul></li></ul><h3 id="在集合中使用泛型"><a href="#在集合中使用泛型" class="headerlink" title="在集合中使用泛型"></a>在集合中使用泛型</h3><p>对于集合没有泛型的情况:</p><ol><li>放入集合中的对象可以是任意类型.</li><li>获取元素后，需进行类型的强制转换。</li></ol><p>如下所示：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">persons</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<span class="hljs-comment">//放入集合中的对象可以是任意类型</span>persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;AA&quot;</span>,<span class="hljs-number">12</span>));persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;BB&quot;</span>,<span class="hljs-number">13</span>));persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;CC&quot;</span>,<span class="hljs-number">14</span>));persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;DD&quot;</span>,<span class="hljs-number">15</span>));persons.add(<span class="hljs-string">&quot;person&quot;</span>);<span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> persons.get(<span class="hljs-number">0</span>)<span class="hljs-comment">//获取元素后，需进行类型的强制转换</span><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) persons.get(<span class="hljs-number">1</span>);<span class="hljs-comment">//这里遍历会出现类型转换异常</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;persons.size();i++)&#123;    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) persons.get(i);    System.out.println(person);&#125;</code></pre></div><p>使用泛型之后，<code>List&lt;Person&gt;</code>是一个带一个类型参数的泛型接口</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Person&gt; persons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//只能放类型为Person的类</span>persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-number">12</span>));persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;BB&quot;</span>, <span class="hljs-number">13</span>));persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;CC&quot;</span>, <span class="hljs-number">14</span>));persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;DD&quot;</span>, <span class="hljs-number">15</span>));<span class="hljs-comment">//遍历时不用类型转换</span><span class="hljs-keyword">for</span> (Person person : persons) &#123;    System.out.println(person);&#125;<span class="hljs-comment">//告诉返回类型为person</span>Person[] personArray = persons.toArray(Person[<span class="hljs-number">0</span>]);System.out.println(personArray.length);<span class="hljs-comment">//4</span></code></pre></div><p>Map使用泛型</p><div class="code-wrapper"><pre><code class="hljs java">Map&lt;String, Person&gt; personMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;();personMap.put(<span class="hljs-string">&quot;AA&quot;</span>, persons.get(<span class="hljs-number">0</span>));personMap.put(<span class="hljs-string">&quot;BB&quot;</span>, persons.get(<span class="hljs-number">1</span>));personMap.put(<span class="hljs-string">&quot;CC&quot;</span>, persons.get(<span class="hljs-number">2</span>));personMap.put(<span class="hljs-string">&quot;DD&quot;</span>, persons.get(<span class="hljs-number">3</span>));<span class="hljs-keyword">for</span> (Map.Entry&lt;String, Person&gt; entry : personMap.entrySet()) &#123;    System.out.println(entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());&#125;</code></pre></div><h3 id="定义简单的泛型"><a href="#定义简单的泛型" class="headerlink" title="定义简单的泛型"></a>定义简单的泛型</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//在声明类的同时声明泛型类型，T为形参，一般为单个大写字母</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DAO</span>&lt;T&gt; &#123;    <span class="hljs-comment">//方法的返回值可以使用前面声明的泛型类型</span>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(Integer id)</span>&#123;        <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-comment">//方法的参数也可以使用声明类时声明的泛型类型.</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(T entity)</span>&#123;    &#125;&#125;</code></pre></div><p>类型参数在整个类的声明中可用，几乎是所有可以使用其他普通类型的地方</p><p>使用：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//传入实参Person</span>DAO&lt;Person&gt; dao = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DAO</span>&lt;&gt;();<span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> dao.get(<span class="hljs-number">10</span>);dao.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>());</code></pre></div><h3 id="泛型和子类继承"><a href="#泛型和子类继承" class="headerlink" title="泛型和子类继承"></a>泛型和子类继承</h3><p>String 为 Object 类型的子类，则String[] 也是Object[] 的子类。</p><div class="code-wrapper"><pre><code class="hljs java">Object [] objects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;AA&quot;</span>,<span class="hljs-string">&quot;BB&quot;</span>&#125;;</code></pre></div><p>String 为 Object 类型的子类，而<code>List&lt;String&gt;</code>不是<code>List&lt;Object&gt;</code>的子类！</p><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>实例：</p><div class="code-wrapper"><pre><code class="hljs java">Collection&lt;?&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<span class="hljs-comment">//可以正常取，但不能放入任何对象，除了null </span>c.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<span class="hljs-comment">//编译错误</span>c.add(<span class="hljs-literal">null</span>);<span class="hljs-comment">//只能放null</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//工具方法，打印Person信息</span><span class="hljs-comment">//List&lt;? extends Person代表可以放入所有Person的子类</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printPersonInfo</span><span class="hljs-params">(List&lt;?&gt; extends Person&gt; persons)</span> &#123;    <span class="hljs-comment">//不能放，只能取</span>    <span class="hljs-keyword">for</span> (Person person : persons) &#123;        System.out.println(person);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    List&lt;Student&gt; stus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    stus.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;BB&quot;</span>,<span class="hljs-number">22</span>,<span class="hljs-string">&quot;NIIT&quot;</span>));    printPersonInfo(stus);    List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    personList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;AA&quot;</span>,<span class="hljs-number">12</span>));    printPersonInfo(personList);&#125;<span class="hljs-comment">//输出：</span><span class="hljs-comment">//Person [name=&#x27;BB&#x27;, age=22, school=NIIT]</span><span class="hljs-comment">//Person [name=&#x27;AA&#x27;, age=12]</span></code></pre></div><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法:在方法声明时，同时声明泛型。在方法的返回值，参数列表以及方法体中都可以使用泛型类型.</p><p>实例：<br>把指定类型的数组中的元素放入到指定类型的集合中</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">fromArrayToCollection</span><span class="hljs-params">(T[] objs, Collection&lt;T&gt; coll)</span>&#123;        &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;            String [] objs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;AA&quot;</span>,<span class="hljs-string">&quot;BB&quot;</span>,<span class="hljs-string">&quot;CC&quot;</span>&#125;;    Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    fromArrayToCollection(objs,coll);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>泛型</tag>
      
      <tag>Generic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python实用脚本收集</title>
    <link href="/Python/PythonScripts/"/>
    <url>/Python/PythonScripts/</url>
    
    <content type="html"><![CDATA[<h1 id="python实用脚本收集"><a href="#python实用脚本收集" class="headerlink" title="python实用脚本收集"></a>python实用脚本收集</h1><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p>BUG:部分图片压缩后体积反而变大</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<span class="hljs-keyword">import</span> os<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_size</span>(<span class="hljs-params">file</span>):    <span class="hljs-comment"># 获取文件大小:KB</span>    size = os.path.getsize(file)    <span class="hljs-keyword">return</span> size / <span class="hljs-number">1024</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_outfile</span>(<span class="hljs-params">infile, outfile</span>):    <span class="hljs-keyword">if</span> outfile:        <span class="hljs-keyword">return</span> outfile    <span class="hljs-built_in">dir</span>, suffix = os.path.splitext(infile)    outfile = <span class="hljs-string">&#x27;&#123;&#125;-out&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">dir</span>, suffix)    <span class="hljs-keyword">return</span> outfile<span class="hljs-keyword">def</span> <span class="hljs-title function_">compress_image</span>(<span class="hljs-params">infile, outfile=<span class="hljs-string">&#x27;&#x27;</span>, mb=<span class="hljs-number">400</span>, step=<span class="hljs-number">10</span>, quality=<span class="hljs-number">90</span></span>):    <span class="hljs-string">&quot;&quot;&quot;不改变图片尺寸压缩到指定大小</span><span class="hljs-string">    :param infile: 压缩源文件</span><span class="hljs-string">    :param outfile: 压缩文件保存地址</span><span class="hljs-string">    :param mb: 压缩目标，KB</span><span class="hljs-string">    :param step: 每次调整的压缩比率</span><span class="hljs-string">    :param quality: 初始压缩比率</span><span class="hljs-string">    :return: 压缩文件地址，压缩文件大小</span><span class="hljs-string">    &quot;&quot;&quot;</span>    o_size = get_size(infile)    <span class="hljs-keyword">if</span> o_size &lt;= mb:        <span class="hljs-keyword">return</span> infile    outfile = get_outfile(infile, outfile)    <span class="hljs-keyword">while</span> o_size &gt; mb:        im = Image.<span class="hljs-built_in">open</span>(infile)        im.save(outfile, quality=quality)        <span class="hljs-keyword">if</span> quality - step &lt; <span class="hljs-number">0</span>:            <span class="hljs-keyword">break</span>        quality -= step        o_size = get_size(outfile)    <span class="hljs-keyword">return</span> outfile, get_size(outfile)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">resize_image</span>(<span class="hljs-params">infile, outfile=<span class="hljs-string">&#x27;&#x27;</span>, x_s=<span class="hljs-number">1376</span></span>):    <span class="hljs-string">&quot;&quot;&quot;修改图片尺寸</span><span class="hljs-string">    :param infile: 图片源文件</span><span class="hljs-string">    :param outfile: 重设尺寸文件保存地址</span><span class="hljs-string">    :param x_s: 设置的宽度</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    im = Image.<span class="hljs-built_in">open</span>(infile)    x, y = im.size    y_s = <span class="hljs-built_in">int</span>(y * x_s / x)    out = im.resize((x_s, y_s), Image.ANTIALIAS)    outfile = get_outfile(infile, outfile)    out.save(outfile)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    <span class="hljs-comment"># 这里填写图片的路径和输出路径</span>    compress_image(<span class="hljs-string">r&quot;E:\download\yorick.love.png&quot;</span>)   <span class="hljs-comment">#resize_image(r&#x27;D:\learn\space.jpg&#x27;)</span></code></pre></div><h2 id="QQ-TimOCR转md表格"><a href="#QQ-TimOCR转md表格" class="headerlink" title="QQ&#x2F;TimOCR转md表格"></a>QQ&#x2F;TimOCR转md表格</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 将表格内容的QCR文本结果还原为Markdown文档的表格格式</span><span class="hljs-comment"># 暂不支持空单元格</span><span class="hljs-comment"># 使用方法：</span><span class="hljs-comment"># 1. 运行脚本</span><span class="hljs-comment"># 2. 用QQ/Tim的OCR识别表格内容并复制</span><span class="hljs-comment"># 3. 按下快捷键 shift+alt+表格列数（2~4）</span><span class="hljs-comment"># 4. 粘贴文本</span><span class="hljs-keyword">import</span> pyperclip, keyboard<span class="hljs-keyword">def</span> <span class="hljs-title function_">formatTable</span>(<span class="hljs-params">columnNum</span>):    <span class="hljs-comment"># 获取剪贴板内容</span>    raw = pyperclip.paste()    <span class="hljs-comment"># 按行分割</span>    raw = raw.replace(<span class="hljs-string">&quot;\r&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)    rawLine = raw.split(<span class="hljs-string">&quot;\n&quot;</span>)    <span class="hljs-comment"># 接受结果</span>    tableLine = []    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(rawLine)):        <span class="hljs-comment"># 加入制表符</span>        <span class="hljs-keyword">if</span> i == columnNum:            tableLine.append(columnNum * <span class="hljs-string">&quot;|---&quot;</span> + <span class="hljs-string">&quot;|\n&quot;</span>)        <span class="hljs-keyword">if</span> i % columnNum == <span class="hljs-number">0</span>:            <span class="hljs-comment"># 如果是第一列</span>            tableLine.append(<span class="hljs-string">&quot;|&quot;</span> + rawLine[i] + <span class="hljs-string">&quot;|&quot;</span>)        <span class="hljs-keyword">elif</span> i % columnNum == columnNum - <span class="hljs-number">1</span>:            <span class="hljs-comment"># 如果是最后一列</span>            tableLine.append(rawLine[i] + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span>)        <span class="hljs-keyword">else</span>:            <span class="hljs-comment"># 普通列</span>            tableLine.append(rawLine[i] + <span class="hljs-string">&quot;|&quot;</span>)    <span class="hljs-comment"># print(&quot;&quot;.join(tableLine))</span>    <span class="hljs-comment"># 写入剪切板</span>    pyperclip.copy(<span class="hljs-string">&quot;&quot;</span>.join(tableLine))<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    keyboard.add_hotkey(<span class="hljs-string">&quot;shift+alt+2&quot;</span>, formatTable, args=(<span class="hljs-number">2</span>,))    keyboard.add_hotkey(<span class="hljs-string">&quot;shift+alt+3&quot;</span>, formatTable, args=(<span class="hljs-number">3</span>,))    keyboard.add_hotkey(<span class="hljs-string">&quot;shift+alt+4&quot;</span>, formatTable, args=(<span class="hljs-number">4</span>,))    keyboard.record(<span class="hljs-string">&quot;shift+alt+1&quot;</span>)</code></pre></div><h2 id="hexo博客格式化"><a href="#hexo博客格式化" class="headerlink" title="hexo博客格式化"></a>hexo博客格式化</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 将任意路径下的所有md文档格式化为Hexo博客并转移到Hexo目录下，同时转移图片文件</span><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> re<span class="hljs-keyword">import</span> datetime<span class="hljs-comment"># md文档路径</span>md_path = <span class="hljs-string">r&quot;C:\Users\yurui\Desktop\Coding_Note\python_note&quot;</span><span class="hljs-comment"># 获取文档名的正则表达式，例如“24_Python脚本.md”，提取后为Python脚本</span>re_file_name = <span class="hljs-string">r&quot;[0-9]*_(.+?).md&quot;</span><span class="hljs-comment"># 获取文档内容中图片路径的表达式</span>re_img_name = <span class="hljs-string">r&quot;!\[.*\]\((.+?)\)&quot;</span><span class="hljs-comment"># 博客首页图默认路径</span>img_default_url = <span class="hljs-string">r&quot;/img/default.png&quot;</span><span class="hljs-comment"># 定义默认分类</span>categories = <span class="hljs-string">&quot;Python&quot;</span><span class="hljs-comment"># 博客路径</span>post_url = <span class="hljs-string">r&quot;D:\Blog\source\_posts&quot;</span><span class="hljs-comment"># 前缀</span>prefix = <span class="hljs-string">&quot;Python&quot;</span><span class="hljs-comment"># 获取md文档并格式化</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">format</span>(<span class="hljs-params">md_path</span>):    <span class="hljs-comment"># 得到文件夹下的所有文件名称，返回列表</span>    files = os.listdir(md_path)    <span class="hljs-comment"># 遍历每个文件</span>    <span class="hljs-keyword">for</span> file_name <span class="hljs-keyword">in</span> files:        <span class="hljs-comment"># 保存博客头信息</span>        heads_list = [            <span class="hljs-string">&quot;---\n&quot;</span>,            <span class="hljs-string">&quot;title: &#123;title&#125;\n&quot;</span>,            <span class="hljs-string">&quot;index_img: &#123;img_path&#125;\n&quot;</span>,            <span class="hljs-string">&quot;categories: \n&quot;</span>,            <span class="hljs-string">&quot;  - &#123;categories&#125;\n&quot;</span>,            <span class="hljs-string">&quot;date: &#123;time&#125;\n&quot;</span>,            <span class="hljs-string">&quot;tags: \n&quot;</span>,            <span class="hljs-string">&quot;  - \n&quot;</span>,            <span class="hljs-string">&quot;sticky: \n&quot;</span>,            <span class="hljs-string">&quot;---\n&quot;</span>,        ]        <span class="hljs-comment"># 获取文件绝对路径</span>        file_path = md_path + <span class="hljs-string">&quot;/&quot;</span> + file_name        <span class="hljs-comment"># 判断是否是文件</span>        <span class="hljs-keyword">if</span> os.path.isfile(file_path) <span class="hljs-keyword">and</span> file_name.split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;md&quot;</span>:            <span class="hljs-comment"># 获取blog名称</span>            blog_name = re.findall(re_file_name, file_name)            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(blog_name) == <span class="hljs-number">1</span>:                blog_name = blog_name[<span class="hljs-number">0</span>]            <span class="hljs-keyword">else</span>:                blog_name = file_name.split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">0</span>]            <span class="hljs-comment"># 获取blog首图</span>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:                <span class="hljs-comment"># 获取文件全部内容</span>                content = f.read()                <span class="hljs-comment"># 正则匹配</span>                img_url = re.findall(re_img_name, content)                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(img_url) &gt; <span class="hljs-number">0</span>:                    img_url = img_url[<span class="hljs-number">0</span>]                <span class="hljs-keyword">else</span>:                    img_url = img_default_url            <span class="hljs-comment"># 将assets替换为img</span>            img_url = img_url.replace(<span class="hljs-string">&quot;assets&quot;</span>, <span class="hljs-string">&quot;img&quot;</span>)            <span class="hljs-comment"># 获取文件创建日期</span>            blog_time = <span class="hljs-built_in">int</span>(os.path.getctime(file_path))            blog_time = datetime.datetime.fromtimestamp(blog_time)            heads_list[<span class="hljs-number">1</span>] = heads_list[<span class="hljs-number">1</span>].<span class="hljs-built_in">format</span>(title=blog_name)            heads_list[<span class="hljs-number">2</span>] = heads_list[<span class="hljs-number">2</span>].<span class="hljs-built_in">format</span>(img_path=img_url)            heads_list[<span class="hljs-number">4</span>] = heads_list[<span class="hljs-number">4</span>].<span class="hljs-built_in">format</span>(categories=categories)            heads_list[<span class="hljs-number">5</span>] = heads_list[<span class="hljs-number">5</span>].<span class="hljs-built_in">format</span>(time=blog_time)            <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> heads_list:                <span class="hljs-built_in">print</span>(li)            flag = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;本博客头信息如上所示，是否修改？\n 0.完美，1.标题，2.图片路径，3.分类  &quot;</span>)            <span class="hljs-keyword">while</span> flag != <span class="hljs-string">&quot;0&quot;</span>:                <span class="hljs-keyword">if</span> flag == <span class="hljs-string">&quot;1&quot;</span>:                    heads_list[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;title: &#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入标题，回车后输入 0 提交：&quot;</span>))                <span class="hljs-keyword">elif</span> flag == <span class="hljs-string">&quot;2&quot;</span>:                    heads_list[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;index_img: &#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(                        <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入图片路径，回车后输入 0 提交：&quot;</span>)                    )                <span class="hljs-keyword">elif</span> flag == <span class="hljs-string">&quot;3&quot;</span>:                    heads_list[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;  - &#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入分类，回车后输入 0 提交：&quot;</span>))                <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> heads_list:                    <span class="hljs-built_in">print</span>(li)                flag = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;本博客头信息如上所示，是否修改？\n 0.完美，1.标题，2.图片路径，3.分类  &quot;</span>)            <span class="hljs-comment"># 获取博客</span>            blog_body = []            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&quot;r+&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:                blog_body = f.readlines()            <span class="hljs-comment"># 将head写入博客头</span>            heads_list.append(<span class="hljs-string">&quot;\n&quot;</span>)            heads_list.reverse()            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> heads_list:                blog_body.insert(<span class="hljs-number">0</span>, line)            <span class="hljs-comment"># 批量替换关键词</span>            <span class="hljs-comment"># 写入博客</span>            blog_url = post_url + <span class="hljs-string">&quot;/&quot;</span> + prefix +blog_name + <span class="hljs-string">&quot;.md&quot;</span>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(blog_url, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:                f.writelines(blog_body)            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;写入成功，博客路径：<span class="hljs-subst">&#123;blog_url&#125;</span>&quot;</span>)<span class="hljs-built_in">format</span>(md_path)<span class="hljs-comment"># BUG</span><span class="hljs-comment"># 文章内图片路径没改</span><span class="hljs-comment"># 图片资源文件夹没有迁移</span><span class="hljs-comment"># 修改文章名称是文件名称不变</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Script</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python使用mysql</title>
    <link href="/Python/Python%E4%BD%BF%E7%94%A8mysql/"/>
    <url>/Python/Python%E4%BD%BF%E7%94%A8mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="Python使用MySQL"><a href="#Python使用MySQL" class="headerlink" title="Python使用MySQL"></a>Python使用MySQL</h1><div class="code-wrapper"><pre><code class="hljs python">导入MySQL驱动:<span class="hljs-keyword">import</span> mysql.connector<span class="hljs-comment"># 注意把password设为你的root口令:</span>conn = mysql.connector.connect(user=<span class="hljs-string">&#x27;root&#x27;</span>, password=<span class="hljs-string">&#x27;123456&#x27;</span>,auth_plugin=<span class="hljs-string">&#x27;mysql_native_password&#x27;</span>,database=<span class="hljs-string">&#x27;testing&#x27;</span>)<span class="hljs-comment"># cursor = conn.cursor()</span><span class="hljs-comment"># 创建user表:</span>cursor.execute(<span class="hljs-string">&#x27;create table user (id varchar(20) primary key, name varchar(20))&#x27;</span>)<span class="hljs-comment"># 插入一行记录，注意MySQL的占位符是%s:</span>cursor.execute(<span class="hljs-string">&#x27;insert into user (id, name) values (%s, %s)&#x27;</span>, [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Yorick&#x27;</span>])<span class="hljs-built_in">print</span>(cursor.rowcount)<span class="hljs-comment"># 提交事务:</span>conn.commit()cursor.close()<span class="hljs-comment"># 运行查询</span>cursor = conn.cursor()cursor.execute(<span class="hljs-string">&#x27;select * from user where id = %s&#x27;</span>,(<span class="hljs-string">&#x27;1&#x27;</span>,))values = cursor.fetchall()<span class="hljs-built_in">print</span>(values)cursor.close()conn.close()<span class="hljs-comment"># 由于Python的DB-API定义都是通用的，所以，操作MySQL的数据库代码和SQLite类似。</span><span class="hljs-comment"># 执行INSERT等操作后要调用commit()提交事务；</span><span class="hljs-comment"># MySQL的SQL占位符是%s。</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python笔记</title>
    <link href="/Python/PythonNote/"/>
    <url>/Python/PythonNote/</url>
    
    <content type="html"><![CDATA[<h3 id="Python-Mini-Note"><a href="#Python-Mini-Note" class="headerlink" title="Python_Mini_Note"></a>Python_Mini_Note</h3><ol><li><p>import random 随机数库</p></li><li><p>import decimal 十进制库，提供精准的浮点数</p></li><li><p><code>//</code>地板除,两数相除后向下取整的结果</p></li><li><p>一个公式：<code>x == (x // y) * y+(x % y)</code></p></li><li><p><code>divmod(a,b)</code> 得到 <code>(a // b,a % b)</code></p></li><li><p><code>ads(x)</code>返回x的绝对值，若x是复数，则返回x的模</p></li><li><p><code>pow(x,y)</code>和<code>x ** y</code>都表示x的y次方 </p></li><li><p><code>pow(x,y,z)</code>表示x的y次方除以z的余数</p></li><li><p>for in </p></li><li><p>深拷贝和浅拷贝 <code>import copy</code></p></li><li><p>列表推导式</p></li><li><p>元组不可以修改，只支持查</p></li><li><p>打包和解包</p><div class="code-wrapper"><pre><code class="hljs py">t = (<span class="hljs-number">123</span>,<span class="hljs-number">222</span>,<span class="hljs-string">&quot;hh&quot;</span>)x,y,z = ta,b,c,d,e,f = <span class="hljs-string">&#x27;Yorick&#x27;</span>a,b,c,*d = <span class="hljs-string">&#x27;Yorick&#x27;</span></code></pre></div></li><li><p>多重赋值<code>x,y = 1,2</code></p></li><li><p>元组里放列表就可变</p></li><li><p><code>zip(x,y,z)</code>以最短的为准,可以<code>import itertools</code> 使用<code>itertools.zip_longest(x,y,z)</code>可以按照最长的来，空用<code>None</code>填充</p></li><li><p>map()</p> <div class="code-wrapper"><pre><code class="hljs py">mapped = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">pow</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<span class="hljs-comment">#等价：</span>mapped = [<span class="hljs-built_in">pow</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)]</code></pre></div></li><li><p>filter()</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">str</span>.islower,<span class="hljs-string">&quot;Yorick&quot;</span>))<span class="hljs-comment"># [&#x27;o&#x27;, &#x27;r&#x27;, &#x27;i&#x27;, &#x27;c&#x27;, &#x27;k&#x27;]</span></code></pre></div></li><li><p>set 集合元素具有唯一性</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>])<span class="hljs-comment">#输出去重集合</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;</code></pre></div></li><li><p>参数列表里<code>/</code>左边只能传递位置参数，不能传递关键字参数。</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">abc</span>(<span class="hljs-params">a,/,b,c</span>): <span class="hljs-built_in">print</span>(a,b,c)abc(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<span class="hljs-comment">#正常输出 1 2 3</span>abc(a = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<span class="hljs-comment">#报错SyntaxError: positional argument follows keyword argument</span></code></pre></div></li><li><p><code>*</code>限制参数列表,<code>*</code>号右侧只能为关键字参数,左侧不限</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">abc</span>(<span class="hljs-params">a,*,b,c</span>): <span class="hljs-built_in">print</span>(a,b,c)</code></pre></div></li><li><p>收集参数，利用元组（tuple）的打包解包功能实现动态参数</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>(<span class="hljs-params">*args</span>):    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;有&#123;&#125;个参数&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(args)))    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第二个参数是：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(args[<span class="hljs-number">1</span>]))myfunc(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<span class="hljs-comment"># 输出：</span><span class="hljs-comment"># 有3个参数</span><span class="hljs-comment"># 第二个参数是：2</span></code></pre></div><p>当某函数的参数列表中存在收集参数时，收集参数右侧只能为关键字参数,左侧不限。（同22）</p></li><li><p><code>**</code>字典形式的收集参数</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>(<span class="hljs-params">a,*b,**c</span>):    <span class="hljs-built_in">print</span>(a,b,c)myfunc(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,x=<span class="hljs-number">5</span>,y=<span class="hljs-number">6</span>)<span class="hljs-comment"># 输出：</span><span class="hljs-comment"># 1 (2, 3, 4) &#123;&#x27;x&#x27;: 5, &#x27;y&#x27;: 6&#125;</span></code></pre></div><p>常见于<code>format</code>函数：</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-built_in">help</span>(<span class="hljs-built_in">str</span>.<span class="hljs-built_in">format</span>)Help on method_descriptor:<span class="hljs-built_in">format</span>(...)    S.<span class="hljs-built_in">format</span>(*args, **kwargs) -&gt; <span class="hljs-built_in">str</span>    Return a formatted version of S, using substitutions <span class="hljs-keyword">from</span> args <span class="hljs-keyword">and</span> kwargs.    The substitutions are identified by braces (<span class="hljs-string">&#x27;&#123;&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>).</code></pre></div></li><li><p>解包参数<br>调用时解包元组<code>*</code>，解包字典<code>**</code>。</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-comment">#定义一个元组</span>arg = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<span class="hljs-comment">#定义一函数，需要4个参数</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>(<span class="hljs-params">a,b,c,d</span>):    <span class="hljs-built_in">print</span>(a,b,c,d)<span class="hljs-comment">#第一个报错</span>myfunc(arg)<span class="hljs-comment">#第二个正常输出1 2 3 4，解包了</span>myfunc(*arg)</code></pre></div></li><li><p>全局变量无法在函数中改变，只能访问。<br>如果非要改，用<code>global</code>关键字，但不提倡</p><div class="code-wrapper"><pre><code class="hljs py">    x = <span class="hljs-number">880</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>():        <span class="hljs-keyword">global</span> x        x = <span class="hljs-number">520</span>        <span class="hljs-built_in">print</span>(x)        myfunc()    <span class="hljs-comment">#输出520</span>    <span class="hljs-built_in">print</span>(x)    <span class="hljs-comment">#输出520，全局变量x被改变</span>    ````    <span class="hljs-number">27.</span> `<span class="hljs-keyword">nonlocal</span>`实现在内部函数改变外部函数的变量<span class="hljs-number">28.</span> 变量作用域遵循LEGB规则，优先级由高到低    `Local`局部作用域    `Enclosed`嵌套函数的外层作用域    `Global`全局作用域    `Built-In`内置作用域<span class="hljs-number">29.</span> 闭包，工厂函数    <span class="hljs-number">1.</span> 利用嵌套函数的外层作用域具有记忆能力这个特性。    <span class="hljs-number">2.</span> 将内层函数作为返回值给返回<span class="hljs-number">30.</span> 返回值是一个函数时不用加`()`<span class="hljs-number">31.</span> 装饰器,不改变原函数的前提下加功能    注意：    - **多个装饰器**调用顺序：**自下往上**    - 可以通过再套一层函数的方式来传递参数    实现原理：    ```py    <span class="hljs-keyword">import</span> time    <span class="hljs-keyword">def</span> <span class="hljs-title function_">time_master</span>(<span class="hljs-params">func</span>):        <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_func</span>():        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Starting...&quot;</span>)        start = time.time()        func()        stop = time.time()        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ending...&quot;</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;time:<span class="hljs-subst">&#123;(stop-start):<span class="hljs-number">.2</span>f&#125;</span>秒&quot;</span>)        <span class="hljs-keyword">return</span> call_func    <span class="hljs-comment">#原函数</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>():        time.sleep(<span class="hljs-number">2</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello Yorick&quot;</span>)    <span class="hljs-comment">#闭包覆盖原函数</span>    myfunc = time_master(myfunc)    <span class="hljs-comment">#调用</span>    myfunc()    <span class="hljs-comment">#输出：</span>    <span class="hljs-comment">#Starting...</span>    <span class="hljs-comment">#Hello Yorick</span>    <span class="hljs-comment">#ending...</span>    <span class="hljs-comment">#time:2.00秒</span></code></pre></div><p>语法糖：</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">def</span> <span class="hljs-title function_">time_master</span>(<span class="hljs-params">func</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_func</span>():     <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Starting...&quot;</span>)     start = time.time()     func()     stop = time.time()     <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ending...&quot;</span>)     <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;time:<span class="hljs-subst">&#123;(stop-start):<span class="hljs-number">.2</span>f&#125;</span>秒&quot;</span>)    <span class="hljs-keyword">return</span> call_func<span class="hljs-comment">#语法糖，以后再调用myfunc，则将此函数作参数代入至time_master函数中运行time_master</span><span class="hljs-meta">@time_master</span><span class="hljs-comment">#原函数</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>():    time.sleep(<span class="hljs-number">2</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello Yorick&quot;</span>)<span class="hljs-comment">#调用</span>myfunc()<span class="hljs-comment">#输出：</span><span class="hljs-comment">#Starting...</span><span class="hljs-comment">#Hello Yorick</span><span class="hljs-comment">#ending...</span><span class="hljs-comment">#time:2.00秒</span></code></pre></div></li><li><p>lambda函数，匿名函数，一行流</p><div class="code-wrapper"><pre><code class="hljs py">y = [<span class="hljs-keyword">lambda</span> x : x * x,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]y[<span class="hljs-number">0</span>](y[<span class="hljs-number">1</span>])<span class="hljs-comment">#结果：4</span></code></pre></div></li><li><p>生成器：每次调用提供一份数据，并保留函数内部状态，下次调用重复以上过程</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">counter</span>():    i = <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> i &lt;= <span class="hljs-number">5</span>:        <span class="hljs-keyword">yield</span> i        <span class="hljs-comment">#yield i与函数中的return i类似，返回上层程序并给出返回值。</span>        <span class="hljs-comment">#但是函数在return后不保存当前状态，生成器则是一个迭代器，每次引用时从上一次的结束状态开始运行。</span>        i += <span class="hljs-number">1</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> counter():    <span class="hljs-built_in">print</span>(i)<span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">输出：</span><span class="hljs-string">0</span><span class="hljs-string">1</span><span class="hljs-string">2</span><span class="hljs-string">3</span><span class="hljs-string">4</span><span class="hljs-string">5</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment">#也可以用next()语句，不支持下表索引</span></code></pre></div><p>斐波那契数列:</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-comment">#斐波那契数列生成器函数</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(): back1,back2 = <span class="hljs-number">0</span>,<span class="hljs-number">1</span> <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:  <span class="hljs-keyword">yield</span> back1  back1, back2 = back2, back1+back2f = fib()<span class="hljs-comment">#下一个斐波那契数</span><span class="hljs-built_in">next</span>(f)<span class="hljs-comment">#打印斐波那契数列</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> f:    <span class="hljs-built_in">print</span>(i)</code></pre></div></li><li><p>生成器表达式和列表表达式：生成器表达式每次调用只输出一个数据，而列表表达式一次调用全部输出为列表形式。</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-comment">#生成器表式</span>g = (i ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<span class="hljs-built_in">next</span>(g)<span class="hljs-comment">#输出0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> g:    <span class="hljs-built_in">print</span>()<span class="hljs-comment">#依次输出16 25 36 49 64 91 </span><span class="hljs-comment">#列表表达式</span>[i ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<span class="hljs-comment">#输出：[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></code></pre></div></li></ol><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python匿名函数(lambda)</title>
    <link href="/Python/Python%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0(lambda)/"/>
    <url>/Python/Python%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0(lambda)/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-lambda表达式（匿名函数）"><a href="#Python-lambda表达式（匿名函数）" class="headerlink" title="Python lambda表达式（匿名函数）"></a>Python lambda表达式（匿名函数）</h1><p>参考链接：</p><ul><li><a href="http://c.biancheng.net/view/2262.html">Python lambda表达式（匿名函数）及用法</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017451447842528">匿名函数</a></li></ul><p>语法格式：</p><div class="code-wrapper"><pre><code class="hljs py">name = <span class="hljs-keyword">lambda</span> [<span class="hljs-built_in">list</span>] : 表达式</code></pre></div><p>其中，定义 lambda 表达式，必须使用 lambda 关键字；[list] 作为可选参数，等同于定义函数是指定的参数列表；name 为该表达式的名称。<br>转换成普通函数的形式:</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params"><span class="hljs-built_in">list</span></span>):    <span class="hljs-keyword">return</span> 表达式</code></pre></div><p>实例：</p><div class="code-wrapper"><pre><code class="hljs py">fun = <span class="hljs-keyword">lambda</span> x: x * x<span class="hljs-built_in">print</span>(fun(<span class="hljs-number">5</span>))<span class="hljs-comment"># 25</span></code></pre></div><p>相当于：</p><div class="code-wrapper"><pre><code class="py">def fun(x):    return x * xprint(fun(5))# 25</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lambda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python魔法方法</title>
    <link href="/Python/Python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    <url>/Python/Python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Python的魔法方法"><a href="#Python的魔法方法" class="headerlink" title="Python的魔法方法"></a>Python的魔法方法</h1><p>目录：</p><ul><li><a href="#python%E7%9A%84%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95">Python的魔法方法</a><ul><li><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95__new__">构造方法<code>__new__</code></a></li><li><a href="#__str__%E5%92%8C__repr__"><code>__str__</code>和<code>__repr__</code></a></li><li><a href="#__getattr____setattr__%E5%92%8C__delattr__"><code>__getattr__</code>、<code>__setattr__</code>和<code>__delattr__</code></a></li></ul></li></ul><p>参考链接：</p><ul><li><a href="https://url.cy/0wKANr">Python魔法方法指南</a></li><li><a href="http://c.biancheng.net/view/7817.html">Python常用魔术方法一览表</a></li><li><a href="https://blog.csdn.net/yusuiyu/article/details/87945149">Python 魔法方法</a></li></ul><p>Python中的魔法方法像是Java中的重载，Python中的魔法方法可以理解为：对类中的内置方法的重载，注意这里不是重写。</p><p>下面列出部分常用的方法：</p><h3 id="构造方法-new"><a href="#构造方法-new" class="headerlink" title="构造方法__new__"></a>构造方法<code>__new__</code></h3><p><a href="./__new__%E6%96%B9%E6%B3%95.md">__init__方法</a></p><h3 id="str-和-repr"><a href="#str-和-repr" class="headerlink" title="__str__和__repr__"></a><code>__str__</code>和<code>__repr__</code></h3><p><code>__str__</code>定义对类的实例调用<code>str()</code>时的行为。而<code>__repr__</code>定义对类的实例调用<code>repr()</code>的行为，这两者的区别就是<code>repr</code>面向开发者，<code>str</code>面向用户。定义类的输出的时候经常会使用这两个其中的魔法。</p><p>实例：</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-title class_ inherited__">object</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,weight</span>):        <span class="hljs-variable language_">self</span>.name = name        <span class="hljs-variable language_">self</span>.weight = weight    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;&#125;:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-variable language_">self</span>.name,<span class="hljs-variable language_">self</span>.weight)<span class="hljs-built_in">print</span>(Apple(<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;30g&#x27;</span>))<span class="hljs-comment"># 输出；A:30g</span></code></pre></div><p>这里可以看见<code>__str__</code>起作用了，但是如果我们在命令行里运行<code>Apple(&#39;A&#39;,&#39;30g&#39;)</code>的话，输出的可能是：</p><div class="code-wrapper"><pre><code class="hljs py">&lt;__main__.Apple <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000001785036DEE0</span>&gt;</code></pre></div><p>因为这里是<code>__repr__控制的</code>，修改Apple类，添加<code>__repr__ = __str__</code>则可以输出：</p><div class="code-wrapper"><pre><code class="hljs py">A:30g</code></pre></div><h3 id="getattr-、-setattr-和-delattr"><a href="#getattr-、-setattr-和-delattr" class="headerlink" title="__getattr__、__setattr__和__delattr__"></a><code>__getattr__</code>、<code>__setattr__</code>和<code>__delattr__</code></h3><p><code>__getattr__</code>定义对象访问不存在的属性或方法时的行为(对象访问不存在的属性或者调用方法时调用)<br><code>__setattr__</code>定义对属性或方法进行修改操作时的行为,在实例化的时候，会在<code>__init__</code>里初始化，对value的属性值进行了设置，这时候会调用<code>__setattr__</code>方法。<br>需要注意的地方是，在重写<code>__setattr__</code>方法的时候千万不要重复调用造成死循环。<br><code>__delattr__</code>定义定义删除属性时的行为</p><p>实例：<br>可以参考<a href="./orm.md">ORM框架</a>的<code>Model</code>类</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span>(<span class="hljs-title class_ inherited__">object</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, weight</span>):        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;进入__init__初始化对象属性&quot;</span>)        <span class="hljs-variable language_">self</span>.name = name        <span class="hljs-variable language_">self</span>.weight = weight    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, attr</span>):        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;不存在&#123;&#125;属性&quot;</span>.<span class="hljs-built_in">format</span>(attr)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, name, value</span>):        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在生成实例化对象的&#123;&#125;属性，值为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(name, value))        <span class="hljs-built_in">object</span>.__setattr__(<span class="hljs-variable language_">self</span>, name, value)        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;正在生成实例化对象的&#123;&#125;属性，值为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(name, value)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delattr__</span>(<span class="hljs-params">self, attr: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在删除&#123;&#125;属性&quot;</span>.<span class="hljs-built_in">format</span>(attr))        <span class="hljs-built_in">object</span>.__delattr__(<span class="hljs-variable language_">self</span>, attr)a = Apple(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;30g&quot;</span>)<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a.name:&quot;</span>,a.name)<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a.weight&quot;</span>,a.weight)<span class="hljs-built_in">print</span>(a.key)<span class="hljs-keyword">del</span> a.name<span class="hljs-keyword">del</span> a.weight<span class="hljs-built_in">print</span>(a.name,a.weight)</code></pre></div><p>结果：</p><div class="code-wrapper"><pre><code class="hljs py">进入__init__初始化对象属性正在生成实例化对象的name属性，值为A正在生成实例化对象的weight属性，值为30ga.name: Aa.weight 30g不存在key属性正在删除name属性正在删除weight属性不存在name属性 不存在weight属性</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python静态方法和动态方法</title>
    <link href="/Python/Python%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95/"/>
    <url>/Python/Python%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="python的静态方法和动态方法"><a href="#python的静态方法和动态方法" class="headerlink" title="python的静态方法和动态方法"></a>python的静态方法和动态方法</h1><p>目录：</p><ul><li><a href="#python%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95">python的静态方法和动态方法</a><ul><li><a href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">实例方法</a></li><li><a href="#%E7%B1%BB%E6%96%B9%E6%B3%95">类方法</a></li><li><a href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">静态方法</a></li><li><a href="#%E5%AE%9E%E4%BE%8B">实例</a></li></ul></li></ul><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法。  </p><p>调用：只能由实例对象调用。</p><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法。  </p><p>调用：实例对象和类对象都可以调用。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>定义：使用装饰器@staticmethod。参数随意，没有self和cls参数，但是方法体中不能使用类或实例的任何属性和方法。  </p><p>调用：实例对象和类对象都可以调用。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-title class_ inherited__">object</span>):    <span class="hljs-comment"># 定义了实例方法</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params">self</span>):        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;object:这里定义了实例方法&quot;</span>)    <span class="hljs-comment"># 定义了类方法</span><span class="hljs-meta">    @classmethod</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params">clss</span>):        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;class：这里定义了类方法&quot;</span>)    <span class="hljs-comment"># 定义了静态方法</span><span class="hljs-meta">    @staticmethod</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test3</span>():        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;static：这里定义了静态方法&quot;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    obj = Foo()        obj.test1()        Foo.test2()    obj.test2()        Foo.test3()    obj.test3()</code></pre></div><p>输出：</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-built_in">object</span>:这里定义了实例方法<span class="hljs-keyword">class</span>：这里定义了类方法<span class="hljs-keyword">class</span>：这里定义了类方法static：这里定义了静态方法static：这里定义了静态方法</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python__name__属性</title>
    <link href="/Python/Python__name__%E5%B1%9E%E6%80%A7/"/>
    <url>/Python/Python__name__%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="python的-name-方法"><a href="#python的-name-方法" class="headerlink" title="python的__name__方法"></a>python的__name__方法</h1><p><code>__name__</code>属性是Python的一个内置属性，记录了一个字符串。<br>若是在当前文件，<code>__name__</code> 的值是<code>__main__</code>。<br>若该文件被别的文件当模块导入(import)，<code>__name__</code>是模块名。<br>所以用下面的语句判断该文件的执行者，pass通常用测试代码替换掉。</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    <span class="hljs-keyword">pass</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python__new__方法</title>
    <link href="/Python/Python__new__%E6%96%B9%E6%B3%95/"/>
    <url>/Python/Python__new__%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="python的-new-方法"><a href="#python的-new-方法" class="headerlink" title="python的__new__方法"></a>python的__new__方法</h1><h3 id="什么是-new-方法"><a href="#什么是-new-方法" class="headerlink" title="什么是__new__方法"></a>什么是__new__方法</h3><p>在Python中<code>__new__</code>方法与<code>__init__</code>方法类似，但是如果两个都存在那么<code>__new__</code>先执行。</p><p><code>__new__</code>方法的返回值是</p><p>可以将类比作制造商，<code>__new__</code>方法就是前期的原材料购买环节，init方法就是在有原材料的基础上，加工，初始化商品环节。</p><p>实例：</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):      <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):        <span class="hljs-variable language_">self</span>.name = name        <span class="hljs-variable language_">self</span>.age = age         <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, age</span>):        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt; age &lt; <span class="hljs-number">150</span>:            <span class="hljs-keyword">return</span> <span class="hljs-built_in">object</span>.__new__(cls)            <span class="hljs-comment"># return super(Person, cls).__new__(cls)</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;0&#125;(&#123;1&#125;)&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-variable language_">self</span>.__class__.__name__, <span class="hljs-variable language_">self</span>.__dict__)  <span class="hljs-built_in">print</span>(Person(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">10</span>))<span class="hljs-built_in">print</span>(Person(<span class="hljs-string">&#x27;Mike&#x27;</span>, <span class="hljs-number">200</span>))</code></pre></div><p>结果：</p><div class="code-wrapper"><pre><code class="hljs py">Person(&#123;<span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>&#125;)<span class="hljs-literal">None</span> <span class="hljs-comment"># 注意此时__init()__没被执行</span></code></pre></div><p>执行过程：</p><ol><li>当执行<code>Person(&#39;Tom&#39;,10)</code>时，实例化类，<code>name=&#39;Tom&#39;,age=&#39;10&#39;</code>被当作参数带入<code>__new__</code>方法，参数cls表示需要实例化的类，即Person,这里由Python解析器自动提供.</li><li><code>__new__</code>方法会返回Person类的一个实例，通常是其父类new出来的实例，或者直接是<code>object</code>的new出来的实例。</li><li>然后利用这个实例来调用类的<code>__init__</code>方法，如果<code>__new__</code>方法返回<code>None</code>，则<code>__init__</code>方法不会被执行。</li></ol><h3 id="什么时候需要-new"><a href="#什么时候需要-new" class="headerlink" title="什么时候需要__new__"></a>什么时候需要__new__</h3><p><code>__new__</code>方法主要是当你继承一些不可变的class时(比如int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。还有就是实现自定义的<code>metaclass</code>。</p><p>实例：<br>定义一个只能输出正数的整数类型:</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PositiveInteger</span>(<span class="hljs-title class_ inherited__">int</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, value</span>):        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(PositiveInteger, cls).__new__(cls, <span class="hljs-built_in">abs</span>(value))i = PositiveInteger(-<span class="hljs-number">3</span>)<span class="hljs-built_in">print</span>(i)<span class="hljs-comment"># 输出：3</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python编写ORM框架</title>
    <link href="/Python/PythonORM/"/>
    <url>/Python/PythonORM/</url>
    
    <content type="html"><![CDATA[<h1 id="Python编写ORM框架"><a href="#Python编写ORM框架" class="headerlink" title="Python编写ORM框架"></a>Python编写ORM框架</h1><p>ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。</p><p>要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。</p><p>首先来定义Field类，它负责保存数据库表的字段名和字段类型：</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Field</span>(<span class="hljs-title class_ inherited__">object</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, column_type</span>):        <span class="hljs-variable language_">self</span>.name = name        <span class="hljs-variable language_">self</span>.column_type = column_type    <span class="hljs-comment"># __str__方法，重写print()函数返回值</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;%s:%s&gt;&#x27;</span> % (<span class="hljs-variable language_">self</span>.__class__.__name__, <span class="hljs-variable language_">self</span>.name)</code></pre></div><p>在Field的基础上，进一步定义各种类型的Field，比如StringField，IntegerField等等：</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringField</span>(<span class="hljs-title class_ inherited__">Field</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):        <span class="hljs-comment"># 用super()调用父类方法</span>        <span class="hljs-built_in">super</span>().__init__(name, <span class="hljs-string">&#x27;varchar(100)&#x27;</span>)<span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerField</span>(<span class="hljs-title class_ inherited__">Field</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):        <span class="hljs-built_in">super</span>().__init__(name, <span class="hljs-string">&#x27;bigint&#x27;</span>)</code></pre></div><p>下一步，就是编写最复杂的ModelMetaclass了：</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelMetaclass</span>(<span class="hljs-title class_ inherited__">type</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs</span>):        <span class="hljs-comment"># attrs是一个字典，包含Model类及其子类的所有属性</span>        <span class="hljs-comment"># 排除掉对Model类的修改，只修改其子类</span>        <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;Model&quot;</span>:            <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>.__new__(cls, name, bases, attrs)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Found model: %s&#x27;</span> % name)        mappings = <span class="hljs-built_in">dict</span>()        <span class="hljs-comment"># 筛选出Field属性或其子类</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> attrs.items():            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(v,Field):                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Found mapping: %s ==&gt; %s&quot;</span> % (k,v))                mappings[k] = v        <span class="hljs-comment"># 从子类属性中删除该Field属性，子类属性会覆盖自动生成的属性</span>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> mappings.keys():            attrs.pop(k)        <span class="hljs-comment"># 为Model的子类添加新属性</span>        attrs[<span class="hljs-string">&#x27;__mappings__&#x27;</span>] = mappings <span class="hljs-comment"># 保存属性和列的映射关系</span>        attrs[<span class="hljs-string">&#x27;__table__&#x27;</span>] = name <span class="hljs-comment"># 假设表名和类名一致</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>.__new__(cls, name, bases, attrs)</code></pre></div><p>然后，编写User类的基类Model</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span>(<span class="hljs-built_in">dict</span>, metaclass=ModelMetaclass):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, **kw</span>):        <span class="hljs-built_in">super</span>(Model, <span class="hljs-variable language_">self</span>).__init__(**kw)    <span class="hljs-comment"># 把一个类的所有属性和方法调用全部动态化处理</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, key</span>):        <span class="hljs-keyword">try</span>:            <span class="hljs-comment"># self已经是一个dict</span>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>[key]        <span class="hljs-keyword">except</span> KeyError:            <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">r&quot;&#x27;Model&#x27; object has no attribute &#x27;%s&#x27;&quot;</span> % key)    <span class="hljs-comment"># 生成实例化对象时调用</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, key, value</span>):        <span class="hljs-variable language_">self</span>[key] = value    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save</span>(<span class="hljs-params">self</span>):        fields = []        params = []        args = []        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.__mappings__.items():            fields.append(v.name) <span class="hljs-comment"># 等同于fields.append(k)</span>            params.append(<span class="hljs-string">&#x27;?&#x27;</span>)            <span class="hljs-comment"># None这一位参数表示如果拿不到参数k，自动返回None</span>            args.append(<span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>, k, <span class="hljs-literal">None</span>))        sql = <span class="hljs-string">&#x27;insert into %s (%s) values (%s)&#x27;</span> % (<span class="hljs-variable language_">self</span>.__table__, <span class="hljs-string">&#x27;,&#x27;</span>.join(fields), <span class="hljs-string">&#x27;,&#x27;</span>.join(params))        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;SQL: %s&#x27;</span> % sql)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ARGS: %s&#x27;</span> % <span class="hljs-built_in">str</span>(args))</code></pre></div><p>最后定义User类</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">Model</span>):    <span class="hljs-comment"># 定义类的属性到列的映射：</span>    <span class="hljs-built_in">id</span> = IntegerField(<span class="hljs-string">&#x27;id&#x27;</span>)    name = StringField(<span class="hljs-string">&#x27;username&#x27;</span>)    email = StringField(<span class="hljs-string">&#x27;email&#x27;</span>)    password = StringField(<span class="hljs-string">&#x27;password&#x27;</span>)</code></pre></div><p>测试：</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-comment"># 创建一个实例：</span>u = User(<span class="hljs-built_in">id</span>=<span class="hljs-number">12345</span>, name=<span class="hljs-string">&#x27;Yorick&#x27;</span>, email=<span class="hljs-string">&#x27;test@orm.org&#x27;</span>, password=<span class="hljs-string">&#x27;my-pwd&#x27;</span>)<span class="hljs-comment"># 保存到数据库：</span>u.save()</code></pre></div><p>输出：</p><div class="code-wrapper"><pre><code class="hljs py">Found model: UserFound mapping: <span class="hljs-built_in">id</span> ==&gt; &lt;IntegerField:<span class="hljs-built_in">id</span>&gt;Found mapping: name ==&gt; &lt;StringField:username&gt;Found mapping: email ==&gt; &lt;StringField:email&gt;Found mapping: password ==&gt; &lt;StringField:password&gt;SQL: insert into User (<span class="hljs-built_in">id</span>,username,email,password) values (?,?,?,?)ARGS: [<span class="hljs-number">12345</span>, <span class="hljs-string">&#x27;Yorick&#x27;</span>, <span class="hljs-string">&#x27;test@orm.org&#x27;</span>, <span class="hljs-string">&#x27;my-pwd&#x27;</span>]</code></pre></div><p>完整代码：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Field</span>(<span class="hljs-title class_ inherited__">object</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, column_type</span>):        <span class="hljs-variable language_">self</span>.name = name        <span class="hljs-variable language_">self</span>.column_type = column_type    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;%s:%s&gt;&quot;</span> % (<span class="hljs-variable language_">self</span>.__class__.__name__, <span class="hljs-variable language_">self</span>.name)<span class="hljs-keyword">class</span> <span class="hljs-title class_">StringField</span>(<span class="hljs-title class_ inherited__">Field</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):        <span class="hljs-built_in">super</span>().__init__(name, <span class="hljs-string">&quot;varchar(100)&quot;</span>)<span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerField</span>(<span class="hljs-title class_ inherited__">Field</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):        <span class="hljs-built_in">super</span>().__init__(name, <span class="hljs-string">&quot;bigint&quot;</span>)<span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelMetaclass</span>(<span class="hljs-title class_ inherited__">type</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs</span>):        <span class="hljs-comment"># 排除掉对Model类的修改，只修改其子类</span>        <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;Model&quot;</span>:            <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>.__new__(cls, name, bases, attrs)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Found model: %s&#x27;</span> % name)        mappings = <span class="hljs-built_in">dict</span>()        <span class="hljs-comment"># 查找Field属性</span>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> attrs.items():            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(v,Field):                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Found mapping: %s ==&gt; %s&quot;</span> % (k,v))                mappings[k] = v        <span class="hljs-comment"># 从类属性中删除该Field属性</span>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> mappings.keys():            attrs.pop(k)        <span class="hljs-comment"># 为Model的子类添加新属性</span>        attrs[<span class="hljs-string">&#x27;__mappings__&#x27;</span>] = mappings <span class="hljs-comment"># 保存属性和列的映射关系</span>        attrs[<span class="hljs-string">&#x27;__table__&#x27;</span>] = name <span class="hljs-comment"># 假设表名和类名一致</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>.__new__(cls, name, bases, attrs)        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span>(<span class="hljs-built_in">dict</span>, metaclass=ModelMetaclass):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, **kw</span>):        <span class="hljs-built_in">super</span>(Model, <span class="hljs-variable language_">self</span>).__init__(**kw)    <span class="hljs-comment"># 把一个类的所有属性和方法调用全部动态化处理</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, key</span>):        <span class="hljs-keyword">try</span>:            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>[key]        <span class="hljs-keyword">except</span> KeyError:            <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">r&quot;&#x27;Model&#x27; object has no attribute &#x27;%s&#x27;&quot;</span> % key)    <span class="hljs-comment"># 生成实例化对象时调用</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, key, value</span>):        <span class="hljs-variable language_">self</span>[key] = value    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save</span>(<span class="hljs-params">self</span>):        fields = []        params = []        args = []        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.__mappings__.items():            fields.append(v.name) <span class="hljs-comment"># 等同于fields.append(k)</span>            params.append(<span class="hljs-string">&#x27;?&#x27;</span>)            args.append(<span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>, k, <span class="hljs-literal">None</span>))        sql = <span class="hljs-string">&#x27;insert into %s (%s) values (%s)&#x27;</span> % (<span class="hljs-variable language_">self</span>.__table__, <span class="hljs-string">&#x27;,&#x27;</span>.join(fields), <span class="hljs-string">&#x27;,&#x27;</span>.join(params))        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;SQL: %s&#x27;</span> % sql)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ARGS: %s&#x27;</span> % <span class="hljs-built_in">str</span>(args))<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">Model</span>):    <span class="hljs-comment"># 定义类的属性到列的映射：</span>    <span class="hljs-built_in">id</span> = IntegerField(<span class="hljs-string">&#x27;id&#x27;</span>)    name = StringField(<span class="hljs-string">&#x27;username&#x27;</span>)    email = StringField(<span class="hljs-string">&#x27;email&#x27;</span>)    password = StringField(<span class="hljs-string">&#x27;password&#x27;</span>)<span class="hljs-comment"># 创建一个实例：</span>u = User(<span class="hljs-built_in">id</span>=<span class="hljs-number">12345</span>, name=<span class="hljs-string">&#x27;Yorick&#x27;</span>, email=<span class="hljs-string">&#x27;test@orm.org&#x27;</span>, password=<span class="hljs-string">&#x27;my-pwd&#x27;</span>)<span class="hljs-comment"># 保存到数据库：</span>u.save()</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ORM</tag>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python类与对象</title>
    <link href="/Python/Python%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <url>/Python/Python%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Python类与对象易忘点"><a href="#Python类与对象易忘点" class="headerlink" title="Python类与对象易忘点"></a>Python类与对象易忘点</h1><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017496031185408">参考链接</a></p><p><strong>目录：</strong></p><ul><li><a href="#python%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%98%93%E5%BF%98%E7%82%B9">Python类与对象易忘点</a><ul><li><a href="#__init__%E6%96%B9%E6%B3%95"><code>__init()__</code>方法</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%85%83%E7%B1%BBtype%E5%92%8Cmetaclass">使用元类，<code>type()</code>和<code>metaclass</code></a><ul><li><a href="#type">type()</a></li><li><a href="#metaclass%E5%85%83%E7%B1%BB">metaclass(元类)</a></li></ul></li></ul></li></ul><h2 id="init-方法"><a href="#init-方法" class="headerlink" title="__init()__方法"></a><code>__init()__</code>方法</h2><p>注意：<strong>两个下划线</strong>，类似Java的构造器函数</p><p>实例：</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):        <span class="hljs-variable language_">self</span>.name = name        <span class="hljs-variable language_">self</span>.score = score</code></pre></div><p>注意：<code>__init()__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身。  </p><p>有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但<code>self</code>不需要传，Python解释器自己会把实例变量传进去：</p><div class="code-wrapper"><pre><code class="hljs py">yorick = Student(<span class="hljs-string">&#x27;Yorick&#x27;</span>,<span class="hljs-number">88</span>)yorick.name<span class="hljs-comment"># &#x27;Yorick&#x27;</span>yorick.score<span class="hljs-comment"># 88</span></code></pre></div><h2 id="使用元类，type-和metaclass"><a href="#使用元类，type-和metaclass" class="headerlink" title="使用元类，type()和metaclass"></a>使用元类，<code>type()</code>和<code>metaclass</code></h2><p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。</p><h3 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h3><p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过<code>type()</code>函数创建出Hello类，而无需通过<code>class Hello(object)...</code>的定义：</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-comment"># 先定义类的方法</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">self, name=<span class="hljs-string">&#x27;world&#x27;</span></span>):     <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, %s.&#x27;</span> % name)<span class="hljs-comment"># 创建Hello class</span>Hello = <span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, (<span class="hljs-built_in">object</span>,), <span class="hljs-built_in">dict</span>(hello=fn))<span class="hljs-comment"># 创建类的实例</span>h = Hello()<span class="hljs-comment"># 调用实例的方法</span>h.hello()<span class="hljs-comment"># Hello, world.</span>h.hello(<span class="hljs-string">&#x27;Yorick&#x27;</span>)<span class="hljs-comment"># Hello, Yorick.</span></code></pre></div><h3 id="metaclass-元类"><a href="#metaclass-元类" class="headerlink" title="metaclass(元类)"></a>metaclass(元类)</h3><p>先定义<code>metaclass</code>，就可以创建类，最后创建实例，可以把类看成是<code>metaclass</code>创建出来的“实例”</p><p>实例：</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-comment"># metaclass是类的模板，所以必须从`type`类型派生：</span><span class="hljs-comment"># 按照习惯，metaclass的类名总是以Metaclass结尾</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListMetaclass</span>(<span class="hljs-title class_ inherited__">type</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs</span>):        attrs[<span class="hljs-string">&#x27;add&#x27;</span>] = <span class="hljs-keyword">lambda</span> <span class="hljs-variable language_">self</span>, value: <span class="hljs-variable language_">self</span>.append(value)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>.__new__(cls, name, bases, attrs)</code></pre></div><p><code>__new__</code>方法接收到的参数依次是：</p><ol><li>当前准备创建的类的对象；</li><li>类的名字；</li><li>类继承的父类集合；</li><li>类的方法集合。</li></ol><p>有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数metaclass：</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-comment"># 继承普通list类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>(<span class="hljs-built_in">list</span>, metaclass=ListMetaclass):    <span class="hljs-keyword">pass</span></code></pre></div><p>测试一下MyList是否可以调用add()方法：</p><div class="code-wrapper"><pre><code class="hljs py">L = MyList()L.add(<span class="hljs-number">1</span>)L<span class="hljs-comment"># [1]</span></code></pre></div><p>实例：<a href="./orm.md">编写ORM</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python可变参数与关键字参数</title>
    <link href="/Python/Python%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0/"/>
    <url>/Python/Python%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="可变参数和关键字参数"><a href="#可变参数和关键字参数" class="headerlink" title="可变参数和关键字参数"></a>可变参数和关键字参数</h1><p>Variable Parameter &amp; Keyword Argument </p><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/98f7e34845b5">简书</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888">廖大</a></li></ul><h3 id="可变参数："><a href="#可变参数：" class="headerlink" title="可变参数："></a>可变参数：</h3><p>实例：</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc</span>(<span class="hljs-params">*numbers</span>):    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> numbers:        <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + n * n    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span></code></pre></div><p>定义函数<code>cala()</code>，<code>*numbers</code>即为可变参数，在函数内部，参数<code>numbers</code>接收到的是一个<code>tuple</code>（元组），因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个：</p><div class="code-wrapper"><pre><code class="hljs py">calc(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-comment"># 5</span>calc()<span class="hljs-comment"># 0</span></code></pre></div><p>把<code>list</code>或<code>tuple</code>的元素变成可变参数传进去：</p><div class="code-wrapper"><pre><code class="hljs py">nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]calc(*nums)<span class="hljs-comment"># 14</span></code></pre></div><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>实例：</p><div class="code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, **kw</span>):    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name:&#x27;</span>, name, <span class="hljs-string">&#x27;age:&#x27;</span>, age, <span class="hljs-string">&#x27;other:&#x27;</span>, kw)</code></pre></div><p>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>：</p><div class="code-wrapper"><pre><code class="hljs py">person(<span class="hljs-string">&#x27;Adam&#x27;</span>, <span class="hljs-number">35</span>, gender=<span class="hljs-string">&#x27;M&#x27;</span>, job=<span class="hljs-string">&#x27;Engineer&#x27;</span>)<span class="hljs-comment"># name: Adam age: 35 other: &#123;&#x27;gender&#x27;: &#x27;M&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;</span></code></pre></div><p>另外<code>person()</code>也接受<code>dict</code>类型参数：</p><div class="code-wrapper"><pre><code class="hljs py">extra = &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>, <span class="hljs-string">&#x27;job&#x27;</span>: <span class="hljs-string">&#x27;Engineer&#x27;</span>&#125;person(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">24</span>, city=extra[<span class="hljs-string">&#x27;city&#x27;</span>], job=extra[<span class="hljs-string">&#x27;job&#x27;</span>])<span class="hljs-comment"># name: Jack age: 24 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;</span></code></pre></div><p>简化：</p><div class="code-wrapper"><pre><code class="py">extra = &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;person(&#39;Jack&#39;, 24, **extra)# name: Jack age: 24 other: &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[!(function () {    /** 计时起始时间，自行修改 **/    var start = new Date("2022/11/27 00:00:00");    function update() {        var now = new Date();        now.setTime(now.getTime() + 250);        days = (now - start) / 1000 / 60 / 60 / 24;        dnum = Math.floor(days);        hours = (now - start) / 1000 / 60 / 60 - (24 * dnum);        hnum = Math.floor(hours);        if (String(hnum).length === 1) {            hnum = "0" + hnum;        }        minutes = (now - start) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);        mnum = Math.floor(minutes);        if (String(mnum).length === 1) {            mnum = "0" + mnum;        }        seconds = (now - start) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);        snum = Math.round(seconds);        if (String(snum).length === 1) {            snum = "0" + snum;        }        document.getElementById("timeDate").innerHTML = "本站已安全运行&nbsp" + dnum + "&nbsp天";        document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";    }    update();    setInterval(update, 1000);})();]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<div class="top-app-bar__title">  我的项目</div><div class="card card--elevated">  <div class="padding-3">    <h3 class="headline-small margin-top-0 margin-bottom-3">    酷客工具箱    </h3>    <div class="body-medum margin-bottom-3">      本软件适用于vivo/iqoo手机，借助系统开发测试的工具，实现一些正常情况下被阉割或者隐藏的功能。    </div>    <div class="display-flex justify-content-flex-end">    <button type="button" class="button button--filled" onclick="window.location.href='https://github.com/Yorick-Ryu/CokoTools/tree/release'">        查看源码      </button>      <button type="button" class="button button--filled" style="margin-left:10px;" onclick="window.location.href='https://www.coolapk.com/apk/com.yorick.cokotools'">        下载      </button>    </div>  </div></div>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[:root {  --opacity-state-hover: 8%;  --opacity-state-focus: 12%;  --opacity-state-press: 12%;  --opacity-state-drag: 16%;  --space-0: 0px;  --space-1: 4px;  --space-2: 8px;  --space-3: 16px;  --space-4: 32px;  --space-5: 64px;  --transition-duration: 0.2s;}@media (prefers-color-scheme: light) {  :root {    --color-primary: #543a92;    --color-on-primary: white;    --color-primary-container: #e1daf1;    --color-on-primary-container: #150e25;    --color-secondary: #615874;    --color-on-secondary: white;    --color-secondary-container: #e4e2e9;    --color-on-secondary-container: #18161d;    --color-tertiary: #7f4d5d;    --color-on-tertiary: white;    --color-tertiary-container: #ecdfe3;    --color-on-tertiary-container: #201317;    --color-error: #af251d;    --color-on-error: white;    --color-error-container: #f8d5d3;    --color-on-error-container: #2c0907;    --color-background: #fcfcfd;    --color-on-background: #19181b;    --color-surface: #fcfcfd;    --color-on-surface: #19181b;    --color-surface-1: #f4f2f8;    --color-surface-2: #efecf5;    --color-surface-3: #eae7f1;    --color-surface-4: #e8e5f0;    --color-surface-5: #e4e1ee;    --color-inverse-surface: #323036;    --color-on-inverse-surface: #f2f1f3;    --color-inverse-primary: #c3b6e2;    --color-disabled: rgba(25, 24, 27, 0.12);    --color-on-disabled: rgba(25, 24, 27, 0.38);    --color-surface-variant: #e6e5e6;    --color-on-surface-variant: #4d4a4f;    --color-outline: #807b84;    --shadow-0: none;    --shadow-1: 0 1px 2px rgba(25, 24, 27, 0.3);    --shadow-2: 0 2px 3px rgba(25, 24, 27, 0.3);    --shadow-3: 0 3px 4px rgba(25, 24, 27, 0.3);    --shadow-4: 0 4px 5px rgba(25, 24, 27, 0.3);    --shadow-5: 0 5px 6px rgba(25, 24, 27, 0.3);    --color-scrim: rgba(25, 24, 27, 0.5);  }}@media (prefers-color-scheme: dark) {  :root {    --color-primary: #c3b6e2;    --color-on-primary: #2a1d49;    --color-primary-container: #3f2b6e;    --color-on-primary-container: #e1daf1;    --color-secondary: #cac5d3;    --color-on-secondary: #312c3a;    --color-secondary-container: #494257;    --color-on-secondary-container: #e4e2e9;    --color-tertiary: #d8c0c7;    --color-on-tertiary: #3f272e;    --color-tertiary-container: #5f3a46;    --color-on-tertiary-container: #ecdfe3;    --color-error: #f0aba8;    --color-on-error: #57120f;    --color-error-container: #831c16;    --color-on-error-container: #f8d5d3;    --color-background: #19181b;    --color-on-background: #e5e4e7;    --color-surface: #19181b;    --color-on-surface: #e5e4e7;    --color-surface-1: #1c1a21;    --color-surface-2: #1e1b25;    --color-surface-3: #1f1c28;    --color-surface-4: #201c29;    --color-surface-5: #211d2c;    --color-inverse-surface: #e5e4e7;    --color-on-inverse-surface: #323036;    --color-inverse-primary: #543a92;    --color-disabled: rgba(229, 228, 231, 0.12);    --color-on-disabled: rgba(229, 228, 231, 0.38);    --color-surface-variant: #4c4851;    --color-on-surface-variant: #cbc9cf;    --color-outline: #98939f;    --shadow-0: none;    --shadow-1: 0 1px 2px rgba(229, 228, 231, 0.3);    --shadow-2: 0 2px 3px rgba(229, 228, 231, 0.3);    --shadow-3: 0 3px 4px rgba(229, 228, 231, 0.3);    --shadow-4: 0 4px 5px rgba(229, 228, 231, 0.3);    --shadow-5: 0 5px 6px rgba(229, 228, 231, 0.3);    --color-scrim: rgba(229, 228, 231, 0.1);  }}:root .light-scheme {  color-scheme: light;  --color-primary: #543a92;  --color-on-primary: white;  --color-primary-container: #e1daf1;  --color-on-primary-container: #150e25;  --color-secondary: #615874;  --color-on-secondary: white;  --color-secondary-container: #e4e2e9;  --color-on-secondary-container: #18161d;  --color-tertiary: #7f4d5d;  --color-on-tertiary: white;  --color-tertiary-container: #ecdfe3;  --color-on-tertiary-container: #201317;  --color-error: #af251d;  --color-on-error: white;  --color-error-container: #f8d5d3;  --color-on-error-container: #2c0907;  --color-background: #fcfcfd;  --color-on-background: #19181b;  --color-surface: #fcfcfd;  --color-on-surface: #19181b;  --color-surface-1: #f4f2f8;  --color-surface-2: #efecf5;  --color-surface-3: #eae7f1;  --color-surface-4: #e8e5f0;  --color-surface-5: #e4e1ee;  --color-inverse-surface: #323036;  --color-on-inverse-surface: #f2f1f3;  --color-inverse-primary: #c3b6e2;  --color-disabled: rgba(25, 24, 27, 0.12);  --color-on-disabled: rgba(25, 24, 27, 0.38);  --color-surface-variant: #e6e5e6;  --color-on-surface-variant: #4d4a4f;  --color-outline: #807b84;  --shadow-0: none;  --shadow-1: 0 1px 2px rgba(25, 24, 27, 0.3);  --shadow-2: 0 2px 3px rgba(25, 24, 27, 0.3);  --shadow-3: 0 3px 4px rgba(25, 24, 27, 0.3);  --shadow-4: 0 4px 5px rgba(25, 24, 27, 0.3);  --shadow-5: 0 5px 6px rgba(25, 24, 27, 0.3);  --color-scrim: rgba(25, 24, 27, 0.5);}:root .dark-scheme {  color-scheme: dark;  --color-primary: #c3b6e2;  --color-on-primary: #2a1d49;  --color-primary-container: #3f2b6e;  --color-on-primary-container: #e1daf1;  --color-secondary: #cac5d3;  --color-on-secondary: #312c3a;  --color-secondary-container: #494257;  --color-on-secondary-container: #e4e2e9;  --color-tertiary: #d8c0c7;  --color-on-tertiary: #3f272e;  --color-tertiary-container: #5f3a46;  --color-on-tertiary-container: #ecdfe3;  --color-error: #f0aba8;  --color-on-error: #57120f;  --color-error-container: #831c16;  --color-on-error-container: #f8d5d3;  --color-background: #19181b;  --color-on-background: #e5e4e7;  --color-surface: #19181b;  --color-on-surface: #e5e4e7;  --color-surface-1: #1c1a21;  --color-surface-2: #1e1b25;  --color-surface-3: #1f1c28;  --color-surface-4: #201c29;  --color-surface-5: #211d2c;  --color-inverse-surface: #e5e4e7;  --color-on-inverse-surface: #323036;  --color-inverse-primary: #543a92;  --color-disabled: rgba(229, 228, 231, 0.12);  --color-on-disabled: rgba(229, 228, 231, 0.38);  --color-surface-variant: #4c4851;  --color-on-surface-variant: #cbc9cf;  --color-outline: #98939f;  --shadow-0: none;  --shadow-1: 0 1px 2px rgba(229, 228, 231, 0.3);  --shadow-2: 0 2px 3px rgba(229, 228, 231, 0.3);  --shadow-3: 0 3px 4px rgba(229, 228, 231, 0.3);  --shadow-4: 0 4px 5px rgba(229, 228, 231, 0.3);  --shadow-5: 0 5px 6px rgba(229, 228, 231, 0.3);  --color-scrim: rgba(229, 228, 231, 0.1);}*,*::before,*::after {  box-sizing: border-box;}html {  margin: 0;  padding: 0;}body {  margin: 0;  padding: 0;  font-family: sans-serif;  line-height: 1.5;  background: var(--color-background);  color: var(--color-on-background);}a {  color: var(--color-primary);}img {  max-width: 100%;}.animate {  animation-duration: 0.15s;  animation-fill-mode: both;}@keyframes zoomIn {  from {    opacity: 0;    transform: scale3d(0.3, 0.3, 0.3);  }  50% {    opacity: 1;  }}.animate--zoom-in {  animation-name: zoomIn;}@keyframes zoomOut {  from {    opacity: 1;  }  50% {    opacity: 0;    transform: scale3d(0.3, 0.3, 0.3);  }  to {    opacity: 0;  }}.animate--zoom-out {  animation-name: zoomOut;}@keyframes fadeIn {  from {    opacity: 0;  }  to {    opacity: 1;  }}.animate--fade-in {  animation-name: fadeIn;}@keyframes fadeOut {  from {    opacity: 1;  }  to {    opacity: 0;  }}.animate--fade-out {  animation-name: fadeOut;}@keyframes drawerIn {  from {    margin-left: -240px;  }  to {    margin-left: 0;  }}.animate--drawer-in {  animation-name: drawerIn;}@keyframes drawerOut {  from {    margin-left: 0;  }  to {    margin-left: -256px;  }}.animate--drawer-out {  animation-name: drawerOut;}@keyframes sheetIn {  from {    margin-right: -256px;  }  to {    margin-right: 0;  }}.animate--sheet-in {  animation-name: sheetIn;}@keyframes sheetOut {  from {    margin-right: 0;  }  to {    margin-right: -240px;  }}.animate--sheet-out {  animation-name: sheetOut;}@keyframes scaleIn {  from {    transform: scale(0);  }  to {    transform: scale(1);  }}.animate--scale-in {  animation-name: scaleIn;}@keyframes scaleOut {  from {    transform: scale(1);  }  to {    transform: scale(0);  }}.animate--scale-out {  animation-name: scaleOut;}@keyframes headShake {  0% {    transform: translateX(0);  }  6.5% {    transform: translateX(-6px) rotateY(-9deg);  }  18.5% {    transform: translateX(5px) rotateY(7deg);  }  31.5% {    transform: translateX(-3px) rotateY(-5deg);  }  43.5% {    transform: translateX(2px) rotateY(3deg);  }  50% {    transform: translateX(0);  }}.headShake {  animation-timing-function: ease-in-out;  animation-name: headShake;}.display-large {  font-size: 57px;  line-height: 64px;  font-weight: 400;}.display-medium {  font-size: 45px;  line-height: 52px;  font-weight: 400;}.display-small {  font-size: 36px;  line-height: 44px;  font-weight: 400;}.headline-large {  font-size: 32px;  line-height: 40px;  font-weight: 400;}.headline-medium {  font-size: 28px;  line-height: 36px;  font-weight: 400;}.headline-small {  font-size: 24px;  line-height: 32px;  font-weight: 400;}.title-large {  font-size: 22px;  line-height: 28px;  font-weight: 400;}.title-medium {  font-size: 16px;  line-height: 24px;  font-weight: 500;}.title-small {  font-size: 14px;  line-height: 20px;  font-weight: 500;}.label-large {  font-size: 14px;  line-height: 20px;  font-weight: 500;}.label-medium {  font-size: 12px;  line-height: 16px;  font-weight: 500;}.label-small {  font-size: 11px;  line-height: 16px;  font-weight: 500;}.body-large {  font-size: 16px;  line-height: 24px;  font-weight: 500;}.body-medium {  font-size: 14px;  line-height: 20px;  font-weight: 500;}.body-small {  font-size: 12px;  line-height: 16px;}.badge {  position: absolute;  top: 0;  left: 50%;  background-color: var(--color-error);  color: var(--color-on-error);  z-index: 1;}.badge--small {  padding: 4px;  border-radius: 4px;  margin-left: 8px;}.badge--large {  padding: 0 4px;  border-radius: 8px;  line-height: 16px;  font-size: 11px;  font-weight: 500;}.button {  margin: 0;  display: inline-flex;  align-items: center;  outline: none;  text-align: center;  text-decoration: none;  box-sizing: border-box;  white-space: nowrap;  font-size: 16px;  vertical-align: middle;  background: transparent;  cursor: pointer;  position: relative;}.button::after {  content: "";  position: absolute;  inset: 0;  background-color: currentColor;  opacity: 0;  border-radius: inherit;  pointer-events: none;}.button:hover::after {  opacity: var(--opacity-state-hover);}.button:focus::after {  opacity: var(--opacity-state-focus);}.button:active::after {  opacity: var(--opacity-state-press);}.button--disabled,button[disabled] {  pointer-events: none;}.button__icon {  width: 18px;  height: 18px;  font-size: 18px;}.button__icon svg {  height: 18px;  width: 18px;  fill: currentColor;}.button__icon .material-icons {  font-size: 18px;}.button__icon:first-child {  margin: 0 8px 0 -8px;}.button__icon:last-child {  margin: 0 -8px 0 8px;}.button--elevated {  color: var(--color-primary);  line-height: 20px;  font-size: 14px;  padding: 10px 24px;  border: 0;  border-radius: 20px;  text-align: center;  font-weight: 500;  box-shadow: var(--shadow-1);  background-color: var(--color-surface-1);}.button--elevated:hover {  background-color: var(--color-surface-2);  box-shadow: var(--shadow-2);}.button--elevated:focus {  background-color: var(--color-surface-1);  box-shadow: var(--shadow-1);}.button--elevated:active {  background-color: var(--color-surface-1);  box-shadow: var(--shadow-1);}.button--elevated:disabled {  color: var(--color-on-disabled);  background-color: var(--color-disabled);  box-shadow: var(--shadow-0);}.button--filled {  color: var(--color-on-primary);  line-height: 20px;  font-size: 14px;  padding: 10px 24px;  border: 0;  border-radius: 20px;  text-align: center;  font-weight: 500;  box-shadow: var(--shadow-0);  background-color: var(--color-primary);}.button--filled:hover {  box-shadow: var(--shadow-1);}.button--filled:focus {  box-shadow: var(--shadow-0);}.button--filled:active {  box-shadow: var(--shadow-0);}.button--filled:disabled {  color: var(--color-on-disabled);  background-color: var(--color-disabled);  box-shadow: var(--shadow-0);}.button--filled-tonal {  color: var(--color-on-secondary-container);  line-height: 20px;  font-size: 14px;  padding: 10px 24px;  border: 0;  border-radius: 20px;  text-align: center;  font-weight: 500;  box-shadow: var(--shadow-0);  background-color: var(--color-secondary-container);}.button--filled-tonal:hover {  box-shadow: var(--shadow-1);}.button--filled-tonal:focus {  box-shadow: var(--shadow-0);}.button--filled-tonal:active {  box-shadow: var(--shadow-0);}.button--filled-tonal:disabled {  color: var(--color-on-disabled);  background-color: var(--color-disabled);  box-shadow: var(--shadow-0);}.button--outlined {  color: var(--color-primary);  line-height: 20px;  font-size: 14px;  padding: 10px 24px;  border: 0;  border-radius: 20px;  text-align: center;  font-weight: 500;  background: transparent;  box-shadow: 0 0 0 1px var(--color-outline);}.button--outlined:focus::before {  border: 1px solid var(--color-primary);}.button--outlined.button--surface::before {  background: var(--color-surface);}.button--outlined:disabled {  color: var(--color-on-disabled);  box-shadow: 0 0 0 1px var(--color-disabled);}.button--text {  color: var(--color-primary);  line-height: 20px;  font-size: 14px;  padding: 10px 12px;  border: 0;  border-radius: 20px;  text-align: center;  font-weight: 500;  background: transparent;  min-width: 48px;}.button--text:disabled {  color: var(--color-on-disabled);}.button--text .button__icon:first-child {  margin: 0 4px 0 0;}.button--text .button__icon:last-child {  margin: 0 0 0 4px;}.button--text .button__label {  margin: 0 4px;}.button--icon {  color: var(--color-primary);  line-height: 1;  font-size: 24px;  padding: 8px;  border: 0;  border-radius: 20px;  text-align: center;  font-weight: 500;  background: transparent;}.button--icon svg {  height: 24px;  width: 24px;  fill: currentColor;}.button--icon .material-icons {  font-size: 24px;}.button--icon:disabled {  color: var(--color-on-disabled);}.button--floating-action {  color: var(--color-on-primary-container);  line-height: 1;  padding: 16px;  border: 0;  border-radius: 16px;  text-align: center;  font-weight: 500;  background-color: var(--color-primary-container);  box-shadow: var(--shadow-3);}.button--floating-action svg {  height: 24px;  width: 24px;  fill: currentColor;}.button--floating-action .material-icons {  font-size: 24px;}.button--floating-action .button__icon {  height: 24px;  width: 24px;  font-size: 24px;  margin: 0 8px 0 0;}.button--floating-action .button__label {  margin: 4px;}.button--floating-action.button--small {  padding: 8px;  border-radius: 12px;}.button--floating-action.button--large {  font-size: 36px;  padding: 30px;  border-radius: 28px;}.button--floating-action.button--large svg {  height: 36px;  width: 36px;}.button--floating-action.button--large .material-icons {  font-size: 36px;}.button--floating-action.button--surface {  color: var(--color-primary);  background-color: var(--color-surface);}.button--floating-action.button--secondary {  color: var(--color-on-secondary-container);  background-color: var(--color-secondary-container);}.button--floating-action.button--tertiary {  color: var(--color-on-tertiary-container);  background-color: var(--color-tertiary-container);}.button--floating-action:hover {  box-shadow: var(--shadow-4);}.button--floating-action:focus {  box-shadow: var(--shadow-3);}.button--floating-action:active {  box-shadow: var(--shadow-3);}.button--floating-action.button--lowered {  box-shadow: var(--shadow-1);}.button--floating-action.button--lowered:hover {  box-shadow: var(--shadow-2);}.button--floating-action.button--lowered:focus {  box-shadow: var(--shadow-1);}.button--floating-action.button--lowered:active {  box-shadow: var(--shadow-1);}.button--floating-action:disabled {  color: var(--color-on-disabled);  background-color: var(--color-disabled);  box-shadow: var(--shadow-0);}.card {  display: block;  text-decoration: none;  border-radius: 12px;}a.card {  position: relative;}a.card::after {  content: "";  position: absolute;  inset: 0;  background-color: currentColor;  opacity: 0;  border-radius: inherit;  pointer-events: none;}a.card:hover::after {  opacity: var(--opacity-state-hover);}a.card:focus::after {  opacity: var(--opacity-state-focus);}a.card:active::after {  opacity: var(--opacity-state-press);}.card--elevated {  color: var(--color-on-surface);  background-color: var(--color-surface-1);  box-shadow: var(--shadow-1);}a.card--elevated:hover {  box-shadow: var(--shadow-2);}a.card--elevated:focus {  box-shadow: var(--shadow-1);}a.card--elevated:active {  box-shadow: var(--shadow-1);}.card--filled {  color: var(--color-on-surface-variant);  background-color: var(--color-surface-variant);}a.card--filled:hover {  box-shadow: var(--shadow-1);}a.card--filled:focus {  box-shadow: var(--shadow-1);}a.card--filled:active {  box-shadow: var(--shadow-0);}.card--outlined {  color: var(--color-on-surface);  background-color: var(--color-surface);  box-shadow: 0 0 0 1px var(--color-outline);}.checkbox {  display: inline-block;  position: relative;  height: 40px;  width: 40px;  border-radius: 50%;  color: var(--color-primary);  cursor: pointer;  position: relative;}.checkbox::after {  content: "";  position: absolute;  inset: 0;  background-color: currentColor;  opacity: 0;  border-radius: inherit;  pointer-events: none;}.checkbox:hover::after {  opacity: var(--opacity-state-hover);}.checkbox:focus::after {  opacity: var(--opacity-state-focus);}.checkbox:active::after {  opacity: var(--opacity-state-press);}.checkbox input[type=checkbox] {  display: none;}.checkbox input[type=checkbox]:checked ~ .checkbox__icon {  border-color: var(--color-primary);  background: var(--color-primary);}.checkbox input[type=checkbox]:checked ~ .checkbox__icon::after {  display: block;}.checkbox--disabled {  pointer-events: none;}.checkbox--disabled .checkbox__icon {  border-color: var(--color-disabled);}.checkbox__icon {  position: absolute;  width: 18px;  height: 18px;  top: 11px;  left: 11px;  border: 2px solid var(--color-on-background);  border-radius: 2px;  transition: background-color var(--transition-duration), border-color var(--transition-duration);}.checkbox__icon::after {  display: none;  content: "";  position: absolute;  top: 0px;  left: 4px;  width: 6px;  height: 12px;  border-right: 2px solid var(--color-on-primary);  border-bottom: 2px solid var(--color-on-primary);  transform: rotate(45deg);}.chip {  display: inline-flex;  align-items: center;  font-size: 14px;  font-weight: 500;  line-height: 20px;  padding: 6px 16px;  border: none;  border-radius: 8px;  vertical-align: middle;  cursor: pointer;  outline: none;  box-shadow: 0 0 0 1px var(--color-outline);  background-color: var(--color-surface);  position: relative;}.chip::after {  content: "";  position: absolute;  inset: 0;  background-color: currentColor;  opacity: 0;  border-radius: inherit;  pointer-events: none;}.chip:hover::after {  opacity: var(--opacity-state-hover);}.chip:focus::after {  opacity: var(--opacity-state-focus);}.chip:active::after {  opacity: var(--opacity-state-press);}.chip--disabled {  pointer-events: none;}.chip__icon {  width: 18px;  height: 18px;  font-size: 18px;}.chip__icon svg {  height: 18px;  width: 18px;  fill: currentColor;}.chip__icon .material-icons {  font-size: 18px;}.chip__icon:first-child {  margin: 0 8px 0 -8px;}.chip__icon:last-child {  margin: 0 -8px 0 8px;}.chip__avatar {  width: 24px;  height: 24px;  font-size: 24px;}.chip__avatar svg {  height: 24px;  width: 24px;  fill: currentColor;}.chip__avatar .material-icons {  font-size: 24px;}.chip__avatar:first-child {  margin: -2px 8px -2px -12px;}.chip__avatar:last-child {  margin: -2px -12px -2px 8px;}.chip__action {  width: 24px;  height: 24px;}.chip__action .button--icon {  font-size: 18px;  padding: 3px;  border-radius: 12px;  color: currentColor;}.chip__action .button--icon svg {  height: 18px;  width: 18px;}.chip__action .button--icon .material-icons {  font-size: 18px;}.chip__action .button--icon::after {  background-color: currentColor;}.chip__action:first-child {  margin: -2px 8px -2px -12px;}.chip__action:last-child {  margin: -2px -12px -2px 8px;}.chip--assist {  color: var(--color-on-surface);}.chip--assist .chip__icon {  color: var(--color-primary);}.chip--filter {  color: var(--color-on-surface-variant);}.chip--filter .chip__icon {  color: var(--color-on-surface-variant);}.chip--input {  color: var(--color-on-surface-variant);}.chip--input .chip__icon {  color: var(--color-on-surface-variant);}.chip--suggestion {  color: var(--color-on-surface-variant);}.chip--suggestion .chip__icon {  color: var(--color-on-surface-variant);}.chip--elevated {  background-color: var(--color-surface-1);  box-shadow: var(--shadow-1);}.chip--elevated:hover {  box-shadow: var(--shadow-2);}.chip--elevated:focus {  box-shadow: var(--shadow-1);}.chip--elevated:active {  box-shadow: var(--shadow-1);}.chip--elevated.chip--disabled {  box-shadow: var(--shadow-0);  background-color: var(--color-disabled);}.chip--selected {  color: var(--color-on-secondary-container);  background-color: var(--color-secondary-container);  box-shadow: none;}.chip--selected .chip__icon {  color: var(--color-on-secondary-container);}.chip--selected:hover {  box-shadow: var(--shadow-1);}.chip--selected.chip--disabled {  background-color: var(--color-disabled);}.chip--disabled {  color: var(--color-on-disabled);}.chip--disabled .chip__icon {  color: var(--color-on-disabled);}.dialog {  position: fixed;  inset: 0;  z-index: 64;  padding: 56px;  display: flex;  align-items: center;  justify-content: center;  overflow: hidden;  visibility: hidden;  opacity: 0;  transition-property: visibility, opacity;  transition-duration: var(--transition-duration);}.dialog-toggle {  display: none;}.dialog__container {  border-radius: 28px;  min-width: 280px;  max-width: 560px;  max-height: 100%;  background: var(--color-surface-3);  color: var(--color-on-surface);  z-index: 1;  display: flex;  flex-direction: column;  transform: scale(0);  transition: transform var(--transition-duration);}.dialog__scrim {  display: block;  position: absolute;  inset: 0;  background-color: var(--color-scrim);}.dialog-toggle:checked + .dialog,.dialog--open {  opacity: 1;  visibility: visible;}.dialog-toggle:checked + .dialog .dialog__container,.dialog--open .dialog__container {  transform: scale(1);}.dialog__header {  flex-shrink: 0;  padding: 24px;}.dialog__body {  overflow: auto;  flex-grow: 1;  padding: 24px;}.dialog__footer {  flex-shrink: 0;  padding: 24px;}.dialog__actions {  display: flex;  justify-content: flex-end;  gap: 8px;}.dialog .top-app-bar {  border-radius: 28px 28px 0 0;  padding: 4px;}@media (max-width: 600px) {  .dialog--full-screen {    background: var(--color-surface);    padding: 0;  }  .dialog--full-screen .dialog__container {    border-radius: 0;    width: 100%;    height: 100%;    max-width: none;  }}.dropdown {  position: relative;  display: inline-block;}.dropdown__container {  position: absolute;  top: 100%;  padding: 8px 0;  color: var(--color-on-surface);  background-color: var(--color-surface);  box-shadow: var(--shadow-1);  border-radius: 4px;  min-width: 240px;  z-index: 1;  transform-origin: top left;  transform: scale(0);  visibility: hidden;  transition-property: transform, visibility;  transition-duration: var(--transition-duration);}.dropdown:focus-within .dropdown__container,.dropdown--open .dropdown__container {  transform: scale(1);  visibility: visible;}.dropdown--right .dropdown__container {  transform-origin: top right;  right: 0;}.dropdown--bottom .dropdown__container {  transform-origin: bottom left;  top: auto;  bottom: 100%;}.dropdown--right.dropdown--bottom .dropdown__container {  transform-origin: bottom right;}.dropdown__item {  display: flex;  gap: 16px;  align-items: center;  width: 100%;  border: none;  outline: none;  background: transparent;  font-size: 1em;  font-family: sans-serif;  padding: 8px 16px;  line-height: 24px;  text-decoration: none;  color: var(--color-on-background);  cursor: pointer;  position: relative;}.dropdown__item::after {  content: "";  position: absolute;  inset: 0;  background-color: currentColor;  opacity: 0;  border-radius: inherit;  pointer-events: none;}.dropdown__item:hover::after {  opacity: var(--opacity-state-hover);}.dropdown__item:focus::after {  opacity: var(--opacity-state-focus);}.dropdown__item:active::after {  opacity: var(--opacity-state-press);}.dropdown__item__icon {  height: 24px;  width: 24px;  color: var(--color-on-background);}.dropdown__item__icon svg {  height: 24px;  width: 24px;  fill: currentColor;}.form__field {  margin-bottom: 12px;  flex-grow: 1;}.form__row {  display: flex;  margin: 0 -8px;}.form__row .form__field {  padding: 0 8px;}.form__label {  display: block;  padding: 8px;  color: var(--color-on-background);}.form__control {  display: flex;  cursor: pointer;}.form__control--inline {  display: inline-flex;}.form__control__label {  padding: 8px;  line-height: 24px;  cursor: pointer;  flex-grow: 1;}.navigation-bar {  position: fixed;  bottom: 0;  width: 100%;  display: flex;  align-items: center;  background-color: var(--color-surface-2);  color: var(--color-on-surface-variant);  z-index: 16;}.navigation-bar__item {  position: relative;  text-decoration: none;  display: flex;  padding: 12px 0 16px;  gap: 4px;  flex-direction: column;  align-items: center;  color: var(--color-on-surface-variant);  width: 100%;  position: relative;}.navigation-bar__item::after {  content: "";  position: absolute;  inset: 0;  background-color: currentColor;  opacity: 0;  border-radius: inherit;  pointer-events: none;}.navigation-bar__item:hover::after {  opacity: var(--opacity-state-hover);}.navigation-bar__item:focus::after {  opacity: var(--opacity-state-focus);}.navigation-bar__item:active::after {  opacity: var(--opacity-state-press);}.navigation-bar__item__icon {  line-height: 0;  padding: 4px 20px;  border-radius: 16px;  color: var(--color-on-surface-variant);  position: relative;}.navigation-bar__item__icon svg {  height: 24px;  width: 24px;}.navigation-bar__item__icon .material-icons {  font-size: 24px;}.navigation-bar__item__label {  line-height: 16px;  font-size: 12px;  font-weight: 500;}.navigation-bar__item--active {  color: var(--color-on-surface);}.navigation-bar__item--active .navigation-bar__item__icon {  color: var(--color-on-primary-container);  background-color: var(--color-primary-container);}.navigation-drawer {  position: fixed;  width: auto;  inset: 0;  opacity: 0;  visibility: hidden;  transition-property: visibility, opacity;  transition-duration: var(--transition-duration);  z-index: 32;}.navigation-drawer__container {  box-sizing: border-box;  background-color: var(--color-surface);  color: var(--color-on-surface);  overflow: auto;  width: 360px;  position: absolute;  top: 0;  bottom: 0;  z-index: 1;  padding: 12px;  border-radius: 0 16px 16px 0;  transform: translateX(-100%);  transition: transform var(--transition-duration);}.navigation-drawer__scrim {  position: absolute;  inset: 0;  background-color: var(--color-scrim);  z-index: 0;}.navigation-drawer-toggle {  display: none;}.navigation-drawer-toggle:checked + .navigation-drawer,.navigation-drawer--open {  opacity: 1;  visibility: visible;}.navigation-drawer-toggle:checked + .navigation-drawer .navigation-drawer__container,.navigation-drawer--open .navigation-drawer__container {  transform: translateX(0);}@media (min-width: 1240px) {  .navigation-drawer:not(.navigation-drawer--modal) {    position: static;    width: 360px;    opacity: 1;    visibility: visible;  }  .navigation-drawer:not(.navigation-drawer--modal) .navigation-drawer__container {    border-radius: 0;    position: fixed;    top: 0;    bottom: 0;    transform: translateX(0);  }  .navigation-drawer:not(.navigation-drawer--modal) .navigation-drawer__scrim {    display: none;  }}.navigation-drawer__item {  padding: 18px 24px;  display: flex;  text-decoration: none;  line-height: 20px;  font-size: 14px;  font-weight: 500;  align-items: center;  border-radius: 28px;  position: relative;  overflow: hidden;  color: var(--color-on-surface-variant);  outline: none;  background-color: var(--color-surface);  cursor: pointer;  position: relative;}.navigation-drawer__item::after {  content: "";  position: absolute;  inset: 0;  background-color: currentColor;  opacity: 0;  border-radius: inherit;  pointer-events: none;}.navigation-drawer__item:hover::after {  opacity: var(--opacity-state-hover);}.navigation-drawer__item:focus::after {  opacity: var(--opacity-state-focus);}.navigation-drawer__item:active::after {  opacity: var(--opacity-state-press);}.navigation-drawer__item.navigation-drawer__item--active {  color: var(--color-on-primary-container);  background-color: var(--color-primary-container);}.navigation-drawer__item__icon {  height: 24px;  width: 24px;}.navigation-drawer__item__icon:first-child {  margin: -2px 12px -2px -8px;}.navigation-drawer__item__icon:last-child {  margin: -2px -8px -2px 12px;}.navigation-drawer__item__label {  flex-grow: 1;}.navigation-rail {  width: 80px;  flex-shrink: 0;}.navigation-rail__container {  position: fixed;  top: 0;  bottom: 0;  width: 80px;  display: flex;  flex-direction: column;  gap: 8px;  padding: 12px 0;  align-items: center;  background-color: var(--color-surface);  color: var(--color-on-surface-variant);}.navigation-rail__container .button--icon {  padding: 16px;  border-radius: 28px;}.navigation-rail__container .button--floating-action {  box-shadow: none;}.navigation-rail__item {  position: relative;  padding: 8px;  text-decoration: none;  display: flex;  gap: 4px;  flex-direction: column;  align-items: center;  color: var(--color-on-surface-variant);  width: 100%;  position: relative;}.navigation-rail__item::after {  content: "";  position: absolute;  inset: 0;  background-color: currentColor;  opacity: 0;  border-radius: inherit;  pointer-events: none;}.navigation-rail__item:hover::after {  opacity: var(--opacity-state-hover);}.navigation-rail__item:focus::after {  opacity: var(--opacity-state-focus);}.navigation-rail__item:active::after {  opacity: var(--opacity-state-press);}.navigation-rail__item__icon {  line-height: 0;  padding: 4px 16px;  border-radius: 16px;  color: var(--color-on-surface-variant);  position: relative;}.navigation-rail__item__icon svg {  height: 24px;  width: 24px;}.navigation-rail__item__icon .material-icons {  font-size: 24px;}.navigation-rail__item__label {  line-height: 16px;  font-size: 12px;  font-weight: 500;}.navigation-rail__item--active {  color: var(--color-on-surface);}.navigation-rail__item--active .navigation-rail__item__icon {  color: var(--color-on-primary-container);  background-color: var(--color-primary-container);}.pagination {  display: flex;}.pagination .button--active {  color: var(--color-primary);}.pagination .button--active::after {  opacity: 0.1;}.pagination__info {  padding: 6px;}.pagination__item {  padding: 0 2px;}.pagination__ellipsis {  color: var(--color-on-background);  padding: 6px;}.radio {  display: inline-block;  position: relative;  height: 40px;  width: 40px;  cursor: pointer;  border-radius: 50%;  color: var(--color-primary);  position: relative;}.radio::after {  content: "";  position: absolute;  inset: 0;  background-color: currentColor;  opacity: 0;  border-radius: inherit;  pointer-events: none;}.radio:hover::after {  opacity: var(--opacity-state-hover);}.radio:focus::after {  opacity: var(--opacity-state-focus);}.radio:active::after {  opacity: var(--opacity-state-press);}.radio input[type=radio] {  display: none;}.radio input[type=radio]:checked ~ .radio__icon {  border-color: var(--color-primary);}.radio input[type=radio]:checked ~ .radio__icon::after {  opacity: 1;  transform: scale(0.5);}.radio--disabled {  pointer-events: none;}.radio--disabled .radio__icon {  border-color: var(--color-disabled);}.radio__icon {  position: absolute;  width: 18px;  height: 18px;  top: 11px;  left: 11px;  border: 2px solid var(--color-on-background);  border-radius: 50%;  transition: border-color var(--transition-duration);}.radio__icon::after {  content: "";  display: block;  border-radius: 50%;  background: var(--color-primary);  width: 100%;  height: 100%;  position: absolute;  top: 0;  left: 0;  opacity: 0;  transform: scale(0);  transition: transform var(--transition-duration);}.sheet {  position: fixed;  width: auto;  inset: 0;  visibility: hidden;  opacity: 0;  transition-property: visibility, opacity;  transition-duration: var(--transition-duration);  z-index: 32;}.sheet__container {  box-sizing: border-box;  background-color: var(--color-surface);  color: var(--color-on-surface);  overflow: auto;  width: 320px;  position: absolute;  top: 0;  right: 0;  bottom: 0;  z-index: 1;  padding: 12px;  border-radius: 16px 0 0 16px;  transform: translateX(100%);  transition: transform var(--transition-duration);}.sheet__scrim {  position: absolute;  inset: 0;  background-color: var(--color-scrim);  z-index: 0;}.sheet-toggle {  display: none;}.sheet-toggle:checked + .sheet,.sheet--open {  opacity: 1;  visibility: visible;}.sheet-toggle:checked + .sheet .sheet__container,.sheet--open .sheet__container {  transform: translateX(0);}@media (min-width: 1240px) {  .sheet:not(.sheet--modal) {    position: static;    width: 320px;    opacity: 1;    visibility: visible;  }  .sheet:not(.sheet--modal) .sheet__container {    border-radius: 0;    position: fixed;    top: 0;    right: 0;    bottom: 0;    transform: translateX(0);  }  .sheet:not(.sheet--modal) .sheet__scrim {    display: none;  }}.snackbar-container {  position: fixed;  left: 16px;  bottom: 16px;  z-index: 8;}.snackbar {  display: flex;  justify-content: space-between;  align-items: center;  background: var(--color-inverse-surface);  color: var(--color-on-inverse-surface);  padding: var(--space-3);  font-size: 14px;  border-radius: 4px;  min-width: 288px;  max-width: 568px;}.snackbar .button--text {  margin: -10px -12px;  color: var(--color-inverse-primary);}.snackbar + .snackbar {  margin-top: 16px;}.switch {  display: inline-block;  height: 40px;  width: 56px;  position: relative;}.switch input[type=checkbox] {  display: none;}.switch input[type=checkbox]:checked ~ .switch__track {  background-color: var(--color-primary);}.switch input[type=checkbox]:checked ~ .switch__thumb {  left: 20px;}.switch input[type=checkbox]:checked ~ .switch__thumb::before {  background-color: var(--color-primary);}.switch input[type=checkbox]:disabled ~ .switch__track {  pointer-events: none;  background-color: var(--color-disabled);}.switch input[type=checkbox]:disabled ~ .switch__thumb {  pointer-events: none;}.switch input[type=checkbox]:disabled ~ .switch__thumb::before {  background-color: var(--color-on-disabled);}.switch__track {  height: 16px;  width: 36px;  background: var(--color-on-background);  position: absolute;  top: 12px;  left: 12px;  border-radius: 8px;  opacity: 0.5;  cursor: pointer;}.switch__thumb {  height: 40px;  width: 40px;  position: absolute;  top: 0;  left: 0;  transition: left var(--transition-duration);  color: var(--color-primary);  border-radius: 50%;  cursor: pointer;  position: relative;}.switch__thumb::after {  content: "";  position: absolute;  inset: 0;  background-color: currentColor;  opacity: 0;  border-radius: inherit;  pointer-events: none;}.switch__thumb:hover::after {  opacity: var(--opacity-state-hover);}.switch__thumb:focus::after {  opacity: var(--opacity-state-focus);}.switch__thumb:active::after {  opacity: var(--opacity-state-press);}.switch__thumb::before {  display: block;  content: "";  width: 20px;  height: 20px;  position: absolute;  top: 10px;  left: 10px;  border-radius: 50%;  background: white;  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);  z-index: 1;  transition: background-color var(--transition-duration);}.tab {  display: flex;  overflow: auto;  gap: 8px;}.tab__item {  padding: 10px 24px;  display: flex;  text-decoration: none;  line-height: 20px;  font-size: 14px;  font-weight: 500;  align-items: center;  border-radius: 20px;  position: relative;  overflow: hidden;  color: var(--color-on-surface);  outline: none;  background-color: var(--color-surface);  cursor: pointer;  position: relative;}.tab__item::after {  content: "";  position: absolute;  inset: 0;  background-color: currentColor;  opacity: 0;  border-radius: inherit;  pointer-events: none;}.tab__item:hover::after {  opacity: var(--opacity-state-hover);}.tab__item:focus::after {  opacity: var(--opacity-state-focus);}.tab__item:active::after {  opacity: var(--opacity-state-press);}.tab__item--active {  color: var(--color-on-primary-container);  background-color: var(--color-primary-container);}.table {  width: 100%;  border-spacing: 0;  overflow: auto;}.table th,.table td {  padding: 12px 16px;  font-size: 14px;  line-height: 24px;  text-align: left;  border-bottom: 1px solid var(--color-outline);  white-space: nowrap;}.table tbody tr:last-child th, .table tbody tr:last-child td {  border-bottom: none;}.table th {  font-weight: bold;}.top-app-bar {  color: var(--color-on-surface);  background-color: var(--color-surface);  box-shadow: var(--shadow-0);  display: flex;  align-items: flex-start;  padding: 8px 4px;}.top-app-bar--sticky-top {  position: sticky;  top: 0;  z-index: 16;}.top-app-bar--on-scroll {  box-shadow: var(--shadow-2);}.top-app-bar__title {  line-height: 28px;  font-size: 22px;  font-weight: 400;  flex-grow: 1;  padding: 10px 12px;}.top-app-bar__title a {  text-decoration: none;  color: inherit;}.top-app-bar__action {  padding: 4px;}.top-app-bar__action .button--icon {  color: var(--color-on-surface-variant);}.top-app-bar__action:first-child .button--icon {  color: var(--color-on-surface);}.top-app-bar__avatar {  padding: 9px;  line-height: 1;}.top-app-bar__avatar img {  width: 30px;  height: 30px;  border-radius: 15px;}.top-app-bar--medium .top-app-bar__title {  font-size: 24px;  line-height: 32px;  font-weight: 400;  padding-top: 48px;  padding-bottom: 16px;}.top-app-bar--large .top-app-bar__title {  font-size: 28px;  line-height: 36px;  font-weight: 400;  padding-top: 84px;  padding-bottom: 16px;}.text-field {  width: 100%;}.text-field .text-field__container {  display: flex;  position: relative;}.text-field label {  pointer-events: none;}.text-field .text-field__input {  display: block;  border: none;  margin: 0;  outline: none;  font-family: sans-serif;  flex-grow: 1;  color: var(--color-on-surface);}.text-field select.text-field__input {  -webkit-appearance: none;  -moz-appearance: none;  appearance: none;  padding-right: 48px;  background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDI0IDI0IiB3aWR0aD0iMjRweCIgZmlsbD0iIzAwMDAwMCI+PHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPjxwYXRoIGQ9Ik03IDEwbDUgNSA1LTV6Ii8+PC9zdmc+");  background-repeat: no-repeat;  background-position: right 12px center;}.text-field--filled {  color: var(--color-on-surface);}.text-field--filled .text-field__container {  border-radius: 4px 4px 0 0;  background-color: var(--color-surface-1);  transition: background-color var(--transition-duration);}.text-field--filled .text-field__container::before {  content: "";  border-bottom: 1px solid var(--color-outline);  position: absolute;  inset: 0;  pointer-events: none;  transition: border-color var(--transition-duration);}.text-field--filled .text-field__container:hover {  background-color: var(--color-surface-2);}.text-field--filled .text-field__container:focus-within {  background-color: var(--color-surface-3);}.text-field--filled .text-field__container:focus-within::before {  border-bottom: 2px solid var(--color-primary);}.text-field--filled .text-field__container:focus-within .text-field__label {  font-size: 12px;  top: 8px;  color: var(--color-primary);}.text-field--filled.text-field--error .text-field__container::before {  border-color: var(--color-error);}.text-field--filled.text-field--error .text-field__container::after {  background-color: var(--color-error);}.text-field--filled .text-field__label {  position: absolute;  top: 16px;  left: 16px;  font-size: 16px;  line-height: 1;  transition-property: top, color;  transition-duration: var(--transition-duration);  color: var(--color-on-surface);}.text-field--filled .text-field__input {  padding: 20px 16px 8px;  font-size: 16px;  line-height: 20px;  background: transparent;}.text-field--filled .text-field__input:not(:placeholder-shown) ~ .text-field__label {  font-size: 12px;  top: 8px;}.text-field--filled .text-field__prefix-text {  font-size: 16px;  line-height: 20px;  padding: 20px 0 8px 16px;  color: var(--color-on-surface-variant);}.text-field--filled .text-field__suffix-text {  font-size: 16px;  line-height: 20px;  padding: 20px 16px 8px 0;  color: var(--color-on-surface-variant);}.text-field--filled.text-field--with-prefix-text .text-field__input {  padding-left: 0;}.text-field--filled.text-field--with-prefix-text .text-field__label {  font-size: 12px;  top: 8px;}.text-field--filled.text-field--with-suffix-text input {  padding-right: 0;}.text-field--filled.text-field--with-suffix-text .text-field__label {  font-size: 12px;  top: 8px;}.text-field--filled.text-field--with-leading-icon .text-field__label {  left: 48px;}.text-field--filled.text-field--with-leading-icon .text-field__input {  padding-left: 48px;}.text-field--filled.text-field--with-leading-icon .text-field__leading-icon {  top: 12px;  left: 12px;  position: absolute;  color: var(--color-on-surface-variant);  pointer-events: none;}.text-field--filled.text-field--with-leading-icon .text-field__leading-icon svg {  fill: currentColor;}.text-field--filled.text-field--with-trailing-icon .text-field__input {  padding-right: 48px;}.text-field--filled.text-field--with-trailing-icon .text-field__trailing-icon {  top: 12px;  right: 12px;  position: absolute;  color: var(--color-on-surface-variant);  pointer-events: none;}.text-field--filled.text-field--with-trailing-icon .text-field__trailing-icon svg {  fill: currentColor;}.text-field--outlined .text-field__container::before {  content: "";  border: 1px solid var(--color-outline);  border-radius: 4px;  position: absolute;  top: 0;  left: 0;  right: 0;  bottom: 0;  pointer-events: none;  transition: border-color var(--transition-duration);}.text-field--outlined .text-field__container:focus-within::before {  border: 2px solid var(--color-primary);}.text-field--outlined .text-field__container:focus-within .text-field__label {  font-size: 12px;  top: -6px;  left: 12px;  color: var(--color-primary);}.text-field--outlined .text-field__label {  position: absolute;  top: 16px;  left: 12px;  padding: 0 4px;  font-size: 16px;  line-height: 1;  color: var(--color-on-surface);  background: var(--color-surface);  z-index: 1;  transition-property: top, left, color;  transition-duration: var(--transition-duration);}.text-field--outlined.text-field--error .text-field__container::before {  border-color: var(--color-error);}.text-field--outlined .text-field__input {  padding: 14px 16px;  font-size: 16px;  line-height: 20px;  outline: none;  background: transparent;}.text-field--outlined .text-field__input::placeholder {  opacity: 0;}.text-field--outlined .text-field__input:not(:placeholder-shown) ~ .text-field__label {  font-size: 12px;  top: -6px;  left: 12px;}.text-field--outlined .text-field__prefix-text {  font-size: 16px;  line-height: 20px;  padding: 14px 0 14px 16px;  color: var(--color-on-surface-variant);}.text-field--outlined .text-field__suffix-text {  font-size: 16px;  line-height: 20px;  padding: 14px 16px 14px 0;  color: var(--color-on-surface-variant);}.text-field--outlined.text-field--with-prefix-text .text-field__input,.text-field--outlined.text-field--with-prefix-text .text-field__input:focus {  padding-left: 0;}.text-field--outlined.text-field--with-prefix-text .text-field__label {  font-size: 12px;  top: -6px;}.text-field--outlined.text-field--with-suffix-text .text-field__input,.text-field--outlined.text-field--with-suffix-text .text-field__input:focus {  padding-right: 0;}.text-field--outlined.text-field--with-suffix-text .text-field__label {  font-size: 12px;  top: -6px;}.text-field--outlined.text-field--with-leading-icon .text-field__label {  left: 48px;}.text-field--outlined.text-field--with-leading-icon .text-field__input {  padding-left: 48px;}.text-field--outlined.text-field--with-leading-icon .text-field__leading-icon {  position: absolute;  top: 12px;  left: 12px;  color: var(--color-on-surface-variant);  pointer-events: none;}.text-field--outlined.text-field--with-leading-icon .text-field__leading-icon svg {  fill: var(--color-on-surface-variant);}.text-field--outlined.text-field--with-trailing-icon .text-field__input {  padding-right: 48px;}.text-field--outlined.text-field--with-trailing-icon .text-field__trailing-icon {  position: absolute;  top: 12px;  right: 12px;  color: var(--color-on-surface-variant);  pointer-events: none;}.text-field--outlined.text-field--with-trailing-icon .text-field__trailing-icon svg {  fill: var(--color-on-surface-variant);}.text-field__helper-text {  font-size: 12px;  line-height: 1;  padding: 4px 16px 0;}.text-field--error {  color: var(--color-error);}.text-field--error .text-field__label,.text-field--error .text-field__container:focus-within .text-field__label,.text-field--error .text-field__input:not(:placeholder-shown) ~ .text-field__label {  color: var(--color-error);}.text-field--error .text-field__label {  animation-duration: 1s;  animation-timing-function: ease-in-out;  animation-name: headShake;}.text-field--error .text-field__container::after,.text-field--error .text-field__container:focus-within::after {  border-color: var(--color-error);}.background {  background-color: var(--color-background);  color: var(--color-on-background);}.background-primary {  background-color: var(--color-primary);  color: var(--color-on-primary);}.background-primary-container {  background-color: var(--color-primary-container);  color: var(--color-on-primary-container);}.background-secondary {  background-color: var(--color-secondary);  color: var(--color-on-secondary);}.background-secondary-container {  background-color: var(--color-secondary-container);  color: var(--color-on-secondary-container);}.background-tertiary {  background-color: var(--color-tertiary);  color: var(--color-on-tertiary);}.background-tertiary-container {  background-color: var(--color-tertiary-container);  color: var(--color-on-tertiary-container);}.background-surface {  background-color: var(--color-surface);  color: var(--color-on-surface);}.background-surface-variant {  background-color: var(--color-surface-variant);  color: var(--color-on-surface-variant);}.background-error {  background-color: var(--color-error);  color: var(--color-on-error);}.background-error-container {  background-color: var(--color-error-container);  color: var(--color-on-error-container);}.border {  border: 1px solid var(--color-outline);}.border-top {  border-top: 1px solid var(--color-outline);}.border-bottom {  border-bottom: 1px solid var(--color-outline);}.border-left {  border-left: 1px solid var(--color-outline);}.border-right {  border-right: 1px solid var(--color-outline);}.border-radius-0 {  border-radius: var(--space-0);}.border-radius-1 {  border-radius: var(--space-1);}.border-radius-2 {  border-radius: var(--space-2);}.border-radius-3 {  border-radius: var(--space-3);}.border-radius-4 {  border-radius: var(--space-4);}.border-radius-5 {  border-radius: var(--space-5);}.border-radius-circle {  border-radius: 50%;}@media (min-width: 600px) {  .border\@tablet {    border: 1px solid var(--color-outline);  }  .border-top\@tablet {    border-top: 1px solid var(--color-outline);  }  .border-bottom\@tablet {    border-bottom: 1px solid var(--color-outline);  }  .border-left\@tablet {    border-left: 1px solid var(--color-outline);  }  .border-right\@tablet {    border-right: 1px solid var(--color-outline);  }  .border-radius-0\@tablet {    border-radius: var(--space-0);  }  .border-radius-1\@tablet {    border-radius: var(--space-1);  }  .border-radius-2\@tablet {    border-radius: var(--space-2);  }  .border-radius-3\@tablet {    border-radius: var(--space-3);  }  .border-radius-4\@tablet {    border-radius: var(--space-4);  }  .border-radius-5\@tablet {    border-radius: var(--space-5);  }  .border-radius-circle\@tablet {    border-radius: 50%;  }}@media (min-width: 1240px) {  .border\@laptop {    border: 1px solid var(--color-outline);  }  .border-top\@laptop {    border-top: 1px solid var(--color-outline);  }  .border-bottom\@laptop {    border-bottom: 1px solid var(--color-outline);  }  .border-left\@laptop {    border-left: 1px solid var(--color-outline);  }  .border-right\@laptop {    border-right: 1px solid var(--color-outline);  }  .border-radius-0\@laptop {    border-radius: var(--space-0);  }  .border-radius-1\@laptop {    border-radius: var(--space-1);  }  .border-radius-2\@laptop {    border-radius: var(--space-2);  }  .border-radius-3\@laptop {    border-radius: var(--space-3);  }  .border-radius-4\@laptop {    border-radius: var(--space-4);  }  .border-radius-5\@laptop {    border-radius: var(--space-5);  }  .border-radius-circle\@laptop {    border-radius: 50%;  }}@media (min-width: 1440px) {  .border\@desktop {    border: 1px solid var(--color-outline);  }  .border-top\@desktop {    border-top: 1px solid var(--color-outline);  }  .border-bottom\@desktop {    border-bottom: 1px solid var(--color-outline);  }  .border-left\@desktop {    border-left: 1px solid var(--color-outline);  }  .border-right\@desktop {    border-right: 1px solid var(--color-outline);  }  .border-radius-0\@desktop {    border-radius: var(--space-0);  }  .border-radius-1\@desktop {    border-radius: var(--space-1);  }  .border-radius-2\@desktop {    border-radius: var(--space-2);  }  .border-radius-3\@desktop {    border-radius: var(--space-3);  }  .border-radius-4\@desktop {    border-radius: var(--space-4);  }  .border-radius-5\@desktop {    border-radius: var(--space-5);  }  .border-radius-circle\@desktop {    border-radius: 50%;  }}.display-none {  display: none;}.display-inline {  display: inline;}.display-block {  display: block;}.display-inline-block {  display: inline-block;}.display-flex {  display: flex;}.display-inline-flex {  display: inline-flex;}.display-grid {  display: grid;}.display-table {  display: table;}.display-table-row {  display: table-row;}.display-table-cell {  display: table-cell;}@media (min-width: 600px) {  .display-none\@tablet {    display: none;  }  .display-inline\@tablet {    display: inline;  }  .display-block\@tablet {    display: block;  }  .display-inline-block\@tablet {    display: inline-block;  }  .display-flex\@tablet {    display: flex;  }  .display-inline-flex\@tablet {    display: inline-flex;  }  .display-grid\@tablet {    display: grid;  }  .display-table\@tablet {    display: table;  }  .display-table-row\@tablet {    display: table-row;  }  .display-table-cell\@tablet {    display: table-cell;  }}@media (min-width: 1240px) {  .display-none\@laptop {    display: none;  }  .display-inline\@laptop {    display: inline;  }  .display-block\@laptop {    display: block;  }  .display-inline-block\@laptop {    display: inline-block;  }  .display-flex\@laptop {    display: flex;  }  .display-inline-flex\@laptop {    display: inline-flex;  }  .display-grid\@laptop {    display: grid;  }  .display-table\@laptop {    display: table;  }  .display-table-row\@laptop {    display: table-row;  }  .display-table-cell\@laptop {    display: table-cell;  }}@media (min-width: 1440px) {  .display-none\@desktop {    display: none;  }  .display-inline\@desktop {    display: inline;  }  .display-block\@desktop {    display: block;  }  .display-inline-block\@desktop {    display: inline-block;  }  .display-flex\@desktop {    display: flex;  }  .display-inline-flex\@desktop {    display: inline-flex;  }  .display-grid\@desktop {    display: grid;  }  .display-table\@desktop {    display: table;  }  .display-table-row\@desktop {    display: table-row;  }  .display-table-cell\@desktop {    display: table-cell;  }}.flex-direction-row {  flex-direction: row;}.flex-direction-row-reverse {  flex-direction: row-reverse;}.flex-direction-column {  flex-direction: column;}.flex-direction-column-reverse {  flex-direction: column-reverse;}.flex-nowrap {  flex-wrap: nowrap;}.flex-wrap {  flex-wrap: wrap;}.flex-wrap-reverse {  flex-wrap: wrap-reverse;}.justify-content-flex-start {  justify-content: flex-start;}.justify-content-flex-end {  justify-content: flex-end;}.justify-content-center {  justify-content: center;}.justify-content-space-between {  justify-content: space-between;}.justify-content-space-around {  justify-content: space-around;}.justify-content-space-evenly {  justify-content: space-evenly;}.align-items-flex-start {  align-items: flex-start;}.align-items-flex-end {  align-items: flex-end;}.align-items-center {  align-items: center;}.align-items-stretch {  align-items: stretch;}.align-items-baseline {  align-items: baseline;}.align-content-flex-start {  align-content: flex-start;}.align-content-flex-end {  align-content: flex-end;}.align-content-center {  align-content: center;}.align-content-stretch {  align-content: stretch;}.align-content-space-between {  align-content: space-between;}.align-content-space-around {  align-content: space-around;}.gap-0 {  gap: var(--space-0);}.gap-1 {  gap: var(--space-1);}.gap-2 {  gap: var(--space-2);}.gap-3 {  gap: var(--space-3);}.gap-4 {  gap: var(--space-4);}.gap-5 {  gap: var(--space-5);}.flex-grow-0 {  flex-grow: 0;}.flex-grow-1 {  flex-grow: 1;}.flex-shrink-0 {  flex-shrink: 0;}.flex-shrink-1 {  flex-shrink: 1;}.align-self-flex-start {  align-self: flex-start;}.align-self-flex-end {  align-self: flex-end;}.align-self-center {  align-self: center;}.align-self-baseline {  align-self: baseline;}.align-self-stretch {  align-self: stretch;}@media (min-width: 600px) {  .flex-direction-row\@tablet {    flex-direction: row;  }  .flex-direction-row-reverse\@tablet {    flex-direction: row-reverse;  }  .flex-direction-column\@tablet {    flex-direction: column;  }  .flex-direction-column-reverse\@tablet {    flex-direction: column-reverse;  }  .flex-nowrap\@tablet {    flex-wrap: nowrap;  }  .flex-wrap\@tablet {    flex-wrap: wrap;  }  .flex-wrap-reverse\@tablet {    flex-wrap: wrap-reverse;  }  .justify-content-flex-start\@tablet {    justify-content: flex-start;  }  .justify-content-flex-end\@tablet {    justify-content: flex-end;  }  .justify-content-center\@tablet {    justify-content: center;  }  .justify-content-space-between\@tablet {    justify-content: space-between;  }  .justify-content-space-around\@tablet {    justify-content: space-around;  }  .justify-content-space-evenly\@tablet {    justify-content: space-evenly;  }  .align-items-flex-start\@tablet {    align-items: flex-start;  }  .align-items-flex-end\@tablet {    align-items: flex-end;  }  .align-items-center\@tablet {    align-items: center;  }  .align-items-stretch\@tablet {    align-items: stretch;  }  .align-items-baseline\@tablet {    align-items: baseline;  }  .align-content-flex-start\@tablet {    align-content: flex-start;  }  .align-content-flex-end\@tablet {    align-content: flex-end;  }  .align-content-center\@tablet {    align-content: center;  }  .align-content-stretch\@tablet {    align-content: stretch;  }  .align-content-space-between\@tablet {    align-content: space-between;  }  .align-content-space-around\@tablet {    align-content: space-around;  }  .gap-0\@tablet {    gap: var(--space-0);  }  .gap-1\@tablet {    gap: var(--space-1);  }  .gap-2\@tablet {    gap: var(--space-2);  }  .gap-3\@tablet {    gap: var(--space-3);  }  .gap-4\@tablet {    gap: var(--space-4);  }  .gap-5\@tablet {    gap: var(--space-5);  }  .flex-grow-0\@tablet {    flex-grow: 0;  }  .flex-grow-1\@tablet {    flex-grow: 1;  }  .flex-shrink-0\@tablet {    flex-shrink: 0;  }  .flex-shrink-1\@tablet {    flex-shrink: 1;  }  .align-self-flex-start\@tablet {    align-self: flex-start;  }  .align-self-flex-end\@tablet {    align-self: flex-end;  }  .align-self-center\@tablet {    align-self: center;  }  .align-self-baseline\@tablet {    align-self: baseline;  }  .align-self-stretch\@tablet {    align-self: stretch;  }}@media (min-width: 1240px) {  .flex-direction-row\@laptop {    flex-direction: row;  }  .flex-direction-row-reverse\@laptop {    flex-direction: row-reverse;  }  .flex-direction-column\@laptop {    flex-direction: column;  }  .flex-direction-column-reverse\@laptop {    flex-direction: column-reverse;  }  .flex-nowrap\@laptop {    flex-wrap: nowrap;  }  .flex-wrap\@laptop {    flex-wrap: wrap;  }  .flex-wrap-reverse\@laptop {    flex-wrap: wrap-reverse;  }  .justify-content-flex-start\@laptop {    justify-content: flex-start;  }  .justify-content-flex-end\@laptop {    justify-content: flex-end;  }  .justify-content-center\@laptop {    justify-content: center;  }  .justify-content-space-between\@laptop {    justify-content: space-between;  }  .justify-content-space-around\@laptop {    justify-content: space-around;  }  .justify-content-space-evenly\@laptop {    justify-content: space-evenly;  }  .align-items-flex-start\@laptop {    align-items: flex-start;  }  .align-items-flex-end\@laptop {    align-items: flex-end;  }  .align-items-center\@laptop {    align-items: center;  }  .align-items-stretch\@laptop {    align-items: stretch;  }  .align-items-baseline\@laptop {    align-items: baseline;  }  .align-content-flex-start\@laptop {    align-content: flex-start;  }  .align-content-flex-end\@laptop {    align-content: flex-end;  }  .align-content-center\@laptop {    align-content: center;  }  .align-content-stretch\@laptop {    align-content: stretch;  }  .align-content-space-between\@laptop {    align-content: space-between;  }  .align-content-space-around\@laptop {    align-content: space-around;  }  .gap-0\@laptop {    gap: var(--space-0);  }  .gap-1\@laptop {    gap: var(--space-1);  }  .gap-2\@laptop {    gap: var(--space-2);  }  .gap-3\@laptop {    gap: var(--space-3);  }  .gap-4\@laptop {    gap: var(--space-4);  }  .gap-5\@laptop {    gap: var(--space-5);  }  .flex-grow-0\@laptop {    flex-grow: 0;  }  .flex-grow-1\@laptop {    flex-grow: 1;  }  .flex-shrink-0\@laptop {    flex-shrink: 0;  }  .flex-shrink-1\@laptop {    flex-shrink: 1;  }  .align-self-flex-start\@laptop {    align-self: flex-start;  }  .align-self-flex-end\@laptop {    align-self: flex-end;  }  .align-self-center\@laptop {    align-self: center;  }  .align-self-baseline\@laptop {    align-self: baseline;  }  .align-self-stretch\@laptop {    align-self: stretch;  }}@media (min-width: 1440px) {  .flex-direction-row\@desktop {    flex-direction: row;  }  .flex-direction-row-reverse\@desktop {    flex-direction: row-reverse;  }  .flex-direction-column\@desktop {    flex-direction: column;  }  .flex-direction-column-reverse\@desktop {    flex-direction: column-reverse;  }  .flex-nowrap\@desktop {    flex-wrap: nowrap;  }  .flex-wrap\@desktop {    flex-wrap: wrap;  }  .flex-wrap-reverse\@desktop {    flex-wrap: wrap-reverse;  }  .justify-content-flex-start\@desktop {    justify-content: flex-start;  }  .justify-content-flex-end\@desktop {    justify-content: flex-end;  }  .justify-content-center\@desktop {    justify-content: center;  }  .justify-content-space-between\@desktop {    justify-content: space-between;  }  .justify-content-space-around\@desktop {    justify-content: space-around;  }  .justify-content-space-evenly\@desktop {    justify-content: space-evenly;  }  .align-items-flex-start\@desktop {    align-items: flex-start;  }  .align-items-flex-end\@desktop {    align-items: flex-end;  }  .align-items-center\@desktop {    align-items: center;  }  .align-items-stretch\@desktop {    align-items: stretch;  }  .align-items-baseline\@desktop {    align-items: baseline;  }  .align-content-flex-start\@desktop {    align-content: flex-start;  }  .align-content-flex-end\@desktop {    align-content: flex-end;  }  .align-content-center\@desktop {    align-content: center;  }  .align-content-stretch\@desktop {    align-content: stretch;  }  .align-content-space-between\@desktop {    align-content: space-between;  }  .align-content-space-around\@desktop {    align-content: space-around;  }  .gap-0\@desktop {    gap: var(--space-0);  }  .gap-1\@desktop {    gap: var(--space-1);  }  .gap-2\@desktop {    gap: var(--space-2);  }  .gap-3\@desktop {    gap: var(--space-3);  }  .gap-4\@desktop {    gap: var(--space-4);  }  .gap-5\@desktop {    gap: var(--space-5);  }  .flex-grow-0\@desktop {    flex-grow: 0;  }  .flex-grow-1\@desktop {    flex-grow: 1;  }  .flex-shrink-0\@desktop {    flex-shrink: 0;  }  .flex-shrink-1\@desktop {    flex-shrink: 1;  }  .align-self-flex-start\@desktop {    align-self: flex-start;  }  .align-self-flex-end\@desktop {    align-self: flex-end;  }  .align-self-center\@desktop {    align-self: center;  }  .align-self-baseline\@desktop {    align-self: baseline;  }  .align-self-stretch\@desktop {    align-self: stretch;  }}.link-stretched::after {  position: absolute;  content: "";  top: 0;  left: 0;  right: 0;  bottom: 0;}.overflow-auto {  overflow: auto;}.overflow-hidden {  overflow: hidden;}.overflow-visible {  overflow: visible;}.overflow-scroll {  overflow: scroll;}.position-relative {  position: relative;}.position-absolute {  position: absolute;}.position-fixed {  position: fixed;}.position-static {  position: static;}.position-sticky {  position: sticky;}.top-0 {  top: var(--space-0);}.top-1 {  top: var(--space-1);}.top-2 {  top: var(--space-2);}.top-3 {  top: var(--space-3);}.top-4 {  top: var(--space-4);}.top-5 {  top: var(--space-5);}.right-0 {  right: var(--space-0);}.right-1 {  right: var(--space-1);}.right-2 {  right: var(--space-2);}.right-3 {  right: var(--space-3);}.right-4 {  right: var(--space-4);}.right-5 {  right: var(--space-5);}.bottom-0 {  bottom: var(--space-0);}.bottom-1 {  bottom: var(--space-1);}.bottom-2 {  bottom: var(--space-2);}.bottom-3 {  bottom: var(--space-3);}.bottom-4 {  bottom: var(--space-4);}.bottom-5 {  bottom: var(--space-5);}.left-0 {  left: var(--space-0);}.left-1 {  left: var(--space-1);}.left-2 {  left: var(--space-2);}.left-3 {  left: var(--space-3);}.left-4 {  left: var(--space-4);}.left-5 {  left: var(--space-5);}.shadow-0 {  box-shadow: var(--shadow-0);}.shadow-1 {  box-shadow: var(--shadow-1);}.shadow-2 {  box-shadow: var(--shadow-2);}.shadow-3 {  box-shadow: var(--shadow-3);}.shadow-4 {  box-shadow: var(--shadow-4);}.shadow-5 {  box-shadow: var(--shadow-5);}.margin-0 {  margin: var(--space-0);}.margin-x-0 {  margin-left: var(--space-0);  margin-right: var(--space-0);}.margin-y-0 {  margin-top: var(--space-0);  margin-bottom: var(--space-0);}.margin-top-0 {  margin-top: var(--space-0);}.margin-left-0 {  margin-left: var(--space-0);}.margin-right-0 {  margin-right: var(--space-0);}.margin-bottom-0 {  margin-bottom: var(--space-0);}.margin-1 {  margin: var(--space-1);}.margin-x-1 {  margin-left: var(--space-1);  margin-right: var(--space-1);}.margin-y-1 {  margin-top: var(--space-1);  margin-bottom: var(--space-1);}.margin-top-1 {  margin-top: var(--space-1);}.margin-left-1 {  margin-left: var(--space-1);}.margin-right-1 {  margin-right: var(--space-1);}.margin-bottom-1 {  margin-bottom: var(--space-1);}.margin-2 {  margin: var(--space-2);}.margin-x-2 {  margin-left: var(--space-2);  margin-right: var(--space-2);}.margin-y-2 {  margin-top: var(--space-2);  margin-bottom: var(--space-2);}.margin-top-2 {  margin-top: var(--space-2);}.margin-left-2 {  margin-left: var(--space-2);}.margin-right-2 {  margin-right: var(--space-2);}.margin-bottom-2 {  margin-bottom: var(--space-2);}.margin-3 {  margin: var(--space-3);}.margin-x-3 {  margin-left: var(--space-3);  margin-right: var(--space-3);}.margin-y-3 {  margin-top: var(--space-3);  margin-bottom: var(--space-3);}.margin-top-3 {  margin-top: var(--space-3);}.margin-left-3 {  margin-left: var(--space-3);}.margin-right-3 {  margin-right: var(--space-3);}.margin-bottom-3 {  margin-bottom: var(--space-3);}.margin-4 {  margin: var(--space-4);}.margin-x-4 {  margin-left: var(--space-4);  margin-right: var(--space-4);}.margin-y-4 {  margin-top: var(--space-4);  margin-bottom: var(--space-4);}.margin-top-4 {  margin-top: var(--space-4);}.margin-left-4 {  margin-left: var(--space-4);}.margin-right-4 {  margin-right: var(--space-4);}.margin-bottom-4 {  margin-bottom: var(--space-4);}.margin-5 {  margin: var(--space-5);}.margin-x-5 {  margin-left: var(--space-5);  margin-right: var(--space-5);}.margin-y-5 {  margin-top: var(--space-5);  margin-bottom: var(--space-5);}.margin-top-5 {  margin-top: var(--space-5);}.margin-left-5 {  margin-left: var(--space-5);}.margin-right-5 {  margin-right: var(--space-5);}.margin-bottom-5 {  margin-bottom: var(--space-5);}.padding-0 {  padding: var(--space-0);}.padding-x-0 {  padding-left: var(--space-0);  padding-right: var(--space-0);}.padding-y-0 {  padding-top: var(--space-0);  padding-bottom: var(--space-0);}.padding-top-0 {  padding-top: var(--space-0);}.padding-left-0 {  padding-left: var(--space-0);}.padding-right-0 {  padding-right: var(--space-0);}.padding-bottom-0 {  padding-bottom: var(--space-0);}.padding-1 {  padding: var(--space-1);}.padding-x-1 {  padding-left: var(--space-1);  padding-right: var(--space-1);}.padding-y-1 {  padding-top: var(--space-1);  padding-bottom: var(--space-1);}.padding-top-1 {  padding-top: var(--space-1);}.padding-left-1 {  padding-left: var(--space-1);}.padding-right-1 {  padding-right: var(--space-1);}.padding-bottom-1 {  padding-bottom: var(--space-1);}.padding-2 {  padding: var(--space-2);}.padding-x-2 {  padding-left: var(--space-2);  padding-right: var(--space-2);}.padding-y-2 {  padding-top: var(--space-2);  padding-bottom: var(--space-2);}.padding-top-2 {  padding-top: var(--space-2);}.padding-left-2 {  padding-left: var(--space-2);}.padding-right-2 {  padding-right: var(--space-2);}.padding-bottom-2 {  padding-bottom: var(--space-2);}.padding-3 {  padding: var(--space-3);}.padding-x-3 {  padding-left: var(--space-3);  padding-right: var(--space-3);}.padding-y-3 {  padding-top: var(--space-3);  padding-bottom: var(--space-3);}.padding-top-3 {  padding-top: var(--space-3);}.padding-left-3 {  padding-left: var(--space-3);}.padding-right-3 {  padding-right: var(--space-3);}.padding-bottom-3 {  padding-bottom: var(--space-3);}.padding-4 {  padding: var(--space-4);}.padding-x-4 {  padding-left: var(--space-4);  padding-right: var(--space-4);}.padding-y-4 {  padding-top: var(--space-4);  padding-bottom: var(--space-4);}.padding-top-4 {  padding-top: var(--space-4);}.padding-left-4 {  padding-left: var(--space-4);}.padding-right-4 {  padding-right: var(--space-4);}.padding-bottom-4 {  padding-bottom: var(--space-4);}.padding-5 {  padding: var(--space-5);}.padding-x-5 {  padding-left: var(--space-5);  padding-right: var(--space-5);}.padding-y-5 {  padding-top: var(--space-5);  padding-bottom: var(--space-5);}.padding-top-5 {  padding-top: var(--space-5);}.padding-left-5 {  padding-left: var(--space-5);}.padding-right-5 {  padding-right: var(--space-5);}.padding-bottom-5 {  padding-bottom: var(--space-5);}@media (min-width: 600px) {  .margin-0\@tablet {    margin: var(--space-0);  }  .margin-x-0\@tablet {    margin-left: var(--space-0);    margin-right: var(--space-0);  }  .margin-y-0\@tablet {    margin-top: var(--space-0);    margin-bottom: var(--space-0);  }  .margin-top-0\@tablet {    margin-top: var(--space-0);  }  .margin-left-0\@tablet {    margin-left: var(--space-0);  }  .margin-right-0\@tablet {    margin-right: var(--space-0);  }  .margin-bottom-0\@tablet {    margin-bottom: var(--space-0);  }  .margin-1\@tablet {    margin: var(--space-1);  }  .margin-x-1\@tablet {    margin-left: var(--space-1);    margin-right: var(--space-1);  }  .margin-y-1\@tablet {    margin-top: var(--space-1);    margin-bottom: var(--space-1);  }  .margin-top-1\@tablet {    margin-top: var(--space-1);  }  .margin-left-1\@tablet {    margin-left: var(--space-1);  }  .margin-right-1\@tablet {    margin-right: var(--space-1);  }  .margin-bottom-1\@tablet {    margin-bottom: var(--space-1);  }  .margin-2\@tablet {    margin: var(--space-2);  }  .margin-x-2\@tablet {    margin-left: var(--space-2);    margin-right: var(--space-2);  }  .margin-y-2\@tablet {    margin-top: var(--space-2);    margin-bottom: var(--space-2);  }  .margin-top-2\@tablet {    margin-top: var(--space-2);  }  .margin-left-2\@tablet {    margin-left: var(--space-2);  }  .margin-right-2\@tablet {    margin-right: var(--space-2);  }  .margin-bottom-2\@tablet {    margin-bottom: var(--space-2);  }  .margin-3\@tablet {    margin: var(--space-3);  }  .margin-x-3\@tablet {    margin-left: var(--space-3);    margin-right: var(--space-3);  }  .margin-y-3\@tablet {    margin-top: var(--space-3);    margin-bottom: var(--space-3);  }  .margin-top-3\@tablet {    margin-top: var(--space-3);  }  .margin-left-3\@tablet {    margin-left: var(--space-3);  }  .margin-right-3\@tablet {    margin-right: var(--space-3);  }  .margin-bottom-3\@tablet {    margin-bottom: var(--space-3);  }  .margin-4\@tablet {    margin: var(--space-4);  }  .margin-x-4\@tablet {    margin-left: var(--space-4);    margin-right: var(--space-4);  }  .margin-y-4\@tablet {    margin-top: var(--space-4);    margin-bottom: var(--space-4);  }  .margin-top-4\@tablet {    margin-top: var(--space-4);  }  .margin-left-4\@tablet {    margin-left: var(--space-4);  }  .margin-right-4\@tablet {    margin-right: var(--space-4);  }  .margin-bottom-4\@tablet {    margin-bottom: var(--space-4);  }  .margin-5\@tablet {    margin: var(--space-5);  }  .margin-x-5\@tablet {    margin-left: var(--space-5);    margin-right: var(--space-5);  }  .margin-y-5\@tablet {    margin-top: var(--space-5);    margin-bottom: var(--space-5);  }  .margin-top-5\@tablet {    margin-top: var(--space-5);  }  .margin-left-5\@tablet {    margin-left: var(--space-5);  }  .margin-right-5\@tablet {    margin-right: var(--space-5);  }  .margin-bottom-5\@tablet {    margin-bottom: var(--space-5);  }  .padding-0\@tablet {    padding: var(--space-0);  }  .padding-x-0\@tablet {    padding-left: var(--space-0);    padding-right: var(--space-0);  }  .padding-y-0\@tablet {    padding-top: var(--space-0);    padding-bottom: var(--space-0);  }  .padding-top-0\@tablet {    padding-top: var(--space-0);  }  .padding-left-0\@tablet {    padding-left: var(--space-0);  }  .padding-right-0\@tablet {    padding-right: var(--space-0);  }  .padding-bottom-0\@tablet {    padding-bottom: var(--space-0);  }  .padding-1\@tablet {    padding: var(--space-1);  }  .padding-x-1\@tablet {    padding-left: var(--space-1);    padding-right: var(--space-1);  }  .padding-y-1\@tablet {    padding-top: var(--space-1);    padding-bottom: var(--space-1);  }  .padding-top-1\@tablet {    padding-top: var(--space-1);  }  .padding-left-1\@tablet {    padding-left: var(--space-1);  }  .padding-right-1\@tablet {    padding-right: var(--space-1);  }  .padding-bottom-1\@tablet {    padding-bottom: var(--space-1);  }  .padding-2\@tablet {    padding: var(--space-2);  }  .padding-x-2\@tablet {    padding-left: var(--space-2);    padding-right: var(--space-2);  }  .padding-y-2\@tablet {    padding-top: var(--space-2);    padding-bottom: var(--space-2);  }  .padding-top-2\@tablet {    padding-top: var(--space-2);  }  .padding-left-2\@tablet {    padding-left: var(--space-2);  }  .padding-right-2\@tablet {    padding-right: var(--space-2);  }  .padding-bottom-2\@tablet {    padding-bottom: var(--space-2);  }  .padding-3\@tablet {    padding: var(--space-3);  }  .padding-x-3\@tablet {    padding-left: var(--space-3);    padding-right: var(--space-3);  }  .padding-y-3\@tablet {    padding-top: var(--space-3);    padding-bottom: var(--space-3);  }  .padding-top-3\@tablet {    padding-top: var(--space-3);  }  .padding-left-3\@tablet {    padding-left: var(--space-3);  }  .padding-right-3\@tablet {    padding-right: var(--space-3);  }  .padding-bottom-3\@tablet {    padding-bottom: var(--space-3);  }  .padding-4\@tablet {    padding: var(--space-4);  }  .padding-x-4\@tablet {    padding-left: var(--space-4);    padding-right: var(--space-4);  }  .padding-y-4\@tablet {    padding-top: var(--space-4);    padding-bottom: var(--space-4);  }  .padding-top-4\@tablet {    padding-top: var(--space-4);  }  .padding-left-4\@tablet {    padding-left: var(--space-4);  }  .padding-right-4\@tablet {    padding-right: var(--space-4);  }  .padding-bottom-4\@tablet {    padding-bottom: var(--space-4);  }  .padding-5\@tablet {    padding: var(--space-5);  }  .padding-x-5\@tablet {    padding-left: var(--space-5);    padding-right: var(--space-5);  }  .padding-y-5\@tablet {    padding-top: var(--space-5);    padding-bottom: var(--space-5);  }  .padding-top-5\@tablet {    padding-top: var(--space-5);  }  .padding-left-5\@tablet {    padding-left: var(--space-5);  }  .padding-right-5\@tablet {    padding-right: var(--space-5);  }  .padding-bottom-5\@tablet {    padding-bottom: var(--space-5);  }}@media (min-width: 1240px) {  .margin-0\@laptop {    margin: var(--space-0);  }  .margin-x-0\@laptop {    margin-left: var(--space-0);    margin-right: var(--space-0);  }  .margin-y-0\@laptop {    margin-top: var(--space-0);    margin-bottom: var(--space-0);  }  .margin-top-0\@laptop {    margin-top: var(--space-0);  }  .margin-left-0\@laptop {    margin-left: var(--space-0);  }  .margin-right-0\@laptop {    margin-right: var(--space-0);  }  .margin-bottom-0\@laptop {    margin-bottom: var(--space-0);  }  .margin-1\@laptop {    margin: var(--space-1);  }  .margin-x-1\@laptop {    margin-left: var(--space-1);    margin-right: var(--space-1);  }  .margin-y-1\@laptop {    margin-top: var(--space-1);    margin-bottom: var(--space-1);  }  .margin-top-1\@laptop {    margin-top: var(--space-1);  }  .margin-left-1\@laptop {    margin-left: var(--space-1);  }  .margin-right-1\@laptop {    margin-right: var(--space-1);  }  .margin-bottom-1\@laptop {    margin-bottom: var(--space-1);  }  .margin-2\@laptop {    margin: var(--space-2);  }  .margin-x-2\@laptop {    margin-left: var(--space-2);    margin-right: var(--space-2);  }  .margin-y-2\@laptop {    margin-top: var(--space-2);    margin-bottom: var(--space-2);  }  .margin-top-2\@laptop {    margin-top: var(--space-2);  }  .margin-left-2\@laptop {    margin-left: var(--space-2);  }  .margin-right-2\@laptop {    margin-right: var(--space-2);  }  .margin-bottom-2\@laptop {    margin-bottom: var(--space-2);  }  .margin-3\@laptop {    margin: var(--space-3);  }  .margin-x-3\@laptop {    margin-left: var(--space-3);    margin-right: var(--space-3);  }  .margin-y-3\@laptop {    margin-top: var(--space-3);    margin-bottom: var(--space-3);  }  .margin-top-3\@laptop {    margin-top: var(--space-3);  }  .margin-left-3\@laptop {    margin-left: var(--space-3);  }  .margin-right-3\@laptop {    margin-right: var(--space-3);  }  .margin-bottom-3\@laptop {    margin-bottom: var(--space-3);  }  .margin-4\@laptop {    margin: var(--space-4);  }  .margin-x-4\@laptop {    margin-left: var(--space-4);    margin-right: var(--space-4);  }  .margin-y-4\@laptop {    margin-top: var(--space-4);    margin-bottom: var(--space-4);  }  .margin-top-4\@laptop {    margin-top: var(--space-4);  }  .margin-left-4\@laptop {    margin-left: var(--space-4);  }  .margin-right-4\@laptop {    margin-right: var(--space-4);  }  .margin-bottom-4\@laptop {    margin-bottom: var(--space-4);  }  .margin-5\@laptop {    margin: var(--space-5);  }  .margin-x-5\@laptop {    margin-left: var(--space-5);    margin-right: var(--space-5);  }  .margin-y-5\@laptop {    margin-top: var(--space-5);    margin-bottom: var(--space-5);  }  .margin-top-5\@laptop {    margin-top: var(--space-5);  }  .margin-left-5\@laptop {    margin-left: var(--space-5);  }  .margin-right-5\@laptop {    margin-right: var(--space-5);  }  .margin-bottom-5\@laptop {    margin-bottom: var(--space-5);  }  .padding-0\@laptop {    padding: var(--space-0);  }  .padding-x-0\@laptop {    padding-left: var(--space-0);    padding-right: var(--space-0);  }  .padding-y-0\@laptop {    padding-top: var(--space-0);    padding-bottom: var(--space-0);  }  .padding-top-0\@laptop {    padding-top: var(--space-0);  }  .padding-left-0\@laptop {    padding-left: var(--space-0);  }  .padding-right-0\@laptop {    padding-right: var(--space-0);  }  .padding-bottom-0\@laptop {    padding-bottom: var(--space-0);  }  .padding-1\@laptop {    padding: var(--space-1);  }  .padding-x-1\@laptop {    padding-left: var(--space-1);    padding-right: var(--space-1);  }  .padding-y-1\@laptop {    padding-top: var(--space-1);    padding-bottom: var(--space-1);  }  .padding-top-1\@laptop {    padding-top: var(--space-1);  }  .padding-left-1\@laptop {    padding-left: var(--space-1);  }  .padding-right-1\@laptop {    padding-right: var(--space-1);  }  .padding-bottom-1\@laptop {    padding-bottom: var(--space-1);  }  .padding-2\@laptop {    padding: var(--space-2);  }  .padding-x-2\@laptop {    padding-left: var(--space-2);    padding-right: var(--space-2);  }  .padding-y-2\@laptop {    padding-top: var(--space-2);    padding-bottom: var(--space-2);  }  .padding-top-2\@laptop {    padding-top: var(--space-2);  }  .padding-left-2\@laptop {    padding-left: var(--space-2);  }  .padding-right-2\@laptop {    padding-right: var(--space-2);  }  .padding-bottom-2\@laptop {    padding-bottom: var(--space-2);  }  .padding-3\@laptop {    padding: var(--space-3);  }  .padding-x-3\@laptop {    padding-left: var(--space-3);    padding-right: var(--space-3);  }  .padding-y-3\@laptop {    padding-top: var(--space-3);    padding-bottom: var(--space-3);  }  .padding-top-3\@laptop {    padding-top: var(--space-3);  }  .padding-left-3\@laptop {    padding-left: var(--space-3);  }  .padding-right-3\@laptop {    padding-right: var(--space-3);  }  .padding-bottom-3\@laptop {    padding-bottom: var(--space-3);  }  .padding-4\@laptop {    padding: var(--space-4);  }  .padding-x-4\@laptop {    padding-left: var(--space-4);    padding-right: var(--space-4);  }  .padding-y-4\@laptop {    padding-top: var(--space-4);    padding-bottom: var(--space-4);  }  .padding-top-4\@laptop {    padding-top: var(--space-4);  }  .padding-left-4\@laptop {    padding-left: var(--space-4);  }  .padding-right-4\@laptop {    padding-right: var(--space-4);  }  .padding-bottom-4\@laptop {    padding-bottom: var(--space-4);  }  .padding-5\@laptop {    padding: var(--space-5);  }  .padding-x-5\@laptop {    padding-left: var(--space-5);    padding-right: var(--space-5);  }  .padding-y-5\@laptop {    padding-top: var(--space-5);    padding-bottom: var(--space-5);  }  .padding-top-5\@laptop {    padding-top: var(--space-5);  }  .padding-left-5\@laptop {    padding-left: var(--space-5);  }  .padding-right-5\@laptop {    padding-right: var(--space-5);  }  .padding-bottom-5\@laptop {    padding-bottom: var(--space-5);  }}@media (min-width: 1440px) {  .margin-0\@desktop {    margin: var(--space-0);  }  .margin-x-0\@desktop {    margin-left: var(--space-0);    margin-right: var(--space-0);  }  .margin-y-0\@desktop {    margin-top: var(--space-0);    margin-bottom: var(--space-0);  }  .margin-top-0\@desktop {    margin-top: var(--space-0);  }  .margin-left-0\@desktop {    margin-left: var(--space-0);  }  .margin-right-0\@desktop {    margin-right: var(--space-0);  }  .margin-bottom-0\@desktop {    margin-bottom: var(--space-0);  }  .margin-1\@desktop {    margin: var(--space-1);  }  .margin-x-1\@desktop {    margin-left: var(--space-1);    margin-right: var(--space-1);  }  .margin-y-1\@desktop {    margin-top: var(--space-1);    margin-bottom: var(--space-1);  }  .margin-top-1\@desktop {    margin-top: var(--space-1);  }  .margin-left-1\@desktop {    margin-left: var(--space-1);  }  .margin-right-1\@desktop {    margin-right: var(--space-1);  }  .margin-bottom-1\@desktop {    margin-bottom: var(--space-1);  }  .margin-2\@desktop {    margin: var(--space-2);  }  .margin-x-2\@desktop {    margin-left: var(--space-2);    margin-right: var(--space-2);  }  .margin-y-2\@desktop {    margin-top: var(--space-2);    margin-bottom: var(--space-2);  }  .margin-top-2\@desktop {    margin-top: var(--space-2);  }  .margin-left-2\@desktop {    margin-left: var(--space-2);  }  .margin-right-2\@desktop {    margin-right: var(--space-2);  }  .margin-bottom-2\@desktop {    margin-bottom: var(--space-2);  }  .margin-3\@desktop {    margin: var(--space-3);  }  .margin-x-3\@desktop {    margin-left: var(--space-3);    margin-right: var(--space-3);  }  .margin-y-3\@desktop {    margin-top: var(--space-3);    margin-bottom: var(--space-3);  }  .margin-top-3\@desktop {    margin-top: var(--space-3);  }  .margin-left-3\@desktop {    margin-left: var(--space-3);  }  .margin-right-3\@desktop {    margin-right: var(--space-3);  }  .margin-bottom-3\@desktop {    margin-bottom: var(--space-3);  }  .margin-4\@desktop {    margin: var(--space-4);  }  .margin-x-4\@desktop {    margin-left: var(--space-4);    margin-right: var(--space-4);  }  .margin-y-4\@desktop {    margin-top: var(--space-4);    margin-bottom: var(--space-4);  }  .margin-top-4\@desktop {    margin-top: var(--space-4);  }  .margin-left-4\@desktop {    margin-left: var(--space-4);  }  .margin-right-4\@desktop {    margin-right: var(--space-4);  }  .margin-bottom-4\@desktop {    margin-bottom: var(--space-4);  }  .margin-5\@desktop {    margin: var(--space-5);  }  .margin-x-5\@desktop {    margin-left: var(--space-5);    margin-right: var(--space-5);  }  .margin-y-5\@desktop {    margin-top: var(--space-5);    margin-bottom: var(--space-5);  }  .margin-top-5\@desktop {    margin-top: var(--space-5);  }  .margin-left-5\@desktop {    margin-left: var(--space-5);  }  .margin-right-5\@desktop {    margin-right: var(--space-5);  }  .margin-bottom-5\@desktop {    margin-bottom: var(--space-5);  }  .padding-0\@desktop {    padding: var(--space-0);  }  .padding-x-0\@desktop {    padding-left: var(--space-0);    padding-right: var(--space-0);  }  .padding-y-0\@desktop {    padding-top: var(--space-0);    padding-bottom: var(--space-0);  }  .padding-top-0\@desktop {    padding-top: var(--space-0);  }  .padding-left-0\@desktop {    padding-left: var(--space-0);  }  .padding-right-0\@desktop {    padding-right: var(--space-0);  }  .padding-bottom-0\@desktop {    padding-bottom: var(--space-0);  }  .padding-1\@desktop {    padding: var(--space-1);  }  .padding-x-1\@desktop {    padding-left: var(--space-1);    padding-right: var(--space-1);  }  .padding-y-1\@desktop {    padding-top: var(--space-1);    padding-bottom: var(--space-1);  }  .padding-top-1\@desktop {    padding-top: var(--space-1);  }  .padding-left-1\@desktop {    padding-left: var(--space-1);  }  .padding-right-1\@desktop {    padding-right: var(--space-1);  }  .padding-bottom-1\@desktop {    padding-bottom: var(--space-1);  }  .padding-2\@desktop {    padding: var(--space-2);  }  .padding-x-2\@desktop {    padding-left: var(--space-2);    padding-right: var(--space-2);  }  .padding-y-2\@desktop {    padding-top: var(--space-2);    padding-bottom: var(--space-2);  }  .padding-top-2\@desktop {    padding-top: var(--space-2);  }  .padding-left-2\@desktop {    padding-left: var(--space-2);  }  .padding-right-2\@desktop {    padding-right: var(--space-2);  }  .padding-bottom-2\@desktop {    padding-bottom: var(--space-2);  }  .padding-3\@desktop {    padding: var(--space-3);  }  .padding-x-3\@desktop {    padding-left: var(--space-3);    padding-right: var(--space-3);  }  .padding-y-3\@desktop {    padding-top: var(--space-3);    padding-bottom: var(--space-3);  }  .padding-top-3\@desktop {    padding-top: var(--space-3);  }  .padding-left-3\@desktop {    padding-left: var(--space-3);  }  .padding-right-3\@desktop {    padding-right: var(--space-3);  }  .padding-bottom-3\@desktop {    padding-bottom: var(--space-3);  }  .padding-4\@desktop {    padding: var(--space-4);  }  .padding-x-4\@desktop {    padding-left: var(--space-4);    padding-right: var(--space-4);  }  .padding-y-4\@desktop {    padding-top: var(--space-4);    padding-bottom: var(--space-4);  }  .padding-top-4\@desktop {    padding-top: var(--space-4);  }  .padding-left-4\@desktop {    padding-left: var(--space-4);  }  .padding-right-4\@desktop {    padding-right: var(--space-4);  }  .padding-bottom-4\@desktop {    padding-bottom: var(--space-4);  }  .padding-5\@desktop {    padding: var(--space-5);  }  .padding-x-5\@desktop {    padding-left: var(--space-5);    padding-right: var(--space-5);  }  .padding-y-5\@desktop {    padding-top: var(--space-5);    padding-bottom: var(--space-5);  }  .padding-top-5\@desktop {    padding-top: var(--space-5);  }  .padding-left-5\@desktop {    padding-left: var(--space-5);  }  .padding-right-5\@desktop {    padding-right: var(--space-5);  }  .padding-bottom-5\@desktop {    padding-bottom: var(--space-5);  }}.width-25 {  width: 25%;}.height-25 {  height: 25%;}.width-50 {  width: 50%;}.height-50 {  height: 50%;}.width-75 {  width: 75%;}.height-75 {  height: 75%;}.width-100 {  width: 100%;}.height-100 {  height: 100%;}.max-width-100 {  max-width: 100%;}.max-width-100vw {  max-width: 100vw;}.width-100vw {  width: 100vw;}.min-width-0 {  min-width: 0%;}.min-width-100 {  min-width: 100%;}.min-width-100vw {  min-width: 100vw;}.max-height-100 {  max-height: 100%;}.max-height-100vh {  max-height: 100vh;}.height-100vh {  height: 100vh;}.min-height-0 {  min-height: 0;}.min-height-100 {  min-height: 100%;}.min-height-100vh {  min-height: 100vh;}.text-primary {  color: var(--color-primary);}.text-secondary {  color: var(--color-secondary);}.text-tertiary {  color: var(--color-tertiary);}.text-error {  color: var(--color-error);}.text-align-left {  text-align: left;}.text-align-center {  text-align: center;}.text-align-right {  text-align: right;}.text-wrap {  white-space: normal;}.text-nowrap {  white-space: nowrap;}.text-break-word {  word-wrap: break-word;}.text-overflow-ellipsis {  text-overflow: ellipsis;  white-space: nowrap;  overflow: hidden;}.vertical-align-baseline {  vertical-align: baseline;}.vertical-align-bottom {  vertical-align: bottom;}.vertical-align-middle {  vertical-align: middle;}.vertical-align-sub {  vertical-align: sub;}.vertical-align-super {  vertical-align: super;}.vertical-align-text-bottom {  vertical-align: text-bottom;}.vertical-align-text-top {  vertical-align: text-top;}.vertical-align-top {  vertical-align: top;}]]></content>
    
  </entry>
  
  
  
</search>
